{"version":3,"file":"read-package.js","sources":["../../../../../node_modules/json-parse-even-better-errors/lib/index.js","../../../../../node_modules/@npmcli/package-json/lib/read-package.js"],"sourcesContent":["'use strict'\n\nconst INDENT = Symbol.for('indent')\nconst NEWLINE = Symbol.for('newline')\n\nconst DEFAULT_NEWLINE = '\\n'\nconst DEFAULT_INDENT = '  '\nconst BOM = /^\\uFEFF/\n\n// only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\nconst FORMAT = /^\\s*[{[]((?:\\r?\\n)+)([\\s\\t]*)/\nconst EMPTY = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/\n\n// Node 20 puts single quotes around the token and a comma after it\nconst UNEXPECTED_TOKEN = /^Unexpected token '?(.)'?(,)? /i\n\nconst hexify = (char) => {\n  const h = char.charCodeAt(0).toString(16).toUpperCase()\n  return `0x${h.length % 2 ? '0' : ''}${h}`\n}\n\n// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\nconst stripBOM = (txt) => String(txt).replace(BOM, '')\n\nconst makeParsedError = (msg, parsing, position = 0) => ({\n  message: `${msg} while parsing ${parsing}`,\n  position,\n})\n\nconst parseError = (e, txt, context = 20) => {\n  let msg = e.message\n\n  if (!txt) {\n    return makeParsedError(msg, 'empty string')\n  }\n\n  const badTokenMatch = msg.match(UNEXPECTED_TOKEN)\n  const badIndexMatch = msg.match(/ position\\s+(\\d+)/i)\n\n  if (badTokenMatch) {\n    msg = msg.replace(\n      UNEXPECTED_TOKEN,\n      `Unexpected token ${JSON.stringify(badTokenMatch[1])} (${hexify(badTokenMatch[1])})$2 `\n    )\n  }\n\n  let errIdx\n  if (badIndexMatch) {\n    errIdx = +badIndexMatch[1]\n  } else /* istanbul ignore next - doesnt happen in Node 22 */ if (\n    msg.match(/^Unexpected end of JSON.*/i)\n  ) {\n    errIdx = txt.length - 1\n  }\n\n  if (errIdx == null) {\n    return makeParsedError(msg, `'${txt.slice(0, context * 2)}'`)\n  }\n\n  const start = errIdx <= context ? 0 : errIdx - context\n  const end = errIdx + context >= txt.length ? txt.length : errIdx + context\n  const slice = `${start ? '...' : ''}${txt.slice(start, end)}${end === txt.length ? '' : '...'}`\n\n  return makeParsedError(\n    msg,\n    `${txt === slice ? '' : 'near '}${JSON.stringify(slice)}`,\n    errIdx\n  )\n}\n\nclass JSONParseError extends SyntaxError {\n  constructor (er, txt, context, caller) {\n    const metadata = parseError(er, txt, context)\n    super(metadata.message)\n    Object.assign(this, metadata)\n    this.code = 'EJSONPARSE'\n    this.systemError = er\n    Error.captureStackTrace(this, caller || this.constructor)\n  }\n\n  get name () {\n    return this.constructor.name\n  }\n\n  set name (n) {}\n\n  get [Symbol.toStringTag] () {\n    return this.constructor.name\n  }\n}\n\nconst parseJson = (txt, reviver) => {\n  const result = JSON.parse(txt, reviver)\n  if (result && typeof result === 'object') {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n If the\n    // pattern doesn't match, then it means no indentation. JSON.stringify ignores\n    // symbols, so this is reasonably safe. if the string is '{}' or '[]', then\n    // use the default 2-space indent.\n    const match = txt.match(EMPTY) || txt.match(FORMAT) || [null, '', '']\n    result[NEWLINE] = match[1] ?? DEFAULT_NEWLINE\n    result[INDENT] = match[2] ?? DEFAULT_INDENT\n  }\n  return result\n}\n\nconst parseJsonError = (raw, reviver, context) => {\n  const txt = stripBOM(raw)\n  try {\n    return parseJson(txt, reviver)\n  } catch (e) {\n    if (typeof raw !== 'string' && !Buffer.isBuffer(raw)) {\n      const msg = Array.isArray(raw) && raw.length === 0 ? 'an empty array' : String(raw)\n      throw Object.assign(\n        new TypeError(`Cannot parse ${msg}`),\n        { code: 'EJSONPARSE', systemError: e }\n      )\n    }\n    throw new JSONParseError(e, txt, context, parseJsonError)\n  }\n}\n\nmodule.exports = parseJsonError\nparseJsonError.JSONParseError = JSONParseError\nparseJsonError.noExceptions = (raw, reviver) => {\n  try {\n    return parseJson(stripBOM(raw), reviver)\n  } catch {\n    // no exceptions\n  }\n}\n","// This is JUST the code needed to open a package.json file and parse it.\n// It's isolated out so that code needing to parse a package.json file can do so in the same way as this module does, without needing to require the whole module, or needing to require the underlying parsing library.\n\nconst { readFile } = require('fs/promises')\nconst parseJSON = require('json-parse-even-better-errors')\n\nasync function read (filename) {\n  try {\n    const data = await readFile(filename, 'utf8')\n    return data\n  } catch (err) {\n    err.message = `Could not read package.json: ${err}`\n    throw err\n  }\n}\n\nfunction parse (data) {\n  try {\n    const content = parseJSON(data)\n    return content\n  } catch (err) {\n    err.message = `Invalid package.json: ${err}`\n    throw err\n  }\n}\n\n// This is what most external libs will use.\n// PackageJson will call read and parse separately\nasync function readPackage (filename) {\n  const data = await read(filename)\n  const content = parse(data)\n  return content\n}\n\nmodule.exports = {\n  read,\n  parse,\n  readPackage,\n}\n"],"names":["INDENT","Symbol","for","NEWLINE","DEFAULT_NEWLINE","DEFAULT_INDENT","BOM","FORMAT","EMPTY","UNEXPECTED_TOKEN","hexify","char","h","charCodeAt","toString","toUpperCase","length","stripBOM","txt","String","replace","makeParsedError","msg","parsing","position","message","parseError","e","context","badTokenMatch","match","badIndexMatch","JSON","stringify","errIdx","slice","start","end","JSONParseError","SyntaxError","constructor","er","caller","metadata","Object","assign","code","systemError","Error","captureStackTrace","name","n","toStringTag","parseJson","reviver","result","parse","parseJsonError","raw","Buffer","isBuffer","Array","isArray","TypeError","lib","noExceptions","readFile","require$$0","parseJSON","require$$1","read","filename","data","err","content","readPackage","readPackage_1"],"mappings":"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","x_google_ignoreList":[0,1]}