{"version":3,"file":"vendor.js","sources":["../node_modules/pony-cause/lib/error-with-cause.mjs","../node_modules/pony-cause/lib/helpers.mjs","../node_modules/ionstore/dist/utils.js","../node_modules/ionstore/dist/abstract.js","../node_modules/ionstore/dist/node.js","../node_modules/tiny-colors/dist/constants.js","../node_modules/tiny-colors/dist/index.js","../node_modules/when-exit/dist/node/constants.js","../node_modules/when-exit/dist/node/signals.js","../node_modules/when-exit/dist/node/interceptor.js","../node_modules/when-exit/dist/node/index.js","../node_modules/tiny-updater/dist/compare.js","../node_modules/tiny-updater/dist/utils.js","../node_modules/tiny-updater/dist/store.js","../node_modules/tiny-updater/dist/index.js","../node_modules/ajv/dist/compile/codegen/code.js","../node_modules/ajv/dist/compile/codegen/scope.js","../node_modules/ajv/dist/compile/codegen/index.js","../node_modules/ajv/dist/compile/util.js","../node_modules/ajv/dist/compile/names.js","../node_modules/ajv/dist/compile/errors.js","../node_modules/ajv/dist/compile/validate/boolSchema.js","../node_modules/ajv/dist/compile/validate/applicability.js","../node_modules/ajv/dist/compile/validate/dataType.js","../node_modules/ajv/dist/compile/validate/defaults.js","../node_modules/ajv/dist/vocabularies/code.js","../node_modules/ajv/dist/compile/validate/keyword.js","../node_modules/ajv/dist/compile/validate/subschema.js","../node_modules/fast-deep-equal/index.js","../node_modules/json-schema-traverse/index.js","../node_modules/ajv/dist/compile/resolve.js","../node_modules/ajv/dist/compile/validate/index.js","../node_modules/ajv/dist/runtime/validation_error.js","../node_modules/ajv/dist/compile/ref_error.js","../node_modules/ajv/dist/compile/index.js","../node_modules/fast-uri/lib/scopedChars.js","../node_modules/fast-uri/lib/utils.js","../node_modules/fast-uri/lib/schemes.js","../node_modules/fast-uri/index.js","../node_modules/ajv/dist/core.js","../node_modules/ajv/dist/vocabularies/core/ref.js","../node_modules/ajv/dist/vocabularies/core/index.js","../node_modules/ajv/dist/vocabularies/validation/limitNumber.js","../node_modules/ajv/dist/vocabularies/validation/multipleOf.js","../node_modules/ajv/dist/runtime/ucs2length.js","../node_modules/ajv/dist/vocabularies/validation/limitLength.js","../node_modules/ajv/dist/vocabularies/validation/pattern.js","../node_modules/ajv/dist/vocabularies/validation/limitProperties.js","../node_modules/ajv/dist/vocabularies/validation/required.js","../node_modules/ajv/dist/vocabularies/validation/limitItems.js","../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js","../node_modules/ajv/dist/vocabularies/validation/const.js","../node_modules/ajv/dist/vocabularies/validation/enum.js","../node_modules/ajv/dist/vocabularies/validation/index.js","../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js","../node_modules/ajv/dist/vocabularies/applicator/items.js","../node_modules/ajv/dist/vocabularies/applicator/prefixItems.js","../node_modules/ajv/dist/vocabularies/applicator/items2020.js","../node_modules/ajv/dist/vocabularies/applicator/contains.js","../node_modules/ajv/dist/vocabularies/applicator/dependencies.js","../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js","../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js","../node_modules/ajv/dist/vocabularies/applicator/properties.js","../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js","../node_modules/ajv/dist/vocabularies/applicator/not.js","../node_modules/ajv/dist/vocabularies/applicator/anyOf.js","../node_modules/ajv/dist/vocabularies/applicator/oneOf.js","../node_modules/ajv/dist/vocabularies/applicator/allOf.js","../node_modules/ajv/dist/vocabularies/applicator/if.js","../node_modules/ajv/dist/vocabularies/applicator/thenElse.js","../node_modules/ajv/dist/vocabularies/applicator/index.js","../node_modules/ajv/dist/vocabularies/format/format.js","../node_modules/ajv/dist/vocabularies/metadata.js","../node_modules/ajv/dist/vocabularies/draft7.js","../node_modules/ajv/dist/vocabularies/discriminator/index.js","../node_modules/ajv/dist/ajv.js","../node_modules/pony-cause/index.js","../node_modules/yaml/dist/nodes/identity.js","../node_modules/yaml/dist/visit.js","../node_modules/yaml/dist/doc/directives.js","../node_modules/yaml/dist/doc/anchors.js","../node_modules/yaml/dist/doc/applyReviver.js","../node_modules/yaml/dist/nodes/toJS.js","../node_modules/yaml/dist/nodes/Node.js","../node_modules/yaml/dist/nodes/Alias.js","../node_modules/yaml/dist/nodes/Scalar.js","../node_modules/yaml/dist/doc/createNode.js","../node_modules/yaml/dist/nodes/Collection.js","../node_modules/yaml/dist/stringify/stringifyComment.js","../node_modules/yaml/dist/stringify/foldFlowLines.js","../node_modules/yaml/dist/stringify/stringifyString.js","../node_modules/yaml/dist/stringify/stringify.js","../node_modules/yaml/dist/stringify/stringifyPair.js","../node_modules/yaml/dist/log.js","../node_modules/yaml/dist/schema/yaml-1.1/merge.js","../node_modules/yaml/dist/nodes/addPairToJSMap.js","../node_modules/yaml/dist/nodes/Pair.js","../node_modules/yaml/dist/stringify/stringifyCollection.js","../node_modules/yaml/dist/nodes/YAMLMap.js","../node_modules/yaml/dist/schema/common/map.js","../node_modules/yaml/dist/nodes/YAMLSeq.js","../node_modules/yaml/dist/schema/common/seq.js","../node_modules/yaml/dist/schema/common/string.js","../node_modules/yaml/dist/schema/common/null.js","../node_modules/yaml/dist/schema/core/bool.js","../node_modules/yaml/dist/stringify/stringifyNumber.js","../node_modules/yaml/dist/schema/core/float.js","../node_modules/yaml/dist/schema/core/int.js","../node_modules/yaml/dist/schema/core/schema.js","../node_modules/yaml/dist/schema/json/schema.js","../node_modules/yaml/dist/schema/yaml-1.1/binary.js","../node_modules/yaml/dist/schema/yaml-1.1/pairs.js","../node_modules/yaml/dist/schema/yaml-1.1/omap.js","../node_modules/yaml/dist/schema/yaml-1.1/bool.js","../node_modules/yaml/dist/schema/yaml-1.1/float.js","../node_modules/yaml/dist/schema/yaml-1.1/int.js","../node_modules/yaml/dist/schema/yaml-1.1/set.js","../node_modules/yaml/dist/schema/yaml-1.1/timestamp.js","../node_modules/yaml/dist/schema/yaml-1.1/schema.js","../node_modules/yaml/dist/schema/tags.js","../node_modules/yaml/dist/schema/Schema.js","../node_modules/yaml/dist/stringify/stringifyDocument.js","../node_modules/yaml/dist/doc/Document.js","../node_modules/yaml/dist/errors.js","../node_modules/yaml/dist/compose/resolve-props.js","../node_modules/yaml/dist/compose/util-contains-newline.js","../node_modules/yaml/dist/compose/util-flow-indent-check.js","../node_modules/yaml/dist/compose/util-map-includes.js","../node_modules/yaml/dist/compose/resolve-block-map.js","../node_modules/yaml/dist/compose/resolve-block-seq.js","../node_modules/yaml/dist/compose/resolve-end.js","../node_modules/yaml/dist/compose/resolve-flow-collection.js","../node_modules/yaml/dist/compose/compose-collection.js","../node_modules/yaml/dist/compose/resolve-block-scalar.js","../node_modules/yaml/dist/compose/resolve-flow-scalar.js","../node_modules/yaml/dist/compose/compose-scalar.js","../node_modules/yaml/dist/compose/util-empty-scalar-position.js","../node_modules/yaml/dist/compose/compose-node.js","../node_modules/yaml/dist/compose/compose-doc.js","../node_modules/yaml/dist/compose/composer.js","../node_modules/yaml/dist/parse/cst-scalar.js","../node_modules/yaml/dist/parse/cst-stringify.js","../node_modules/yaml/dist/parse/cst-visit.js","../node_modules/yaml/dist/parse/cst.js","../node_modules/yaml/dist/parse/lexer.js","../node_modules/yaml/dist/parse/line-counter.js","../node_modules/yaml/dist/parse/parser.js","../node_modules/yaml/dist/public-api.js","../node_modules/yaml/dist/index.js","../node_modules/@socketsecurity/config/lib/v1.js","../node_modules/@socketsecurity/config/index.js","../node_modules/ignore/index.js","../node_modules/braces/lib/utils.js","../node_modules/braces/lib/stringify.js","../virtual:purge-polyfills:is-number","../node_modules/to-regex-range/index.js","../node_modules/fill-range/index.js","../node_modules/braces/lib/compile.js","../node_modules/braces/lib/expand.js","../node_modules/braces/lib/constants.js","../node_modules/braces/lib/parse.js","../node_modules/braces/index.js","../node_modules/micromatch/node_modules/picomatch/lib/constants.js","../node_modules/micromatch/node_modules/picomatch/lib/utils.js","../node_modules/micromatch/node_modules/picomatch/lib/scan.js","../node_modules/micromatch/node_modules/picomatch/lib/parse.js","../node_modules/micromatch/node_modules/picomatch/lib/picomatch.js","../node_modules/micromatch/index.js","../node_modules/fdir/dist/utils.js","../node_modules/fdir/dist/api/functions/join-path.js","../node_modules/fdir/dist/api/functions/push-directory.js","../node_modules/fdir/dist/api/functions/push-file.js","../node_modules/fdir/dist/api/functions/get-array.js","../node_modules/fdir/dist/api/functions/group-files.js","../node_modules/fdir/dist/api/functions/resolve-symlink.js","../node_modules/fdir/dist/api/functions/invoke-callback.js","../node_modules/fdir/dist/api/functions/walk-directory.js","../node_modules/fdir/dist/api/queue.js","../node_modules/fdir/dist/api/counter.js","../node_modules/fdir/dist/api/walker.js","../node_modules/fdir/dist/api/async.js","../node_modules/fdir/dist/api/sync.js","../node_modules/fdir/dist/builder/api-builder.js","../node_modules/picomatch/lib/constants.js","../node_modules/picomatch/lib/utils.js","../node_modules/picomatch/lib/scan.js","../node_modules/picomatch/lib/parse.js","../node_modules/picomatch/lib/picomatch.js","../node_modules/picomatch/index.js","../node_modules/fdir/dist/builder/index.js","../node_modules/fdir/dist/types.js","../node_modules/fdir/dist/index.js","../node_modules/tinyglobby/dist/index.js","../node_modules/yoctocolors-cjs/index.js","../node_modules/hpagent/index.js","../node_modules/hpagent/index.mjs","../node_modules/@socketregistry/is-interactive/index.cjs","../node_modules/@socketsecurity/sdk/dist/index.cjs","../node_modules/meow/build/dependencies.js","../node_modules/meow/build/utils.js","../node_modules/meow/build/options.js","../node_modules/meow/build/parser.js","../node_modules/meow/build/validate.js","../node_modules/meow/build/index.js","../node_modules/semver/internal/constants.js","../node_modules/semver/internal/debug.js","../node_modules/semver/internal/re.js","../node_modules/semver/internal/parse-options.js","../node_modules/semver/internal/identifiers.js","../node_modules/semver/classes/semver.js","../node_modules/semver/functions/parse.js","../node_modules/semver/functions/valid.js","../node_modules/semver/functions/clean.js","../node_modules/semver/functions/inc.js","../node_modules/semver/functions/diff.js","../node_modules/semver/functions/major.js","../node_modules/semver/functions/minor.js","../node_modules/semver/functions/patch.js","../node_modules/semver/functions/prerelease.js","../node_modules/semver/functions/compare.js","../node_modules/semver/functions/rcompare.js","../node_modules/semver/functions/compare-loose.js","../node_modules/semver/functions/compare-build.js","../node_modules/semver/functions/sort.js","../node_modules/semver/functions/rsort.js","../node_modules/semver/functions/gt.js","../node_modules/semver/functions/lt.js","../node_modules/semver/functions/eq.js","../node_modules/semver/functions/neq.js","../node_modules/semver/functions/gte.js","../node_modules/semver/functions/lte.js","../node_modules/semver/functions/cmp.js","../node_modules/semver/functions/coerce.js","../node_modules/semver/internal/lrucache.js","../node_modules/semver/classes/range.js","../node_modules/semver/classes/comparator.js","../node_modules/semver/functions/satisfies.js","../node_modules/semver/ranges/to-comparators.js","../node_modules/semver/ranges/max-satisfying.js","../node_modules/semver/ranges/min-satisfying.js","../node_modules/semver/ranges/min-version.js","../node_modules/semver/ranges/valid.js","../node_modules/semver/ranges/outside.js","../node_modules/semver/ranges/gtr.js","../node_modules/semver/ranges/ltr.js","../node_modules/semver/ranges/intersects.js","../node_modules/semver/ranges/simplify.js","../node_modules/semver/ranges/subset.js","../node_modules/semver/index.js","../node_modules/terminal-link/node_modules/ansi-escapes/index.js","../node_modules/has-flag/index.js","../node_modules/supports-hyperlinks/node_modules/supports-color/index.js","../node_modules/supports-hyperlinks/index.js","../node_modules/terminal-link/index.js","../node_modules/yargs-parser/build/lib/string-utils.js","../node_modules/yargs-parser/build/lib/tokenize-arg-string.js","../node_modules/yargs-parser/build/lib/yargs-parser-types.js","../node_modules/yargs-parser/build/lib/yargs-parser.js","../node_modules/yargs-parser/build/lib/index.js","../node_modules/cmd-shim/lib/to-batch-syntax.js","../node_modules/cmd-shim/lib/index.js","../node_modules/which/node_modules/isexe/dist/cjs/posix.js","../node_modules/which/node_modules/isexe/dist/cjs/win32.js","../node_modules/which/lib/index.js","../node_modules/is-docker/index.js","../node_modules/is-inside-container/index.js","../node_modules/is-wsl/index.js","../node_modules/define-lazy-prop/index.js","../node_modules/default-browser-id/index.js","../node_modules/run-applescript/index.js","../node_modules/bundle-name/index.js","../node_modules/default-browser/windows.js","../node_modules/default-browser/index.js","../node_modules/open/index.js","../node_modules/escape-string-regexp/index.js","../node_modules/chalk-table/node_modules/color-name/index.js","../node_modules/chalk-table/node_modules/color-convert/conversions.js","../node_modules/chalk-table/node_modules/color-convert/route.js","../node_modules/chalk-table/node_modules/color-convert/index.js","../node_modules/chalk-table/node_modules/ansi-styles/index.js","../node_modules/chalk-table/node_modules/has-flag/index.js","../node_modules/chalk-table/node_modules/supports-color/index.js","../node_modules/chalk-table/node_modules/chalk/templates.js","../node_modules/chalk-table/node_modules/chalk/index.js","../node_modules/chalk-table/node_modules/ansi-regex/index.js","../node_modules/chalk-table/node_modules/strip-ansi/index.js","../node_modules/chalk-table/src/index.js","../node_modules/@socketregistry/packageurl-js/src/error.js","../node_modules/@socketregistry/packageurl-js/src/decode.js","../node_modules/@socketregistry/packageurl-js/src/constants.js","../node_modules/@socketregistry/packageurl-js/src/objects.js","../node_modules/@socketregistry/packageurl-js/src/strings.js","../node_modules/@socketregistry/packageurl-js/src/encode.js","../node_modules/@socketregistry/packageurl-js/src/helpers.js","../node_modules/@socketregistry/packageurl-js/src/normalize.js","../node_modules/@socketregistry/packageurl-js/src/lang.js","../node_modules/@socketregistry/packageurl-js/src/validate.js","../node_modules/@socketregistry/packageurl-js/src/purl-component.js","../node_modules/@socketregistry/packageurl-js/src/purl-qualifier-names.js","../node_modules/@socketregistry/packageurl-js/src/purl-type.js","../node_modules/@socketregistry/packageurl-js/src/package-url.js","../node_modules/@socketregistry/packageurl-js/index.js","../node_modules/universal-user-agent/index.js","../node_modules/@octokit/endpoint/dist-bundle/index.js","../node_modules/fast-content-type-parse/index.js","../node_modules/@octokit/request-error/dist-src/index.js","../node_modules/@octokit/request/dist-bundle/index.js","../node_modules/@octokit/graphql/dist-bundle/index.js","../node_modules/before-after-hook/lib/register.js","../node_modules/before-after-hook/lib/add.js","../node_modules/before-after-hook/lib/remove.js","../node_modules/before-after-hook/index.js","../node_modules/@octokit/auth-token/dist-bundle/index.js","../node_modules/@octokit/core/dist-src/version.js","../node_modules/@octokit/core/dist-src/index.js","../node_modules/@octokit/plugin-request-log/dist-src/version.js","../node_modules/@octokit/plugin-request-log/dist-src/index.js","../node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js","../node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js","../node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js","../node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js","../node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js","../node_modules/@octokit/rest/dist-src/version.js","../node_modules/@octokit/rest/dist-src/index.js","../node_modules/@socketregistry/indent-string/index.cjs","../node_modules/hosted-git-info/node_modules/lru-cache/dist/commonjs/index.js","../node_modules/hosted-git-info/lib/hosts.js","../node_modules/hosted-git-info/lib/parse-url.js","../node_modules/hosted-git-info/lib/from-url.js","../node_modules/hosted-git-info/lib/index.js","../node_modules/validate-npm-package-name/lib/index.js","../node_modules/proc-log/lib/index.js","../node_modules/npm-package-arg/lib/npa.js","../node_modules/graceful-fs/polyfills.js","../node_modules/graceful-fs/legacy-streams.js","../node_modules/graceful-fs/clone.js","../node_modules/graceful-fs/graceful-fs.js","../node_modules/@pnpm/graceful-fs/lib/index.js","../node_modules/minipass/dist/commonjs/index.js","../node_modules/@pnpm/crypto.hash/node_modules/ssri/lib/index.js","../node_modules/@pnpm/crypto.hash/lib/index.js","../node_modules/@pnpm/dependency-path/lib/index.js","../node_modules/@pnpm/lockfile.detect-dep-types/lib/index.js","../node_modules/@pnpm/constants/lib/index.js","../node_modules/@zkochan/rimraf/index.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/common.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/exception.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/snippet.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/schema.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/str.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/seq.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/map.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/schema/failsafe.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/null.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/bool.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/int.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/float.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/schema/json.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/timestamp.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/merge.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/binary.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/omap.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/pairs.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/type/set.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/schema/default.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/loader.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/lib/dumper.js","../node_modules/@pnpm/lockfile.fs/node_modules/js-yaml/index.js","../node_modules/ramda/src/internal/_isPlaceholder.js","../node_modules/ramda/src/internal/_curry1.js","../node_modules/ramda/src/internal/_has.js","../node_modules/ramda/src/internal/_isArguments.js","../node_modules/ramda/src/internal/_isObject.js","../node_modules/ramda/src/internal/_isString.js","../node_modules/ramda/src/internal/_isTypedArray.js","../node_modules/ramda/src/empty.js","../node_modules/ramda/src/internal/_curry2.js","../node_modules/ramda/src/internal/_arrayFromIterator.js","../node_modules/ramda/src/internal/_includesWith.js","../node_modules/ramda/src/internal/_functionName.js","../node_modules/ramda/src/internal/_objectIs.js","../node_modules/ramda/src/keys.js","../node_modules/ramda/src/type.js","../node_modules/ramda/src/internal/_equals.js","../node_modules/ramda/src/equals.js","../node_modules/ramda/src/isEmpty.js","../node_modules/imurmurhash/imurmurhash.js","../node_modules/signal-exit/dist/cjs/signals.js","../node_modules/signal-exit/dist/cjs/index.js","../node_modules/write-file-atomic/lib/index.js","../node_modules/fast-safe-stringify/index.js","../node_modules/individual/index.js","../node_modules/bole/format.js","../node_modules/bole/bole.js","../node_modules/@pnpm/logger/lib/logger.js","../node_modules/through2/node_modules/readable-stream/lib/internal/streams/stream.js","../node_modules/through2/node_modules/readable-stream/lib/internal/streams/buffer_list.js","../node_modules/through2/node_modules/readable-stream/lib/internal/streams/destroy.js","../node_modules/through2/node_modules/readable-stream/errors.js","../node_modules/through2/node_modules/readable-stream/lib/internal/streams/state.js","../node_modules/inherits/inherits_browser.js","../node_modules/inherits/inherits.js","../node_modules/util-deprecate/node.js","../node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js","../node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js","../node_modules/safe-buffer/index.js","../node_modules/through2/node_modules/string_decoder/lib/string_decoder.js","../node_modules/through2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","../node_modules/through2/node_modules/readable-stream/lib/internal/streams/async_iterator.js","../node_modules/through2/node_modules/readable-stream/lib/internal/streams/from.js","../node_modules/through2/node_modules/readable-stream/lib/_stream_readable.js","../node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js","../node_modules/through2/node_modules/readable-stream/lib/_stream_passthrough.js","../node_modules/through2/node_modules/readable-stream/lib/internal/streams/pipeline.js","../node_modules/through2/node_modules/readable-stream/readable.js","../node_modules/through2/through2.js","../node_modules/split2/node_modules/readable-stream/lib/internal/streams/stream.js","../node_modules/split2/node_modules/readable-stream/lib/internal/streams/buffer_list.js","../node_modules/split2/node_modules/readable-stream/lib/internal/streams/destroy.js","../node_modules/split2/node_modules/readable-stream/errors.js","../node_modules/split2/node_modules/readable-stream/lib/internal/streams/state.js","../node_modules/split2/node_modules/readable-stream/lib/_stream_writable.js","../node_modules/split2/node_modules/readable-stream/lib/_stream_duplex.js","../node_modules/split2/node_modules/string_decoder/lib/string_decoder.js","../node_modules/split2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","../node_modules/split2/node_modules/readable-stream/lib/internal/streams/async_iterator.js","../node_modules/split2/node_modules/readable-stream/lib/internal/streams/from.js","../node_modules/split2/node_modules/readable-stream/lib/_stream_readable.js","../node_modules/split2/node_modules/readable-stream/lib/_stream_transform.js","../node_modules/split2/node_modules/readable-stream/lib/_stream_passthrough.js","../node_modules/split2/node_modules/readable-stream/lib/internal/streams/pipeline.js","../node_modules/split2/node_modules/readable-stream/readable.js","../node_modules/split2/index.js","../node_modules/json-stringify-safe/stringify.js","../node_modules/ndjson/index.js","../node_modules/@pnpm/logger/lib/streamParser.js","../node_modules/@pnpm/logger/lib/index.js","../node_modules/is-plain-obj/index.js","../node_modules/sort-keys/index.js","../node_modules/@pnpm/object.key-sorting/lib/index.js","../node_modules/@pnpm/lockfile.fs/lib/sortLockfileKeys.js","../node_modules/isexe/windows.js","../node_modules/isexe/mode.js","../node_modules/isexe/index.js","../node_modules/@zkochan/which/which.js","../node_modules/cross-spawn/node_modules/which/which.js","../node_modules/path-key/index.js","../node_modules/cross-spawn/lib/util/resolveCommand.js","../node_modules/cross-spawn/lib/util/escape.js","../node_modules/shebang-regex/index.js","../node_modules/shebang-command/index.js","../node_modules/cross-spawn/lib/util/readShebang.js","../node_modules/cross-spawn/lib/parse.js","../node_modules/cross-spawn/lib/enoent.js","../node_modules/cross-spawn/index.js","../node_modules/strip-final-newline/index.js","../node_modules/npm-run-path/index.js","../node_modules/mimic-fn/index.js","../node_modules/execa/node_modules/onetime/index.js","../node_modules/human-signals/build/src/core.js","../node_modules/human-signals/build/src/realtime.js","../node_modules/human-signals/build/src/signals.js","../node_modules/human-signals/build/src/main.js","../node_modules/execa/node_modules/execa/lib/error.js","../node_modules/execa/node_modules/execa/lib/stdio.js","../node_modules/execa/node_modules/signal-exit/signals.js","../node_modules/execa/node_modules/signal-exit/index.js","../node_modules/execa/node_modules/execa/lib/kill.js","../node_modules/execa/node_modules/is-stream/index.js","../node_modules/execa/node_modules/get-stream/buffer-stream.js","../node_modules/execa/node_modules/get-stream/index.js","../node_modules/merge-stream/index.js","../node_modules/execa/node_modules/execa/lib/stream.js","../node_modules/execa/node_modules/execa/lib/promise.js","../node_modules/execa/node_modules/execa/lib/command.js","../node_modules/execa/node_modules/execa/index.js","../node_modules/path-name/index.js","../node_modules/execa/lib/index.js","../node_modules/@pnpm/git-utils/lib/index.js","../node_modules/@pnpm/lockfile.fs/lib/lockfileName.js","../node_modules/@pnpm/types/lib/misc.js","../node_modules/ramda/src/internal/_isTransformer.js","../node_modules/ramda/src/internal/_dispatchable.js","../node_modules/ramda/src/internal/_map.js","../node_modules/ramda/src/internal/_isArrayLike.js","../node_modules/ramda/src/internal/_xwrap.js","../node_modules/ramda/src/internal/_arity.js","../node_modules/ramda/src/bind.js","../node_modules/ramda/src/internal/_reduce.js","../node_modules/ramda/src/internal/_xfBase.js","../node_modules/ramda/src/internal/_xmap.js","../node_modules/ramda/src/internal/_curryN.js","../node_modules/ramda/src/curryN.js","../node_modules/ramda/src/map.js","../node_modules/ramda/src/omit.js","../node_modules/ramda/src/pickBy.js","../node_modules/ramda/src/pick.js","../node_modules/@pnpm/lockfile.fs/lib/lockfileFormatConverters.js","../node_modules/@pnpm/lockfile.fs/lib/write.js","../node_modules/@pnpm/lockfile.fs/lib/existsWantedLockfile.js","../node_modules/normalize-path/index.js","../node_modules/@pnpm/error/lib/index.js","../node_modules/comver-to-semver/index.js","../node_modules/@pnpm/lockfile.merger/lib/index.js","../node_modules/strip-bom/index.js","../node_modules/@pnpm/lockfile.fs/lib/gitMergeFile.js","../node_modules/@pnpm/lockfile.fs/lib/gitBranchLockfile.js","../node_modules/@pnpm/lockfile.fs/lib/read.js","../node_modules/caniuse-lite/data/browsers.js","../node_modules/caniuse-lite/dist/unpacker/browsers.js","../node_modules/caniuse-lite/data/browserVersions.js","../node_modules/caniuse-lite/dist/unpacker/browserVersions.js","../node_modules/caniuse-lite/data/agents.js","../node_modules/caniuse-lite/dist/unpacker/agents.js","../node_modules/electron-to-chromium/versions.js","../node_modules/browserslist/error.js","../node_modules/caniuse-lite/dist/lib/statuses.js","../node_modules/caniuse-lite/dist/lib/supported.js","../node_modules/caniuse-lite/dist/unpacker/feature.js","../node_modules/caniuse-lite/dist/unpacker/region.js","../node_modules/browserslist/node.js","../node_modules/browserslist/parse.js","../node_modules/browserslist/index.js","../node_modules/@socketregistry/hyrious__bun.lockb/index.cjs"],"sourcesContent":["'use strict';\n\n/** @template [T=undefined] */\nexport class ErrorWithCause extends Error {\n  /**\n   * @param {string} message\n   * @param {{ cause?: T }} options\n   */\n  constructor (message, { cause } = {}) {\n    super(message);\n\n    /** @type {string} */\n    this.name = ErrorWithCause.name;\n    if (cause) {\n      /** @type {T} */\n      this.cause = cause;\n    }\n    /** @type {string} */\n    this.message = message;\n  }\n}\n","'use strict';\n\n/**\n * @template {Error} T\n * @param {unknown} err\n * @param {new(...args: any[]) => T} reference\n * @returns {T|undefined}\n */\nexport const findCauseByReference = (err, reference) => {\n  if (!err || !reference) return;\n  if (!(err instanceof Error)) return;\n  if (\n    !(reference.prototype instanceof Error) &&\n    // @ts-ignore\n    reference !== Error\n  ) return;\n\n  /**\n   * Ensures we don't go circular\n   *\n   * @type {Set<Error>}\n   */\n  const seen = new Set();\n\n  /** @type {Error|undefined} */\n  let currentErr = err;\n\n  while (currentErr && !seen.has(currentErr)) {\n    seen.add(currentErr);\n\n    if (currentErr instanceof reference) {\n      return currentErr;\n    }\n\n    currentErr = getErrorCause(currentErr);\n  }\n};\n\n/**\n * @param {Error|{ cause?: unknown|(()=>err)}} err\n * @returns {Error|undefined}\n */\nexport const getErrorCause = (err) => {\n  if (!err || typeof err !== 'object' || !('cause' in err)) {\n    return;\n  }\n\n  // VError / NError style causes\n  if (typeof err.cause === 'function') {\n    const causeResult = err.cause();\n\n    return causeResult instanceof Error\n      ? causeResult\n      : undefined;\n  } else {\n    return err.cause instanceof Error\n      ? err.cause\n      : undefined;\n  }\n};\n\n/**\n * Internal method that keeps a track of which error we have already added, to avoid circular recursion\n *\n * @private\n * @param {Error} err\n * @param {Set<Error>} seen\n * @returns {string}\n */\nconst _stackWithCauses = (err, seen) => {\n  if (!(err instanceof Error)) return '';\n\n  const stack = err.stack || '';\n\n  // Ensure we don't go circular or crazily deep\n  if (seen.has(err)) {\n    return stack + '\\ncauses have become circular...';\n  }\n\n  const cause = getErrorCause(err);\n\n  // TODO: Follow up in https://github.com/nodejs/node/issues/38725#issuecomment-920309092 on how to log stuff\n\n  if (cause) {\n    seen.add(err);\n    return (stack + '\\ncaused by: ' + _stackWithCauses(cause, seen));\n  } else {\n    return stack;\n  }\n};\n\n/**\n * @param {Error} err\n * @returns {string}\n */\nexport const stackWithCauses = (err) => _stackWithCauses(err, new Set());\n\n/**\n * Internal method that keeps a track of which error we have already added, to avoid circular recursion\n *\n * @private\n * @param {Error} err\n * @param {Set<Error>} seen\n * @param {boolean} [skip]\n * @returns {string}\n */\nconst _messageWithCauses = (err, seen, skip) => {\n  if (!(err instanceof Error)) return '';\n\n  const message = skip ? '' : (err.message || '');\n\n  // Ensure we don't go circular or crazily deep\n  if (seen.has(err)) {\n    return message + ': ...';\n  }\n\n  const cause = getErrorCause(err);\n\n  if (cause) {\n    seen.add(err);\n\n    const skipIfVErrorStyleCause = 'cause' in err && typeof err.cause === 'function';\n\n    return (message +\n      (skipIfVErrorStyleCause ? '' : ': ') +\n      _messageWithCauses(cause, seen, skipIfVErrorStyleCause));\n  } else {\n    return message;\n  }\n};\n\n/**\n * @param {Error} err\n * @returns {string}\n */\nexport const messageWithCauses = (err) => _messageWithCauses(err, new Set());\n","/* MAIN */\nconst attempt = (fn, fallback) => {\n    try {\n        return fn();\n    }\n    catch {\n        return fallback;\n    }\n};\n/* EXPORT */\nexport { attempt };\n","/* IMPORT */\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractStore_save;\nimport { attempt } from './utils.js';\n/* MAIN */\nclass AbstractStore extends Map {\n    /* CONSTRUCTOR */\n    constructor(options) {\n        super();\n        /* VARIABLES */\n        _AbstractStore_save.set(this, void 0);\n        const { id, backend } = options;\n        if (!/^[a-zA-Z0-9_-]+$/.test(id))\n            throw new Error(`Invalid store id: \"${id}\"`);\n        const read = () => attempt(() => backend.read(id), []);\n        const write = () => attempt(() => backend.write(id, this.entries()), null);\n        for (const [key, value] of read()) {\n            super.set(key, value);\n        }\n        __classPrivateFieldSet(this, _AbstractStore_save, write, \"f\");\n        return this;\n    }\n    /* API */\n    clear() {\n        if (!this.size)\n            return;\n        super.clear();\n        __classPrivateFieldGet(this, _AbstractStore_save, \"f\").call(this);\n    }\n    delete(key) {\n        const deleted = super.delete(key);\n        if (!deleted)\n            return false;\n        __classPrivateFieldGet(this, _AbstractStore_save, \"f\").call(this);\n        return true;\n    }\n    set(key, value) {\n        const valuePrev = this.get(key);\n        if (value === valuePrev)\n            return this;\n        super.set(key, value);\n        __classPrivateFieldGet(this, _AbstractStore_save, \"f\").call(this);\n        return this;\n    }\n}\n_AbstractStore_save = new WeakMap();\n/* EXPORT */\nexport default AbstractStore;\n","/* IMPORT */\nimport fs from 'node:fs';\nimport os from 'node:os';\nimport path from 'node:path';\nimport AbstractStore from './abstract.js';\n/* MAIN */\nclass NodeStore extends AbstractStore {\n    /* CONSTRUCTOR */\n    constructor(id) {\n        super({\n            id,\n            backend: {\n                read: id => {\n                    const filePath = path.join(os.tmpdir(), `ionstore_${id}.json`);\n                    const content = fs.readFileSync(filePath, 'utf8');\n                    return JSON.parse(content);\n                },\n                write: (id, data) => {\n                    const filePath = path.join(os.tmpdir(), `ionstore_${id}.json`);\n                    const content = JSON.stringify(Array.from(data));\n                    return fs.writeFileSync(filePath, content);\n                }\n            }\n        });\n    }\n}\n/* EXPORT */\nexport default NodeStore;\n","/* MAIN */\nconst ENV = globalThis.process?.env || {};\nconst ARGV = globalThis.process?.argv || [];\nconst IS_ENABLED = !('NO_COLOR' in ENV) && (ENV.TERM !== 'dumb') && !ARGV.includes('--no-color') && !ARGV.includes('--no-colors') && (!globalThis.process?.stdout || globalThis.process?.stdout?.isTTY === true);\n/* EXPORT */\nexport { IS_ENABLED };\n","/* IMPORT */\nimport { IS_ENABLED } from './constants.js';\n/* HELPERS */\nconst chain = (modifier) => {\n    return new Proxy(modifier, {\n        get(target, prop) {\n            if (prop in colors) {\n                return chain(string => modifier(colors[prop](string)));\n            }\n            else {\n                return target[prop];\n            }\n        }\n    });\n};\nconst wrap = (start, end) => {\n    return chain((string) => {\n        if (!IS_ENABLED)\n            return string;\n        return `\\u001B[${start}m${string}\\u001B[${end}m`;\n    });\n};\n/* MAIN */\nconst colors = {\n    /* MODIFIERS */\n    reset: wrap(0, 0),\n    bold: wrap(1, 22),\n    dim: wrap(2, 22),\n    italic: wrap(3, 23),\n    underline: wrap(4, 24),\n    overline: wrap(53, 55),\n    inverse: wrap(7, 27),\n    hidden: wrap(8, 28),\n    strikethrough: wrap(9, 29),\n    /* FOREGOUND */\n    black: wrap(30, 39),\n    red: wrap(31, 39),\n    green: wrap(32, 39),\n    yellow: wrap(33, 39),\n    blue: wrap(34, 39),\n    magenta: wrap(35, 39),\n    cyan: wrap(36, 39),\n    white: wrap(37, 39),\n    gray: wrap(90, 39),\n    /* BACKGROUND */\n    bgBlack: wrap(40, 49),\n    bgRed: wrap(41, 49),\n    bgGreen: wrap(42, 49),\n    bgYellow: wrap(43, 49),\n    bgBlue: wrap(44, 49),\n    bgMagenta: wrap(45, 49),\n    bgCyan: wrap(46, 49),\n    bgWhite: wrap(47, 49),\n    bgGray: wrap(100, 49)\n};\n/* EXPORT */\nexport default colors;\n","/* IMPORT */\nimport process from 'node:process';\n/* MAIN */\nconst IS_LINUX = (process.platform === 'linux');\nconst IS_WINDOWS = (process.platform === 'win32');\n/* EXPORT */\nexport { IS_LINUX, IS_WINDOWS };\n","/* IMPORT */\nimport { IS_LINUX, IS_WINDOWS } from './constants.js';\n/* MAIN */\n//URL: https://github.com/tapjs/signal-exit/blob/03dd77a96caa309c6a02c59274d58c812a2dce45/signals.js\nconst Signals = ['SIGABRT', 'SIGALRM', 'SIGHUP', 'SIGINT', 'SIGTERM'];\nif (!IS_WINDOWS) {\n    Signals.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT');\n}\nif (IS_LINUX) {\n    Signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT', 'SIGUNUSED');\n}\n/* EXPORT */\nexport default Signals;\n","/* IMPORT */\nimport process from 'node:process';\nimport { IS_WINDOWS } from './constants.js';\nimport Signals from './signals.js';\n/* MAIN */\nclass Interceptor {\n    /* CONSTRUCTOR */\n    constructor() {\n        /* VARIABLES */\n        this.callbacks = new Set();\n        this.exited = false;\n        /* API */\n        this.exit = (signal) => {\n            if (this.exited)\n                return;\n            this.exited = true;\n            for (const callback of this.callbacks) {\n                callback();\n            }\n            if (signal) {\n                if (IS_WINDOWS && (signal !== 'SIGINT' && signal !== 'SIGTERM' && signal !== 'SIGKILL')) { // Windows doesn't support POSIX signals, but Node emulates these 3 signals for us\n                    process.kill(process.pid, 'SIGTERM');\n                }\n                else {\n                    process.kill(process.pid, signal);\n                }\n            }\n        };\n        this.hook = () => {\n            process.once('exit', () => this.exit());\n            for (const signal of Signals) {\n                try {\n                    process.once(signal, () => this.exit(signal));\n                }\n                catch {\n                    // Sometimes \"process.once\" can throw...\n                }\n            }\n        };\n        this.register = (callback) => {\n            this.callbacks.add(callback);\n            return () => {\n                this.callbacks.delete(callback);\n            };\n        };\n        this.hook();\n    }\n}\n/* EXPORT */\nexport default new Interceptor();\n","/* IMPORT */\nimport Interceptor from './interceptor.js';\n/* MAIN */\nconst whenExit = Interceptor.register;\n/* EXPORT */\nexport default whenExit;\n","/**\n * This software is released under the MIT license:\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n/* MAIN */\n// The following is just a slightly modified version of semver-compare\nconst compare = (a, b) => {\n    const pa = a.split('.');\n    const pb = b.split('.');\n    for (let i = 0; i < 3; i++) {\n        let na = Number(pa[i]);\n        let nb = Number(pb[i]);\n        if (na > nb)\n            return 1;\n        if (nb > na)\n            return -1;\n        if (!isNaN(na) && isNaN(nb))\n            return 1;\n        if (isNaN(na) && !isNaN(nb))\n            return -1;\n    }\n    return 0;\n};\n/* EXPORT */\nexport default compare;\n","/* IMPORT */\nimport colors from 'tiny-colors';\nimport whenExit from 'when-exit';\nimport compare from './compare.js';\n/* MAIN */\nconst Utils = {\n    /* API */\n    fetch: async (url) => {\n        const signal = Utils.getExitSignal();\n        const request = await fetch(url, { signal });\n        const json = await request.json();\n        return json;\n    },\n    getExitSignal: () => {\n        const aborter = new AbortController();\n        whenExit(() => aborter.abort());\n        return aborter.signal;\n    },\n    getLatestVersion: async (name) => {\n        const latestUrl = `https://registry.npmjs.org/${name}/latest`;\n        const latest = await Utils.fetch(latestUrl);\n        return latest.version;\n    },\n    isNumber: (value) => {\n        return typeof value === 'number';\n    },\n    isString: (value) => {\n        return typeof value === 'string';\n    },\n    isUpdateAvailable: (current, latest) => {\n        return compare(current, latest) === -1;\n    },\n    noop: () => {\n        return;\n    },\n    notify: (name, version, latest) => {\n        if (!globalThis.process?.stdout?.isTTY)\n            return; // Probably piping stdout\n        const log = () => console.log(`\\n\\n📦 Update available for ${colors.cyan(name)}: ${colors.gray(version)} → ${colors.green(latest)}`);\n        whenExit(log);\n    }\n};\n/* EXPORT */\nexport default Utils;\n","/* IMPORT */\nimport IonStore from 'ionstore';\nimport Utils from './utils.js';\n/* MAIN */\nclass Store {\n    constructor() {\n        /* VARIABLES */\n        this.store = new IonStore('tiny-updater');\n        /* API */\n        this.get = (name) => {\n            try {\n                const recordRaw = this.store.get(name);\n                if (!recordRaw)\n                    return;\n                const record = JSON.parse(recordRaw);\n                if (!Utils.isNumber(record.timestampFetch))\n                    return;\n                if (!Utils.isNumber(record.timestampNotification))\n                    return;\n                if (!Utils.isString(record.version))\n                    return;\n                return record;\n            }\n            catch {\n                return;\n            }\n        };\n        this.set = (name, record) => {\n            this.store.set(name, JSON.stringify(record));\n        };\n    }\n}\n/* EXPORT */\nexport default new Store();\n","/* IMPORT */\nimport Store from './store.js';\nimport Utils from './utils.js';\n/* MAIN */\n//TODO: Account for non-latest releases\nconst updater = async ({ name, version, ttl = 0 }) => {\n    const record = Store.get(name);\n    const timestamp = Date.now();\n    const isFresh = !record || (timestamp - record.timestampFetch) >= ttl;\n    const latest = isFresh ? await Utils.getLatestVersion(name).catch(Utils.noop) : record?.version;\n    if (!latest)\n        return false;\n    if (isFresh) {\n        const record = { timestampFetch: timestamp, timestampNotification: timestamp, version: latest };\n        Store.set(name, record);\n    }\n    if (!Utils.isUpdateAvailable(version, latest)) {\n        return false;\n    }\n    if (isFresh) {\n        Utils.notify(name, version, latest);\n    }\n    return true;\n};\n/* EXPORT */\nexport default updater;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass _CodeOrName {\n}\nexports._CodeOrName = _CodeOrName;\nexports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass Name extends _CodeOrName {\n    constructor(s) {\n        super();\n        if (!exports.IDENTIFIER.test(s))\n            throw new Error(\"CodeGen: name must be a valid identifier\");\n        this.str = s;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        return false;\n    }\n    get names() {\n        return { [this.str]: 1 };\n    }\n}\nexports.Name = Name;\nclass _Code extends _CodeOrName {\n    constructor(code) {\n        super();\n        this._items = typeof code === \"string\" ? [code] : code;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        if (this._items.length > 1)\n            return false;\n        const item = this._items[0];\n        return item === \"\" || item === '\"\"';\n    }\n    get str() {\n        var _a;\n        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, \"\")));\n    }\n    get names() {\n        var _a;\n        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {\n            if (c instanceof Name)\n                names[c.str] = (names[c.str] || 0) + 1;\n            return names;\n        }, {})));\n    }\n}\nexports._Code = _Code;\nexports.nil = new _Code(\"\");\nfunction _(strs, ...args) {\n    const code = [strs[0]];\n    let i = 0;\n    while (i < args.length) {\n        addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n    }\n    return new _Code(code);\n}\nexports._ = _;\nconst plus = new _Code(\"+\");\nfunction str(strs, ...args) {\n    const expr = [safeStringify(strs[0])];\n    let i = 0;\n    while (i < args.length) {\n        expr.push(plus);\n        addCodeArg(expr, args[i]);\n        expr.push(plus, safeStringify(strs[++i]));\n    }\n    optimize(expr);\n    return new _Code(expr);\n}\nexports.str = str;\nfunction addCodeArg(code, arg) {\n    if (arg instanceof _Code)\n        code.push(...arg._items);\n    else if (arg instanceof Name)\n        code.push(arg);\n    else\n        code.push(interpolate(arg));\n}\nexports.addCodeArg = addCodeArg;\nfunction optimize(expr) {\n    let i = 1;\n    while (i < expr.length - 1) {\n        if (expr[i] === plus) {\n            const res = mergeExprItems(expr[i - 1], expr[i + 1]);\n            if (res !== undefined) {\n                expr.splice(i - 1, 3, res);\n                continue;\n            }\n            expr[i++] = \"+\";\n        }\n        i++;\n    }\n}\nfunction mergeExprItems(a, b) {\n    if (b === '\"\"')\n        return a;\n    if (a === '\"\"')\n        return b;\n    if (typeof a == \"string\") {\n        if (b instanceof Name || a[a.length - 1] !== '\"')\n            return;\n        if (typeof b != \"string\")\n            return `${a.slice(0, -1)}${b}\"`;\n        if (b[0] === '\"')\n            return a.slice(0, -1) + b.slice(1);\n        return;\n    }\n    if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name))\n        return `\"${a}${b.slice(1)}`;\n    return;\n}\nfunction strConcat(c1, c2) {\n    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;\n}\nexports.strConcat = strConcat;\n// TODO do not allow arrays here\nfunction interpolate(x) {\n    return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n        ? x\n        : safeStringify(Array.isArray(x) ? x.join(\",\") : x);\n}\nfunction stringify(x) {\n    return new _Code(safeStringify(x));\n}\nexports.stringify = stringify;\nfunction safeStringify(x) {\n    return JSON.stringify(x)\n        .replace(/\\u2028/g, \"\\\\u2028\")\n        .replace(/\\u2029/g, \"\\\\u2029\");\n}\nexports.safeStringify = safeStringify;\nfunction getProperty(key) {\n    return typeof key == \"string\" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;\n}\nexports.getProperty = getProperty;\n//Does best effort to format the name properly\nfunction getEsmExportName(key) {\n    if (typeof key == \"string\" && exports.IDENTIFIER.test(key)) {\n        return new _Code(`${key}`);\n    }\n    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n}\nexports.getEsmExportName = getEsmExportName;\nfunction regexpCode(rx) {\n    return new _Code(rx.toString());\n}\nexports.regexpCode = regexpCode;\n//# sourceMappingURL=code.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = require(\"./code\");\nclass ValueError extends Error {\n    constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n    UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n    UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));\nexports.varKinds = {\n    const: new code_1.Name(\"const\"),\n    let: new code_1.Name(\"let\"),\n    var: new code_1.Name(\"var\"),\n};\nclass Scope {\n    constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {\n            throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return (this._names[prefix] = { prefix, index: 0 });\n    }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n    constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;\n    }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._) `\\n`;\nclass ValueScope extends Scope {\n    constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined)\n            throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name)\n                return _name;\n        }\n        else {\n            vs = this._values[prefix] = new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n            return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n            if (name.scopePath === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return (0, code_1._) `${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n            if (name.value === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n            const vs = values[prefix];\n            if (!vs)\n                continue;\n            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());\n            vs.forEach((name) => {\n                if (nameSet.has(name))\n                    return;\n                nameSet.set(name, UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;\n                }\n                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {\n                    code = (0, code_1._) `${code}${c}${this.opts._n}`;\n                }\n                else {\n                    throw new ValueError(name);\n                }\n                nameSet.set(name, UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nexports.ValueScope = ValueScope;\n//# sourceMappingURL=scope.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\nconst code_1 = require(\"./code\");\nconst scope_1 = require(\"./scope\");\nvar code_2 = require(\"./code\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return code_2._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return code_2.str; } });\nObject.defineProperty(exports, \"strConcat\", { enumerable: true, get: function () { return code_2.strConcat; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return code_2.nil; } });\nObject.defineProperty(exports, \"getProperty\", { enumerable: true, get: function () { return code_2.getProperty; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return code_2.stringify; } });\nObject.defineProperty(exports, \"regexpCode\", { enumerable: true, get: function () { return code_2.regexpCode; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return code_2.Name; } });\nvar scope_2 = require(\"./scope\");\nObject.defineProperty(exports, \"Scope\", { enumerable: true, get: function () { return scope_2.Scope; } });\nObject.defineProperty(exports, \"ValueScope\", { enumerable: true, get: function () { return scope_2.ValueScope; } });\nObject.defineProperty(exports, \"ValueScopeName\", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });\nObject.defineProperty(exports, \"varKinds\", { enumerable: true, get: function () { return scope_2.varKinds; } });\nexports.operators = {\n    GT: new code_1._Code(\">\"),\n    GTE: new code_1._Code(\">=\"),\n    LT: new code_1._Code(\"<\"),\n    LTE: new code_1._Code(\"<=\"),\n    EQ: new code_1._Code(\"===\"),\n    NEQ: new code_1._Code(\"!==\"),\n    NOT: new code_1._Code(\"!\"),\n    OR: new code_1._Code(\"||\"),\n    AND: new code_1._Code(\"&&\"),\n    ADD: new code_1._Code(\"+\"),\n};\nclass Node {\n    optimizeNodes() {\n        return this;\n    }\n    optimizeNames(_names, _constants) {\n        return this;\n    }\n}\nclass Def extends Node {\n    constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n    }\n    render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (!names[this.name.str])\n            return;\n        if (this.rhs)\n            this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n    }\n}\nclass Assign extends Node {\n    constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n    }\n    render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n            return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n    }\n}\nclass AssignOp extends Assign {\n    constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n    }\n    render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n    }\n}\nclass Label extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        return `${this.label}:` + _n;\n    }\n}\nclass Break extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n    }\n}\nclass Throw extends Node {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render({ _n }) {\n        return `throw ${this.error};` + _n;\n    }\n    get names() {\n        return this.error.names;\n    }\n}\nclass AnyCode extends Node {\n    constructor(code) {\n        super();\n        this.code = code;\n    }\n    render({ _n }) {\n        return `${this.code};` + _n;\n    }\n    optimizeNodes() {\n        return `${this.code}` ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n    }\n    get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n    }\n}\nclass ParentNode extends Node {\n    constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n    }\n    render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n    }\n    optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            const n = nodes[i].optimizeNodes();\n            if (Array.isArray(n))\n                nodes.splice(i, 1, ...n);\n            else if (n)\n                nodes[i] = n;\n            else\n                nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            // iterating backwards improves 1-pass optimization\n            const n = nodes[i];\n            if (n.optimizeNames(names, constants))\n                continue;\n            subtractNames(names, n.names);\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n    }\n}\nclass BlockNode extends ParentNode {\n    render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n    }\n}\nclass Root extends ParentNode {\n}\nclass Else extends BlockNode {\n}\nElse.kind = \"else\";\nclass If extends BlockNode {\n    constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n    }\n    render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n            code += \"else \" + this.else.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n            return this.nodes; // else is ignored here\n        let e = this.else;\n        if (e) {\n            const ns = e.optimizeNodes();\n            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n            if (cond === false)\n                return e instanceof If ? e : e.nodes;\n            if (this.nodes.length)\n                return this;\n            return new If(not(cond), e instanceof If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n            return undefined;\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n            return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n            addNames(names, this.else.names);\n        return names;\n    }\n}\nIf.kind = \"if\";\nclass For extends BlockNode {\n}\nFor.kind = \"for\";\nclass ForLoop extends For {\n    constructor(iteration) {\n        super();\n        this.iteration = iteration;\n    }\n    render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iteration.names);\n    }\n}\nclass ForRange extends For {\n    constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n    }\n    render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n    }\n    get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n    }\n}\nclass ForIter extends For {\n    constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n    }\n    render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iterable.names);\n    }\n}\nclass Func extends BlockNode {\n    constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n    }\n    render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n    }\n}\nFunc.kind = \"func\";\nclass Return extends ParentNode {\n    render(opts) {\n        return \"return \" + super.render(opts);\n    }\n}\nReturn.kind = \"return\";\nclass Try extends BlockNode {\n    render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch)\n            code += this.catch.render(opts);\n        if (this.finally)\n            code += this.finally.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        if (this.catch)\n            addNames(names, this.catch.names);\n        if (this.finally)\n            addNames(names, this.finally.names);\n        return names;\n    }\n}\nclass Catch extends BlockNode {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n    }\n}\nCatch.kind = \"catch\";\nclass Finally extends BlockNode {\n    render(opts) {\n        return \"finally\" + super.render(opts);\n    }\n}\nFinally.kind = \"finally\";\nclass CodeGen {\n    constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? \"\\n\" : \"\" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n    }\n    toString() {\n        return this._root.render(this.opts);\n    }\n    // returns unique name in the internal scope\n    name(prefix) {\n        return this._scope.name(prefix);\n    }\n    // reserves unique name in the external scope\n    scopeName(prefix) {\n        return this._extScope.name(prefix);\n    }\n    // reserves unique name in the external scope and assigns value to it\n    scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n        vs.add(name);\n        return name;\n    }\n    getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n    }\n    // return code that assigns values in the external scope to the names that are used internally\n    // (same names that were returned by gen.scopeName or gen.scopeValue)\n    scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n    }\n    scopeCode() {\n        return this._extScope.scopeCode(this._values);\n    }\n    _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== undefined && constant)\n            this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n    }\n    // `const` declaration (`var` in es5 mode)\n    const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n    }\n    // `let` declaration with optional assignment (`var` in es5 mode)\n    let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n    }\n    // `var` declaration with optional assignment\n    var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n    }\n    // assignment code\n    assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n    }\n    // `+=` code\n    add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n    }\n    // appends passed SafeExpr to code or executes Block\n    code(c) {\n        if (typeof c == \"function\")\n            c();\n        else if (c !== code_1.nil)\n            this._leafNode(new AnyCode(c));\n        return this;\n    }\n    // returns code for object literal for the passed argument list of key-value pairs\n    object(...keyValues) {\n        const code = [\"{\"];\n        for (const [key, value] of keyValues) {\n            if (code.length > 1)\n                code.push(\",\");\n            code.push(key);\n            if (key !== value || this.opts.es5) {\n                code.push(\":\");\n                (0, code_1.addCodeArg)(code, value);\n            }\n        }\n        code.push(\"}\");\n        return new code_1._Code(code);\n    }\n    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n    if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n            this.code(thenBody).else().code(elseBody).endIf();\n        }\n        else if (thenBody) {\n            this.code(thenBody).endIf();\n        }\n        else if (elseBody) {\n            throw new Error('CodeGen: \"else\" body without \"then\" body');\n        }\n        return this;\n    }\n    // `else if` clause - invalid without `if` or after `else` clauses\n    elseIf(condition) {\n        return this._elseNode(new If(condition));\n    }\n    // `else` clause - only valid after `if` or `else if` clauses\n    else() {\n        return this._elseNode(new Else());\n    }\n    // end `if` statement (needed if gen.if was used only with condition)\n    endIf() {\n        return this._endBlockNode(If, Else);\n    }\n    _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n            this.code(forBody).endFor();\n        return this;\n    }\n    // a generic `for` clause (or statement if `forBody` is passed)\n    for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n    }\n    // `for` statement for a range of values\n    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n    }\n    // `for-of` statement (in es5 mode replace with a normal for loop)\n    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n            const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n            return this.forRange(\"_i\", 0, (0, code_1._) `${arr}.length`, (i) => {\n                this.var(name, (0, code_1._) `${arr}[${i}]`);\n                forBody(name);\n            });\n        }\n        return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n    }\n    // `for-in` statement.\n    // With option `ownProperties` replaced with a `for-of` loop for object keys\n    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n    }\n    // end `for` loop\n    endFor() {\n        return this._endBlockNode(For);\n    }\n    // `label` statement\n    label(label) {\n        return this._leafNode(new Label(label));\n    }\n    // `break` statement\n    break(label) {\n        return this._leafNode(new Break(label));\n    }\n    // `return` statement\n    return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n            throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode(Return);\n    }\n    // `try` statement\n    try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n            throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n            const error = this.name(\"e\");\n            this._currNode = node.catch = new Catch(error);\n            catchCode(error);\n        }\n        if (finallyCode) {\n            this._currNode = node.finally = new Finally();\n            this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n    }\n    // `throw` statement\n    throw(error) {\n        return this._leafNode(new Throw(error));\n    }\n    // start self-balancing block\n    block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n            this.code(body).endBlock(nodeCount);\n        return this;\n    }\n    // end the current self-balancing block\n    endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === undefined)\n            throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n    }\n    // `function` heading (or definition if funcBody is passed)\n    func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n            this.code(funcBody).endFunc();\n        return this;\n    }\n    // end function definition\n    endFunc() {\n        return this._endBlockNode(Func);\n    }\n    optimize(n = 1) {\n        while (n-- > 0) {\n            this._root.optimizeNodes();\n            this._root.optimizeNames(this._root.names, this._constants);\n        }\n    }\n    _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n    }\n    _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n    }\n    _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || (N2 && n instanceof N2)) {\n            this._nodes.pop();\n            return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n    }\n    _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n            throw new Error('CodeGen: \"else\" without \"if\"');\n        }\n        this._currNode = n.else = node;\n        return this;\n    }\n    get _root() {\n        return this._nodes[0];\n    }\n    get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n    }\n    set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n    }\n}\nexports.CodeGen = CodeGen;\nfunction addNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n    return names;\n}\nfunction addExprNames(names, from) {\n    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\nfunction optimizeExpr(expr, names, constants) {\n    if (expr instanceof code_1.Name)\n        return replaceName(expr);\n    if (!canOptimize(expr))\n        return expr;\n    return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n            c = replaceName(c);\n        if (c instanceof code_1._Code)\n            items.push(...c._items);\n        else\n            items.push(c);\n        return items;\n    }, []));\n    function replaceName(n) {\n        const c = constants[n.str];\n        if (c === undefined || names[n.str] !== 1)\n            return n;\n        delete names[n.str];\n        return c;\n    }\n    function canOptimize(e) {\n        return (e instanceof code_1._Code &&\n            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));\n    }\n}\nfunction subtractNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction not(x) {\n    return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._) `!${par(x)}`;\n}\nexports.not = not;\nconst andCode = mappend(exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction and(...args) {\n    return args.reduce(andCode);\n}\nexports.and = and;\nconst orCode = mappend(exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction or(...args) {\n    return args.reduce(orCode);\n}\nexports.or = or;\nfunction mappend(op) {\n    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);\n}\nfunction par(x) {\n    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst code_1 = require(\"./codegen/code\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === \"boolean\")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: \"${key}\"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n            return schema;\n        if (typeof schema == \"string\")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == \"number\")\n        return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var(\"items\", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type || (exports.Type = Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `\"[\" + ${dataProp} + \"]\"`\n                : (0, codegen_1._) `\"['\" + ${dataProp} + \"']\"`\n            : isNumber\n                ? (0, codegen_1._) `\"/\" + ${dataProp}`\n                : (0, codegen_1._) `\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n//# sourceMappingURL=util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"./codegen\");\nconst names = {\n    // validation function arguments\n    data: new codegen_1.Name(\"data\"), // data passed to validation function\n    // args passed from referencing schema\n    valCxt: new codegen_1.Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n    instancePath: new codegen_1.Name(\"instancePath\"),\n    parentData: new codegen_1.Name(\"parentData\"),\n    parentDataProperty: new codegen_1.Name(\"parentDataProperty\"),\n    rootData: new codegen_1.Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n    dynamicAnchors: new codegen_1.Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n    // function scoped variables\n    vErrors: new codegen_1.Name(\"vErrors\"), // null or array of validation errors\n    errors: new codegen_1.Name(\"errors\"), // counter of validation errors\n    this: new codegen_1.Name(\"this\"),\n    // \"globals\"\n    self: new codegen_1.Name(\"self\"),\n    scope: new codegen_1.Name(\"scope\"),\n    // JTD serialize/parse name for JSON string and position\n    json: new codegen_1.Name(\"json\"),\n    jsonPos: new codegen_1.Name(\"jsonPos\"),\n    jsonLen: new codegen_1.Name(\"jsonLen\"),\n    jsonPart: new codegen_1.Name(\"jsonPart\"),\n};\nexports.default = names;\n//# sourceMappingURL=names.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst util_1 = require(\"./util\");\nconst names_1 = require(\"./names\");\nexports.keywordError = {\n    message: ({ keyword }) => (0, codegen_1.str) `must pass \"${keyword}\" keyword validation`,\n};\nexports.keyword$DataError = {\n    message: ({ keyword, schemaType }) => schemaType\n        ? (0, codegen_1.str) `\"${keyword}\" keyword must be ${schemaType} ($data)`\n        : (0, codegen_1.str) `\"${keyword}\" keyword is invalid ($data)`,\n};\nfunction reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {\n        addError(gen, errObj);\n    }\n    else {\n        returnErrors(it, (0, codegen_1._) `[${errObj}]`);\n    }\n}\nexports.reportError = reportError;\nfunction reportExtraError(cxt, error = exports.keywordError, errorPaths) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    addError(gen, errObj);\n    if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n    }\n}\nexports.reportExtraError = reportExtraError;\nfunction resetErrorsCount(gen, errsCount) {\n    gen.assign(names_1.default.errors, errsCount);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\nexports.resetErrorsCount = resetErrorsCount;\nfunction extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {\n    /* istanbul ignore if */\n    if (errsCount === undefined)\n        throw new Error(\"ajv implementation error\");\n    const err = gen.name(\"err\");\n    gen.forRange(\"i\", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);\n        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);\n            gen.assign((0, codegen_1._) `${err}.data`, data);\n        }\n    });\n}\nexports.extendErrors = extendErrors;\nfunction addError(gen, errObj) {\n    const err = gen.const(\"err\", errObj);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);\n    gen.code((0, codegen_1._) `${names_1.default.errors}++`);\n}\nfunction returnErrors(it, errs) {\n    const { gen, validateName, schemaEnv } = it;\n    if (schemaEnv.$async) {\n        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);\n        gen.return(false);\n    }\n}\nconst E = {\n    keyword: new codegen_1.Name(\"keyword\"),\n    schemaPath: new codegen_1.Name(\"schemaPath\"), // also used in JTD errors\n    params: new codegen_1.Name(\"params\"),\n    propertyName: new codegen_1.Name(\"propertyName\"),\n    message: new codegen_1.Name(\"message\"),\n    schema: new codegen_1.Name(\"schema\"),\n    parentSchema: new codegen_1.Name(\"parentSchema\"),\n};\nfunction errorObjectCode(cxt, error, errorPaths) {\n    const { createErrors } = cxt.it;\n    if (createErrors === false)\n        return (0, codegen_1._) `{}`;\n    return errorObject(cxt, error, errorPaths);\n}\nfunction errorObject(cxt, error, errorPaths = {}) {\n    const { gen, it } = cxt;\n    const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths),\n    ];\n    extraErrorProps(cxt, error, keyValues);\n    return gen.object(...keyValues);\n}\nfunction errorInstancePath({ errorPath }, { instancePath }) {\n    const instPath = instancePath\n        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`\n        : errorPath;\n    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n}\nfunction errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;\n    if (schemaPath) {\n        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n    }\n    return [E.schemaPath, schPath];\n}\nfunction extraErrorProps(cxt, { params, message }, keyValues) {\n    const { keyword, data, schemaValue, it } = cxt;\n    const { opts, propertyName, topSchemaRef, schemaPath } = it;\n    keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || (0, codegen_1._) `{}`]);\n    if (opts.messages) {\n        keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n    }\n    if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n    }\n    if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n}\n//# sourceMappingURL=errors.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;\nfunction schemaHasRulesForType({ schema, self }, type) {\n    const group = self.RULES.types[type];\n    return group && group !== true && shouldUseGroup(schema, group);\n}\nexports.schemaHasRulesForType = schemaHasRulesForType;\nfunction shouldUseGroup(schema, group) {\n    return group.rules.some((rule) => shouldUseRule(schema, rule));\n}\nexports.shouldUseGroup = shouldUseGroup;\nfunction shouldUseRule(schema, rule) {\n    var _a;\n    return (schema[rule.keyword] !== undefined ||\n        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));\n}\nexports.shouldUseRule = shouldUseRule;\n//# sourceMappingURL=applicability.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = require(\"../rules\");\nconst applicability_1 = require(\"./applicability\");\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType || (exports.DataType = DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n//# sourceMappingURL=dataType.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assignDefaults = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nfunction assignDefaults(it, ty) {\n    const { properties, items } = it.schema;\n    if (ty === \"object\" && properties) {\n        for (const key in properties) {\n            assignDefault(it, key, properties[key].default);\n        }\n    }\n    else if (ty === \"array\" && Array.isArray(items)) {\n        items.forEach((sch, i) => assignDefault(it, i, sch.default));\n    }\n}\nexports.assignDefaults = assignDefaults;\nfunction assignDefault(it, prop, defaultValue) {\n    const { gen, compositeRule, data, opts } = it;\n    if (defaultValue === undefined)\n        return;\n    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;\n    if (compositeRule) {\n        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n    }\n    let condition = (0, codegen_1._) `${childData} === undefined`;\n    if (opts.useDefaults === \"empty\") {\n        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === \"\"`;\n    }\n    // `${childData} === undefined` +\n    // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);\n}\n//# sourceMappingURL=defaults.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = require(\"../compile/codegen\");\nconst util_1 = require(\"../compile/util\");\nconst names_1 = require(\"../compile/names\");\nconst util_2 = require(\"../compile/util\");\nfunction checkReportMissingProp(cxt, prop) {\n    const { gen, data, it } = cxt;\n    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);\n        cxt.error();\n    });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp({ gen, data, it: { opts } }, properties, missing) {\n    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n    cxt.setParams({ missingProperty: missing }, true);\n    cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n    return gen.scopeValue(\"func\", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,\n    });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {\n    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n    const valCxt = [\n        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],\n        [names_1.default.parentData, it.parentData],\n        [names_1.default.parentDataProperty, it.parentDataProperty],\n        [names_1.default.rootData, names_1.default.rootData],\n    ];\n    if (it.opts.dynamicRef)\n        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;\n    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._) `new RegExp`;\nfunction usePattern({ gen, it: { opts } }, pattern) {\n    const u = opts.unicodeRegExp ? \"u\" : \"\";\n    const { regExp } = opts.code;\n    const rx = regExp(pattern, u);\n    return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._) `${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,\n    });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    if (it.allErrors) {\n        const validArr = gen.let(\"valid\", true);\n        validateItems(() => gen.assign(validArr, false));\n        return validArr;\n    }\n    gen.var(valid, true);\n    validateItems(() => gen.break());\n    return valid;\n    function validateItems(notValid) {\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        gen.forRange(\"i\", 0, len, (i) => {\n            cxt.subschema({\n                keyword,\n                dataProp: i,\n                dataPropType: util_1.Type.Num,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), notValid);\n        });\n    }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n    const { gen, schema, keyword, it } = cxt;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema))\n        throw new Error(\"ajv implementation error\");\n    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));\n    if (alwaysValid && !it.opts.unevaluated)\n        return;\n    const valid = gen.let(\"valid\", false);\n    const schValid = gen.name(\"_valid\");\n    gen.block(() => schema.forEach((_sch, i) => {\n        const schCxt = cxt.subschema({\n            keyword,\n            schemaProp: i,\n            compositeRule: true,\n        }, schValid);\n        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);\n        const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n        // or if all properties and items were evaluated (it.props === true && it.items === true)\n        if (!merged)\n            gen.if((0, codegen_1.not)(valid));\n    }));\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;\n//# sourceMappingURL=code.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nfunction getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {\n    if (keyword !== undefined && schema !== undefined) {\n        throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n    }\n    if (keyword !== undefined) {\n        const sch = it.schema[keyword];\n        return schemaProp === undefined\n            ? {\n                schema: sch,\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n            }\n            : {\n                schema: sch[schemaProp],\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,\n            };\n    }\n    if (schema !== undefined) {\n        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n            throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n        }\n        return {\n            schema,\n            schemaPath,\n            topSchemaRef,\n            errSchemaPath,\n        };\n    }\n    throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nexports.getSubschema = getSubschema;\nfunction extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {\n    if (data !== undefined && dataProp !== undefined) {\n        throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n    }\n    const { gen } = it;\n    if (dataProp !== undefined) {\n        const { errorPath, dataPathArr, opts } = it;\n        const nextData = gen.let(\"data\", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;\n        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n    }\n    if (data !== undefined) {\n        const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n        dataContextProps(nextData);\n        if (propertyName !== undefined)\n            subschema.propertyName = propertyName;\n        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n    }\n    if (dataTypes)\n        subschema.dataTypes = dataTypes;\n    function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [...it.dataNames, _nextData];\n    }\n}\nexports.extendSubschemaData = extendSubschemaData;\nfunction extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {\n    if (compositeRule !== undefined)\n        subschema.compositeRule = compositeRule;\n    if (createErrors !== undefined)\n        subschema.createErrors = createErrors;\n    if (allErrors !== undefined)\n        subschema.allErrors = allErrors;\n    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n    subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nexports.extendSubschemaMode = extendSubschemaMode;\n//# sourceMappingURL=subschema.js.map","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst traverse = require(\"json-schema-traverse\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let innerBaseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            innerBaseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = innerBaseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n//# sourceMappingURL=resolve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction narrowSchemaTypes(it, withTypes) {\n    const ts = [];\n    for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n            ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\")\n            ts.push(\"integer\");\n    }\n    it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ValidationError extends Error {\n    constructor(errors) {\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n    }\n}\nexports.default = ValidationError;\n//# sourceMappingURL=validation_error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst resolve_1 = require(\"./resolve\");\nclass MissingRefError extends Error {\n    constructor(resolver, baseId, ref, msg) {\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));\n    }\n}\nexports.default = MissingRefError;\n//# sourceMappingURL=ref_error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map","'use strict'\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n","'use strict'\n\nconst { HEX } = require('./scopedChars')\n\nconst IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)$/u\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(IPV4_REG) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host)\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n","'use strict'\n\nconst UUID_REG = /^[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n","'use strict'\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require('./lib/utils')\nconst SCHEMES = require('./lib/schemes')\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(components)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?', components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#', components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host)\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports.default = fastUri\nmodule.exports.fastUri = fastUri\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nexports.default = Ajv;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports.default = def;\n//# sourceMappingURL=ref.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst id_1 = require(\"./id\");\nconst ref_1 = require(\"./ref\");\nconst core = [\n    \"$schema\",\n    \"$id\",\n    \"$defs\",\n    \"$vocabulary\",\n    { keyword: \"$comment\" },\n    \"definitions\",\n    id_1.default,\n    ref_1.default,\n];\nexports.default = core;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    maximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    minimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    exclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    exclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: Object.keys(KWDs),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitNumber.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec\n            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n            : (0, codegen_1._) `${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=multipleOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n    const len = str.length;\n    let length = 0;\n    let pos = 0;\n    let value;\n    while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n            // high surrogate, and there is a next character\n            value = str.charCodeAt(pos);\n            if ((value & 0xfc00) === 0xdc00)\n                pos++; // low surrogate\n        }\n    }\n    return length;\n}\nexports.default = ucs2length;\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n//# sourceMappingURL=ucs2length.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst ucs2length_1 = require(\"../../runtime/ucs2length\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxLength\", \"minLength\"],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === \"maxLength\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitLength.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        // TODO regexp should be wrapped in try/catchs\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=pattern.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxProperties\", \"minProperties\"],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=required.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxItems\", \"minItems\"],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataType_1 = require(\"../../compile/validate/dataType\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, codegen_1._) `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == \"string\"`, (0, codegen_1._) `${item} += \"_\"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=uniqueItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to constant\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"const\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || (schema && typeof schema == \"object\")) {\n            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        }\n        else {\n            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=const.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=enum.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst limitNumber_1 = require(\"./limitNumber\");\nconst multipleOf_1 = require(\"./multipleOf\");\nconst limitLength_1 = require(\"./limitLength\");\nconst pattern_1 = require(\"./pattern\");\nconst limitProperties_1 = require(\"./limitProperties\");\nconst required_1 = require(\"./required\");\nconst limitItems_1 = require(\"./limitItems\");\nconst uniqueItems_1 = require(\"./uniqueItems\");\nconst const_1 = require(\"./const\");\nconst enum_1 = require(\"./enum\");\nconst validation = [\n    // number\n    limitNumber_1.default,\n    multipleOf_1.default,\n    // string\n    limitLength_1.default,\n    pattern_1.default,\n    // object\n    limitProperties_1.default,\n    required_1.default,\n    // array\n    limitItems_1.default,\n    uniqueItems_1.default,\n    // any\n    { keyword: \"type\", schemaType: [\"string\", \"array\"] },\n    { keyword: \"nullable\", schemaType: \"boolean\" },\n    const_1.default,\n    enum_1.default,\n];\nexports.default = validation;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = def;\n//# sourceMappingURL=additionalItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;\n//# sourceMappingURL=items.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst items_1 = require(\"./items\");\nconst def = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\"array\"],\n    before: \"uniqueItems\",\n    code: (cxt) => (0, items_1.validateTuple)(cxt, \"items\"),\n};\nexports.default = def;\n//# sourceMappingURL=prefixItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst additionalItems_1 = require(\"./additionalItems\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        if (prefixItems)\n            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n            cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nexports.default = def;\n//# sourceMappingURL=items2020.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=contains.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nexports.error = {\n    message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n};\nconst def = {\n    keyword: \"dependencies\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: exports.error,\n    code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n    },\n};\nfunction splitDependencies({ schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for (const key in schema) {\n        if (key === \"__proto__\")\n            continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen, data, it } = cxt;\n    if (Object.keys(propertyDeps).length === 0)\n        return;\n    const missing = gen.let(\"missing\");\n    for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n            continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(\", \"),\n        });\n        if (it.allErrors) {\n            gen.if(hasProperty, () => {\n                for (const depProp of deps) {\n                    (0, code_1.checkReportMissingProp)(cxt, depProp);\n                }\n            });\n        }\n        else {\n            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n            continue;\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, () => gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = def;\n//# sourceMappingURL=dependencies.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"property name must be valid\",\n    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,\n};\nconst def = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\"object\", \"boolean\"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key) => {\n            cxt.setParams({ propertyName: key });\n            cxt.subschema({\n                keyword: \"propertyNames\",\n                data: key,\n                dataTypes: [\"string\"],\n                propertyName: key,\n                compositeRule: true,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), () => {\n                cxt.error(true);\n                if (!it.allErrors)\n                    gen.break();\n            });\n        });\n        cxt.ok(valid);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=propertyNames.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must NOT have additional properties\",\n    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,\n};\nconst def = {\n    keyword: \"additionalProperties\",\n    type: [\"object\"],\n    schemaType: [\"boolean\", \"object\"],\n    allowUndefined: true,\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error(\"ajv implementation error\");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n            gen.forIn(\"key\", data, (key) => {\n                if (!props.length && !patProps.length)\n                    additionalPropertyCode(key);\n                else\n                    gen.if(isAdditional(key), () => additionalPropertyCode(key));\n            });\n        }\n        function isAdditional(key) {\n            let definedProp;\n            if (props.length > 8) {\n                // TODO maybe an option instead of hard-coded 8?\n                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n            }\n            else if (props.length) {\n                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));\n            }\n            else {\n                definedProp = codegen_1.nil;\n            }\n            if (patProps.length) {\n                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n            }\n            return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n            gen.code((0, codegen_1._) `delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n            if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n                deleteAdditional(key);\n                return;\n            }\n            if (schema === false) {\n                cxt.setParams({ additionalProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                if (opts.removeAdditional === \"failing\") {\n                    applyAdditionalSchema(key, valid, false);\n                    gen.if((0, codegen_1.not)(valid), () => {\n                        cxt.reset();\n                        deleteAdditional(key);\n                    });\n                }\n                else {\n                    applyAdditionalSchema(key, valid);\n                    if (!allErrors)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                }\n            }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n            const subschema = {\n                keyword: \"additionalProperties\",\n                dataProp: key,\n                dataPropType: util_1.Type.Str,\n            };\n            if (errors === false) {\n                Object.assign(subschema, {\n                    compositeRule: true,\n                    createErrors: false,\n                    allErrors: false,\n                });\n            }\n            cxt.subschema(subschema, valid);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=additionalProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_1 = require(\"../../compile/validate\");\nconst code_1 = require(\"../code\");\nconst util_1 = require(\"../../compile/util\");\nconst additionalProperties_1 = require(\"./additionalProperties\");\nconst def = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n            it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n            return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties) {\n            if (hasDefault(prop)) {\n                applyPropertySchema(prop);\n            }\n            else {\n                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n                applyPropertySchema(prop);\n                if (!it.allErrors)\n                    gen.else().var(valid, true);\n                gen.endIf();\n            }\n            cxt.it.definedProperties.add(prop);\n            cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n        }\n        function applyPropertySchema(prop) {\n            cxt.subschema({\n                keyword: \"properties\",\n                schemaProp: prop,\n                dataProp: prop,\n            }, valid);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=properties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=patternProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: \"must NOT be valid\" },\n};\nexports.default = def;\n//# sourceMappingURL=not.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"anyOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    code: code_1.validateUnion,\n    error: { message: \"must match a schema in anyOf\" },\n};\nexports.default = def;\n//# sourceMappingURL=anyOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=oneOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports.default = def;\n//# sourceMappingURL=allOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports.default = def;\n//# sourceMappingURL=if.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: [\"then\", \"else\"],\n    schemaType: [\"object\", \"boolean\"],\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === undefined)\n            (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=thenElse.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst additionalItems_1 = require(\"./additionalItems\");\nconst prefixItems_1 = require(\"./prefixItems\");\nconst items_1 = require(\"./items\");\nconst items2020_1 = require(\"./items2020\");\nconst contains_1 = require(\"./contains\");\nconst dependencies_1 = require(\"./dependencies\");\nconst propertyNames_1 = require(\"./propertyNames\");\nconst additionalProperties_1 = require(\"./additionalProperties\");\nconst properties_1 = require(\"./properties\");\nconst patternProperties_1 = require(\"./patternProperties\");\nconst not_1 = require(\"./not\");\nconst anyOf_1 = require(\"./anyOf\");\nconst oneOf_1 = require(\"./oneOf\");\nconst allOf_1 = require(\"./allOf\");\nconst if_1 = require(\"./if\");\nconst thenElse_1 = require(\"./thenElse\");\nfunction getApplicator(draft2020 = false) {\n    const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default,\n    ];\n    // array\n    if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n    else\n        applicator.push(additionalItems_1.default, items_1.default);\n    applicator.push(contains_1.default);\n    return applicator;\n}\nexports.default = getApplicator;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || \"string\"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=format.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.contentVocabulary = exports.metadataVocabulary = void 0;\nexports.metadataVocabulary = [\n    \"title\",\n    \"description\",\n    \"default\",\n    \"deprecated\",\n    \"readOnly\",\n    \"writeOnly\",\n    \"examples\",\n];\nexports.contentVocabulary = [\n    \"contentMediaType\",\n    \"contentEncoding\",\n    \"contentSchema\",\n];\n//# sourceMappingURL=metadata.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"./core\");\nconst validation_1 = require(\"./validation\");\nconst applicator_1 = require(\"./applicator\");\nconst format_1 = require(\"./format\");\nconst metadata_1 = require(\"./metadata\");\nconst draft7Vocabularies = [\n    core_1.default,\n    validation_1.default,\n    (0, applicator_1.default)(),\n    format_1.default,\n    metadata_1.metadataVocabulary,\n    metadata_1.contentVocabulary,\n];\nexports.default = draft7Vocabularies;\n//# sourceMappingURL=draft7.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst types_1 = require(\"../discriminator/types\");\nconst compile_1 = require(\"../../compile\");\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    const ref = sch.$ref;\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                    if (sch === undefined)\n                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;\nconst core_1 = require(\"./core\");\nconst draft7_1 = require(\"./vocabularies/draft7\");\nconst discriminator_1 = require(\"./vocabularies/discriminator\");\nconst draft7MetaSchema = require(\"./refs/json-schema-draft-07.json\");\nconst META_SUPPORT_DATA = [\"/properties\"];\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\nclass Ajv extends core_1.default {\n    _addVocabularies() {\n        super._addVocabularies();\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n            this.addKeyword(discriminator_1.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta)\n            return;\n        const metaSchema = this.opts.$data\n            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n            : draft7MetaSchema;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return (this.opts.defaultMeta =\n            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));\n    }\n}\nexports.Ajv = Ajv;\nmodule.exports = exports = Ajv;\nmodule.exports.Ajv = Ajv;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Ajv;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nvar validation_error_1 = require(\"./runtime/validation_error\");\nObject.defineProperty(exports, \"ValidationError\", { enumerable: true, get: function () { return validation_error_1.default; } });\nvar ref_error_1 = require(\"./compile/ref_error\");\nObject.defineProperty(exports, \"MissingRefError\", { enumerable: true, get: function () { return ref_error_1.default; } });\n//# sourceMappingURL=ajv.js.map","'use strict';\n\nconst { ErrorWithCause } = require('./lib/error-with-cause'); // linemod-replace-with: export { ErrorWithCause } from './lib/error-with-cause.mjs';\n\nconst { // linemod-replace-with: export {\n  findCauseByReference,\n  getErrorCause,\n  messageWithCauses,\n  stackWithCauses,\n} = require('./lib/helpers'); // linemod-replace-with: } from './lib/helpers.mjs';\n\nmodule.exports = {      // linemod-remove\n  ErrorWithCause,       // linemod-remove\n  findCauseByReference, // linemod-remove\n  getErrorCause,        // linemod-remove\n  stackWithCauses,      // linemod-remove\n  messageWithCauses,    // linemod-remove\n};                      // linemod-remove\n","'use strict';\n\nconst ALIAS = Symbol.for('yaml.alias');\nconst DOC = Symbol.for('yaml.document');\nconst MAP = Symbol.for('yaml.map');\nconst PAIR = Symbol.for('yaml.pair');\nconst SCALAR = Symbol.for('yaml.scalar');\nconst SEQ = Symbol.for('yaml.seq');\nconst NODE_TYPE = Symbol.for('yaml.node.type');\nconst isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;\nconst isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;\nconst isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;\nconst isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;\nconst isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;\nconst isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;\nfunction isCollection(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case MAP:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nfunction isNode(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case ALIAS:\n            case MAP:\n            case SCALAR:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nconst hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;\n\nexports.ALIAS = ALIAS;\nexports.DOC = DOC;\nexports.MAP = MAP;\nexports.NODE_TYPE = NODE_TYPE;\nexports.PAIR = PAIR;\nexports.SCALAR = SCALAR;\nexports.SEQ = SEQ;\nexports.hasAnchor = hasAnchor;\nexports.isAlias = isAlias;\nexports.isCollection = isCollection;\nexports.isDocument = isDocument;\nexports.isMap = isMap;\nexports.isNode = isNode;\nexports.isPair = isPair;\nexports.isScalar = isScalar;\nexports.isSeq = isSeq;\n","'use strict';\n\nvar identity = require('./nodes/identity.js');\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove node');\n/**\n * Apply a visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nfunction visit(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (identity.isDocument(node)) {\n        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        visit_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisit.SKIP = SKIP;\n/** Remove the current node */\nvisit.REMOVE = REMOVE;\nfunction visit_(key, node, visitor, path) {\n    const ctrl = callVisitor(key, node, visitor, path);\n    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visit_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (identity.isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = visit_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (identity.isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = visit_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = visit_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\n/**\n * Apply an async visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `Promise`: Must resolve to one of the following values\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nasync function visitAsync(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (identity.isDocument(node)) {\n        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        await visitAsync_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisitAsync.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisitAsync.SKIP = SKIP;\n/** Remove the current node */\nvisitAsync.REMOVE = REMOVE;\nasync function visitAsync_(key, node, visitor, path) {\n    const ctrl = await callVisitor(key, node, visitor, path);\n    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visitAsync_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (identity.isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = await visitAsync_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (identity.isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = await visitAsync_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = await visitAsync_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\nfunction initVisitor(visitor) {\n    if (typeof visitor === 'object' &&\n        (visitor.Collection || visitor.Node || visitor.Value)) {\n        return Object.assign({\n            Alias: visitor.Node,\n            Map: visitor.Node,\n            Scalar: visitor.Node,\n            Seq: visitor.Node\n        }, visitor.Value && {\n            Map: visitor.Value,\n            Scalar: visitor.Value,\n            Seq: visitor.Value\n        }, visitor.Collection && {\n            Map: visitor.Collection,\n            Seq: visitor.Collection\n        }, visitor);\n    }\n    return visitor;\n}\nfunction callVisitor(key, node, visitor, path) {\n    if (typeof visitor === 'function')\n        return visitor(key, node, path);\n    if (identity.isMap(node))\n        return visitor.Map?.(key, node, path);\n    if (identity.isSeq(node))\n        return visitor.Seq?.(key, node, path);\n    if (identity.isPair(node))\n        return visitor.Pair?.(key, node, path);\n    if (identity.isScalar(node))\n        return visitor.Scalar?.(key, node, path);\n    if (identity.isAlias(node))\n        return visitor.Alias?.(key, node, path);\n    return undefined;\n}\nfunction replaceNode(key, path, node) {\n    const parent = path[path.length - 1];\n    if (identity.isCollection(parent)) {\n        parent.items[key] = node;\n    }\n    else if (identity.isPair(parent)) {\n        if (key === 'key')\n            parent.key = node;\n        else\n            parent.value = node;\n    }\n    else if (identity.isDocument(parent)) {\n        parent.contents = node;\n    }\n    else {\n        const pt = identity.isAlias(parent) ? 'alias' : 'scalar';\n        throw new Error(`Cannot replace node with ${pt} parent`);\n    }\n}\n\nexports.visit = visit;\nexports.visitAsync = visitAsync;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar visit = require('../visit.js');\n\nconst escapeChars = {\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n};\nconst escapeTagName = (tn) => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\nclass Directives {\n    constructor(yaml, tags) {\n        /**\n         * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n         * included in the document's stringified representation.\n         */\n        this.docStart = null;\n        /** The doc-end marker `...`.  */\n        this.docEnd = false;\n        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\n        this.tags = Object.assign({}, Directives.defaultTags, tags);\n    }\n    clone() {\n        const copy = new Directives(this.yaml, this.tags);\n        copy.docStart = this.docStart;\n        return copy;\n    }\n    /**\n     * During parsing, get a Directives instance for the current document and\n     * update the stream state according to the current version's spec.\n     */\n    atDocument() {\n        const res = new Directives(this.yaml, this.tags);\n        switch (this.yaml.version) {\n            case '1.1':\n                this.atNextDocument = true;\n                break;\n            case '1.2':\n                this.atNextDocument = false;\n                this.yaml = {\n                    explicit: Directives.defaultYaml.explicit,\n                    version: '1.2'\n                };\n                this.tags = Object.assign({}, Directives.defaultTags);\n                break;\n        }\n        return res;\n    }\n    /**\n     * @param onError - May be called even if the action was successful\n     * @returns `true` on success\n     */\n    add(line, onError) {\n        if (this.atNextDocument) {\n            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };\n            this.tags = Object.assign({}, Directives.defaultTags);\n            this.atNextDocument = false;\n        }\n        const parts = line.trim().split(/[ \\t]+/);\n        const name = parts.shift();\n        switch (name) {\n            case '%TAG': {\n                if (parts.length !== 2) {\n                    onError(0, '%TAG directive should contain exactly two parts');\n                    if (parts.length < 2)\n                        return false;\n                }\n                const [handle, prefix] = parts;\n                this.tags[handle] = prefix;\n                return true;\n            }\n            case '%YAML': {\n                this.yaml.explicit = true;\n                if (parts.length !== 1) {\n                    onError(0, '%YAML directive should contain exactly one part');\n                    return false;\n                }\n                const [version] = parts;\n                if (version === '1.1' || version === '1.2') {\n                    this.yaml.version = version;\n                    return true;\n                }\n                else {\n                    const isValid = /^\\d+\\.\\d+$/.test(version);\n                    onError(6, `Unsupported YAML version ${version}`, isValid);\n                    return false;\n                }\n            }\n            default:\n                onError(0, `Unknown directive ${name}`, true);\n                return false;\n        }\n    }\n    /**\n     * Resolves a tag, matching handles to those defined in %TAG directives.\n     *\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n     *   `'!local'` tag, or `null` if unresolvable.\n     */\n    tagName(source, onError) {\n        if (source === '!')\n            return '!'; // non-specific tag\n        if (source[0] !== '!') {\n            onError(`Not a valid tag: ${source}`);\n            return null;\n        }\n        if (source[1] === '<') {\n            const verbatim = source.slice(2, -1);\n            if (verbatim === '!' || verbatim === '!!') {\n                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);\n                return null;\n            }\n            if (source[source.length - 1] !== '>')\n                onError('Verbatim tags must end with a >');\n            return verbatim;\n        }\n        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);\n        if (!suffix)\n            onError(`The ${source} tag has no suffix`);\n        const prefix = this.tags[handle];\n        if (prefix) {\n            try {\n                return prefix + decodeURIComponent(suffix);\n            }\n            catch (error) {\n                onError(String(error));\n                return null;\n            }\n        }\n        if (handle === '!')\n            return source; // local tag\n        onError(`Could not resolve tag: ${source}`);\n        return null;\n    }\n    /**\n     * Given a fully resolved tag, returns its printable string form,\n     * taking into account current tag prefixes and defaults.\n     */\n    tagString(tag) {\n        for (const [handle, prefix] of Object.entries(this.tags)) {\n            if (tag.startsWith(prefix))\n                return handle + escapeTagName(tag.substring(prefix.length));\n        }\n        return tag[0] === '!' ? tag : `!<${tag}>`;\n    }\n    toString(doc) {\n        const lines = this.yaml.explicit\n            ? [`%YAML ${this.yaml.version || '1.2'}`]\n            : [];\n        const tagEntries = Object.entries(this.tags);\n        let tagNames;\n        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {\n            const tags = {};\n            visit.visit(doc.contents, (_key, node) => {\n                if (identity.isNode(node) && node.tag)\n                    tags[node.tag] = true;\n            });\n            tagNames = Object.keys(tags);\n        }\n        else\n            tagNames = [];\n        for (const [handle, prefix] of tagEntries) {\n            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')\n                continue;\n            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))\n                lines.push(`%TAG ${handle} ${prefix}`);\n        }\n        return lines.join('\\n');\n    }\n}\nDirectives.defaultYaml = { explicit: false, version: '1.2' };\nDirectives.defaultTags = { '!!': 'tag:yaml.org,2002:' };\n\nexports.Directives = Directives;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar visit = require('../visit.js');\n\n/**\n * Verify that the input string is a valid anchor.\n *\n * Will throw on errors.\n */\nfunction anchorIsValid(anchor) {\n    if (/[\\x00-\\x19\\s,[\\]{}]/.test(anchor)) {\n        const sa = JSON.stringify(anchor);\n        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;\n        throw new Error(msg);\n    }\n    return true;\n}\nfunction anchorNames(root) {\n    const anchors = new Set();\n    visit.visit(root, {\n        Value(_key, node) {\n            if (node.anchor)\n                anchors.add(node.anchor);\n        }\n    });\n    return anchors;\n}\n/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */\nfunction findNewAnchor(prefix, exclude) {\n    for (let i = 1; true; ++i) {\n        const name = `${prefix}${i}`;\n        if (!exclude.has(name))\n            return name;\n    }\n}\nfunction createNodeAnchors(doc, prefix) {\n    const aliasObjects = [];\n    const sourceObjects = new Map();\n    let prevAnchors = null;\n    return {\n        onAnchor: (source) => {\n            aliasObjects.push(source);\n            if (!prevAnchors)\n                prevAnchors = anchorNames(doc);\n            const anchor = findNewAnchor(prefix, prevAnchors);\n            prevAnchors.add(anchor);\n            return anchor;\n        },\n        /**\n         * With circular references, the source node is only resolved after all\n         * of its child nodes are. This is why anchors are set only after all of\n         * the nodes have been created.\n         */\n        setAnchors: () => {\n            for (const source of aliasObjects) {\n                const ref = sourceObjects.get(source);\n                if (typeof ref === 'object' &&\n                    ref.anchor &&\n                    (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {\n                    ref.node.anchor = ref.anchor;\n                }\n                else {\n                    const error = new Error('Failed to resolve repeated object (this should not happen)');\n                    error.source = source;\n                    throw error;\n                }\n            }\n        },\n        sourceObjects\n    };\n}\n\nexports.anchorIsValid = anchorIsValid;\nexports.anchorNames = anchorNames;\nexports.createNodeAnchors = createNodeAnchors;\nexports.findNewAnchor = findNewAnchor;\n","'use strict';\n\n/**\n * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,\n * in section 24.5.1.1 \"Runtime Semantics: InternalizeJSONProperty\" of the\n * 2021 edition: https://tc39.es/ecma262/#sec-json.parse\n *\n * Includes extensions for handling Map and Set objects.\n */\nfunction applyReviver(reviver, obj, key, val) {\n    if (val && typeof val === 'object') {\n        if (Array.isArray(val)) {\n            for (let i = 0, len = val.length; i < len; ++i) {\n                const v0 = val[i];\n                const v1 = applyReviver(reviver, val, String(i), v0);\n                // eslint-disable-next-line @typescript-eslint/no-array-delete\n                if (v1 === undefined)\n                    delete val[i];\n                else if (v1 !== v0)\n                    val[i] = v1;\n            }\n        }\n        else if (val instanceof Map) {\n            for (const k of Array.from(val.keys())) {\n                const v0 = val.get(k);\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    val.delete(k);\n                else if (v1 !== v0)\n                    val.set(k, v1);\n            }\n        }\n        else if (val instanceof Set) {\n            for (const v0 of Array.from(val)) {\n                const v1 = applyReviver(reviver, val, v0, v0);\n                if (v1 === undefined)\n                    val.delete(v0);\n                else if (v1 !== v0) {\n                    val.delete(v0);\n                    val.add(v1);\n                }\n            }\n        }\n        else {\n            for (const [k, v0] of Object.entries(val)) {\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    delete val[k];\n                else if (v1 !== v0)\n                    val[k] = v1;\n            }\n        }\n    }\n    return reviver.call(obj, key, val);\n}\n\nexports.applyReviver = applyReviver;\n","'use strict';\n\nvar identity = require('./identity.js');\n\n/**\n * Recursively convert any node or its contents to native JavaScript\n *\n * @param value - The input value\n * @param arg - If `value` defines a `toJSON()` method, use this\n *   as its first argument\n * @param ctx - Conversion context, originally set in Document#toJS(). If\n *   `{ keep: true }` is not set, output should be suitable for JSON\n *   stringification.\n */\nfunction toJS(value, arg, ctx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    if (Array.isArray(value))\n        return value.map((v, i) => toJS(v, String(i), ctx));\n    if (value && typeof value.toJSON === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        if (!ctx || !identity.hasAnchor(value))\n            return value.toJSON(arg, ctx);\n        const data = { aliasCount: 0, count: 1, res: undefined };\n        ctx.anchors.set(value, data);\n        ctx.onCreate = res => {\n            data.res = res;\n            delete ctx.onCreate;\n        };\n        const res = value.toJSON(arg, ctx);\n        if (ctx.onCreate)\n            ctx.onCreate(res);\n        return res;\n    }\n    if (typeof value === 'bigint' && !ctx?.keep)\n        return Number(value);\n    return value;\n}\n\nexports.toJS = toJS;\n","'use strict';\n\nvar applyReviver = require('../doc/applyReviver.js');\nvar identity = require('./identity.js');\nvar toJS = require('./toJS.js');\n\nclass NodeBase {\n    constructor(type) {\n        Object.defineProperty(this, identity.NODE_TYPE, { value: type });\n    }\n    /** Create a copy of this node.  */\n    clone() {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** A plain JavaScript representation of this node. */\n    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        if (!identity.isDocument(doc))\n            throw new TypeError('A document argument is required');\n        const ctx = {\n            anchors: new Map(),\n            doc,\n            keep: true,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS.toJS(this, '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver.applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n}\n\nexports.NodeBase = NodeBase;\n","'use strict';\n\nvar anchors = require('../doc/anchors.js');\nvar visit = require('../visit.js');\nvar identity = require('./identity.js');\nvar Node = require('./Node.js');\nvar toJS = require('./toJS.js');\n\nclass Alias extends Node.NodeBase {\n    constructor(source) {\n        super(identity.ALIAS);\n        this.source = source;\n        Object.defineProperty(this, 'tag', {\n            set() {\n                throw new Error('Alias nodes cannot have tags');\n            }\n        });\n    }\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc) {\n        let found = undefined;\n        visit.visit(doc, {\n            Node: (_key, node) => {\n                if (node === this)\n                    return visit.visit.BREAK;\n                if (node.anchor === this.source)\n                    found = node;\n            }\n        });\n        return found;\n    }\n    toJSON(_arg, ctx) {\n        if (!ctx)\n            return { source: this.source };\n        const { anchors, doc, maxAliasCount } = ctx;\n        const source = this.resolve(doc);\n        if (!source) {\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n            throw new ReferenceError(msg);\n        }\n        let data = anchors.get(source);\n        if (!data) {\n            // Resolve anchors for Node.prototype.toJS()\n            toJS.toJS(source, null, ctx);\n            data = anchors.get(source);\n        }\n        /* istanbul ignore if */\n        if (!data || data.res === undefined) {\n            const msg = 'This should not happen: Alias anchor was not resolved?';\n            throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            data.count += 1;\n            if (data.aliasCount === 0)\n                data.aliasCount = getAliasCount(doc, source, anchors);\n            if (data.count * data.aliasCount > maxAliasCount) {\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\n                throw new ReferenceError(msg);\n            }\n        }\n        return data.res;\n    }\n    toString(ctx, _onComment, _onChompKeep) {\n        const src = `*${this.source}`;\n        if (ctx) {\n            anchors.anchorIsValid(this.source);\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n                throw new Error(msg);\n            }\n            if (ctx.implicitKey)\n                return `${src} `;\n        }\n        return src;\n    }\n}\nfunction getAliasCount(doc, node, anchors) {\n    if (identity.isAlias(node)) {\n        const source = node.resolve(doc);\n        const anchor = anchors && source && anchors.get(source);\n        return anchor ? anchor.count * anchor.aliasCount : 0;\n    }\n    else if (identity.isCollection(node)) {\n        let count = 0;\n        for (const item of node.items) {\n            const c = getAliasCount(doc, item, anchors);\n            if (c > count)\n                count = c;\n        }\n        return count;\n    }\n    else if (identity.isPair(node)) {\n        const kc = getAliasCount(doc, node.key, anchors);\n        const vc = getAliasCount(doc, node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n}\n\nexports.Alias = Alias;\n","'use strict';\n\nvar identity = require('./identity.js');\nvar Node = require('./Node.js');\nvar toJS = require('./toJS.js');\n\nconst isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');\nclass Scalar extends Node.NodeBase {\n    constructor(value) {\n        super(identity.SCALAR);\n        this.value = value;\n    }\n    toJSON(arg, ctx) {\n        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);\n    }\n    toString() {\n        return String(this.value);\n    }\n}\nScalar.BLOCK_FOLDED = 'BLOCK_FOLDED';\nScalar.BLOCK_LITERAL = 'BLOCK_LITERAL';\nScalar.PLAIN = 'PLAIN';\nScalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';\nScalar.QUOTE_SINGLE = 'QUOTE_SINGLE';\n\nexports.Scalar = Scalar;\nexports.isScalarValue = isScalarValue;\n","'use strict';\n\nvar Alias = require('../nodes/Alias.js');\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\n\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nfunction findTagObject(value, tagName, tags) {\n    if (tagName) {\n        const match = tags.filter(t => t.tag === tagName);\n        const tagObj = match.find(t => !t.format) ?? match[0];\n        if (!tagObj)\n            throw new Error(`Tag ${tagName} not found`);\n        return tagObj;\n    }\n    return tags.find(t => t.identify?.(value) && !t.format);\n}\nfunction createNode(value, tagName, ctx) {\n    if (identity.isDocument(value))\n        value = value.contents;\n    if (identity.isNode(value))\n        return value;\n    if (identity.isPair(value)) {\n        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);\n        map.items.push(value);\n        return map;\n    }\n    if (value instanceof String ||\n        value instanceof Number ||\n        value instanceof Boolean ||\n        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere\n    ) {\n        // https://tc39.es/ecma262/#sec-serializejsonproperty\n        value = value.valueOf();\n    }\n    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;\n    // Detect duplicate references to the same object & use Alias nodes for all\n    // after first. The `ref` wrapper allows for circular references to resolve.\n    let ref = undefined;\n    if (aliasDuplicateObjects && value && typeof value === 'object') {\n        ref = sourceObjects.get(value);\n        if (ref) {\n            if (!ref.anchor)\n                ref.anchor = onAnchor(value);\n            return new Alias.Alias(ref.anchor);\n        }\n        else {\n            ref = { anchor: null, node: null };\n            sourceObjects.set(value, ref);\n        }\n    }\n    if (tagName?.startsWith('!!'))\n        tagName = defaultTagPrefix + tagName.slice(2);\n    let tagObj = findTagObject(value, tagName, schema.tags);\n    if (!tagObj) {\n        if (value && typeof value.toJSON === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            value = value.toJSON();\n        }\n        if (!value || typeof value !== 'object') {\n            const node = new Scalar.Scalar(value);\n            if (ref)\n                ref.node = node;\n            return node;\n        }\n        tagObj =\n            value instanceof Map\n                ? schema[identity.MAP]\n                : Symbol.iterator in Object(value)\n                    ? schema[identity.SEQ]\n                    : schema[identity.MAP];\n    }\n    if (onTagObj) {\n        onTagObj(tagObj);\n        delete ctx.onTagObj;\n    }\n    const node = tagObj?.createNode\n        ? tagObj.createNode(ctx.schema, value, ctx)\n        : typeof tagObj?.nodeClass?.from === 'function'\n            ? tagObj.nodeClass.from(ctx.schema, value, ctx)\n            : new Scalar.Scalar(value);\n    if (tagName)\n        node.tag = tagName;\n    else if (!tagObj.default)\n        node.tag = tagObj.tag;\n    if (ref)\n        ref.node = node;\n    return node;\n}\n\nexports.createNode = createNode;\n","'use strict';\n\nvar createNode = require('../doc/createNode.js');\nvar identity = require('./identity.js');\nvar Node = require('./Node.js');\n\nfunction collectionFromPath(schema, path, value) {\n    let v = value;\n    for (let i = path.length - 1; i >= 0; --i) {\n        const k = path[i];\n        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n            const a = [];\n            a[k] = v;\n            v = a;\n        }\n        else {\n            v = new Map([[k, v]]);\n        }\n    }\n    return createNode.createNode(v, undefined, {\n        aliasDuplicateObjects: false,\n        keepUndefined: false,\n        onAnchor: () => {\n            throw new Error('This should not happen, please report a bug.');\n        },\n        schema,\n        sourceObjects: new Map()\n    });\n}\n// Type guard is intentionally a little wrong so as to be more useful,\n// as it does not cover untypable empty non-string iterables (e.g. []).\nconst isEmptyPath = (path) => path == null ||\n    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);\nclass Collection extends Node.NodeBase {\n    constructor(type, schema) {\n        super(type);\n        Object.defineProperty(this, 'schema', {\n            value: schema,\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n    /**\n     * Create a copy of this collection.\n     *\n     * @param schema - If defined, overwrites the original's schema\n     */\n    clone(schema) {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (schema)\n            copy.schema = schema;\n        copy.items = copy.items.map(it => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /**\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\n     * that already exists in the map.\n     */\n    addIn(path, value) {\n        if (isEmptyPath(path))\n            this.add(value);\n        else {\n            const [key, ...rest] = path;\n            const node = this.get(key, true);\n            if (identity.isCollection(node))\n                node.addIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.delete(key);\n        const node = this.get(key, true);\n        if (identity.isCollection(node))\n            return node.deleteIn(rest);\n        else\n            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        const [key, ...rest] = path;\n        const node = this.get(key, true);\n        if (rest.length === 0)\n            return !keepScalar && identity.isScalar(node) ? node.value : node;\n        else\n            return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n    }\n    hasAllNullValues(allowScalar) {\n        return this.items.every(node => {\n            if (!identity.isPair(node))\n                return false;\n            const n = node.value;\n            return (n == null ||\n                (allowScalar &&\n                    identity.isScalar(n) &&\n                    n.value == null &&\n                    !n.commentBefore &&\n                    !n.comment &&\n                    !n.tag));\n        });\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    hasIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.has(key);\n        const node = this.get(key, true);\n        return identity.isCollection(node) ? node.hasIn(rest) : false;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        const [key, ...rest] = path;\n        if (rest.length === 0) {\n            this.set(key, value);\n        }\n        else {\n            const node = this.get(key, true);\n            if (identity.isCollection(node))\n                node.setIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n}\n\nexports.Collection = Collection;\nexports.collectionFromPath = collectionFromPath;\nexports.isEmptyPath = isEmptyPath;\n","'use strict';\n\n/**\n * Stringifies a comment.\n *\n * Empty comment lines are left empty,\n * lines consisting of a single space are replaced by `#`,\n * and all other lines are prefixed with a `#`.\n */\nconst stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');\nfunction indentComment(comment, indent) {\n    if (/^\\n+$/.test(comment))\n        return comment.substring(1);\n    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;\n}\nconst lineComment = (str, indent, comment) => str.endsWith('\\n')\n    ? indentComment(comment, indent)\n    : comment.includes('\\n')\n        ? '\\n' + indentComment(comment, indent)\n        : (str.endsWith(' ') ? '' : ' ') + comment;\n\nexports.indentComment = indentComment;\nexports.lineComment = lineComment;\nexports.stringifyComment = stringifyComment;\n","'use strict';\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\n    if (!lineWidth || lineWidth < 0)\n        return text;\n    if (lineWidth < minContentWidth)\n        minContentWidth = 0;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep)\n        return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === 'number') {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\n            folds.push(0);\n        else\n            end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    let escStart = -1;\n    let escEnd = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i, indent.length);\n        if (i !== -1)\n            end = i + endStep;\n    }\n    for (let ch; (ch = text[(i += 1)]);) {\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\n            escStart = i;\n            switch (text[i + 1]) {\n                case 'x':\n                    i += 3;\n                    break;\n                case 'u':\n                    i += 5;\n                    break;\n                case 'U':\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n            escEnd = i;\n        }\n        if (ch === '\\n') {\n            if (mode === FOLD_BLOCK)\n                i = consumeMoreIndentedLines(text, i, indent.length);\n            end = i + indent.length + endStep;\n            split = undefined;\n        }\n        else {\n            if (ch === ' ' &&\n                prev &&\n                prev !== ' ' &&\n                prev !== '\\n' &&\n                prev !== '\\t') {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\n                    split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                }\n                else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while (prev === ' ' || prev === '\\t') {\n                        prev = ch;\n                        ch = text[(i += 1)];\n                        overflow = true;\n                    }\n                    // Account for newline escape, but don't break preceding escape\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\n                    if (escapedFolds[j])\n                        return text;\n                    folds.push(j);\n                    escapedFolds[j] = true;\n                    end = j + endStep;\n                    split = undefined;\n                }\n                else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow)\n        onOverflow();\n    if (folds.length === 0)\n        return text;\n    if (onFold)\n        onFold();\n    let res = text.slice(0, folds[0]);\n    for (let i = 0; i < folds.length; ++i) {\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0)\n            res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\n                res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i, indent) {\n    let end = i;\n    let start = i + 1;\n    let ch = text[start];\n    while (ch === ' ' || ch === '\\t') {\n        if (i < start + indent) {\n            ch = text[++i];\n        }\n        else {\n            do {\n                ch = text[++i];\n            } while (ch && ch !== '\\n');\n            end = i;\n            start = i + 1;\n            ch = text[start];\n        }\n    }\n    return end;\n}\n\nexports.FOLD_BLOCK = FOLD_BLOCK;\nexports.FOLD_FLOW = FOLD_FLOW;\nexports.FOLD_QUOTED = FOLD_QUOTED;\nexports.foldFlowLines = foldFlowLines;\n","'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\nvar foldFlowLines = require('./foldFlowLines.js');\n\nconst getFoldOptions = (ctx, isBlock) => ({\n    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,\n    lineWidth: ctx.options.lineWidth,\n    minContentWidth: ctx.options.minContentWidth\n});\n// Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\nconst containsDocumentMarker = (str) => /^(%|---|\\.\\.\\.)/m.test(str);\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n    if (!lineWidth || lineWidth < 0)\n        return false;\n    const limit = lineWidth - indentLength;\n    const strLen = str.length;\n    if (strLen <= limit)\n        return false;\n    for (let i = 0, start = 0; i < strLen; ++i) {\n        if (str[i] === '\\n') {\n            if (i - start > limit)\n                return true;\n            start = i + 1;\n            if (strLen - start <= limit)\n                return false;\n        }\n    }\n    return true;\n}\nfunction doubleQuotedString(value, ctx) {\n    const json = JSON.stringify(value);\n    if (ctx.options.doubleQuotedAsJSON)\n        return json;\n    const { implicitKey } = ctx;\n    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    let str = '';\n    let start = 0;\n    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n        if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n            // space before newline needs to be escaped to not be folded\n            str += json.slice(start, i) + '\\\\ ';\n            i += 1;\n            start = i;\n            ch = '\\\\';\n        }\n        if (ch === '\\\\')\n            switch (json[i + 1]) {\n                case 'u':\n                    {\n                        str += json.slice(start, i);\n                        const code = json.substr(i + 2, 4);\n                        switch (code) {\n                            case '0000':\n                                str += '\\\\0';\n                                break;\n                            case '0007':\n                                str += '\\\\a';\n                                break;\n                            case '000b':\n                                str += '\\\\v';\n                                break;\n                            case '001b':\n                                str += '\\\\e';\n                                break;\n                            case '0085':\n                                str += '\\\\N';\n                                break;\n                            case '00a0':\n                                str += '\\\\_';\n                                break;\n                            case '2028':\n                                str += '\\\\L';\n                                break;\n                            case '2029':\n                                str += '\\\\P';\n                                break;\n                            default:\n                                if (code.substr(0, 2) === '00')\n                                    str += '\\\\x' + code.substr(2);\n                                else\n                                    str += json.substr(i, 6);\n                        }\n                        i += 5;\n                        start = i + 1;\n                    }\n                    break;\n                case 'n':\n                    if (implicitKey ||\n                        json[i + 2] === '\"' ||\n                        json.length < minMultiLineLength) {\n                        i += 1;\n                    }\n                    else {\n                        // folding will eat first newline\n                        str += json.slice(start, i) + '\\n\\n';\n                        while (json[i + 2] === '\\\\' &&\n                            json[i + 3] === 'n' &&\n                            json[i + 4] !== '\"') {\n                            str += '\\n';\n                            i += 2;\n                        }\n                        str += indent;\n                        // space after newline needs to be escaped to not be folded\n                        if (json[i + 2] === ' ')\n                            str += '\\\\';\n                        i += 1;\n                        start = i + 1;\n                    }\n                    break;\n                default:\n                    i += 1;\n            }\n    }\n    str = start ? str + json.slice(start) : json;\n    return implicitKey\n        ? str\n        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));\n}\nfunction singleQuotedString(value, ctx) {\n    if (ctx.options.singleQuote === false ||\n        (ctx.implicitKey && value.includes('\\n')) ||\n        /[ \\t]\\n|\\n[ \\t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline\n    )\n        return doubleQuotedString(value, ctx);\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n    return ctx.implicitKey\n        ? res\n        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction quotedString(value, ctx) {\n    const { singleQuote } = ctx.options;\n    let qs;\n    if (singleQuote === false)\n        qs = doubleQuotedString;\n    else {\n        const hasDouble = value.includes('\"');\n        const hasSingle = value.includes(\"'\");\n        if (hasDouble && !hasSingle)\n            qs = singleQuotedString;\n        else if (hasSingle && !hasDouble)\n            qs = doubleQuotedString;\n        else\n            qs = singleQuote ? singleQuotedString : doubleQuotedString;\n    }\n    return qs(value, ctx);\n}\n// The negative lookbehind avoids a polynomial search,\n// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind\nlet blockEndNewlines;\ntry {\n    blockEndNewlines = new RegExp('(^|(?<!\\n))\\n+(?!\\n|$)', 'g');\n}\ncatch {\n    blockEndNewlines = /\\n+(?!\\n|$)/g;\n}\nfunction blockString({ comment, type, value }, ctx, onComment, onChompKeep) {\n    const { blockQuote, commentString, lineWidth } = ctx.options;\n    // 1. Block can't end in whitespace unless the last line is non-empty.\n    // 2. Strings consisting of only whitespace are best rendered explicitly.\n    if (!blockQuote || /\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n        return quotedString(value, ctx);\n    }\n    const indent = ctx.indent ||\n        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n    const literal = blockQuote === 'literal'\n        ? true\n        : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED\n            ? false\n            : type === Scalar.Scalar.BLOCK_LITERAL\n                ? true\n                : !lineLengthOverLimit(value, lineWidth, indent.length);\n    if (!value)\n        return literal ? '|\\n' : '>\\n';\n    // determine chomping from whitespace at value end\n    let chomp;\n    let endStart;\n    for (endStart = value.length; endStart > 0; --endStart) {\n        const ch = value[endStart - 1];\n        if (ch !== '\\n' && ch !== '\\t' && ch !== ' ')\n            break;\n    }\n    let end = value.substring(endStart);\n    const endNlPos = end.indexOf('\\n');\n    if (endNlPos === -1) {\n        chomp = '-'; // strip\n    }\n    else if (value === end || endNlPos !== end.length - 1) {\n        chomp = '+'; // keep\n        if (onChompKeep)\n            onChompKeep();\n    }\n    else {\n        chomp = ''; // clip\n    }\n    if (end) {\n        value = value.slice(0, -end.length);\n        if (end[end.length - 1] === '\\n')\n            end = end.slice(0, -1);\n        end = end.replace(blockEndNewlines, `$&${indent}`);\n    }\n    // determine indent indicator from whitespace at value start\n    let startWithSpace = false;\n    let startEnd;\n    let startNlPos = -1;\n    for (startEnd = 0; startEnd < value.length; ++startEnd) {\n        const ch = value[startEnd];\n        if (ch === ' ')\n            startWithSpace = true;\n        else if (ch === '\\n')\n            startNlPos = startEnd;\n        else\n            break;\n    }\n    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);\n    if (start) {\n        value = value.substring(start.length);\n        start = start.replace(/\\n+/g, `$&${indent}`);\n    }\n    const indentSize = indent ? '2' : '1'; // root is at -1\n    // Leading | or > is added later\n    let header = (startWithSpace ? indentSize : '') + chomp;\n    if (comment) {\n        header += ' ' + commentString(comment.replace(/ ?[\\r\\n]+/g, ' '));\n        if (onComment)\n            onComment();\n    }\n    if (!literal) {\n        const foldedValue = value\n            .replace(/\\n+/g, '\\n$&')\n            .replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n            //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent\n            .replace(/\\n+/g, `$&${indent}`);\n        let literalFallback = false;\n        const foldOptions = getFoldOptions(ctx, true);\n        if (blockQuote !== 'folded' && type !== Scalar.Scalar.BLOCK_FOLDED) {\n            foldOptions.onOverflow = () => {\n                literalFallback = true;\n            };\n        }\n        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);\n        if (!literalFallback)\n            return `>${header}\\n${indent}${body}`;\n    }\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `|${header}\\n${indent}${start}${value}${end}`;\n}\nfunction plainString(item, ctx, onComment, onChompKeep) {\n    const { type, value } = item;\n    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;\n    if ((implicitKey && value.includes('\\n')) ||\n        (inFlow && /[[\\]{},]/.test(value))) {\n        return quotedString(value, ctx);\n    }\n    if (!value ||\n        /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n        // not allowed:\n        // - empty string, '-' or '?'\n        // - start with an indicator character (except [?:-]) or /[?-] /\n        // - '\\n ', ': ' or ' \\n' anywhere\n        // - '#' not preceded by a non-space char\n        // - end with ' ' or ':'\n        return implicitKey || inFlow || !value.includes('\\n')\n            ? quotedString(value, ctx)\n            : blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (!implicitKey &&\n        !inFlow &&\n        type !== Scalar.Scalar.PLAIN &&\n        value.includes('\\n')) {\n        // Where allowed & type not set explicitly, prefer block style for multiline strings\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (containsDocumentMarker(value)) {\n        if (indent === '') {\n            ctx.forceBlockIndent = true;\n            return blockString(item, ctx, onComment, onChompKeep);\n        }\n        else if (implicitKey && indent === indentStep) {\n            return quotedString(value, ctx);\n        }\n    }\n    const str = value.replace(/\\n+/g, `$&\\n${indent}`);\n    // Verify that output will be parsed as a string, as e.g. plain numbers and\n    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n    // and others in v1.1.\n    if (actualString) {\n        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);\n        const { compat, tags } = ctx.doc.schema;\n        if (tags.some(test) || compat?.some(test))\n            return quotedString(value, ctx);\n    }\n    return implicitKey\n        ? str\n        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n    const { implicitKey, inFlow } = ctx;\n    const ss = typeof item.value === 'string'\n        ? item\n        : Object.assign({}, item, { value: String(item.value) });\n    let { type } = item;\n    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {\n        // force double quotes on control characters & unpaired surrogates\n        if (/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(ss.value))\n            type = Scalar.Scalar.QUOTE_DOUBLE;\n    }\n    const _stringify = (_type) => {\n        switch (_type) {\n            case Scalar.Scalar.BLOCK_FOLDED:\n            case Scalar.Scalar.BLOCK_LITERAL:\n                return implicitKey || inFlow\n                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers\n                    : blockString(ss, ctx, onComment, onChompKeep);\n            case Scalar.Scalar.QUOTE_DOUBLE:\n                return doubleQuotedString(ss.value, ctx);\n            case Scalar.Scalar.QUOTE_SINGLE:\n                return singleQuotedString(ss.value, ctx);\n            case Scalar.Scalar.PLAIN:\n                return plainString(ss, ctx, onComment, onChompKeep);\n            default:\n                return null;\n        }\n    };\n    let res = _stringify(type);\n    if (res === null) {\n        const { defaultKeyType, defaultStringType } = ctx.options;\n        const t = (implicitKey && defaultKeyType) || defaultStringType;\n        res = _stringify(t);\n        if (res === null)\n            throw new Error(`Unsupported default string type ${t}`);\n    }\n    return res;\n}\n\nexports.stringifyString = stringifyString;\n","'use strict';\n\nvar anchors = require('../doc/anchors.js');\nvar identity = require('../nodes/identity.js');\nvar stringifyComment = require('./stringifyComment.js');\nvar stringifyString = require('./stringifyString.js');\n\nfunction createStringifyContext(doc, options) {\n    const opt = Object.assign({\n        blockQuote: true,\n        commentString: stringifyComment.stringifyComment,\n        defaultKeyType: null,\n        defaultStringType: 'PLAIN',\n        directives: null,\n        doubleQuotedAsJSON: false,\n        doubleQuotedMinMultiLineLength: 40,\n        falseStr: 'false',\n        flowCollectionPadding: true,\n        indentSeq: true,\n        lineWidth: 80,\n        minContentWidth: 20,\n        nullStr: 'null',\n        simpleKeys: false,\n        singleQuote: null,\n        trueStr: 'true',\n        verifyAliasOrder: true\n    }, doc.schema.toStringOptions, options);\n    let inFlow;\n    switch (opt.collectionStyle) {\n        case 'block':\n            inFlow = false;\n            break;\n        case 'flow':\n            inFlow = true;\n            break;\n        default:\n            inFlow = null;\n    }\n    return {\n        anchors: new Set(),\n        doc,\n        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',\n        indent: '',\n        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',\n        inFlow,\n        options: opt\n    };\n}\nfunction getTagObject(tags, item) {\n    if (item.tag) {\n        const match = tags.filter(t => t.tag === item.tag);\n        if (match.length > 0)\n            return match.find(t => t.format === item.format) ?? match[0];\n    }\n    let tagObj = undefined;\n    let obj;\n    if (identity.isScalar(item)) {\n        obj = item.value;\n        let match = tags.filter(t => t.identify?.(obj));\n        if (match.length > 1) {\n            const testMatch = match.filter(t => t.test);\n            if (testMatch.length > 0)\n                match = testMatch;\n        }\n        tagObj =\n            match.find(t => t.format === item.format) ?? match.find(t => !t.format);\n    }\n    else {\n        obj = item;\n        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n    }\n    if (!tagObj) {\n        const name = obj?.constructor?.name ?? typeof obj;\n        throw new Error(`Tag not resolved for ${name} value`);\n    }\n    return tagObj;\n}\n// needs to be called before value stringifier to allow for circular anchor refs\nfunction stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {\n    if (!doc.directives)\n        return '';\n    const props = [];\n    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;\n    if (anchor && anchors.anchorIsValid(anchor)) {\n        anchors$1.add(anchor);\n        props.push(`&${anchor}`);\n    }\n    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;\n    if (tag)\n        props.push(doc.directives.tagString(tag));\n    return props.join(' ');\n}\nfunction stringify(item, ctx, onComment, onChompKeep) {\n    if (identity.isPair(item))\n        return item.toString(ctx, onComment, onChompKeep);\n    if (identity.isAlias(item)) {\n        if (ctx.doc.directives)\n            return item.toString(ctx);\n        if (ctx.resolvedAliases?.has(item)) {\n            throw new TypeError(`Cannot stringify circular structure without alias nodes`);\n        }\n        else {\n            if (ctx.resolvedAliases)\n                ctx.resolvedAliases.add(item);\n            else\n                ctx.resolvedAliases = new Set([item]);\n            item = item.resolve(ctx.doc);\n        }\n    }\n    let tagObj = undefined;\n    const node = identity.isNode(item)\n        ? item\n        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });\n    if (!tagObj)\n        tagObj = getTagObject(ctx.doc.schema.tags, node);\n    const props = stringifyProps(node, tagObj, ctx);\n    if (props.length > 0)\n        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;\n    const str = typeof tagObj.stringify === 'function'\n        ? tagObj.stringify(node, ctx, onComment, onChompKeep)\n        : identity.isScalar(node)\n            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)\n            : node.toString(ctx, onComment, onChompKeep);\n    if (!props)\n        return str;\n    return identity.isScalar(node) || str[0] === '{' || str[0] === '['\n        ? `${props} ${str}`\n        : `${props}\\n${ctx.indent}${str}`;\n}\n\nexports.createStringifyContext = createStringifyContext;\nexports.stringify = stringify;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar stringify = require('./stringify.js');\nvar stringifyComment = require('./stringifyComment.js');\n\nfunction stringifyPair({ key, value }, ctx, onComment, onChompKeep) {\n    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;\n    let keyComment = (identity.isNode(key) && key.comment) || null;\n    if (simpleKeys) {\n        if (keyComment) {\n            throw new Error('With simple keys, key nodes cannot have comments');\n        }\n        if (identity.isCollection(key) || (!identity.isNode(key) && typeof key === 'object')) {\n            const msg = 'With simple keys, collection cannot be used as a key value';\n            throw new Error(msg);\n        }\n    }\n    let explicitKey = !simpleKeys &&\n        (!key ||\n            (keyComment && value == null && !ctx.inFlow) ||\n            identity.isCollection(key) ||\n            (identity.isScalar(key)\n                ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL\n                : typeof key === 'object'));\n    ctx = Object.assign({}, ctx, {\n        allNullValues: false,\n        implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n        indent: indent + indentStep\n    });\n    let keyCommentDone = false;\n    let chompKeep = false;\n    let str = stringify.stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));\n    if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n        if (simpleKeys)\n            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n    }\n    if (ctx.inFlow) {\n        if (allNullValues || value == null) {\n            if (keyCommentDone && onComment)\n                onComment();\n            return str === '' ? '?' : explicitKey ? `? ${str}` : str;\n        }\n    }\n    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {\n        str = `? ${str}`;\n        if (keyComment && !keyCommentDone) {\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n        }\n        else if (chompKeep && onChompKeep)\n            onChompKeep();\n        return str;\n    }\n    if (keyCommentDone)\n        keyComment = null;\n    if (explicitKey) {\n        if (keyComment)\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n        str = `? ${str}\\n${indent}:`;\n    }\n    else {\n        str = `${str}:`;\n        if (keyComment)\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n    }\n    let vsb, vcb, valueComment;\n    if (identity.isNode(value)) {\n        vsb = !!value.spaceBefore;\n        vcb = value.commentBefore;\n        valueComment = value.comment;\n    }\n    else {\n        vsb = false;\n        vcb = null;\n        valueComment = null;\n        if (value && typeof value === 'object')\n            value = doc.createNode(value);\n    }\n    ctx.implicitKey = false;\n    if (!explicitKey && !keyComment && identity.isScalar(value))\n        ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n    if (!indentSeq &&\n        indentStep.length >= 2 &&\n        !ctx.inFlow &&\n        !explicitKey &&\n        identity.isSeq(value) &&\n        !value.flow &&\n        !value.tag &&\n        !value.anchor) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substring(2);\n    }\n    let valueCommentDone = false;\n    const valueStr = stringify.stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));\n    let ws = ' ';\n    if (keyComment || vsb || vcb) {\n        ws = vsb ? '\\n' : '';\n        if (vcb) {\n            const cs = commentString(vcb);\n            ws += `\\n${stringifyComment.indentComment(cs, ctx.indent)}`;\n        }\n        if (valueStr === '' && !ctx.inFlow) {\n            if (ws === '\\n')\n                ws = '\\n\\n';\n        }\n        else {\n            ws += `\\n${ctx.indent}`;\n        }\n    }\n    else if (!explicitKey && identity.isCollection(value)) {\n        const vs0 = valueStr[0];\n        const nl0 = valueStr.indexOf('\\n');\n        const hasNewline = nl0 !== -1;\n        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;\n        if (hasNewline || !flow) {\n            let hasPropsLine = false;\n            if (hasNewline && (vs0 === '&' || vs0 === '!')) {\n                let sp0 = valueStr.indexOf(' ');\n                if (vs0 === '&' &&\n                    sp0 !== -1 &&\n                    sp0 < nl0 &&\n                    valueStr[sp0 + 1] === '!') {\n                    sp0 = valueStr.indexOf(' ', sp0 + 1);\n                }\n                if (sp0 === -1 || nl0 < sp0)\n                    hasPropsLine = true;\n            }\n            if (!hasPropsLine)\n                ws = `\\n${ctx.indent}`;\n        }\n    }\n    else if (valueStr === '' || valueStr[0] === '\\n') {\n        ws = '';\n    }\n    str += ws + valueStr;\n    if (ctx.inFlow) {\n        if (valueCommentDone && onComment)\n            onComment();\n    }\n    else if (valueComment && !valueCommentDone) {\n        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));\n    }\n    else if (chompKeep && onChompKeep) {\n        onChompKeep();\n    }\n    return str;\n}\n\nexports.stringifyPair = stringifyPair;\n","'use strict';\n\nvar node_process = require('node:process');\n\nfunction debug(logLevel, ...messages) {\n    if (logLevel === 'debug')\n        console.log(...messages);\n}\nfunction warn(logLevel, warning) {\n    if (logLevel === 'debug' || logLevel === 'warn') {\n        if (typeof node_process.emitWarning === 'function')\n            node_process.emitWarning(warning);\n        else\n            console.warn(warning);\n    }\n}\n\nexports.debug = debug;\nexports.warn = warn;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar Scalar = require('../../nodes/Scalar.js');\n\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nconst MERGE_KEY = '<<';\nconst merge = {\n    identify: value => value === MERGE_KEY ||\n        (typeof value === 'symbol' && value.description === MERGE_KEY),\n    default: 'key',\n    tag: 'tag:yaml.org,2002:merge',\n    test: /^<<$/,\n    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {\n        addToJSMap: addMergeToJSMap\n    }),\n    stringify: () => MERGE_KEY\n};\nconst isMergeKey = (ctx, key) => (merge.identify(key) ||\n    (identity.isScalar(key) &&\n        (!key.type || key.type === Scalar.Scalar.PLAIN) &&\n        merge.identify(key.value))) &&\n    ctx?.doc.schema.tags.some(tag => tag.tag === merge.tag && tag.default);\nfunction addMergeToJSMap(ctx, map, value) {\n    value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (identity.isSeq(value))\n        for (const it of value.items)\n            mergeValue(ctx, map, it);\n    else if (Array.isArray(value))\n        for (const it of value)\n            mergeValue(ctx, map, it);\n    else\n        mergeValue(ctx, map, value);\n}\nfunction mergeValue(ctx, map, value) {\n    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (!identity.isMap(source))\n        throw new Error('Merge sources must be maps or map aliases');\n    const srcMap = source.toJSON(null, ctx, Map);\n    for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n            if (!map.has(key))\n                map.set(key, value);\n        }\n        else if (map instanceof Set) {\n            map.add(key);\n        }\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n            Object.defineProperty(map, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    return map;\n}\n\nexports.addMergeToJSMap = addMergeToJSMap;\nexports.isMergeKey = isMergeKey;\nexports.merge = merge;\n","'use strict';\n\nvar log = require('../log.js');\nvar merge = require('../schema/yaml-1.1/merge.js');\nvar stringify = require('../stringify/stringify.js');\nvar identity = require('./identity.js');\nvar toJS = require('./toJS.js');\n\nfunction addPairToJSMap(ctx, map, { key, value }) {\n    if (identity.isNode(key) && key.addToJSMap)\n        key.addToJSMap(ctx, map, value);\n    // TODO: Should drop this special case for bare << handling\n    else if (merge.isMergeKey(ctx, key))\n        merge.addMergeToJSMap(ctx, map, value);\n    else {\n        const jsKey = toJS.toJS(key, '', ctx);\n        if (map instanceof Map) {\n            map.set(jsKey, toJS.toJS(value, jsKey, ctx));\n        }\n        else if (map instanceof Set) {\n            map.add(jsKey);\n        }\n        else {\n            const stringKey = stringifyKey(key, jsKey, ctx);\n            const jsValue = toJS.toJS(value, stringKey, ctx);\n            if (stringKey in map)\n                Object.defineProperty(map, stringKey, {\n                    value: jsValue,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            else\n                map[stringKey] = jsValue;\n        }\n    }\n    return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n    if (jsKey === null)\n        return '';\n    if (typeof jsKey !== 'object')\n        return String(jsKey);\n    if (identity.isNode(key) && ctx?.doc) {\n        const strCtx = stringify.createStringifyContext(ctx.doc, {});\n        strCtx.anchors = new Set();\n        for (const node of ctx.anchors.keys())\n            strCtx.anchors.add(node.anchor);\n        strCtx.inFlow = true;\n        strCtx.inStringifyKey = true;\n        const strKey = key.toString(strCtx);\n        if (!ctx.mapKeyWarned) {\n            let jsonStr = JSON.stringify(strKey);\n            if (jsonStr.length > 40)\n                jsonStr = jsonStr.substring(0, 36) + '...\"';\n            log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n            ctx.mapKeyWarned = true;\n        }\n        return strKey;\n    }\n    return JSON.stringify(jsKey);\n}\n\nexports.addPairToJSMap = addPairToJSMap;\n","'use strict';\n\nvar createNode = require('../doc/createNode.js');\nvar stringifyPair = require('../stringify/stringifyPair.js');\nvar addPairToJSMap = require('./addPairToJSMap.js');\nvar identity = require('./identity.js');\n\nfunction createPair(key, value, ctx) {\n    const k = createNode.createNode(key, undefined, ctx);\n    const v = createNode.createNode(value, undefined, ctx);\n    return new Pair(k, v);\n}\nclass Pair {\n    constructor(key, value = null) {\n        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });\n        this.key = key;\n        this.value = value;\n    }\n    clone(schema) {\n        let { key, value } = this;\n        if (identity.isNode(key))\n            key = key.clone(schema);\n        if (identity.isNode(value))\n            value = value.clone(schema);\n        return new Pair(key, value);\n    }\n    toJSON(_, ctx) {\n        const pair = ctx?.mapAsMap ? new Map() : {};\n        return addPairToJSMap.addPairToJSMap(ctx, pair, this);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        return ctx?.doc\n            ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)\n            : JSON.stringify(this);\n    }\n}\n\nexports.Pair = Pair;\nexports.createPair = createPair;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar stringify = require('./stringify.js');\nvar stringifyComment = require('./stringifyComment.js');\n\nfunction stringifyCollection(collection, ctx, options) {\n    const flow = ctx.inFlow ?? collection.flow;\n    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;\n    return stringify(collection, ctx, options);\n}\nfunction stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {\n    const { indent, options: { commentString } } = ctx;\n    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });\n    let chompKeep = false; // flag for the preceding node's status\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (identity.isNode(item)) {\n            if (!chompKeep && item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (identity.isPair(item)) {\n            const ik = identity.isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (!chompKeep && ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);\n            }\n        }\n        chompKeep = false;\n        let str = stringify.stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));\n        if (comment)\n            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));\n        if (chompKeep && comment)\n            chompKeep = false;\n        lines.push(blockItemPrefix + str);\n    }\n    let str;\n    if (lines.length === 0) {\n        str = flowChars.start + flowChars.end;\n    }\n    else {\n        str = lines[0];\n        for (let i = 1; i < lines.length; ++i) {\n            const line = lines[i];\n            str += line ? `\\n${indent}${line}` : '\\n';\n        }\n    }\n    if (comment) {\n        str += '\\n' + stringifyComment.indentComment(commentString(comment), indent);\n        if (onComment)\n            onComment();\n    }\n    else if (chompKeep && onChompKeep)\n        onChompKeep();\n    return str;\n}\nfunction stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {\n    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;\n    itemIndent += indentStep;\n    const itemCtx = Object.assign({}, ctx, {\n        indent: itemIndent,\n        inFlow: true,\n        type: null\n    });\n    let reqNewline = false;\n    let linesAtValue = 0;\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (identity.isNode(item)) {\n            if (item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, false);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (identity.isPair(item)) {\n            const ik = identity.isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, false);\n                if (ik.comment)\n                    reqNewline = true;\n            }\n            const iv = identity.isNode(item.value) ? item.value : null;\n            if (iv) {\n                if (iv.comment)\n                    comment = iv.comment;\n                if (iv.commentBefore)\n                    reqNewline = true;\n            }\n            else if (item.value == null && ik?.comment) {\n                comment = ik.comment;\n            }\n        }\n        if (comment)\n            reqNewline = true;\n        let str = stringify.stringify(item, itemCtx, () => (comment = null));\n        if (i < items.length - 1)\n            str += ',';\n        if (comment)\n            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));\n        if (!reqNewline && (lines.length > linesAtValue || str.includes('\\n')))\n            reqNewline = true;\n        lines.push(str);\n        linesAtValue = lines.length;\n    }\n    const { start, end } = flowChars;\n    if (lines.length === 0) {\n        return start + end;\n    }\n    else {\n        if (!reqNewline) {\n            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);\n            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;\n        }\n        if (reqNewline) {\n            let str = start;\n            for (const line of lines)\n                str += line ? `\\n${indentStep}${indent}${line}` : '\\n';\n            return `${str}\\n${indent}${end}`;\n        }\n        else {\n            return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;\n        }\n    }\n}\nfunction addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {\n    if (comment && chompKeep)\n        comment = comment.replace(/^\\n+/, '');\n    if (comment) {\n        const ic = stringifyComment.indentComment(commentString(comment), indent);\n        lines.push(ic.trimStart()); // Avoid double indent on first line\n    }\n}\n\nexports.stringifyCollection = stringifyCollection;\n","'use strict';\n\nvar stringifyCollection = require('../stringify/stringifyCollection.js');\nvar addPairToJSMap = require('./addPairToJSMap.js');\nvar Collection = require('./Collection.js');\nvar identity = require('./identity.js');\nvar Pair = require('./Pair.js');\nvar Scalar = require('./Scalar.js');\n\nfunction findPair(items, key) {\n    const k = identity.isScalar(key) ? key.value : key;\n    for (const it of items) {\n        if (identity.isPair(it)) {\n            if (it.key === key || it.key === k)\n                return it;\n            if (identity.isScalar(it.key) && it.key.value === k)\n                return it;\n        }\n    }\n    return undefined;\n}\nclass YAMLMap extends Collection.Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:map';\n    }\n    constructor(schema) {\n        super(identity.MAP, schema);\n        this.items = [];\n    }\n    /**\n     * A generic collection parsing method that can be extended\n     * to other node classes that inherit from YAMLMap\n     */\n    static from(schema, obj, ctx) {\n        const { keepUndefined, replacer } = ctx;\n        const map = new this(schema);\n        const add = (key, value) => {\n            if (typeof replacer === 'function')\n                value = replacer.call(obj, key, value);\n            else if (Array.isArray(replacer) && !replacer.includes(key))\n                return;\n            if (value !== undefined || keepUndefined)\n                map.items.push(Pair.createPair(key, value, ctx));\n        };\n        if (obj instanceof Map) {\n            for (const [key, value] of obj)\n                add(key, value);\n        }\n        else if (obj && typeof obj === 'object') {\n            for (const key of Object.keys(obj))\n                add(key, obj[key]);\n        }\n        if (typeof schema.sortMapEntries === 'function') {\n            map.items.sort(schema.sortMapEntries);\n        }\n        return map;\n    }\n    /**\n     * Adds a value to the collection.\n     *\n     * @param overwrite - If not set `true`, using a key that is already in the\n     *   collection will throw. Otherwise, overwrites the previous value.\n     */\n    add(pair, overwrite) {\n        let _pair;\n        if (identity.isPair(pair))\n            _pair = pair;\n        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\n            // In TypeScript, this never happens.\n            _pair = new Pair.Pair(pair, pair?.value);\n        }\n        else\n            _pair = new Pair.Pair(pair.key, pair.value);\n        const prev = findPair(this.items, _pair.key);\n        const sortEntries = this.schema?.sortMapEntries;\n        if (prev) {\n            if (!overwrite)\n                throw new Error(`Key ${_pair.key} already set`);\n            // For scalars, keep the old node & its comments and anchors\n            if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))\n                prev.value.value = _pair.value;\n            else\n                prev.value = _pair.value;\n        }\n        else if (sortEntries) {\n            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\n            if (i === -1)\n                this.items.push(_pair);\n            else\n                this.items.splice(i, 0, _pair);\n        }\n        else {\n            this.items.push(_pair);\n        }\n    }\n    delete(key) {\n        const it = findPair(this.items, key);\n        if (!it)\n            return false;\n        const del = this.items.splice(this.items.indexOf(it), 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const it = findPair(this.items, key);\n        const node = it?.value;\n        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;\n    }\n    has(key) {\n        return !!findPair(this.items, key);\n    }\n    set(key, value) {\n        this.add(new Pair.Pair(key, value), true);\n    }\n    /**\n     * @param ctx - Conversion context, originally set in Document#toJS()\n     * @param {Class} Type - If set, forces the returned collection type\n     * @returns Instance of Type, Map, or Object\n     */\n    toJSON(_, ctx, Type) {\n        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const item of this.items)\n            addPairToJSMap.addPairToJSMap(ctx, map, item);\n        return map;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        for (const item of this.items) {\n            if (!identity.isPair(item))\n                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n        }\n        if (!ctx.allNullValues && this.hasAllNullValues(false))\n            ctx = Object.assign({}, ctx, { allNullValues: true });\n        return stringifyCollection.stringifyCollection(this, ctx, {\n            blockItemPrefix: '',\n            flowChars: { start: '{', end: '}' },\n            itemIndent: ctx.indent || '',\n            onChompKeep,\n            onComment\n        });\n    }\n}\n\nexports.YAMLMap = YAMLMap;\nexports.findPair = findPair;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar YAMLMap = require('../../nodes/YAMLMap.js');\n\nconst map = {\n    collection: 'map',\n    default: true,\n    nodeClass: YAMLMap.YAMLMap,\n    tag: 'tag:yaml.org,2002:map',\n    resolve(map, onError) {\n        if (!identity.isMap(map))\n            onError('Expected a mapping for this tag');\n        return map;\n    },\n    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)\n};\n\nexports.map = map;\n","'use strict';\n\nvar createNode = require('../doc/createNode.js');\nvar stringifyCollection = require('../stringify/stringifyCollection.js');\nvar Collection = require('./Collection.js');\nvar identity = require('./identity.js');\nvar Scalar = require('./Scalar.js');\nvar toJS = require('./toJS.js');\n\nclass YAMLSeq extends Collection.Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:seq';\n    }\n    constructor(schema) {\n        super(identity.SEQ, schema);\n        this.items = [];\n    }\n    add(value) {\n        this.items.push(value);\n    }\n    /**\n     * Removes a value from the collection.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     *\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return false;\n        const del = this.items.splice(idx, 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return undefined;\n        const it = this.items[idx];\n        return !keepScalar && identity.isScalar(it) ? it.value : it;\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     */\n    has(key) {\n        const idx = asItemIndex(key);\n        return typeof idx === 'number' && idx < this.items.length;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     *\n     * If `key` does not contain a representation of an integer, this will throw.\n     * It may be wrapped in a `Scalar`.\n     */\n    set(key, value) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            throw new Error(`Expected a valid index, not ${key}.`);\n        const prev = this.items[idx];\n        if (identity.isScalar(prev) && Scalar.isScalarValue(value))\n            prev.value = value;\n        else\n            this.items[idx] = value;\n    }\n    toJSON(_, ctx) {\n        const seq = [];\n        if (ctx?.onCreate)\n            ctx.onCreate(seq);\n        let i = 0;\n        for (const item of this.items)\n            seq.push(toJS.toJS(item, String(i++), ctx));\n        return seq;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        return stringifyCollection.stringifyCollection(this, ctx, {\n            blockItemPrefix: '- ',\n            flowChars: { start: '[', end: ']' },\n            itemIndent: (ctx.indent || '') + '  ',\n            onChompKeep,\n            onComment\n        });\n    }\n    static from(schema, obj, ctx) {\n        const { replacer } = ctx;\n        const seq = new this(schema);\n        if (obj && Symbol.iterator in Object(obj)) {\n            let i = 0;\n            for (let it of obj) {\n                if (typeof replacer === 'function') {\n                    const key = obj instanceof Set ? it : String(i++);\n                    it = replacer.call(obj, key, it);\n                }\n                seq.items.push(createNode.createNode(it, undefined, ctx));\n            }\n        }\n        return seq;\n    }\n}\nfunction asItemIndex(key) {\n    let idx = identity.isScalar(key) ? key.value : key;\n    if (idx && typeof idx === 'string')\n        idx = Number(idx);\n    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0\n        ? idx\n        : null;\n}\n\nexports.YAMLSeq = YAMLSeq;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar YAMLSeq = require('../../nodes/YAMLSeq.js');\n\nconst seq = {\n    collection: 'seq',\n    default: true,\n    nodeClass: YAMLSeq.YAMLSeq,\n    tag: 'tag:yaml.org,2002:seq',\n    resolve(seq, onError) {\n        if (!identity.isSeq(seq))\n            onError('Expected a sequence for this tag');\n        return seq;\n    },\n    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)\n};\n\nexports.seq = seq;\n","'use strict';\n\nvar stringifyString = require('../../stringify/stringifyString.js');\n\nconst string = {\n    identify: value => typeof value === 'string',\n    default: true,\n    tag: 'tag:yaml.org,2002:str',\n    resolve: str => str,\n    stringify(item, ctx, onComment, onChompKeep) {\n        ctx = Object.assign({ actualString: true }, ctx);\n        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);\n    }\n};\n\nexports.string = string;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\n\nconst nullTag = {\n    identify: value => value == null,\n    createNode: () => new Scalar.Scalar(null),\n    default: true,\n    tag: 'tag:yaml.org,2002:null',\n    test: /^(?:~|[Nn]ull|NULL)?$/,\n    resolve: () => new Scalar.Scalar(null),\n    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)\n        ? source\n        : ctx.options.nullStr\n};\n\nexports.nullTag = nullTag;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\n\nconst boolTag = {\n    identify: value => typeof value === 'boolean',\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n    resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),\n    stringify({ source, value }, ctx) {\n        if (source && boolTag.test.test(source)) {\n            const sv = source[0] === 't' || source[0] === 'T';\n            if (value === sv)\n                return source;\n        }\n        return value ? ctx.options.trueStr : ctx.options.falseStr;\n    }\n};\n\nexports.boolTag = boolTag;\n","'use strict';\n\nfunction stringifyNumber({ format, minFractionDigits, tag, value }) {\n    if (typeof value === 'bigint')\n        return String(value);\n    const num = typeof value === 'number' ? value : Number(value);\n    if (!isFinite(num))\n        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';\n    let n = JSON.stringify(value);\n    if (!format &&\n        minFractionDigits &&\n        (!tag || tag === 'tag:yaml.org,2002:float') &&\n        /^\\d/.test(n)) {\n        let i = n.indexOf('.');\n        if (i < 0) {\n            i = n.length;\n            n += '.';\n        }\n        let d = minFractionDigits - (n.length - i - 1);\n        while (d-- > 0)\n            n += '0';\n    }\n    return n;\n}\n\nexports.stringifyNumber = stringifyNumber;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: str => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber.stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n    resolve: str => parseFloat(str),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\n    resolve(str) {\n        const node = new Scalar.Scalar(parseFloat(str));\n        const dot = str.indexOf('.');\n        if (dot !== -1 && str[str.length - 1] === '0')\n            node.minFractionDigits = str.length - dot - 1;\n        return node;\n    },\n    stringify: stringifyNumber.stringifyNumber\n};\n\nexports.float = float;\nexports.floatExp = floatExp;\nexports.floatNaN = floatNaN;\n","'use strict';\n\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nconst intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value) && value >= 0)\n        return prefix + value.toString(radix);\n    return stringifyNumber.stringifyNumber(node);\n}\nconst intOct = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^0o[0-7]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),\n    stringify: node => intStringify(node, 8, '0o')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber.stringifyNumber\n};\nconst intHex = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^0x[0-9a-fA-F]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexports.int = int;\nexports.intHex = intHex;\nexports.intOct = intOct;\n","'use strict';\n\nvar map = require('../common/map.js');\nvar _null = require('../common/null.js');\nvar seq = require('../common/seq.js');\nvar string = require('../common/string.js');\nvar bool = require('./bool.js');\nvar float = require('./float.js');\nvar int = require('./int.js');\n\nconst schema = [\n    map.map,\n    seq.seq,\n    string.string,\n    _null.nullTag,\n    bool.boolTag,\n    int.intOct,\n    int.int,\n    int.intHex,\n    float.floatNaN,\n    float.floatExp,\n    float.float\n];\n\nexports.schema = schema;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar map = require('../common/map.js');\nvar seq = require('../common/seq.js');\n\nfunction intIdentify(value) {\n    return typeof value === 'bigint' || Number.isInteger(value);\n}\nconst stringifyJSON = ({ value }) => JSON.stringify(value);\nconst jsonScalars = [\n    {\n        identify: value => typeof value === 'string',\n        default: true,\n        tag: 'tag:yaml.org,2002:str',\n        resolve: str => str,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => value == null,\n        createNode: () => new Scalar.Scalar(null),\n        default: true,\n        tag: 'tag:yaml.org,2002:null',\n        test: /^null$/,\n        resolve: () => null,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => typeof value === 'boolean',\n        default: true,\n        tag: 'tag:yaml.org,2002:bool',\n        test: /^true$|^false$/,\n        resolve: str => str === 'true',\n        stringify: stringifyJSON\n    },\n    {\n        identify: intIdentify,\n        default: true,\n        tag: 'tag:yaml.org,2002:int',\n        test: /^-?(?:0|[1-9][0-9]*)$/,\n        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),\n        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)\n    },\n    {\n        identify: value => typeof value === 'number',\n        default: true,\n        tag: 'tag:yaml.org,2002:float',\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n        resolve: str => parseFloat(str),\n        stringify: stringifyJSON\n    }\n];\nconst jsonError = {\n    default: true,\n    tag: '',\n    test: /^/,\n    resolve(str, onError) {\n        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n        return str;\n    }\n};\nconst schema = [map.map, seq.seq].concat(jsonScalars, jsonError);\n\nexports.schema = schema;\n","'use strict';\n\nvar node_buffer = require('node:buffer');\nvar Scalar = require('../../nodes/Scalar.js');\nvar stringifyString = require('../../stringify/stringifyString.js');\n\nconst binary = {\n    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof node_buffer.Buffer === 'function') {\n            return node_buffer.Buffer.from(src, 'base64');\n        }\n        else if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        if (!value)\n            return '';\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof node_buffer.Buffer === 'function') {\n            str =\n                buf instanceof node_buffer.Buffer\n                    ? buf.toString('base64')\n                    : node_buffer.Buffer.from(buf.buffer).toString('base64');\n        }\n        else if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        if (!type)\n            type = Scalar.Scalar.BLOCK_LITERAL;\n        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexports.binary = binary;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar Pair = require('../../nodes/Pair.js');\nvar Scalar = require('../../nodes/Scalar.js');\nvar YAMLSeq = require('../../nodes/YAMLSeq.js');\n\nfunction resolvePairs(seq, onError) {\n    if (identity.isSeq(seq)) {\n        for (let i = 0; i < seq.items.length; ++i) {\n            let item = seq.items[i];\n            if (identity.isPair(item))\n                continue;\n            else if (identity.isMap(item)) {\n                if (item.items.length > 1)\n                    onError('Each pair must have its own sequence indicator');\n                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));\n                if (item.commentBefore)\n                    pair.key.commentBefore = pair.key.commentBefore\n                        ? `${item.commentBefore}\\n${pair.key.commentBefore}`\n                        : item.commentBefore;\n                if (item.comment) {\n                    const cn = pair.value ?? pair.key;\n                    cn.comment = cn.comment\n                        ? `${item.comment}\\n${cn.comment}`\n                        : item.comment;\n                }\n                item = pair;\n            }\n            seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);\n        }\n    }\n    else\n        onError('Expected a sequence for this tag');\n    return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n    const { replacer } = ctx;\n    const pairs = new YAMLSeq.YAMLSeq(schema);\n    pairs.tag = 'tag:yaml.org,2002:pairs';\n    let i = 0;\n    if (iterable && Symbol.iterator in Object(iterable))\n        for (let it of iterable) {\n            if (typeof replacer === 'function')\n                it = replacer.call(iterable, String(i++), it);\n            let key, value;\n            if (Array.isArray(it)) {\n                if (it.length === 2) {\n                    key = it[0];\n                    value = it[1];\n                }\n                else\n                    throw new TypeError(`Expected [key, value] tuple: ${it}`);\n            }\n            else if (it && it instanceof Object) {\n                const keys = Object.keys(it);\n                if (keys.length === 1) {\n                    key = keys[0];\n                    value = it[key];\n                }\n                else {\n                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);\n                }\n            }\n            else {\n                key = it;\n            }\n            pairs.items.push(Pair.createPair(key, value, ctx));\n        }\n    return pairs;\n}\nconst pairs = {\n    collection: 'seq',\n    default: false,\n    tag: 'tag:yaml.org,2002:pairs',\n    resolve: resolvePairs,\n    createNode: createPairs\n};\n\nexports.createPairs = createPairs;\nexports.pairs = pairs;\nexports.resolvePairs = resolvePairs;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar toJS = require('../../nodes/toJS.js');\nvar YAMLMap = require('../../nodes/YAMLMap.js');\nvar YAMLSeq = require('../../nodes/YAMLSeq.js');\nvar pairs = require('./pairs.js');\n\nclass YAMLOMap extends YAMLSeq.YAMLSeq {\n    constructor() {\n        super();\n        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);\n        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);\n        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);\n        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);\n        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);\n        this.tag = YAMLOMap.tag;\n    }\n    /**\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n     * but TypeScript won't allow widening the signature of a child method.\n     */\n    toJSON(_, ctx) {\n        if (!ctx)\n            return super.toJSON(_);\n        const map = new Map();\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const pair of this.items) {\n            let key, value;\n            if (identity.isPair(pair)) {\n                key = toJS.toJS(pair.key, '', ctx);\n                value = toJS.toJS(pair.value, key, ctx);\n            }\n            else {\n                key = toJS.toJS(pair, '', ctx);\n            }\n            if (map.has(key))\n                throw new Error('Ordered maps must not include duplicate keys');\n            map.set(key, value);\n        }\n        return map;\n    }\n    static from(schema, iterable, ctx) {\n        const pairs$1 = pairs.createPairs(schema, iterable, ctx);\n        const omap = new this();\n        omap.items = pairs$1.items;\n        return omap;\n    }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n    collection: 'seq',\n    identify: value => value instanceof Map,\n    nodeClass: YAMLOMap,\n    default: false,\n    tag: 'tag:yaml.org,2002:omap',\n    resolve(seq, onError) {\n        const pairs$1 = pairs.resolvePairs(seq, onError);\n        const seenKeys = [];\n        for (const { key } of pairs$1.items) {\n            if (identity.isScalar(key)) {\n                if (seenKeys.includes(key.value)) {\n                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n                }\n                else {\n                    seenKeys.push(key.value);\n                }\n            }\n        }\n        return Object.assign(new YAMLOMap(), pairs$1);\n    },\n    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)\n};\n\nexports.YAMLOMap = YAMLOMap;\nexports.omap = omap;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\n\nfunction boolStringify({ value, source }, ctx) {\n    const boolObj = value ? trueTag : falseTag;\n    if (source && boolObj.test.test(source))\n        return source;\n    return value ? ctx.options.trueStr : ctx.options.falseStr;\n}\nconst trueTag = {\n    identify: value => value === true,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n    resolve: () => new Scalar.Scalar(true),\n    stringify: boolStringify\n};\nconst falseTag = {\n    identify: value => value === false,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,\n    resolve: () => new Scalar.Scalar(false),\n    stringify: boolStringify\n};\n\nexports.falseTag = falseTag;\nexports.trueTag = trueTag;\n","'use strict';\n\nvar Scalar = require('../../nodes/Scalar.js');\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber.stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n    resolve: (str) => parseFloat(str.replace(/_/g, '')),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\n    resolve(str) {\n        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));\n        const dot = str.indexOf('.');\n        if (dot !== -1) {\n            const f = str.substring(dot + 1).replace(/_/g, '');\n            if (f[f.length - 1] === '0')\n                node.minFractionDigits = f.length;\n        }\n        return node;\n    },\n    stringify: stringifyNumber.stringifyNumber\n};\n\nexports.float = float;\nexports.floatExp = floatExp;\nexports.floatNaN = floatNaN;\n","'use strict';\n\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nfunction intResolve(str, offset, radix, { intAsBigInt }) {\n    const sign = str[0];\n    if (sign === '-' || sign === '+')\n        offset += 1;\n    str = str.substring(offset).replace(/_/g, '');\n    if (intAsBigInt) {\n        switch (radix) {\n            case 2:\n                str = `0b${str}`;\n                break;\n            case 8:\n                str = `0o${str}`;\n                break;\n            case 16:\n                str = `0x${str}`;\n                break;\n        }\n        const n = BigInt(str);\n        return sign === '-' ? BigInt(-1) * n : n;\n    }\n    const n = parseInt(str, radix);\n    return sign === '-' ? -1 * n : n;\n}\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value)) {\n        const str = value.toString(radix);\n        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n    }\n    return stringifyNumber.stringifyNumber(node);\n}\nconst intBin = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'BIN',\n    test: /^[-+]?0b[0-1_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),\n    stringify: node => intStringify(node, 2, '0b')\n};\nconst intOct = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^[-+]?0[0-7_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),\n    stringify: node => intStringify(node, 8, '0')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9][0-9_]*$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber.stringifyNumber\n};\nconst intHex = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^[-+]?0x[0-9a-fA-F_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexports.int = int;\nexports.intBin = intBin;\nexports.intHex = intHex;\nexports.intOct = intOct;\n","'use strict';\n\nvar identity = require('../../nodes/identity.js');\nvar Pair = require('../../nodes/Pair.js');\nvar YAMLMap = require('../../nodes/YAMLMap.js');\n\nclass YAMLSet extends YAMLMap.YAMLMap {\n    constructor(schema) {\n        super(schema);\n        this.tag = YAMLSet.tag;\n    }\n    add(key) {\n        let pair;\n        if (identity.isPair(key))\n            pair = key;\n        else if (key &&\n            typeof key === 'object' &&\n            'key' in key &&\n            'value' in key &&\n            key.value === null)\n            pair = new Pair.Pair(key.key, null);\n        else\n            pair = new Pair.Pair(key, null);\n        const prev = YAMLMap.findPair(this.items, pair.key);\n        if (!prev)\n            this.items.push(pair);\n    }\n    /**\n     * If `keepPair` is `true`, returns the Pair matching `key`.\n     * Otherwise, returns the value of that Pair's key.\n     */\n    get(key, keepPair) {\n        const pair = YAMLMap.findPair(this.items, key);\n        return !keepPair && identity.isPair(pair)\n            ? identity.isScalar(pair.key)\n                ? pair.key.value\n                : pair.key\n            : pair;\n    }\n    set(key, value) {\n        if (typeof value !== 'boolean')\n            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n        const prev = YAMLMap.findPair(this.items, key);\n        if (prev && !value) {\n            this.items.splice(this.items.indexOf(prev), 1);\n        }\n        else if (!prev && value) {\n            this.items.push(new Pair.Pair(key));\n        }\n    }\n    toJSON(_, ctx) {\n        return super.toJSON(_, ctx, Set);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        if (this.hasAllNullValues(true))\n            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);\n        else\n            throw new Error('Set items must all have null values');\n    }\n    static from(schema, iterable, ctx) {\n        const { replacer } = ctx;\n        const set = new this(schema);\n        if (iterable && Symbol.iterator in Object(iterable))\n            for (let value of iterable) {\n                if (typeof replacer === 'function')\n                    value = replacer.call(iterable, value, value);\n                set.items.push(Pair.createPair(value, null, ctx));\n            }\n        return set;\n    }\n}\nYAMLSet.tag = 'tag:yaml.org,2002:set';\nconst set = {\n    collection: 'map',\n    identify: value => value instanceof Set,\n    nodeClass: YAMLSet,\n    default: false,\n    tag: 'tag:yaml.org,2002:set',\n    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),\n    resolve(map, onError) {\n        if (identity.isMap(map)) {\n            if (map.hasAllNullValues(true))\n                return Object.assign(new YAMLSet(), map);\n            else\n                onError('Set items must all have null values');\n        }\n        else\n            onError('Expected a mapping for this tag');\n        return map;\n    }\n};\n\nexports.YAMLSet = YAMLSet;\nexports.set = set;\n","'use strict';\n\nvar stringifyNumber = require('../../stringify/stringifyNumber.js');\n\n/** Internal types handle bigint as number, because TS can't figure it out. */\nfunction parseSexagesimal(str, asBigInt) {\n    const sign = str[0];\n    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;\n    const num = (n) => asBigInt ? BigInt(n) : Number(n);\n    const res = parts\n        .replace(/_/g, '')\n        .split(':')\n        .reduce((res, p) => res * num(60) + num(p), num(0));\n    return (sign === '-' ? num(-1) * res : res);\n}\n/**\n * hhhh:mm:ss.sss\n *\n * Internal types handle bigint as number, because TS can't figure it out.\n */\nfunction stringifySexagesimal(node) {\n    let { value } = node;\n    let num = (n) => n;\n    if (typeof value === 'bigint')\n        num = n => BigInt(n);\n    else if (isNaN(value) || !isFinite(value))\n        return stringifyNumber.stringifyNumber(node);\n    let sign = '';\n    if (value < 0) {\n        sign = '-';\n        value *= num(-1);\n    }\n    const _60 = num(60);\n    const parts = [value % _60]; // seconds, including ms\n    if (value < 60) {\n        parts.unshift(0); // at least one : is required\n    }\n    else {\n        value = (value - parts[0]) / _60;\n        parts.unshift(value % _60); // minutes\n        if (value >= 60) {\n            value = (value - parts[0]) / _60;\n            parts.unshift(value); // hours\n        }\n    }\n    return (sign +\n        parts\n            .map(n => String(n).padStart(2, '0'))\n            .join(':')\n            .replace(/000000\\d*$/, '') // % 60 may introduce error\n    );\n}\nconst intTime = {\n    identify: value => typeof value === 'bigint' || Number.isInteger(value),\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\n    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),\n    stringify: stringifySexagesimal\n};\nconst floatTime = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\n    resolve: str => parseSexagesimal(str, false),\n    stringify: stringifySexagesimal\n};\nconst timestamp = {\n    identify: value => value instanceof Date,\n    default: true,\n    tag: 'tag:yaml.org,2002:timestamp',\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\n    // assumed to be 00:00:00Z (start of day, UTC).\n    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n        '(?:' + // time is optional\n        '(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n        '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n        ')?$'),\n    resolve(str) {\n        const match = str.match(timestamp.test);\n        if (!match)\n            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');\n        const [, year, month, day, hour, minute, second] = match.map(Number);\n        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);\n        const tz = match[8];\n        if (tz && tz !== 'Z') {\n            let d = parseSexagesimal(tz, false);\n            if (Math.abs(d) < 30)\n                d *= 60;\n            date -= 60000 * d;\n        }\n        return new Date(date);\n    },\n    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\\.000Z$/, '') ?? ''\n};\n\nexports.floatTime = floatTime;\nexports.intTime = intTime;\nexports.timestamp = timestamp;\n","'use strict';\n\nvar map = require('../common/map.js');\nvar _null = require('../common/null.js');\nvar seq = require('../common/seq.js');\nvar string = require('../common/string.js');\nvar binary = require('./binary.js');\nvar bool = require('./bool.js');\nvar float = require('./float.js');\nvar int = require('./int.js');\nvar merge = require('./merge.js');\nvar omap = require('./omap.js');\nvar pairs = require('./pairs.js');\nvar set = require('./set.js');\nvar timestamp = require('./timestamp.js');\n\nconst schema = [\n    map.map,\n    seq.seq,\n    string.string,\n    _null.nullTag,\n    bool.trueTag,\n    bool.falseTag,\n    int.intBin,\n    int.intOct,\n    int.int,\n    int.intHex,\n    float.floatNaN,\n    float.floatExp,\n    float.float,\n    binary.binary,\n    merge.merge,\n    omap.omap,\n    pairs.pairs,\n    set.set,\n    timestamp.intTime,\n    timestamp.floatTime,\n    timestamp.timestamp\n];\n\nexports.schema = schema;\n","'use strict';\n\nvar map = require('./common/map.js');\nvar _null = require('./common/null.js');\nvar seq = require('./common/seq.js');\nvar string = require('./common/string.js');\nvar bool = require('./core/bool.js');\nvar float = require('./core/float.js');\nvar int = require('./core/int.js');\nvar schema = require('./core/schema.js');\nvar schema$1 = require('./json/schema.js');\nvar binary = require('./yaml-1.1/binary.js');\nvar merge = require('./yaml-1.1/merge.js');\nvar omap = require('./yaml-1.1/omap.js');\nvar pairs = require('./yaml-1.1/pairs.js');\nvar schema$2 = require('./yaml-1.1/schema.js');\nvar set = require('./yaml-1.1/set.js');\nvar timestamp = require('./yaml-1.1/timestamp.js');\n\nconst schemas = new Map([\n    ['core', schema.schema],\n    ['failsafe', [map.map, seq.seq, string.string]],\n    ['json', schema$1.schema],\n    ['yaml11', schema$2.schema],\n    ['yaml-1.1', schema$2.schema]\n]);\nconst tagsByName = {\n    binary: binary.binary,\n    bool: bool.boolTag,\n    float: float.float,\n    floatExp: float.floatExp,\n    floatNaN: float.floatNaN,\n    floatTime: timestamp.floatTime,\n    int: int.int,\n    intHex: int.intHex,\n    intOct: int.intOct,\n    intTime: timestamp.intTime,\n    map: map.map,\n    merge: merge.merge,\n    null: _null.nullTag,\n    omap: omap.omap,\n    pairs: pairs.pairs,\n    seq: seq.seq,\n    set: set.set,\n    timestamp: timestamp.timestamp\n};\nconst coreKnownTags = {\n    'tag:yaml.org,2002:binary': binary.binary,\n    'tag:yaml.org,2002:merge': merge.merge,\n    'tag:yaml.org,2002:omap': omap.omap,\n    'tag:yaml.org,2002:pairs': pairs.pairs,\n    'tag:yaml.org,2002:set': set.set,\n    'tag:yaml.org,2002:timestamp': timestamp.timestamp\n};\nfunction getTags(customTags, schemaName, addMergeTag) {\n    const schemaTags = schemas.get(schemaName);\n    if (schemaTags && !customTags) {\n        return addMergeTag && !schemaTags.includes(merge.merge)\n            ? schemaTags.concat(merge.merge)\n            : schemaTags.slice();\n    }\n    let tags = schemaTags;\n    if (!tags) {\n        if (Array.isArray(customTags))\n            tags = [];\n        else {\n            const keys = Array.from(schemas.keys())\n                .filter(key => key !== 'yaml11')\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown schema \"${schemaName}\"; use one of ${keys} or define customTags array`);\n        }\n    }\n    if (Array.isArray(customTags)) {\n        for (const tag of customTags)\n            tags = tags.concat(tag);\n    }\n    else if (typeof customTags === 'function') {\n        tags = customTags(tags.slice());\n    }\n    if (addMergeTag)\n        tags = tags.concat(merge.merge);\n    return tags.reduce((tags, tag) => {\n        const tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;\n        if (!tagObj) {\n            const tagName = JSON.stringify(tag);\n            const keys = Object.keys(tagsByName)\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);\n        }\n        if (!tags.includes(tagObj))\n            tags.push(tagObj);\n        return tags;\n    }, []);\n}\n\nexports.coreKnownTags = coreKnownTags;\nexports.getTags = getTags;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar map = require('./common/map.js');\nvar seq = require('./common/seq.js');\nvar string = require('./common/string.js');\nvar tags = require('./tags.js');\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\nclass Schema {\n    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {\n        this.compat = Array.isArray(compat)\n            ? tags.getTags(compat, 'compat')\n            : compat\n                ? tags.getTags(null, compat)\n                : null;\n        this.name = (typeof schema === 'string' && schema) || 'core';\n        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};\n        this.tags = tags.getTags(customTags, this.name, merge);\n        this.toStringOptions = toStringDefaults ?? null;\n        Object.defineProperty(this, identity.MAP, { value: map.map });\n        Object.defineProperty(this, identity.SCALAR, { value: string.string });\n        Object.defineProperty(this, identity.SEQ, { value: seq.seq });\n        // Used by createMap()\n        this.sortMapEntries =\n            typeof sortMapEntries === 'function'\n                ? sortMapEntries\n                : sortMapEntries === true\n                    ? sortMapEntriesByKey\n                    : null;\n    }\n    clone() {\n        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));\n        copy.tags = this.tags.slice();\n        return copy;\n    }\n}\n\nexports.Schema = Schema;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar stringify = require('./stringify.js');\nvar stringifyComment = require('./stringifyComment.js');\n\nfunction stringifyDocument(doc, options) {\n    const lines = [];\n    let hasDirectives = options.directives === true;\n    if (options.directives !== false && doc.directives) {\n        const dir = doc.directives.toString(doc);\n        if (dir) {\n            lines.push(dir);\n            hasDirectives = true;\n        }\n        else if (doc.directives.docStart)\n            hasDirectives = true;\n    }\n    if (hasDirectives)\n        lines.push('---');\n    const ctx = stringify.createStringifyContext(doc, options);\n    const { commentString } = ctx.options;\n    if (doc.commentBefore) {\n        if (lines.length !== 1)\n            lines.unshift('');\n        const cs = commentString(doc.commentBefore);\n        lines.unshift(stringifyComment.indentComment(cs, ''));\n    }\n    let chompKeep = false;\n    let contentComment = null;\n    if (doc.contents) {\n        if (identity.isNode(doc.contents)) {\n            if (doc.contents.spaceBefore && hasDirectives)\n                lines.push('');\n            if (doc.contents.commentBefore) {\n                const cs = commentString(doc.contents.commentBefore);\n                lines.push(stringifyComment.indentComment(cs, ''));\n            }\n            // top-level block scalars need to be indented if followed by a comment\n            ctx.forceBlockIndent = !!doc.comment;\n            contentComment = doc.contents.comment;\n        }\n        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);\n        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);\n        if (contentComment)\n            body += stringifyComment.lineComment(body, '', commentString(contentComment));\n        if ((body[0] === '|' || body[0] === '>') &&\n            lines[lines.length - 1] === '---') {\n            // Top-level block scalars with a preceding doc marker ought to use the\n            // same line for their header.\n            lines[lines.length - 1] = `--- ${body}`;\n        }\n        else\n            lines.push(body);\n    }\n    else {\n        lines.push(stringify.stringify(doc.contents, ctx));\n    }\n    if (doc.directives?.docEnd) {\n        if (doc.comment) {\n            const cs = commentString(doc.comment);\n            if (cs.includes('\\n')) {\n                lines.push('...');\n                lines.push(stringifyComment.indentComment(cs, ''));\n            }\n            else {\n                lines.push(`... ${cs}`);\n            }\n        }\n        else {\n            lines.push('...');\n        }\n    }\n    else {\n        let dc = doc.comment;\n        if (dc && chompKeep)\n            dc = dc.replace(/^\\n+/, '');\n        if (dc) {\n            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')\n                lines.push('');\n            lines.push(stringifyComment.indentComment(commentString(dc), ''));\n        }\n    }\n    return lines.join('\\n') + '\\n';\n}\n\nexports.stringifyDocument = stringifyDocument;\n","'use strict';\n\nvar Alias = require('../nodes/Alias.js');\nvar Collection = require('../nodes/Collection.js');\nvar identity = require('../nodes/identity.js');\nvar Pair = require('../nodes/Pair.js');\nvar toJS = require('../nodes/toJS.js');\nvar Schema = require('../schema/Schema.js');\nvar stringifyDocument = require('../stringify/stringifyDocument.js');\nvar anchors = require('./anchors.js');\nvar applyReviver = require('./applyReviver.js');\nvar createNode = require('./createNode.js');\nvar directives = require('./directives.js');\n\nclass Document {\n    constructor(value, replacer, options) {\n        /** A comment before this Document */\n        this.commentBefore = null;\n        /** A comment immediately after this Document */\n        this.comment = null;\n        /** Errors encountered during parsing. */\n        this.errors = [];\n        /** Warnings encountered during parsing. */\n        this.warnings = [];\n        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });\n        let _replacer = null;\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const opt = Object.assign({\n            intAsBigInt: false,\n            keepSourceTokens: false,\n            logLevel: 'warn',\n            prettyErrors: true,\n            strict: true,\n            stringKeys: false,\n            uniqueKeys: true,\n            version: '1.2'\n        }, options);\n        this.options = opt;\n        let { version } = opt;\n        if (options?._directives) {\n            this.directives = options._directives.atDocument();\n            if (this.directives.yaml.explicit)\n                version = this.directives.yaml.version;\n        }\n        else\n            this.directives = new directives.Directives({ version });\n        this.setSchema(version, options);\n        // @ts-expect-error We can't really know that this matches Contents.\n        this.contents =\n            value === undefined ? null : this.createNode(value, _replacer, options);\n    }\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone() {\n        const copy = Object.create(Document.prototype, {\n            [identity.NODE_TYPE]: { value: identity.DOC }\n        });\n        copy.commentBefore = this.commentBefore;\n        copy.comment = this.comment;\n        copy.errors = this.errors.slice();\n        copy.warnings = this.warnings.slice();\n        copy.options = Object.assign({}, this.options);\n        if (this.directives)\n            copy.directives = this.directives.clone();\n        copy.schema = this.schema.clone();\n        // @ts-expect-error We can't really know that this matches Contents.\n        copy.contents = identity.isNode(this.contents)\n            ? this.contents.clone(copy.schema)\n            : this.contents;\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** Adds a value to the document. */\n    add(value) {\n        if (assertCollection(this.contents))\n            this.contents.add(value);\n    }\n    /** Adds a value to the document. */\n    addIn(path, value) {\n        if (assertCollection(this.contents))\n            this.contents.addIn(path, value);\n    }\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node, name) {\n        if (!node.anchor) {\n            const prev = anchors.anchorNames(this);\n            node.anchor =\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;\n        }\n        return new Alias.Alias(node.anchor);\n    }\n    createNode(value, replacer, options) {\n        let _replacer = undefined;\n        if (typeof replacer === 'function') {\n            value = replacer.call({ '': value }, '', value);\n            _replacer = replacer;\n        }\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0)\n                replacer = replacer.concat(asStr);\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};\n        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, \n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        anchorPrefix || 'a');\n        const ctx = {\n            aliasDuplicateObjects: aliasDuplicateObjects ?? true,\n            keepUndefined: keepUndefined ?? false,\n            onAnchor,\n            onTagObj,\n            replacer: _replacer,\n            schema: this.schema,\n            sourceObjects\n        };\n        const node = createNode.createNode(value, tag, ctx);\n        if (flow && identity.isCollection(node))\n            node.flow = true;\n        setAnchors();\n        return node;\n    }\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, null, options);\n        const v = this.createNode(value, null, options);\n        return new Pair.Pair(k, v);\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        if (Collection.isEmptyPath(path)) {\n            if (this.contents == null)\n                return false;\n            // @ts-expect-error Presumed impossible if Strict extends false\n            this.contents = null;\n            return true;\n        }\n        return assertCollection(this.contents)\n            ? this.contents.deleteIn(path)\n            : false;\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key, keepScalar) {\n        return identity.isCollection(this.contents)\n            ? this.contents.get(key, keepScalar)\n            : undefined;\n    }\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        if (Collection.isEmptyPath(path))\n            return !keepScalar && identity.isScalar(this.contents)\n                ? this.contents.value\n                : this.contents;\n        return identity.isCollection(this.contents)\n            ? this.contents.getIn(path, keepScalar)\n            : undefined;\n    }\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key) {\n        return identity.isCollection(this.contents) ? this.contents.has(key) : false;\n    }\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path) {\n        if (Collection.isEmptyPath(path))\n            return this.contents !== undefined;\n        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key, value) {\n        if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = Collection.collectionFromPath(this.schema, [key], value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.set(key, value);\n        }\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        if (Collection.isEmptyPath(path)) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = value;\n        }\n        else if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.setIn(path, value);\n        }\n    }\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version, options = {}) {\n        if (typeof version === 'number')\n            version = String(version);\n        let opt;\n        switch (version) {\n            case '1.1':\n                if (this.directives)\n                    this.directives.yaml.version = '1.1';\n                else\n                    this.directives = new directives.Directives({ version: '1.1' });\n                opt = { resolveKnownTags: false, schema: 'yaml-1.1' };\n                break;\n            case '1.2':\n            case 'next':\n                if (this.directives)\n                    this.directives.yaml.version = version;\n                else\n                    this.directives = new directives.Directives({ version });\n                opt = { resolveKnownTags: true, schema: 'core' };\n                break;\n            case null:\n                if (this.directives)\n                    delete this.directives;\n                opt = null;\n                break;\n            default: {\n                const sv = JSON.stringify(version);\n                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);\n            }\n        }\n        // Not using `instanceof Schema` to allow for duck typing\n        if (options.schema instanceof Object)\n            this.schema = options.schema;\n        else if (opt)\n            this.schema = new Schema.Schema(Object.assign(opt, options));\n        else\n            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);\n    }\n    // json & jsonArg are only used from toJSON()\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        const ctx = {\n            anchors: new Map(),\n            doc: this,\n            keep: !json,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver.applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\n    }\n    /** A YAML representation of the document. */\n    toString(options = {}) {\n        if (this.errors.length > 0)\n            throw new Error('Document with errors cannot be stringified');\n        if ('indent' in options &&\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n            const s = JSON.stringify(options.indent);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        return stringifyDocument.stringifyDocument(this, options);\n    }\n}\nfunction assertCollection(contents) {\n    if (identity.isCollection(contents))\n        return true;\n    throw new Error('Expected a YAML collection as document contents');\n}\n\nexports.Document = Document;\n","'use strict';\n\nclass YAMLError extends Error {\n    constructor(name, pos, code, message) {\n        super();\n        this.name = name;\n        this.code = code;\n        this.message = message;\n        this.pos = pos;\n    }\n}\nclass YAMLParseError extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLParseError', pos, code, message);\n    }\n}\nclass YAMLWarning extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLWarning', pos, code, message);\n    }\n}\nconst prettifyError = (src, lc) => (error) => {\n    if (error.pos[0] === -1)\n        return;\n    error.linePos = error.pos.map(pos => lc.linePos(pos));\n    const { line, col } = error.linePos[0];\n    error.message += ` at line ${line}, column ${col}`;\n    let ci = col - 1;\n    let lineStr = src\n        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n        .replace(/[\\n\\r]+$/, '');\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n        const trimStart = Math.min(ci - 39, lineStr.length - 79);\n        lineStr = '…' + lineStr.substring(trimStart);\n        ci -= trimStart - 1;\n    }\n    if (lineStr.length > 80)\n        lineStr = lineStr.substring(0, 79) + '…';\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n        // Regexp won't match if start is trimmed\n        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);\n        if (prev.length > 80)\n            prev = prev.substring(0, 79) + '…\\n';\n        lineStr = prev + lineStr;\n    }\n    if (/[^ ]/.test(lineStr)) {\n        let count = 1;\n        const end = error.linePos[1];\n        if (end && end.line === line && end.col > col) {\n            count = Math.max(1, Math.min(end.col - col, 80 - ci));\n        }\n        const pointer = ' '.repeat(ci) + '^'.repeat(count);\n        error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`;\n    }\n};\n\nexports.YAMLError = YAMLError;\nexports.YAMLParseError = YAMLParseError;\nexports.YAMLWarning = YAMLWarning;\nexports.prettifyError = prettifyError;\n","'use strict';\n\nfunction resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let reqSpace = false;\n    let tab = null;\n    let anchor = null;\n    let tag = null;\n    let newlineAfterProp = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        if (tab) {\n            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {\n                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n            }\n            tab = null;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&\n                    token.source.includes('\\t')) {\n                    tab = token;\n                }\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else if (!found || indicator !== 'seq-item-ind')\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    newlineAfterProp = token;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline =\n                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== '')) {\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    }\n    if (tab &&\n        ((atNewline && tab.indent <= parentIndent) ||\n            next?.type === 'block-map' ||\n            next?.type === 'block-seq'))\n        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        anchor,\n        tag,\n        newlineAfterProp,\n        end,\n        start: start ?? end\n    };\n}\n\nexports.resolveProps = resolveProps;\n","'use strict';\n\nfunction containsNewline(key) {\n    if (!key)\n        return null;\n    switch (key.type) {\n        case 'alias':\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            if (key.source.includes('\\n'))\n                return true;\n            if (key.end)\n                for (const st of key.end)\n                    if (st.type === 'newline')\n                        return true;\n            return false;\n        case 'flow-collection':\n            for (const it of key.items) {\n                for (const st of it.start)\n                    if (st.type === 'newline')\n                        return true;\n                if (it.sep)\n                    for (const st of it.sep)\n                        if (st.type === 'newline')\n                            return true;\n                if (containsNewline(it.key) || containsNewline(it.value))\n                    return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\nexports.containsNewline = containsNewline;\n","'use strict';\n\nvar utilContainsNewline = require('./util-contains-newline.js');\n\nfunction flowIndentCheck(indent, fc, onError) {\n    if (fc?.type === 'flow-collection') {\n        const end = fc.end[0];\n        if (end.indent === indent &&\n            (end.source === ']' || end.source === '}') &&\n            utilContainsNewline.containsNewline(fc)) {\n            const msg = 'Flow end indicator should be more indented than parent';\n            onError(end, 'BAD_INDENT', msg, true);\n        }\n    }\n}\n\nexports.flowIndentCheck = flowIndentCheck;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\n\nfunction mapIncludes(ctx, items, search) {\n    const { uniqueKeys } = ctx.options;\n    if (uniqueKeys === false)\n        return false;\n    const isEqual = typeof uniqueKeys === 'function'\n        ? uniqueKeys\n        : (a, b) => a === b || (identity.isScalar(a) && identity.isScalar(b) && a.value === b.value);\n    return items.some(pair => isEqual(pair.key, search));\n}\n\nexports.mapIncludes = mapIncludes;\n","'use strict';\n\nvar Pair = require('../nodes/Pair.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilContainsNewline = require('./util-contains-newline.js');\nvar utilFlowIndentCheck = require('./util-flow-indent-check.js');\nvar utilMapIncludes = require('./util-map-includes.js');\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;\n    const map = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    let commentEnd = null;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps.resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                commentEnd = keyProps.end;\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        ctx.atKey = true;\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);\n        ctx.atKey = false;\n        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps.resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair.Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair.Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    if (commentEnd && commentEnd < offset)\n        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n    map.range = [bm.offset, offset, commentEnd ?? offset];\n    return map;\n}\n\nexports.resolveBlockMap = resolveBlockMap;\n","'use strict';\n\nvar YAMLSeq = require('../nodes/YAMLSeq.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilFlowIndentCheck = require('./util-flow-indent-check.js');\n\nfunction resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;\n    const seq = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = bs.offset;\n    let commentEnd = null;\n    for (const { start, value } of bs.items) {\n        const props = resolveProps.resolveProps(start, {\n            indicator: 'seq-item-ind',\n            next: value,\n            offset,\n            onError,\n            parentIndent: bs.indent,\n            startOnNewline: true\n        });\n        if (!props.found) {\n            if (props.anchor || props.tag || value) {\n                if (value && value.type === 'block-seq')\n                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');\n                else\n                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');\n            }\n            else {\n                commentEnd = props.end;\n                if (props.comment)\n                    seq.comment = props.comment;\n                continue;\n            }\n        }\n        const node = value\n            ? composeNode(ctx, value, props, onError)\n            : composeEmptyNode(ctx, props.end, start, null, props, onError);\n        if (ctx.schema.compat)\n            utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);\n        offset = node.range[2];\n        seq.items.push(node);\n    }\n    seq.range = [bs.offset, offset, commentEnd ?? offset];\n    return seq;\n}\n\nexports.resolveBlockSeq = resolveBlockSeq;\n","'use strict';\n\nfunction resolveEnd(end, offset, reqSpace, onError) {\n    let comment = '';\n    if (end) {\n        let hasSpace = false;\n        let sep = '';\n        for (const token of end) {\n            const { source, type } = token;\n            switch (type) {\n                case 'space':\n                    hasSpace = true;\n                    break;\n                case 'comment': {\n                    if (reqSpace && !hasSpace)\n                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                    const cb = source.substring(1) || ' ';\n                    if (!comment)\n                        comment = cb;\n                    else\n                        comment += sep + cb;\n                    sep = '';\n                    break;\n                }\n                case 'newline':\n                    if (comment)\n                        sep += source;\n                    hasSpace = true;\n                    break;\n                default:\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);\n            }\n            offset += source.length;\n        }\n    }\n    return { comment, offset };\n}\n\nexports.resolveEnd = resolveEnd;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Pair = require('../nodes/Pair.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar YAMLSeq = require('../nodes/YAMLSeq.js');\nvar resolveEnd = require('./resolve-end.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilContainsNewline = require('./util-contains-newline.js');\nvar utilMapIncludes = require('./util-map-includes.js');\n\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {\n    const isMap = fc.start.source === '{';\n    const fcName = isMap ? 'flow map' : 'flow sequence';\n    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq));\n    const coll = new NodeClass(ctx.schema);\n    coll.flow = true;\n    const atRoot = ctx.atRoot;\n    if (atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = fc.offset + fc.start.source.length;\n    for (let i = 0; i < fc.items.length; ++i) {\n        const collItem = fc.items[i];\n        const { start, key, sep, value } = collItem;\n        const props = resolveProps.resolveProps(start, {\n            flow: fcName,\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: fc.indent,\n            startOnNewline: false\n        });\n        if (!props.found) {\n            if (!props.anchor && !props.tag && !sep && !value) {\n                if (i === 0 && props.comma)\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n                else if (i < fc.items.length - 1)\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n                if (props.comment) {\n                    if (coll.comment)\n                        coll.comment += '\\n' + props.comment;\n                    else\n                        coll.comment = props.comment;\n                }\n                offset = props.end;\n                continue;\n            }\n            if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))\n                onError(key, // checked by containsNewline()\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n        }\n        if (i === 0) {\n            if (props.comma)\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n        }\n        else {\n            if (!props.comma)\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n            if (props.comment) {\n                let prevItemComment = '';\n                loop: for (const st of start) {\n                    switch (st.type) {\n                        case 'comma':\n                        case 'space':\n                            break;\n                        case 'comment':\n                            prevItemComment = st.source.substring(1);\n                            break loop;\n                        default:\n                            break loop;\n                    }\n                }\n                if (prevItemComment) {\n                    let prev = coll.items[coll.items.length - 1];\n                    if (identity.isPair(prev))\n                        prev = prev.value ?? prev.key;\n                    if (prev.comment)\n                        prev.comment += '\\n' + prevItemComment;\n                    else\n                        prev.comment = prevItemComment;\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\n                }\n            }\n        }\n        if (!isMap && !sep && !props.found) {\n            // item is a value in a seq\n            // → key & sep are empty, start does not include ? or :\n            const valueNode = value\n                ? composeNode(ctx, value, props, onError)\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n            coll.items.push(valueNode);\n            offset = valueNode.range[2];\n            if (isBlock(value))\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n        }\n        else {\n            // item is a key+value pair\n            // key value\n            ctx.atKey = true;\n            const keyStart = props.end;\n            const keyNode = key\n                ? composeNode(ctx, key, props, onError)\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n            if (isBlock(key))\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            ctx.atKey = false;\n            // value properties\n            const valueProps = resolveProps.resolveProps(sep ?? [], {\n                flow: fcName,\n                indicator: 'map-value-ind',\n                next: value,\n                offset: keyNode.range[2],\n                onError,\n                parentIndent: fc.indent,\n                startOnNewline: false\n            });\n            if (valueProps.found) {\n                if (!isMap && !props.found && ctx.options.strict) {\n                    if (sep)\n                        for (const st of sep) {\n                            if (st === valueProps.found)\n                                break;\n                            if (st.type === 'newline') {\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n                                break;\n                            }\n                        }\n                    if (props.start < valueProps.found.offset - 1024)\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n                }\n            }\n            else if (value) {\n                if ('source' in value && value.source && value.source[0] === ':')\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\n                else\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : valueProps.found\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\n                    : null;\n            if (valueNode) {\n                if (isBlock(value))\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            }\n            else if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair.Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            if (isMap) {\n                const map = coll;\n                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n                map.items.push(pair);\n            }\n            else {\n                const map = new YAMLMap.YAMLMap(ctx.schema);\n                map.flow = true;\n                map.items.push(pair);\n                const endRange = (valueNode ?? keyNode).range;\n                map.range = [keyNode.range[0], endRange[1], endRange[2]];\n                coll.items.push(map);\n            }\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\n        }\n    }\n    const expectedEnd = isMap ? '}' : ']';\n    const [ce, ...ee] = fc.end;\n    let cePos = offset;\n    if (ce && ce.source === expectedEnd)\n        cePos = ce.offset + ce.source.length;\n    else {\n        const name = fcName[0].toUpperCase() + fcName.substring(1);\n        const msg = atRoot\n            ? `${name} must end with a ${expectedEnd}`\n            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n        if (ce && ce.source.length !== 1)\n            ee.unshift(ce);\n    }\n    if (ee.length > 0) {\n        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);\n        if (end.comment) {\n            if (coll.comment)\n                coll.comment += '\\n' + end.comment;\n            else\n                coll.comment = end.comment;\n        }\n        coll.range = [fc.offset, cePos, end.offset];\n    }\n    else {\n        coll.range = [fc.offset, cePos, cePos];\n    }\n    return coll;\n}\n\nexports.resolveFlowCollection = resolveFlowCollection;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar YAMLSeq = require('../nodes/YAMLSeq.js');\nvar resolveBlockMap = require('./resolve-block-map.js');\nvar resolveBlockSeq = require('./resolve-block-seq.js');\nvar resolveFlowCollection = require('./resolve-flow-collection.js');\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, props, onError) {\n    const tagToken = props.tag;\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    if (token.type === 'block-seq') {\n        const { anchor, newlineAfterProp: nl } = props;\n        const lastProp = anchor && tagToken\n            ? anchor.offset > tagToken.offset\n                ? anchor\n                : tagToken\n            : (anchor ?? tagToken);\n        if (lastProp && (!nl || nl.offset < lastProp.offset)) {\n            const message = 'Missing newline after block sequence props';\n            onError(lastProp, 'MISSING_CHAR', message);\n        }\n    }\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.YAMLSeq.tagName && expType === 'seq')) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = identity.isNode(res)\n        ? res\n        : new Scalar.Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexports.composeCollection = composeCollection;\n","'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\n\nfunction resolveBlockScalar(ctx, scalar, onError) {\n    const start = scalar.offset;\n    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);\n    if (!header)\n        return { value: '', type: null, comment: '', range: [start, start, start] };\n    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;\n    const lines = scalar.source ? splitLines(scalar.source) : [];\n    // determine the end of content & start of chomping\n    let chompStart = lines.length;\n    for (let i = lines.length - 1; i >= 0; --i) {\n        const content = lines[i][1];\n        if (content === '' || content === '\\r')\n            chompStart = i;\n        else\n            break;\n    }\n    // shortcut for empty contents\n    if (chompStart === 0) {\n        const value = header.chomp === '+' && lines.length > 0\n            ? '\\n'.repeat(Math.max(1, lines.length - 1))\n            : '';\n        let end = start + header.length;\n        if (scalar.source)\n            end += scalar.source.length;\n        return { value, type, comment: header.comment, range: [start, end, end] };\n    }\n    // find the indentation level to trim from start\n    let trimIndent = scalar.indent + header.indent;\n    let offset = scalar.offset + header.length;\n    let contentStart = 0;\n    for (let i = 0; i < chompStart; ++i) {\n        const [indent, content] = lines[i];\n        if (content === '' || content === '\\r') {\n            if (header.indent === 0 && indent.length > trimIndent)\n                trimIndent = indent.length;\n        }\n        else {\n            if (indent.length < trimIndent) {\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n                onError(offset + indent.length, 'MISSING_CHAR', message);\n            }\n            if (header.indent === 0)\n                trimIndent = indent.length;\n            contentStart = i;\n            if (trimIndent === 0 && !ctx.atRoot) {\n                const message = 'Block scalar values in collections must be indented';\n                onError(offset, 'BAD_INDENT', message);\n            }\n            break;\n        }\n        offset += indent.length + content.length + 1;\n    }\n    // include trailing more-indented empty lines in content\n    for (let i = lines.length - 1; i >= chompStart; --i) {\n        if (lines[i][0].length > trimIndent)\n            chompStart = i + 1;\n    }\n    let value = '';\n    let sep = '';\n    let prevMoreIndented = false;\n    // leading whitespace is kept intact\n    for (let i = 0; i < contentStart; ++i)\n        value += lines[i][0].slice(trimIndent) + '\\n';\n    for (let i = contentStart; i < chompStart; ++i) {\n        let [indent, content] = lines[i];\n        offset += indent.length + content.length + 1;\n        const crlf = content[content.length - 1] === '\\r';\n        if (crlf)\n            content = content.slice(0, -1);\n        /* istanbul ignore if already caught in lexer */\n        if (content && indent.length < trimIndent) {\n            const src = header.indent\n                ? 'explicit indentation indicator'\n                : 'first line';\n            const message = `Block scalar lines must not be less indented than their ${src}`;\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\n            indent = '';\n        }\n        if (type === Scalar.Scalar.BLOCK_LITERAL) {\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n        }\n        else if (indent.length > trimIndent || content[0] === '\\t') {\n            // more-indented content within a folded block\n            if (sep === ' ')\n                sep = '\\n';\n            else if (!prevMoreIndented && sep === '\\n')\n                sep = '\\n\\n';\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n            prevMoreIndented = true;\n        }\n        else if (content === '') {\n            // empty line\n            if (sep === '\\n')\n                value += '\\n';\n            else\n                sep = '\\n';\n        }\n        else {\n            value += sep + content;\n            sep = ' ';\n            prevMoreIndented = false;\n        }\n    }\n    switch (header.chomp) {\n        case '-':\n            break;\n        case '+':\n            for (let i = chompStart; i < lines.length; ++i)\n                value += '\\n' + lines[i][0].slice(trimIndent);\n            if (value[value.length - 1] !== '\\n')\n                value += '\\n';\n            break;\n        default:\n            value += '\\n';\n    }\n    const end = start + header.length + scalar.source.length;\n    return { value, type, comment: header.comment, range: [start, end, end] };\n}\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\n    /* istanbul ignore if should not happen */\n    if (props[0].type !== 'block-scalar-header') {\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n        return null;\n    }\n    const { source } = props[0];\n    const mode = source[0];\n    let indent = 0;\n    let chomp = '';\n    let error = -1;\n    for (let i = 1; i < source.length; ++i) {\n        const ch = source[i];\n        if (!chomp && (ch === '-' || ch === '+'))\n            chomp = ch;\n        else {\n            const n = Number(ch);\n            if (!indent && n)\n                indent = n;\n            else if (error === -1)\n                error = offset + i;\n        }\n    }\n    if (error !== -1)\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n    let hasSpace = false;\n    let comment = '';\n    let length = source.length;\n    for (let i = 1; i < props.length; ++i) {\n        const token = props[i];\n        switch (token.type) {\n            case 'space':\n                hasSpace = true;\n            // fallthrough\n            case 'newline':\n                length += token.source.length;\n                break;\n            case 'comment':\n                if (strict && !hasSpace) {\n                    const message = 'Comments must be separated from other tokens by white space characters';\n                    onError(token, 'MISSING_CHAR', message);\n                }\n                length += token.source.length;\n                comment = token.source.substring(1);\n                break;\n            case 'error':\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\n                length += token.source.length;\n                break;\n            /* istanbul ignore next should not happen */\n            default: {\n                const message = `Unexpected token in block scalar header: ${token.type}`;\n                onError(token, 'UNEXPECTED_TOKEN', message);\n                const ts = token.source;\n                if (ts && typeof ts === 'string')\n                    length += ts.length;\n            }\n        }\n    }\n    return { mode, indent, chomp, comment, length };\n}\n/** @returns Array of lines split up as `[indent, content]` */\nfunction splitLines(source) {\n    const split = source.split(/\\n( *)/);\n    const first = split[0];\n    const m = first.match(/^( *)/);\n    const line0 = m?.[1]\n        ? [m[1], first.slice(m[1].length)]\n        : ['', first];\n    const lines = [line0];\n    for (let i = 1; i < split.length; i += 2)\n        lines.push([split[i], split[i + 1]]);\n    return lines;\n}\n\nexports.resolveBlockScalar = resolveBlockScalar;\n","'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\nvar resolveEnd = require('./resolve-end.js');\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0', // null character\n    a: '\\x07', // bell character\n    b: '\\b', // backspace\n    e: '\\x1b', // escape character\n    f: '\\f', // form feed\n    n: '\\n', // line feed\n    r: '\\r', // carriage return\n    t: '\\t', // horizontal tab\n    v: '\\v', // vertical tab\n    N: '\\u0085', // Unicode next line\n    _: '\\u00a0', // Unicode non-breaking space\n    L: '\\u2028', // Unicode line separator\n    P: '\\u2029', // Unicode paragraph separator\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nexports.resolveFlowScalar = resolveFlowScalar;\n","'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar resolveBlockScalar = require('./resolve-block-scalar.js');\nvar resolveFlowScalar = require('./resolve-flow-scalar.js');\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError)\n        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    let tag;\n    if (ctx.options.stringKeys && ctx.atKey) {\n        tag = ctx.schema[identity.SCALAR];\n    }\n    else if (tagName)\n        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);\n    else if (token.type === 'scalar')\n        tag = findScalarTagByTest(ctx, value, token, onError);\n    else\n        tag = ctx.schema[identity.SCALAR];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar.Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[identity.SCALAR]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[identity.SCALAR];\n}\nfunction findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => (tag.default === true || (atKey && tag.default === 'key')) &&\n        tag.test?.test(value)) || schema[identity.SCALAR];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[identity.SCALAR];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nexports.composeScalar = composeScalar;\n","'use strict';\n\nfunction emptyScalarPosition(offset, before, pos) {\n    if (before) {\n        if (pos === null)\n            pos = before.length;\n        for (let i = pos - 1; i >= 0; --i) {\n            let st = before[i];\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                case 'newline':\n                    offset -= st.source.length;\n                    continue;\n            }\n            // Technically, an empty scalar is immediately after the last non-empty\n            // node, but it's more useful to place it after any whitespace.\n            st = before[++i];\n            while (st?.type === 'space') {\n                offset += st.source.length;\n                st = before[++i];\n            }\n            break;\n        }\n    }\n    return offset;\n}\n\nexports.emptyScalarPosition = emptyScalarPosition;\n","'use strict';\n\nvar Alias = require('../nodes/Alias.js');\nvar identity = require('../nodes/identity.js');\nvar composeCollection = require('./compose-collection.js');\nvar composeScalar = require('./compose-scalar.js');\nvar resolveEnd = require('./resolve-end.js');\nvar utilEmptyScalarPosition = require('./util-empty-scalar-position.js');\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const atKey = ctx.atKey;\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar.composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection.composeCollection(CN, ctx, token, props, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (atKey &&\n        ctx.options.stringKeys &&\n        (!identity.isScalar(node) ||\n            typeof node.value !== 'string' ||\n            (node.tag && node.tag !== 'tag:yaml.org,2002:str'))) {\n        const msg = 'With stringKeys, all keys must be strings';\n        onError(tag ?? token, 'NON_STRING_KEY', msg);\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar.composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        node.comment = comment;\n        node.range[2] = end;\n    }\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias.Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nexports.composeEmptyNode = composeEmptyNode;\nexports.composeNode = composeNode;\n","'use strict';\n\nvar Document = require('../doc/Document.js');\nvar composeNode = require('./compose-node.js');\nvar resolveEnd = require('./resolve-end.js');\nvar resolveProps = require('./resolve-props.js');\n\nfunction composeDoc(options, directives, { offset, start, value, end }, onError) {\n    const opts = Object.assign({ _directives: directives }, options);\n    const doc = new Document.Document(undefined, opts);\n    const ctx = {\n        atKey: false,\n        atRoot: true,\n        directives: doc.directives,\n        options: doc.options,\n        schema: doc.schema\n    };\n    const props = resolveProps.resolveProps(start, {\n        indicator: 'doc-start',\n        next: value ?? end?.[0],\n        offset,\n        onError,\n        parentIndent: 0,\n        startOnNewline: true\n    });\n    if (props.found) {\n        doc.directives.docStart = true;\n        if (value &&\n            (value.type === 'block-map' || value.type === 'block-seq') &&\n            !props.hasNewline)\n            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');\n    }\n    // @ts-expect-error If Contents is set, let's trust the user\n    doc.contents = value\n        ? composeNode.composeNode(ctx, value, props, onError)\n        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);\n    const contentEnd = doc.contents.range[2];\n    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);\n    if (re.comment)\n        doc.comment = re.comment;\n    doc.range = [offset, contentEnd, re.offset];\n    return doc;\n}\n\nexports.composeDoc = composeDoc;\n","'use strict';\n\nvar node_process = require('node:process');\nvar directives = require('../doc/directives.js');\nvar Document = require('../doc/Document.js');\nvar errors = require('../errors.js');\nvar identity = require('../nodes/identity.js');\nvar composeDoc = require('./compose-doc.js');\nvar resolveEnd = require('./resolve-end.js');\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new errors.YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new errors.YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new directives.Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (identity.isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        if (node_process.env.LOG_STREAM)\n            console.dir(token, { depth: null });\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document.Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexports.Composer = Composer;\n","'use strict';\n\nvar resolveBlockScalar = require('../compose/resolve-block-scalar.js');\nvar resolveFlowScalar = require('../compose/resolve-flow-scalar.js');\nvar errors = require('../errors.js');\nvar stringifyString = require('../stringify/stringifyString.js');\n\nfunction resolveAsScalar(token, strict = true, onError) {\n    if (token) {\n        const _onError = (pos, code, message) => {\n            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n            if (onError)\n                onError(offset, code, message);\n            else\n                throw new errors.YAMLParseError([offset, offset + 1], code, message);\n        };\n        switch (token.type) {\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);\n            case 'block-scalar':\n                return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);\n        }\n    }\n    return null;\n}\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction createScalarToken(value, context) {\n    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;\n    const source = stringifyString.stringifyString({ type, value }, {\n        implicitKey,\n        indent: indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    const end = context.end ?? [\n        { type: 'newline', offset: -1, indent, source: '\\n' }\n    ];\n    switch (source[0]) {\n        case '|':\n        case '>': {\n            const he = source.indexOf('\\n');\n            const head = source.substring(0, he);\n            const body = source.substring(he + 1) + '\\n';\n            const props = [\n                { type: 'block-scalar-header', offset, indent, source: head }\n            ];\n            if (!addEndtoBlockProps(props, end))\n                props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n            return { type: 'block-scalar', offset, indent, props, source: body };\n        }\n        case '\"':\n            return { type: 'double-quoted-scalar', offset, indent, source, end };\n        case \"'\":\n            return { type: 'single-quoted-scalar', offset, indent, source, end };\n        default:\n            return { type: 'scalar', offset, indent, source, end };\n    }\n}\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction setScalarValue(token, value, context = {}) {\n    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;\n    let indent = 'indent' in token ? token.indent : null;\n    if (afterKey && typeof indent === 'number')\n        indent += 2;\n    if (!type)\n        switch (token.type) {\n            case 'single-quoted-scalar':\n                type = 'QUOTE_SINGLE';\n                break;\n            case 'double-quoted-scalar':\n                type = 'QUOTE_DOUBLE';\n                break;\n            case 'block-scalar': {\n                const header = token.props[0];\n                if (header.type !== 'block-scalar-header')\n                    throw new Error('Invalid block scalar header');\n                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n                break;\n            }\n            default:\n                type = 'PLAIN';\n        }\n    const source = stringifyString.stringifyString({ type, value }, {\n        implicitKey: implicitKey || indent === null,\n        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    switch (source[0]) {\n        case '|':\n        case '>':\n            setBlockScalarValue(token, source);\n            break;\n        case '\"':\n            setFlowScalarValue(token, source, 'double-quoted-scalar');\n            break;\n        case \"'\":\n            setFlowScalarValue(token, source, 'single-quoted-scalar');\n            break;\n        default:\n            setFlowScalarValue(token, source, 'scalar');\n    }\n}\nfunction setBlockScalarValue(token, source) {\n    const he = source.indexOf('\\n');\n    const head = source.substring(0, he);\n    const body = source.substring(he + 1) + '\\n';\n    if (token.type === 'block-scalar') {\n        const header = token.props[0];\n        if (header.type !== 'block-scalar-header')\n            throw new Error('Invalid block scalar header');\n        header.source = head;\n        token.source = body;\n    }\n    else {\n        const { offset } = token;\n        const indent = 'indent' in token ? token.indent : -1;\n        const props = [\n            { type: 'block-scalar-header', offset, indent, source: head }\n        ];\n        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))\n            props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n        for (const key of Object.keys(token))\n            if (key !== 'type' && key !== 'offset')\n                delete token[key];\n        Object.assign(token, { type: 'block-scalar', indent, props, source: body });\n    }\n}\n/** @returns `true` if last token is a newline */\nfunction addEndtoBlockProps(props, end) {\n    if (end)\n        for (const st of end)\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                    props.push(st);\n                    break;\n                case 'newline':\n                    props.push(st);\n                    return true;\n            }\n    return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n    switch (token.type) {\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            token.type = type;\n            token.source = source;\n            break;\n        case 'block-scalar': {\n            const end = token.props.slice(1);\n            let oa = source.length;\n            if (token.props[0].type === 'block-scalar-header')\n                oa -= token.props[0].source.length;\n            for (const tok of end)\n                tok.offset += oa;\n            delete token.props;\n            Object.assign(token, { type, source, end });\n            break;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            const offset = token.offset + source.length;\n            const nl = { type: 'newline', offset, indent: token.indent, source: '\\n' };\n            delete token.items;\n            Object.assign(token, { type, source, end: [nl] });\n            break;\n        }\n        default: {\n            const indent = 'indent' in token ? token.indent : -1;\n            const end = 'end' in token && Array.isArray(token.end)\n                ? token.end.filter(st => st.type === 'space' ||\n                    st.type === 'comment' ||\n                    st.type === 'newline')\n                : [];\n            for (const key of Object.keys(token))\n                if (key !== 'type' && key !== 'offset')\n                    delete token[key];\n            Object.assign(token, { type, indent, source, end });\n        }\n    }\n}\n\nexports.createScalarToken = createScalarToken;\nexports.resolveAsScalar = resolveAsScalar;\nexports.setScalarValue = setScalarValue;\n","'use strict';\n\n/**\n * Stringify a CST document, token, or collection item\n *\n * Fair warning: This applies no validation whatsoever, and\n * simply concatenates the sources in their logical order.\n */\nconst stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);\nfunction stringifyToken(token) {\n    switch (token.type) {\n        case 'block-scalar': {\n            let res = '';\n            for (const tok of token.props)\n                res += stringifyToken(tok);\n            return res + token.source;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            let res = '';\n            for (const item of token.items)\n                res += stringifyItem(item);\n            return res;\n        }\n        case 'flow-collection': {\n            let res = token.start.source;\n            for (const item of token.items)\n                res += stringifyItem(item);\n            for (const st of token.end)\n                res += st.source;\n            return res;\n        }\n        case 'document': {\n            let res = stringifyItem(token);\n            if (token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n        default: {\n            let res = token.source;\n            if ('end' in token && token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n    }\n}\nfunction stringifyItem({ start, key, sep, value }) {\n    let res = '';\n    for (const st of start)\n        res += st.source;\n    if (key)\n        res += stringifyToken(key);\n    if (sep)\n        for (const st of sep)\n            res += st.source;\n    if (value)\n        res += stringifyToken(value);\n    return res;\n}\n\nexports.stringify = stringify;\n","'use strict';\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove item');\n/**\n * Apply a visitor to a CST document or item.\n *\n * Walks through the tree (depth-first) starting from the root, calling a\n * `visitor` function with two arguments when entering each item:\n *   - `item`: The current item, which included the following members:\n *     - `start: SourceToken[]` – Source tokens before the key or value,\n *       possibly including its anchor or tag.\n *     - `key?: Token | null` – Set for pair values. May then be `null`, if\n *       the key before the `:` separator is empty.\n *     - `sep?: SourceToken[]` – Source tokens between the key and the value,\n *       which should include the `:` map value indicator if `value` is set.\n *     - `value?: Token` – The value of a sequence item, or of a map pair.\n *   - `path`: The steps from the root to the current node, as an array of\n *     `['key' | 'value', number]` tuples.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this token, continue with\n *      next sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current item, then continue with the next one\n *   - `number`: Set the index of the next step. This is useful especially if\n *     the index of the current token has changed.\n *   - `function`: Define the next visitor for this item. After the original\n *     visitor is called on item entry, next visitors are called after handling\n *     a non-empty `key` and when exiting the item.\n */\nfunction visit(cst, visitor) {\n    if ('type' in cst && cst.type === 'document')\n        cst = { start: cst.start, value: cst.value };\n    _visit(Object.freeze([]), cst, visitor);\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current item */\nvisit.SKIP = SKIP;\n/** Remove the current item */\nvisit.REMOVE = REMOVE;\n/** Find the item at `path` from `cst` as the root */\nvisit.itemAtPath = (cst, path) => {\n    let item = cst;\n    for (const [field, index] of path) {\n        const tok = item?.[field];\n        if (tok && 'items' in tok) {\n            item = tok.items[index];\n        }\n        else\n            return undefined;\n    }\n    return item;\n};\n/**\n * Get the immediate parent collection of the item at `path` from `cst` as the root.\n *\n * Throws an error if the collection is not found, which should never happen if the item itself exists.\n */\nvisit.parentCollection = (cst, path) => {\n    const parent = visit.itemAtPath(cst, path.slice(0, -1));\n    const field = path[path.length - 1][0];\n    const coll = parent?.[field];\n    if (coll && 'items' in coll)\n        return coll;\n    throw new Error('Parent collection not found');\n};\nfunction _visit(path, item, visitor) {\n    let ctrl = visitor(item, path);\n    if (typeof ctrl === 'symbol')\n        return ctrl;\n    for (const field of ['key', 'value']) {\n        const token = item[field];\n        if (token && 'items' in token) {\n            for (let i = 0; i < token.items.length; ++i) {\n                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    token.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n            if (typeof ctrl === 'function' && field === 'key')\n                ctrl = ctrl(item, path);\n        }\n    }\n    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;\n}\n\nexports.visit = visit;\n","'use strict';\n\nvar cstScalar = require('./cst-scalar.js');\nvar cstStringify = require('./cst-stringify.js');\nvar cstVisit = require('./cst-visit.js');\n\n/** The byte order mark */\nconst BOM = '\\u{FEFF}';\n/** Start of doc-mode */\nconst DOCUMENT = '\\x02'; // C0: Start of Text\n/** Unexpected end of flow-mode */\nconst FLOW_END = '\\x18'; // C0: Cancel\n/** Next token is a scalar value */\nconst SCALAR = '\\x1f'; // C0: Unit Separator\n/** @returns `true` if `token` is a flow or block collection */\nconst isCollection = (token) => !!token && 'items' in token;\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\nconst isScalar = (token) => !!token &&\n    (token.type === 'scalar' ||\n        token.type === 'single-quoted-scalar' ||\n        token.type === 'double-quoted-scalar' ||\n        token.type === 'block-scalar');\n/* istanbul ignore next */\n/** Get a printable representation of a lexer token */\nfunction prettyToken(token) {\n    switch (token) {\n        case BOM:\n            return '<BOM>';\n        case DOCUMENT:\n            return '<DOC>';\n        case FLOW_END:\n            return '<FLOW_END>';\n        case SCALAR:\n            return '<SCALAR>';\n        default:\n            return JSON.stringify(token);\n    }\n}\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nfunction tokenType(source) {\n    switch (source) {\n        case BOM:\n            return 'byte-order-mark';\n        case DOCUMENT:\n            return 'doc-mode';\n        case FLOW_END:\n            return 'flow-error-end';\n        case SCALAR:\n            return 'scalar';\n        case '---':\n            return 'doc-start';\n        case '...':\n            return 'doc-end';\n        case '':\n        case '\\n':\n        case '\\r\\n':\n            return 'newline';\n        case '-':\n            return 'seq-item-ind';\n        case '?':\n            return 'explicit-key-ind';\n        case ':':\n            return 'map-value-ind';\n        case '{':\n            return 'flow-map-start';\n        case '}':\n            return 'flow-map-end';\n        case '[':\n            return 'flow-seq-start';\n        case ']':\n            return 'flow-seq-end';\n        case ',':\n            return 'comma';\n    }\n    switch (source[0]) {\n        case ' ':\n        case '\\t':\n            return 'space';\n        case '#':\n            return 'comment';\n        case '%':\n            return 'directive-line';\n        case '*':\n            return 'alias';\n        case '&':\n            return 'anchor';\n        case '!':\n            return 'tag';\n        case \"'\":\n            return 'single-quoted-scalar';\n        case '\"':\n            return 'double-quoted-scalar';\n        case '|':\n        case '>':\n            return 'block-scalar-header';\n    }\n    return null;\n}\n\nexports.createScalarToken = cstScalar.createScalarToken;\nexports.resolveAsScalar = cstScalar.resolveAsScalar;\nexports.setScalarValue = cstScalar.setScalarValue;\nexports.stringify = cstStringify.stringify;\nexports.visit = cstVisit.visit;\nexports.BOM = BOM;\nexports.DOCUMENT = DOCUMENT;\nexports.FLOW_END = FLOW_END;\nexports.SCALAR = SCALAR;\nexports.isCollection = isCollection;\nexports.isScalar = isScalar;\nexports.prettyToken = prettyToken;\nexports.tokenType = tokenType;\n","'use strict';\n\nvar cst = require('./cst.js');\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n    switch (ch) {\n        case undefined:\n        case ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n    }\n}\nconst hexDigits = new Set('0123456789ABCDEFabcdef');\nconst tagChars = new Set(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\");\nconst flowIndicatorChars = new Set(',[]{}');\nconst invalidAnchorChars = new Set(' ,[]{}\\n\\r\\t');\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n    constructor() {\n        /**\n         * Flag indicating whether the end of the current buffer marks the end of\n         * all input\n         */\n        this.atEnd = false;\n        /**\n         * Explicit indent set in block scalar header, as an offset from the current\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n         * explicitly set.\n         */\n        this.blockScalarIndent = -1;\n        /**\n         * Block scalars that include a + (keep) chomping indicator in their header\n         * include trailing empty lines, which are otherwise excluded from the\n         * scalar's contents.\n         */\n        this.blockScalarKeep = false;\n        /** Current input */\n        this.buffer = '';\n        /**\n         * Flag noting whether the map value indicator : can immediately follow this\n         * node within a flow context.\n         */\n        this.flowKey = false;\n        /** Count of surrounding flow collection levels. */\n        this.flowLevel = 0;\n        /**\n         * Minimum level of indentation required for next lines to be parsed as a\n         * part of the current scalar value.\n         */\n        this.indentNext = 0;\n        /** Indentation level of the current line. */\n        this.indentValue = 0;\n        /** Position of the next \\n character. */\n        this.lineEndPos = null;\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\n        this.next = null;\n        /** A pointer to `buffer`; the current position of the lexer. */\n        this.pos = 0;\n    }\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    *lex(source, incomplete = false) {\n        if (source) {\n            if (typeof source !== 'string')\n                throw TypeError('source is not a string');\n            this.buffer = this.buffer ? this.buffer + source : source;\n            this.lineEndPos = null;\n        }\n        this.atEnd = !incomplete;\n        let next = this.next ?? 'stream';\n        while (next && (incomplete || this.hasChars(1)))\n            next = yield* this.parseNext(next);\n    }\n    atLineEnd() {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (ch === ' ' || ch === '\\t')\n            ch = this.buffer[++i];\n        if (!ch || ch === '#' || ch === '\\n')\n            return true;\n        if (ch === '\\r')\n            return this.buffer[i + 1] === '\\n';\n        return false;\n    }\n    charAt(n) {\n        return this.buffer[this.pos + n];\n    }\n    continueScalar(offset) {\n        let ch = this.buffer[offset];\n        if (this.indentNext > 0) {\n            let indent = 0;\n            while (ch === ' ')\n                ch = this.buffer[++indent + offset];\n            if (ch === '\\r') {\n                const next = this.buffer[indent + offset + 1];\n                if (next === '\\n' || (!next && !this.atEnd))\n                    return offset + indent + 1;\n            }\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\n                ? offset + indent\n                : -1;\n        }\n        if (ch === '-' || ch === '.') {\n            const dt = this.buffer.substr(offset, 3);\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\n                return -1;\n        }\n        return offset;\n    }\n    getLine() {\n        let end = this.lineEndPos;\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\n            end = this.buffer.indexOf('\\n', this.pos);\n            this.lineEndPos = end;\n        }\n        if (end === -1)\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\n        if (this.buffer[end - 1] === '\\r')\n            end -= 1;\n        return this.buffer.substring(this.pos, end);\n    }\n    hasChars(n) {\n        return this.pos + n <= this.buffer.length;\n    }\n    setNext(state) {\n        this.buffer = this.buffer.substring(this.pos);\n        this.pos = 0;\n        this.lineEndPos = null;\n        this.next = state;\n        return null;\n    }\n    peek(n) {\n        return this.buffer.substr(this.pos, n);\n    }\n    *parseNext(next) {\n        switch (next) {\n            case 'stream':\n                return yield* this.parseStream();\n            case 'line-start':\n                return yield* this.parseLineStart();\n            case 'block-start':\n                return yield* this.parseBlockStart();\n            case 'doc':\n                return yield* this.parseDocument();\n            case 'flow':\n                return yield* this.parseFlowCollection();\n            case 'quoted-scalar':\n                return yield* this.parseQuotedScalar();\n            case 'block-scalar':\n                return yield* this.parseBlockScalar();\n            case 'plain-scalar':\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseStream() {\n        let line = this.getLine();\n        if (line === null)\n            return this.setNext('stream');\n        if (line[0] === cst.BOM) {\n            yield* this.pushCount(1);\n            line = line.substring(1);\n        }\n        if (line[0] === '%') {\n            let dirEnd = line.length;\n            let cs = line.indexOf('#');\n            while (cs !== -1) {\n                const ch = line[cs - 1];\n                if (ch === ' ' || ch === '\\t') {\n                    dirEnd = cs - 1;\n                    break;\n                }\n                else {\n                    cs = line.indexOf('#', cs + 1);\n                }\n            }\n            while (true) {\n                const ch = line[dirEnd - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd -= 1;\n                else\n                    break;\n            }\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n            yield* this.pushCount(line.length - n); // possible comment\n            this.pushNewline();\n            return 'stream';\n        }\n        if (this.atLineEnd()) {\n            const sp = yield* this.pushSpaces(true);\n            yield* this.pushCount(line.length - sp);\n            yield* this.pushNewline();\n            return 'stream';\n        }\n        yield cst.DOCUMENT;\n        return yield* this.parseLineStart();\n    }\n    *parseLineStart() {\n        const ch = this.charAt(0);\n        if (!ch && !this.atEnd)\n            return this.setNext('line-start');\n        if (ch === '-' || ch === '.') {\n            if (!this.atEnd && !this.hasChars(4))\n                return this.setNext('line-start');\n            const s = this.peek(3);\n            if ((s === '---' || s === '...') && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                this.indentValue = 0;\n                this.indentNext = 0;\n                return s === '---' ? 'doc' : 'stream';\n            }\n        }\n        this.indentValue = yield* this.pushSpaces(false);\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\n            this.indentNext = this.indentValue;\n        return yield* this.parseBlockStart();\n    }\n    *parseBlockStart() {\n        const [ch0, ch1] = this.peek(2);\n        if (!ch1 && !this.atEnd)\n            return this.setNext('block-start');\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n            this.indentNext = this.indentValue + 1;\n            this.indentValue += n;\n            return yield* this.parseBlockStart();\n        }\n        return 'doc';\n    }\n    *parseDocument() {\n        yield* this.pushSpaces(true);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('doc');\n        let n = yield* this.pushIndicators();\n        switch (line[n]) {\n            case '#':\n                yield* this.pushCount(line.length - n);\n            // fallthrough\n            case undefined:\n                yield* this.pushNewline();\n                return yield* this.parseLineStart();\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel = 1;\n                return 'flow';\n            case '}':\n            case ']':\n                // this is an error\n                yield* this.pushCount(1);\n                return 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'doc';\n            case '\"':\n            case \"'\":\n                return yield* this.parseQuotedScalar();\n            case '|':\n            case '>':\n                n += yield* this.parseBlockScalarHeader();\n                n += yield* this.pushSpaces(true);\n                yield* this.pushCount(line.length - n);\n                yield* this.pushNewline();\n                return yield* this.parseBlockScalar();\n            default:\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseFlowCollection() {\n        let nl, sp;\n        let indent = -1;\n        do {\n            nl = yield* this.pushNewline();\n            if (nl > 0) {\n                sp = yield* this.pushSpaces(false);\n                this.indentValue = indent = sp;\n            }\n            else {\n                sp = 0;\n            }\n            sp += yield* this.pushSpaces(true);\n        } while (nl + sp > 0);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('flow');\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\n            (indent === 0 &&\n                (line.startsWith('---') || line.startsWith('...')) &&\n                isEmpty(line[3]))) {\n            // Allowing for the terminal ] or } at the same (rather than greater)\n            // indent level as the initial [ or { is technically invalid, but\n            // failing here would be surprising to users.\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\n                this.flowLevel === 1 &&\n                (line[0] === ']' || line[0] === '}');\n            if (!atFlowEndMarker) {\n                // this is an error\n                this.flowLevel = 0;\n                yield cst.FLOW_END;\n                return yield* this.parseLineStart();\n            }\n        }\n        let n = 0;\n        while (line[n] === ',') {\n            n += yield* this.pushCount(1);\n            n += yield* this.pushSpaces(true);\n            this.flowKey = false;\n        }\n        n += yield* this.pushIndicators();\n        switch (line[n]) {\n            case undefined:\n                return 'flow';\n            case '#':\n                yield* this.pushCount(line.length - n);\n                return 'flow';\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel += 1;\n                return 'flow';\n            case '}':\n            case ']':\n                yield* this.pushCount(1);\n                this.flowKey = true;\n                this.flowLevel -= 1;\n                return this.flowLevel ? 'flow' : 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'flow';\n            case '\"':\n            case \"'\":\n                this.flowKey = true;\n                return yield* this.parseQuotedScalar();\n            case ':': {\n                const next = this.charAt(1);\n                if (this.flowKey || isEmpty(next) || next === ',') {\n                    this.flowKey = false;\n                    yield* this.pushCount(1);\n                    yield* this.pushSpaces(true);\n                    return 'flow';\n                }\n            }\n            // fallthrough\n            default:\n                this.flowKey = false;\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseQuotedScalar() {\n        const quote = this.charAt(0);\n        let end = this.buffer.indexOf(quote, this.pos + 1);\n        if (quote === \"'\") {\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\n                end = this.buffer.indexOf(\"'\", end + 2);\n        }\n        else {\n            // double-quote\n            while (end !== -1) {\n                let n = 0;\n                while (this.buffer[end - 1 - n] === '\\\\')\n                    n += 1;\n                if (n % 2 === 0)\n                    break;\n                end = this.buffer.indexOf('\"', end + 1);\n            }\n        }\n        // Only looking for newlines within the quotes\n        const qb = this.buffer.substring(0, end);\n        let nl = qb.indexOf('\\n', this.pos);\n        if (nl !== -1) {\n            while (nl !== -1) {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = qb.indexOf('\\n', cs);\n            }\n            if (nl !== -1) {\n                // this is an error caused by an unexpected unindent\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n            }\n        }\n        if (end === -1) {\n            if (!this.atEnd)\n                return this.setNext('quoted-scalar');\n            end = this.buffer.length;\n        }\n        yield* this.pushToIndex(end + 1, false);\n        return this.flowLevel ? 'flow' : 'doc';\n    }\n    *parseBlockScalarHeader() {\n        this.blockScalarIndent = -1;\n        this.blockScalarKeep = false;\n        let i = this.pos;\n        while (true) {\n            const ch = this.buffer[++i];\n            if (ch === '+')\n                this.blockScalarKeep = true;\n            else if (ch > '0' && ch <= '9')\n                this.blockScalarIndent = Number(ch) - 1;\n            else if (ch !== '-')\n                break;\n        }\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n    }\n    *parseBlockScalar() {\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\n        let indent = 0;\n        let ch;\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\n            switch (ch) {\n                case ' ':\n                    indent += 1;\n                    break;\n                case '\\n':\n                    nl = i;\n                    indent = 0;\n                    break;\n                case '\\r': {\n                    const next = this.buffer[i + 1];\n                    if (!next && !this.atEnd)\n                        return this.setNext('block-scalar');\n                    if (next === '\\n')\n                        break;\n                } // fallthrough\n                default:\n                    break loop;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('block-scalar');\n        if (indent >= this.indentNext) {\n            if (this.blockScalarIndent === -1)\n                this.indentNext = indent;\n            else {\n                this.indentNext =\n                    this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);\n            }\n            do {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = this.buffer.indexOf('\\n', cs);\n            } while (nl !== -1);\n            if (nl === -1) {\n                if (!this.atEnd)\n                    return this.setNext('block-scalar');\n                nl = this.buffer.length;\n            }\n        }\n        // Trailing insufficiently indented tabs are invalid.\n        // To catch that during parsing, we include them in the block scalar value.\n        let i = nl + 1;\n        ch = this.buffer[i];\n        while (ch === ' ')\n            ch = this.buffer[++i];\n        if (ch === '\\t') {\n            while (ch === '\\t' || ch === ' ' || ch === '\\r' || ch === '\\n')\n                ch = this.buffer[++i];\n            nl = i - 1;\n        }\n        else if (!this.blockScalarKeep) {\n            do {\n                let i = nl - 1;\n                let ch = this.buffer[i];\n                if (ch === '\\r')\n                    ch = this.buffer[--i];\n                const lastChar = i; // Drop the line if last char not more indented\n                while (ch === ' ')\n                    ch = this.buffer[--i];\n                if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar)\n                    nl = i;\n                else\n                    break;\n            } while (true);\n        }\n        yield cst.SCALAR;\n        yield* this.pushToIndex(nl + 1, true);\n        return yield* this.parseLineStart();\n    }\n    *parsePlainScalar() {\n        const inFlow = this.flowLevel > 0;\n        let end = this.pos - 1;\n        let i = this.pos - 1;\n        let ch;\n        while ((ch = this.buffer[++i])) {\n            if (ch === ':') {\n                const next = this.buffer[i + 1];\n                if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next)))\n                    break;\n                end = i;\n            }\n            else if (isEmpty(ch)) {\n                let next = this.buffer[i + 1];\n                if (ch === '\\r') {\n                    if (next === '\\n') {\n                        i += 1;\n                        ch = '\\n';\n                        next = this.buffer[i + 1];\n                    }\n                    else\n                        end = i;\n                }\n                if (next === '#' || (inFlow && flowIndicatorChars.has(next)))\n                    break;\n                if (ch === '\\n') {\n                    const cs = this.continueScalar(i + 1);\n                    if (cs === -1)\n                        break;\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n                }\n            }\n            else {\n                if (inFlow && flowIndicatorChars.has(ch))\n                    break;\n                end = i;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('plain-scalar');\n        yield cst.SCALAR;\n        yield* this.pushToIndex(end + 1, true);\n        return inFlow ? 'flow' : 'doc';\n    }\n    *pushCount(n) {\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos += n;\n            return n;\n        }\n        return 0;\n    }\n    *pushToIndex(i, allowEmpty) {\n        const s = this.buffer.slice(this.pos, i);\n        if (s) {\n            yield s;\n            this.pos += s.length;\n            return s.length;\n        }\n        else if (allowEmpty)\n            yield '';\n        return 0;\n    }\n    *pushIndicators() {\n        switch (this.charAt(0)) {\n            case '!':\n                return ((yield* this.pushTag()) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '&':\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '-': // this is an error\n            case '?': // this is an error outside flow collections\n            case ':': {\n                const inFlow = this.flowLevel > 0;\n                const ch1 = this.charAt(1);\n                if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {\n                    if (!inFlow)\n                        this.indentNext = this.indentValue + 1;\n                    else if (this.flowKey)\n                        this.flowKey = false;\n                    return ((yield* this.pushCount(1)) +\n                        (yield* this.pushSpaces(true)) +\n                        (yield* this.pushIndicators()));\n                }\n            }\n        }\n        return 0;\n    }\n    *pushTag() {\n        if (this.charAt(1) === '<') {\n            let i = this.pos + 2;\n            let ch = this.buffer[i];\n            while (!isEmpty(ch) && ch !== '>')\n                ch = this.buffer[++i];\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n        }\n        else {\n            let i = this.pos + 1;\n            let ch = this.buffer[i];\n            while (ch) {\n                if (tagChars.has(ch))\n                    ch = this.buffer[++i];\n                else if (ch === '%' &&\n                    hexDigits.has(this.buffer[i + 1]) &&\n                    hexDigits.has(this.buffer[i + 2])) {\n                    ch = this.buffer[(i += 3)];\n                }\n                else\n                    break;\n            }\n            return yield* this.pushToIndex(i, false);\n        }\n    }\n    *pushNewline() {\n        const ch = this.buffer[this.pos];\n        if (ch === '\\n')\n            return yield* this.pushCount(1);\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\n            return yield* this.pushCount(2);\n        else\n            return 0;\n    }\n    *pushSpaces(allowTabs) {\n        let i = this.pos - 1;\n        let ch;\n        do {\n            ch = this.buffer[++i];\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\n        const n = i - this.pos;\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos = i;\n        }\n        return n;\n    }\n    *pushUntil(test) {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (!test(ch))\n            ch = this.buffer[++i];\n        return yield* this.pushToIndex(i, false);\n    }\n}\n\nexports.Lexer = Lexer;\n","'use strict';\n\n/**\n * Tracks newlines during parsing in order to provide an efficient API for\n * determining the one-indexed `{ line, col }` position for any offset\n * within the input.\n */\nclass LineCounter {\n    constructor() {\n        this.lineStarts = [];\n        /**\n         * Should be called in ascending order. Otherwise, call\n         * `lineCounter.lineStarts.sort()` before calling `linePos()`.\n         */\n        this.addNewLine = (offset) => this.lineStarts.push(offset);\n        /**\n         * Performs a binary search and returns the 1-indexed { line, col }\n         * position of `offset`. If `line === 0`, `addNewLine` has never been\n         * called or `offset` is before the first known newline.\n         */\n        this.linePos = (offset) => {\n            let low = 0;\n            let high = this.lineStarts.length;\n            while (low < high) {\n                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)\n                if (this.lineStarts[mid] < offset)\n                    low = mid + 1;\n                else\n                    high = mid;\n            }\n            if (this.lineStarts[low] === offset)\n                return { line: low + 1, col: 1 };\n            if (low === 0)\n                return { line: 0, col: offset };\n            const start = this.lineStarts[low - 1];\n            return { line: low, col: offset - start + 1 };\n        };\n    }\n}\n\nexports.LineCounter = LineCounter;\n","'use strict';\n\nvar node_process = require('node:process');\nvar cst = require('./cst.js');\nvar lexer = require('./lexer.js');\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new lexer.Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (node_process.env.LOG_TOKENS)\n            console.log('|', cst.prettyToken(source));\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = cst.tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !it.explicitKey;\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atMapIndent = !this.onKeyLine && this.indent === map.indent;\n            const atNextItem = atMapIndent &&\n                (it.sep || it.explicitKey) &&\n                this.type !== 'seq-item-ind';\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !it.explicitKey) {\n                        it.start.push(this.sourceToken);\n                        it.explicitKey = true;\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start, explicitKey: true });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken], explicitKey: true }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (it.explicitKey) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key;\n                            // @ts-expect-error type guard is wrong here\n                            delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (bv.type === 'block-seq') {\n                            if (!it.explicitKey &&\n                                it.sep &&\n                                !includesToken(it.sep, 'newline')) {\n                                yield* this.pop({\n                                    type: 'error',\n                                    offset: this.offset,\n                                    message: 'Unexpected block-seq-ind on same line with key',\n                                    source: this.source\n                                });\n                                return;\n                            }\n                        }\n                        else if (atMapIndent) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, explicitKey: true }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexports.Parser = Parser;\n","'use strict';\n\nvar composer = require('./compose/composer.js');\nvar Document = require('./doc/Document.js');\nvar errors = require('./errors.js');\nvar log = require('./log.js');\nvar identity = require('./nodes/identity.js');\nvar lineCounter = require('./parse/line-counter.js');\nvar parser = require('./parse/parser.js');\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter$1 = options.lineCounter || (prettyErrors && new lineCounter.LineCounter()) || null;\n    return { lineCounter: lineCounter$1, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser$1 = new parser.Parser(lineCounter?.addNewLine);\n    const composer$1 = new composer.Composer(options);\n    const docs = Array.from(composer$1.compose(parser$1.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(errors.prettifyError(source, lineCounter));\n            doc.warnings.forEach(errors.prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer$1.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser$1 = new parser.Parser(lineCounter?.addNewLine);\n    const composer$1 = new composer.Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(errors.prettifyError(source, lineCounter));\n        doc.warnings.forEach(errors.prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    if (identity.isDocument(value) && !_replacer)\n        return value.toString(options);\n    return new Document.Document(value, _replacer, options).toString(options);\n}\n\nexports.parse = parse;\nexports.parseAllDocuments = parseAllDocuments;\nexports.parseDocument = parseDocument;\nexports.stringify = stringify;\n","'use strict';\n\nvar composer = require('./compose/composer.js');\nvar Document = require('./doc/Document.js');\nvar Schema = require('./schema/Schema.js');\nvar errors = require('./errors.js');\nvar Alias = require('./nodes/Alias.js');\nvar identity = require('./nodes/identity.js');\nvar Pair = require('./nodes/Pair.js');\nvar Scalar = require('./nodes/Scalar.js');\nvar YAMLMap = require('./nodes/YAMLMap.js');\nvar YAMLSeq = require('./nodes/YAMLSeq.js');\nvar cst = require('./parse/cst.js');\nvar lexer = require('./parse/lexer.js');\nvar lineCounter = require('./parse/line-counter.js');\nvar parser = require('./parse/parser.js');\nvar publicApi = require('./public-api.js');\nvar visit = require('./visit.js');\n\n\n\nexports.Composer = composer.Composer;\nexports.Document = Document.Document;\nexports.Schema = Schema.Schema;\nexports.YAMLError = errors.YAMLError;\nexports.YAMLParseError = errors.YAMLParseError;\nexports.YAMLWarning = errors.YAMLWarning;\nexports.Alias = Alias.Alias;\nexports.isAlias = identity.isAlias;\nexports.isCollection = identity.isCollection;\nexports.isDocument = identity.isDocument;\nexports.isMap = identity.isMap;\nexports.isNode = identity.isNode;\nexports.isPair = identity.isPair;\nexports.isScalar = identity.isScalar;\nexports.isSeq = identity.isSeq;\nexports.Pair = Pair.Pair;\nexports.Scalar = Scalar.Scalar;\nexports.YAMLMap = YAMLMap.YAMLMap;\nexports.YAMLSeq = YAMLSeq.YAMLSeq;\nexports.CST = cst;\nexports.Lexer = lexer.Lexer;\nexports.LineCounter = lineCounter.LineCounter;\nexports.Parser = parser.Parser;\nexports.parse = publicApi.parse;\nexports.parseAllDocuments = publicApi.parseAllDocuments;\nexports.parseDocument = publicApi.parseDocument;\nexports.stringify = publicApi.stringify;\nexports.visit = visit.visit;\nexports.visitAsync = visit.visitAsync;\n","'use strict'\n\n/**\n * @typedef SocketYmlV1\n * @property {string[]} [ignore]\n * @property {{ [issueName: string]: boolean }} [issues]\n * @property {boolean} [beta] unused v1 option\n * @property {boolean} [enabled] enable/disable the Socket.dev GitHub app entirely\n * @property {boolean} [projectReportsEnabled] enable/disable Github app project report checks\n * @property {boolean} [pullRequestAlertsEnabled] enable/disable GitHub app pull request alert checks\n */\n\n/** @type {import('ajv').JSONSchemaType<SocketYmlV1>} */\nconst socketYmlSchemaV1 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  properties: {\n    ignore: {\n      type: 'array',\n      items: { type: 'string' },\n      nullable: true,\n    },\n    issues: {\n      type: 'object',\n      nullable: true,\n      required: [],\n      additionalProperties: { type: 'boolean' },\n    },\n    beta: { type: 'boolean', nullable: true, default: true },\n    enabled: { type: 'boolean', nullable: true, default: true },\n    projectReportsEnabled: { type: 'boolean', nullable: true, default: true },\n    pullRequestAlertsEnabled: { type: 'boolean', nullable: true, default: true },\n  },\n  minProperties: 1,\n  additionalProperties: false,\n}\n\nmodule.exports = {\n  socketYmlSchemaV1\n}\n","'use strict'\n\nconst { readFile } = require('node:fs/promises')\n\nconst { default: Ajv } = require('ajv')\nconst { ErrorWithCause } = require('pony-cause')\nconst { parse: yamlParse } = require('yaml')\n\nconst { socketYmlSchemaV1 } = require('./lib/v1')\n\n/**\n * @typedef SocketYmlGitHub\n * @property {boolean} [enabled] enable/disable the Socket.dev GitHub app entirely\n * @property {string[]} [ignoreUsers] list of GitHub usernames to ignore when creating reports\n * @property {boolean} [projectReportsEnabled] enable/disable Github app project report checks\n * @property {boolean} [pullRequestAlertsEnabled] enable/disable GitHub app pull request alert checks\n * @property {boolean} [dependencyOverviewEnabled] enable/disable Pull request comments with details about changed dependencies\n * @property {boolean} [authenticatedProjectReports] enable/disable authenticated project report URLs\n */\n\n/**\n * @typedef SocketYml\n * @property {2} version\n * @property {string[]} projectIgnorePaths\n * @property {{ [issueName: string]: boolean }} issueRules\n * @property {SocketYmlGitHub} githubApp\n */\n\n/** @type {import('ajv').JSONSchemaType<SocketYml>} */\nconst socketYmlSchema = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  properties: {\n    version: { type: 'integer' },\n    projectIgnorePaths: {\n      type: 'array',\n      items: { type: 'string' },\n      default: []\n    },\n    issueRules: {\n      type: 'object',\n      required: [],\n      additionalProperties: { type: 'boolean' },\n      default: {}\n    },\n    githubApp: {\n      type: 'object',\n      properties: {\n        enabled: { type: 'boolean', nullable: true },\n        ignoreUsers: {\n          type: 'array',\n          items: { type: 'string' },\n          nullable: true\n        },\n        projectReportsEnabled: { type: 'boolean', nullable: true },\n        pullRequestAlertsEnabled: { type: 'boolean', nullable: true },\n        dependencyOverviewEnabled: { type: 'boolean', nullable: true },\n        authenticatedProjectReports: { type: 'boolean', nullable: true }\n      },\n      required: [],\n      additionalProperties: false,\n      default: {}\n    },\n  },\n  required: ['version'],\n  additionalProperties: false,\n}\n\nconst ajvOptions = /** @type {const} */ ({\n  allErrors: true,\n  coerceTypes: 'array',\n  logger: false,\n  useDefaults: true\n})\n\nconst ajv = new Ajv({\n  ...ajvOptions,\n  removeAdditional: 'failing',\n})\n\nconst validate = ajv.compile(socketYmlSchema)\n\n// We want to be strict and fail rather than removeAdditional when we parse a possible v1 config – only fallback to it when it actually matches well\nconst ajvV1 = new Ajv({\n  ...ajvOptions\n})\n\nconst validateV1 = ajvV1.compile(socketYmlSchemaV1)\n\n/**\n * @param {string} filePath\n * @returns {Promise<SocketYml|undefined>}\n * @throws {SocketValidationError}\n */\nasync function readSocketConfig (filePath) {\n  /** @type {string} */\n  let fileContent\n\n  try {\n    fileContent = await readFile(filePath, 'utf8')\n  } catch (err) {\n    if (isErrnoException(err) && err.code === 'ENOENT') {\n      return\n    }\n    throw new ErrorWithCause('Error when reading socket.yml config file', { cause: err })\n  }\n\n  return parseSocketConfig(fileContent)\n}\n\n/**\n * @param {string} fileContent\n * @returns {SocketYml}\n * @throws {SocketValidationError}\n */\nfunction parseSocketConfig (fileContent) {\n  /** @type {unknown} */\n  let parsedContent\n\n  try {\n    parsedContent = yamlParse(fileContent)\n  } catch (err) {\n    throw new ErrorWithCause('Error when parsing socket.yml config', { cause: err })\n  }\n\n  if (parsedContent && typeof parsedContent === 'object' && !('version' in parsedContent)) {\n    const parsedV1 = parseV1SocketConfig(parsedContent)\n    if (parsedV1) {\n      return parsedV1\n    }\n  }\n\n  if (!validate(parsedContent)) {\n    throw new SocketValidationError(\n      'Invalid config definition',\n      validate.errors || [],\n      parsedContent\n    )\n  }\n\n  return parsedContent\n}\n\n/**\n * @param {unknown} value\n * @returns {value is NodeJS.ErrnoException}\n */\nfunction isErrnoException (value) {\n  if (!(value instanceof Error)) {\n    return false\n  }\n\n  const errnoException = /** @type NodeJS.ErrnoException} */ (value)\n\n  return errnoException.code !== undefined\n}\n\nclass SocketValidationError extends Error {\n  /**\n   * @param {string} message\n   * @param {import('ajv').ErrorObject[]} validationErrors\n   * @param {unknown} parsedContent\n   */\n  constructor (message, validationErrors, parsedContent) {\n    super(message)\n\n    /** @type {unknown} */\n    this.data = parsedContent\n\n    /** @type {import('ajv').JSONSchemaType<SocketYml>} */\n    this.schema = socketYmlSchema\n\n    /** @type {import('ajv').ErrorObject[]} */\n    this.validationErrors = validationErrors\n  }\n}\n\n/**\n * @param {object} parsedV1Content\n * @returns {SocketYml | undefined}\n */\nfunction parseV1SocketConfig (parsedV1Content) {\n  if (!validateV1(parsedV1Content)) {\n    return\n  }\n\n  /** @type {SocketYml} */\n  const v2 = {\n    version: 2,\n    projectIgnorePaths: parsedV1Content?.ignore ?? [],\n    issueRules: parsedV1Content?.issues ?? {},\n    githubApp: {\n      ...('enabled' in parsedV1Content ? { enabled: parsedV1Content.enabled } : {}),\n      ...('pullRequestAlertsEnabled' in parsedV1Content ? { pullRequestAlertsEnabled: parsedV1Content.pullRequestAlertsEnabled } : {}),\n      ...('projectReportsEnabled' in parsedV1Content ? { projectReportsEnabled: parsedV1Content.projectReportsEnabled } : {}),\n    }\n  }\n\n  return v2\n}\n\n/** @returns {SocketYml} */\nfunction getDefaultConfig () {\n  const config = { version: 2 }\n\n  if (!validate(config)) {\n    throw new Error('Unexpectedly invalid default config')\n  }\n\n  return config\n}\n\nmodule.exports = {\n  getDefaultConfig,\n  parseSocketConfig,\n  readSocketConfig,\n  SocketValidationError,\n  socketYmlSchema,\n}\n","// A simple implementation of make-array\nfunction makeArray (subject) {\n  return Array.isArray(subject)\n    ? subject\n    : [subject]\n}\n\nconst UNDEFINED = undefined\nconst EMPTY = ''\nconst SPACE = ' '\nconst ESCAPE = '\\\\'\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/\nconst REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\\\]|^)\\\\$/\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g\n\n// Invalid:\n// - /foo,\n// - ./foo,\n// - ../foo,\n// - .\n// - ..\n// Valid:\n// - .foo\nconst REGEX_TEST_INVALID_PATH = /^\\.{0,2}\\/|^\\.{1,2}$/\n\nconst REGEX_TEST_TRAILING_SLASH = /\\/$/\n\nconst SLASH = '/'\n\n// Do not use ternary expression here, since \"istanbul ignore next\" is buggy\nlet TMP_KEY_IGNORE = 'node-ignore'\n/* istanbul ignore else */\nif (typeof Symbol !== 'undefined') {\n  TMP_KEY_IGNORE = Symbol.for('node-ignore')\n}\nconst KEY_IGNORE = TMP_KEY_IGNORE\n\nconst define = (object, key, value) => {\n  Object.defineProperty(object, key, {value})\n  return value\n}\n\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g\n\nconst RETURN_FALSE = () => false\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = range => range.replace(\n  REGEX_REGEXP_RANGE,\n  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)\n    ? match\n    // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : EMPTY\n)\n\n// See fixtures #59\nconst cleanRangeBackSlash = slashes => {\n  const {length} = slashes\n  return slashes.slice(0, length - length % 2)\n}\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nconst REPLACERS = [\n\n  [\n    // Remove BOM\n    // TODO:\n    // Other similar zero-width characters?\n    /^\\uFEFF/,\n    () => EMPTY\n  ],\n\n  // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n  [\n    // (a\\ ) -> (a )\n    // (a  ) -> (a)\n    // (a ) -> (a)\n    // (a \\ ) -> (a  )\n    /((?:\\\\\\\\)*?)(\\\\?\\s+)$/,\n    (_, m1, m2) => m1 + (\n      m2.indexOf('\\\\') === 0\n        ? SPACE\n        : EMPTY\n    )\n  ],\n\n  // Replace (\\ ) with ' '\n  // (\\ ) -> ' '\n  // (\\\\ ) -> '\\\\ '\n  // (\\\\\\ ) -> '\\\\ '\n  [\n    /(\\\\+?)\\s/g,\n    (_, m1) => {\n      const {length} = m1\n      return m1.slice(0, length - length % 2) + SPACE\n    }\n  ],\n\n  // Escape metacharacters\n  // which is written down by users but means special for regular expressions.\n\n  // > There are 12 characters with special meanings:\n  // > - the backslash \\,\n  // > - the caret ^,\n  // > - the dollar sign $,\n  // > - the period or dot .,\n  // > - the vertical bar or pipe symbol |,\n  // > - the question mark ?,\n  // > - the asterisk or star *,\n  // > - the plus sign +,\n  // > - the opening parenthesis (,\n  // > - the closing parenthesis ),\n  // > - and the opening square bracket [,\n  // > - the opening curly brace {,\n  // > These special characters are often called \"metacharacters\".\n  [\n    /[\\\\$.|*+(){^]/g,\n    match => `\\\\${match}`\n  ],\n\n  [\n    // > a question mark (?) matches a single character\n    /(?!\\\\)\\?/g,\n    () => '[^/]'\n  ],\n\n  // leading slash\n  [\n\n    // > A leading slash matches the beginning of the pathname.\n    // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n    // A leading slash matches the beginning of the pathname\n    /^\\//,\n    () => '^'\n  ],\n\n  // replace special metacharacter slash after the leading slash\n  [\n    /\\//g,\n    () => '\\\\/'\n  ],\n\n  [\n    // > A leading \"**\" followed by a slash means match in all directories.\n    // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n    // > the same as pattern \"foo\".\n    // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n    // >   under directory \"foo\".\n    // Notice that the '*'s have been replaced as '\\\\*'\n    /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n\n    // '**/foo' <-> 'foo'\n    () => '^(?:.*\\\\/)?'\n  ],\n\n  // starting\n  [\n    // there will be no leading '/'\n    //   (which has been replaced by section \"leading slash\")\n    // If starts with '**', adding a '^' to the regular expression also works\n    /^(?=[^^])/,\n    function startingReplacer () {\n      // If has a slash `/` at the beginning or middle\n      return !/\\/(?!$)/.test(this)\n        // > Prior to 2.22.1\n        // > If the pattern does not contain a slash /,\n        // >   Git treats it as a shell glob pattern\n        // Actually, if there is only a trailing slash,\n        //   git also treats it as a shell glob pattern\n\n        // After 2.22.1 (compatible but clearer)\n        // > If there is a separator at the beginning or middle (or both)\n        // > of the pattern, then the pattern is relative to the directory\n        // > level of the particular .gitignore file itself.\n        // > Otherwise the pattern may also match at any level below\n        // > the .gitignore level.\n        ? '(?:^|\\\\/)'\n\n        // > Otherwise, Git treats the pattern as a shell glob suitable for\n        // >   consumption by fnmatch(3)\n        : '^'\n    }\n  ],\n\n  // two globstars\n  [\n    // Use lookahead assertions so that we could match more than one `'/**'`\n    /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n\n    // Zero, one or several directories\n    // should not use '*', or it will be replaced by the next replacer\n\n    // Check if it is not the last `'/**'`\n    (_, index, str) => index + 6 < str.length\n\n      // case: /**/\n      // > A slash followed by two consecutive asterisks then a slash matches\n      // >   zero or more directories.\n      // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n      // '/**/'\n      ? '(?:\\\\/[^\\\\/]+)*'\n\n      // case: /**\n      // > A trailing `\"/**\"` matches everything inside.\n\n      // #21: everything inside but it should not include the current folder\n      : '\\\\/.+'\n  ],\n\n  // normal intermediate wildcards\n  [\n    // Never replace escaped '*'\n    // ignore rule '\\*' will match the path '*'\n\n    // 'abc.*/' -> go\n    // 'abc.*'  -> skip this rule,\n    //    coz trailing single wildcard will be handed by [trailing wildcard]\n    /(^|[^\\\\]+)(\\\\\\*)+(?=.+)/g,\n\n    // '*.js' matches '.js'\n    // '*.js' doesn't match 'abc'\n    (_, p1, p2) => {\n      // 1.\n      // > An asterisk \"*\" matches anything except a slash.\n      // 2.\n      // > Other consecutive asterisks are considered regular asterisks\n      // > and will match according to the previous rules.\n      const unescaped = p2.replace(/\\\\\\*/g, '[^\\\\/]*')\n      return p1 + unescaped\n    }\n  ],\n\n  [\n    // unescape, revert step 3 except for back slash\n    // For example, if a user escape a '\\\\*',\n    // after step 3, the result will be '\\\\\\\\\\\\*'\n    /\\\\\\\\\\\\(?=[$.|*+(){^])/g,\n    () => ESCAPE\n  ],\n\n  [\n    // '\\\\\\\\' -> '\\\\'\n    /\\\\\\\\/g,\n    () => ESCAPE\n  ],\n\n  [\n    // > The range notation, e.g. [a-zA-Z],\n    // > can be used to match one of the characters in a range.\n\n    // `\\` is escaped by step 3\n    /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,\n    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE\n      // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n      ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}`\n      : close === ']'\n        ? endEscape.length % 2 === 0\n          // A normal case, and it is a range notation\n          // '[bar]'\n          // '[bar\\\\\\\\]'\n          ? `[${sanitizeRange(range)}${endEscape}]`\n          // Invalid range notaton\n          // '[bar\\\\]' -> '[bar\\\\\\\\]'\n          : '[]'\n        : '[]'\n  ],\n\n  // ending\n  [\n    // 'js' will not match 'js.'\n    // 'ab' will not match 'abc'\n    /(?:[^*])$/,\n\n    // WTF!\n    // https://git-scm.com/docs/gitignore\n    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n    // which re-fixes #24, #38\n\n    // > If there is a separator at the end of the pattern then the pattern\n    // > will only match directories, otherwise the pattern can match both\n    // > files and directories.\n\n    // 'js*' will not match 'a.js'\n    // 'js/' will not match 'a.js'\n    // 'js' will match 'a.js' and 'a.js/'\n    match => /\\/$/.test(match)\n      // foo/ will not match 'foo'\n      ? `${match}$`\n      // foo matches 'foo' and 'foo/'\n      : `${match}(?=$|\\\\/$)`\n  ]\n]\n\nconst REGEX_REPLACE_TRAILING_WILDCARD = /(^|\\\\\\/)?\\\\\\*$/\nconst MODE_IGNORE = 'regex'\nconst MODE_CHECK_IGNORE = 'checkRegex'\nconst UNDERSCORE = '_'\n\nconst TRAILING_WILD_CARD_REPLACERS = {\n  [MODE_IGNORE] (_, p1) {\n    const prefix = p1\n      // '\\^':\n      // '/*' does not match EMPTY\n      // '/*' does not match everything\n\n      // '\\\\\\/':\n      // 'abc/*' does not match 'abc/'\n      ? `${p1}[^/]+`\n\n      // 'a*' matches 'a'\n      // 'a*' matches 'aa'\n      : '[^/]*'\n\n    return `${prefix}(?=$|\\\\/$)`\n  },\n\n  [MODE_CHECK_IGNORE] (_, p1) {\n    // When doing `git check-ignore`\n    const prefix = p1\n      // '\\\\\\/':\n      // 'abc/*' DOES match 'abc/' !\n      ? `${p1}[^/]*`\n\n      // 'a*' matches 'a'\n      // 'a*' matches 'aa'\n      : '[^/]*'\n\n    return `${prefix}(?=$|\\\\/$)`\n  }\n}\n\n// @param {pattern}\nconst makeRegexPrefix = pattern => REPLACERS.reduce(\n  (prev, [matcher, replacer]) =>\n    prev.replace(matcher, replacer.bind(pattern)),\n  pattern\n)\n\nconst isString = subject => typeof subject === 'string'\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = pattern => pattern\n  && isString(pattern)\n  && !REGEX_TEST_BLANK_LINE.test(pattern)\n  && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)\n\n  // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0\n\nconst splitPattern = pattern => pattern\n.split(REGEX_SPLITALL_CRLF)\n.filter(Boolean)\n\nclass IgnoreRule {\n  constructor (\n    pattern,\n    mark,\n    body,\n    ignoreCase,\n    negative,\n    prefix\n  ) {\n    this.pattern = pattern\n    this.mark = mark\n    this.negative = negative\n\n    define(this, 'body', body)\n    define(this, 'ignoreCase', ignoreCase)\n    define(this, 'regexPrefix', prefix)\n  }\n\n  get regex () {\n    const key = UNDERSCORE + MODE_IGNORE\n\n    if (this[key]) {\n      return this[key]\n    }\n\n    return this._make(MODE_IGNORE, key)\n  }\n\n  get checkRegex () {\n    const key = UNDERSCORE + MODE_CHECK_IGNORE\n\n    if (this[key]) {\n      return this[key]\n    }\n\n    return this._make(MODE_CHECK_IGNORE, key)\n  }\n\n  _make (mode, key) {\n    const str = this.regexPrefix.replace(\n      REGEX_REPLACE_TRAILING_WILDCARD,\n\n      // It does not need to bind pattern\n      TRAILING_WILD_CARD_REPLACERS[mode]\n    )\n\n    const regex = this.ignoreCase\n      ? new RegExp(str, 'i')\n      : new RegExp(str)\n\n    return define(this, key, regex)\n  }\n}\n\nconst createRule = ({\n  pattern,\n  mark\n}, ignoreCase) => {\n  let negative = false\n  let body = pattern\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (body.indexOf('!') === 0) {\n    negative = true\n    body = body.substr(1)\n  }\n\n  body = body\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')\n\n  const regexPrefix = makeRegexPrefix(body)\n\n  return new IgnoreRule(\n    pattern,\n    mark,\n    body,\n    ignoreCase,\n    negative,\n    regexPrefix\n  )\n}\n\nclass RuleManager {\n  constructor (ignoreCase) {\n    this._ignoreCase = ignoreCase\n    this._rules = []\n  }\n\n  _add (pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules._rules)\n      this._added = true\n      return\n    }\n\n    if (isString(pattern)) {\n      pattern = {\n        pattern\n      }\n    }\n\n    if (checkPattern(pattern.pattern)) {\n      const rule = createRule(pattern, this._ignoreCase)\n      this._added = true\n      this._rules.push(rule)\n    }\n  }\n\n  // @param {Array<string> | string | Ignore} pattern\n  add (pattern) {\n    this._added = false\n\n    makeArray(\n      isString(pattern)\n        ? splitPattern(pattern)\n        : pattern\n    ).forEach(this._add, this)\n\n    return this._added\n  }\n\n  // Test one single path without recursively checking parent directories\n  //\n  // - checkUnignored `boolean` whether should check if the path is unignored,\n  //   setting `checkUnignored` to `false` could reduce additional\n  //   path matching.\n  // - check `string` either `MODE_IGNORE` or `MODE_CHECK_IGNORE`\n\n  // @returns {TestResult} true if a file is ignored\n  test (path, checkUnignored, mode) {\n    let ignored = false\n    let unignored = false\n    let matchedRule\n\n    this._rules.forEach(rule => {\n      const {negative} = rule\n\n      //          |           ignored : unignored\n      // -------- | ---------------------------------------\n      // negative |   0:0   |   0:1   |   1:0   |   1:1\n      // -------- | ------- | ------- | ------- | --------\n      //     0    |  TEST   |  TEST   |  SKIP   |    X\n      //     1    |  TESTIF |  SKIP   |  TEST   |    X\n\n      // - SKIP: always skip\n      // - TEST: always test\n      // - TESTIF: only test if checkUnignored\n      // - X: that never happen\n      if (\n        unignored === negative && ignored !== unignored\n        || negative && !ignored && !unignored && !checkUnignored\n      ) {\n        return\n      }\n\n      const matched = rule[mode].test(path)\n\n      if (!matched) {\n        return\n      }\n\n      ignored = !negative\n      unignored = negative\n\n      matchedRule = negative\n        ? UNDEFINED\n        : rule\n    })\n\n    const ret = {\n      ignored,\n      unignored\n    }\n\n    if (matchedRule) {\n      ret.rule = matchedRule\n    }\n\n    return ret\n  }\n}\n\nconst throwError = (message, Ctor) => {\n  throw new Ctor(message)\n}\n\nconst checkPath = (path, originalPath, doThrow) => {\n  if (!isString(path)) {\n    return doThrow(\n      `path must be a string, but got \\`${originalPath}\\``,\n      TypeError\n    )\n  }\n\n  // We don't know if we should ignore EMPTY, so throw\n  if (!path) {\n    return doThrow(`path must not be empty`, TypeError)\n  }\n\n  // Check if it is a relative path\n  if (checkPath.isNotRelative(path)) {\n    const r = '`path.relative()`d'\n    return doThrow(\n      `path should be a ${r} string, but got \"${originalPath}\"`,\n      RangeError\n    )\n  }\n\n  return true\n}\n\nconst isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)\n\ncheckPath.isNotRelative = isNotRelative\n\n// On windows, the following function will be replaced\n/* istanbul ignore next */\ncheckPath.convert = p => p\n\n\nclass Ignore {\n  constructor ({\n    ignorecase = true,\n    ignoreCase = ignorecase,\n    allowRelativePaths = false\n  } = {}) {\n    define(this, KEY_IGNORE, true)\n\n    this._rules = new RuleManager(ignoreCase)\n    this._strictPathCheck = !allowRelativePaths\n    this._initCache()\n  }\n\n  _initCache () {\n    // A cache for the result of `.ignores()`\n    this._ignoreCache = Object.create(null)\n\n    // A cache for the result of `.test()`\n    this._testCache = Object.create(null)\n  }\n\n  add (pattern) {\n    if (this._rules.add(pattern)) {\n      // Some rules have just added to the ignore,\n      //   making the behavior changed,\n      //   so we need to re-initialize the result cache\n      this._initCache()\n    }\n\n    return this\n  }\n\n  // legacy\n  addPattern (pattern) {\n    return this.add(pattern)\n  }\n\n  // @returns {TestResult}\n  _test (originalPath, cache, checkUnignored, slices) {\n    const path = originalPath\n      // Supports nullable path\n      && checkPath.convert(originalPath)\n\n    checkPath(\n      path,\n      originalPath,\n      this._strictPathCheck\n        ? throwError\n        : RETURN_FALSE\n    )\n\n    return this._t(path, cache, checkUnignored, slices)\n  }\n\n  checkIgnore (path) {\n    // If the path doest not end with a slash, `.ignores()` is much equivalent\n    //   to `git check-ignore`\n    if (!REGEX_TEST_TRAILING_SLASH.test(path)) {\n      return this.test(path)\n    }\n\n    const slices = path.split(SLASH).filter(Boolean)\n    slices.pop()\n\n    if (slices.length) {\n      const parent = this._t(\n        slices.join(SLASH) + SLASH,\n        this._testCache,\n        true,\n        slices\n      )\n\n      if (parent.ignored) {\n        return parent\n      }\n    }\n\n    return this._rules.test(path, false, MODE_CHECK_IGNORE)\n  }\n\n  _t (\n    // The path to be tested\n    path,\n\n    // The cache for the result of a certain checking\n    cache,\n\n    // Whether should check if the path is unignored\n    checkUnignored,\n\n    // The path slices\n    slices\n  ) {\n    if (path in cache) {\n      return cache[path]\n    }\n\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH).filter(Boolean)\n    }\n\n    slices.pop()\n\n    // If the path has no parent directory, just test it\n    if (!slices.length) {\n      return cache[path] = this._rules.test(path, checkUnignored, MODE_IGNORE)\n    }\n\n    const parent = this._t(\n      slices.join(SLASH) + SLASH,\n      cache,\n      checkUnignored,\n      slices\n    )\n\n    // If the path contains a parent directory, check the parent first\n    return cache[path] = parent.ignored\n      // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      ? parent\n      : this._rules.test(path, checkUnignored, MODE_IGNORE)\n  }\n\n  ignores (path) {\n    return this._test(path, this._ignoreCache, false).ignored\n  }\n\n  createFilter () {\n    return path => !this.ignores(path)\n  }\n\n  filter (paths) {\n    return makeArray(paths).filter(this.createFilter())\n  }\n\n  // @returns {TestResult}\n  test (path) {\n    return this._test(path, this._testCache, true)\n  }\n}\n\nconst factory = options => new Ignore(options)\n\nconst isPathValid = path =>\n  checkPath(path && checkPath.convert(path), path, RETURN_FALSE)\n\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore next */\nif (\n  // Detect `process` so that it can run in browsers.\n  typeof process !== 'undefined'\n  && (\n    process.env && process.env.IGNORE_TEST_WIN32\n    || process.platform === 'win32'\n  )\n) {\n  /* eslint no-control-regex: \"off\" */\n  const makePosix = str => /^\\\\\\\\\\?\\\\/.test(str)\n  || /[\"<>|\\u0000-\\u001F]+/u.test(str)\n    ? str\n    : str.replace(/\\\\/g, '/')\n\n  checkPath.convert = makePosix\n\n  // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n  const REGEX_TEST_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i\n  checkPath.isNotRelative = path =>\n    REGEX_TEST_WINDOWS_PATH_ABSOLUTE.test(path)\n    || isNotRelative(path)\n}\n\n// COMMONJS_EXPORTS ////////////////////////////////////////////////////////////\n\nmodule.exports = factory\n\n// Although it is an anti-pattern,\n//   it is still widely misused by a lot of libraries in github\n// Ref: https://github.com/search?q=ignore.default%28%29&type=code\nfactory.default = factory\n\nmodule.exports.isPathValid = isPathValid\n","'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  const node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      const ele = arr[i];\n\n      if (Array.isArray(ele)) {\n        flat(ele);\n        continue;\n      }\n\n      if (ele !== undefined) {\n        result.push(ele);\n      }\n    }\n    return result;\n  };\n\n  flat(args);\n  return result;\n};\n","'use strict';\n\nconst utils = require('./utils');\n\nmodule.exports = (ast, options = {}) => {\n  const stringify = (node, parent = {}) => {\n    const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    const invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (const child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n","export default v => typeof v === \"number\"\n","/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n","/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options, maxLen) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.map(v => toMaxLen(String(v), maxLen)).join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.map(v => toMaxLen(String(v), maxLen)).join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options, maxLen)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n","'use strict';\n\nconst fill = require('fill-range');\nconst utils = require('./utils');\n\nconst compile = (ast, options = {}) => {\n  const walk = (node, parent = {}) => {\n    const invalidBlock = utils.isInvalidBrace(parent);\n    const invalidNode = node.invalid === true && options.escapeInvalid === true;\n    const invalid = invalidBlock === true || invalidNode === true;\n    const prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n\n    if (node.isClose === true) {\n      console.log('node.isClose', prefix, node.value);\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      const args = utils.reduce(node.nodes);\n      const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (const child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n","'use strict';\n\nconst fill = require('fill-range');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  const result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (const item of queue) {\n    if (Array.isArray(item)) {\n      for (const value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  const rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;\n\n  const walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      const args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    const enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      const child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n","'use strict';\n\nmodule.exports = {\n  MAX_LENGTH: 10000,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n","'use strict';\n\nconst stringify = require('./stringify');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = require('./constants');\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  const opts = options || {};\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  const ast = { type: 'root', input, nodes: [] };\n  const stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  const length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      const open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      const dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      const brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      const type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        const open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      const siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        const before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      const parent = stack[stack.length - 1];\n      const index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst stringify = require('./lib/stringify');\nconst compile = require('./lib/compile');\nconst expand = require('./lib/expand');\nconst parse = require('./lib/parse');\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (const pattern of input) {\n      const result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n  return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n","'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nconst util = require('util');\nconst braces = require('braces');\nconst picomatch = require('picomatch');\nconst utils = require('picomatch/lib/utils');\n\nconst isEmptyString = v => v === '' || v === './';\nconst hasBraces = v => {\n  const index = v.indexOf('{');\n  return index > -1 && v.indexOf('}', index) > -1;\n};\n\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} `list` List of strings to match.\n * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.match = micromatch;\n\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `[options]` See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.any = micromatch.isMatch;\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = new Set(micromatch(list, patterns, { ...options, onResult }));\n\n  for (let item of items) {\n    if (!matches.has(item)) {\n      result.add(item);\n    }\n  }\n  return [...result];\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any of the patterns matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, { ...options, contains: true });\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n  for (let key of keys) res[key] = obj[key];\n  return res;\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`\n * @api public\n */\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`\n * @api public\n */\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils.isWindows(options);\n  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\n\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\nmicromatch.scan = (...args) => picomatch.scan(...args);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.parse(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces(String(pattern), options)) {\n      res.push(picomatch.parse(str, options));\n    }\n  }\n  return res;\n};\n\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  if ((options && options.nobrace === true) || !hasBraces(pattern)) {\n    return [pattern];\n  }\n  return braces(pattern, options);\n};\n\n/**\n * Expand braces\n */\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, { ...options, expand: true });\n};\n\n/**\n * Expose micromatch\n */\n\n// exposed for tests\nmicromatch.hasBraces = hasBraces;\nmodule.exports = micromatch;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizePath = exports.isRootDirectory = exports.convertSlashes = exports.cleanPath = void 0;\nconst path_1 = require(\"path\");\nfunction cleanPath(path) {\n    let normalized = (0, path_1.normalize)(path);\n    // we have to remove the last path separator\n    // to account for / root path\n    if (normalized.length > 1 && normalized[normalized.length - 1] === path_1.sep)\n        normalized = normalized.substring(0, normalized.length - 1);\n    return normalized;\n}\nexports.cleanPath = cleanPath;\nconst SLASHES_REGEX = /[\\\\/]/g;\nfunction convertSlashes(path, separator) {\n    return path.replace(SLASHES_REGEX, separator);\n}\nexports.convertSlashes = convertSlashes;\nfunction isRootDirectory(path) {\n    return path === \"/\" || /^[a-z]:\\\\$/i.test(path);\n}\nexports.isRootDirectory = isRootDirectory;\nfunction normalizePath(path, options) {\n    const { resolvePaths, normalizePath, pathSeparator } = options;\n    const pathNeedsCleaning = (process.platform === \"win32\" && path.includes(\"/\")) ||\n        path.startsWith(\".\");\n    if (resolvePaths)\n        path = (0, path_1.resolve)(path);\n    if (normalizePath || pathNeedsCleaning)\n        path = cleanPath(path);\n    if (path === \".\")\n        return \"\";\n    const needsSeperator = path[path.length - 1] !== pathSeparator;\n    return convertSlashes(needsSeperator ? path + pathSeparator : path, pathSeparator);\n}\nexports.normalizePath = normalizePath;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.build = exports.joinDirectoryPath = exports.joinPathWithBasePath = void 0;\nconst path_1 = require(\"path\");\nconst utils_1 = require(\"../../utils\");\nfunction joinPathWithBasePath(filename, directoryPath) {\n    return directoryPath + filename;\n}\nexports.joinPathWithBasePath = joinPathWithBasePath;\nfunction joinPathWithRelativePath(root, options) {\n    return function (filename, directoryPath) {\n        const sameRoot = directoryPath.startsWith(root);\n        if (sameRoot)\n            return directoryPath.replace(root, \"\") + filename;\n        else\n            return ((0, utils_1.convertSlashes)((0, path_1.relative)(root, directoryPath), options.pathSeparator) +\n                options.pathSeparator +\n                filename);\n    };\n}\nfunction joinPath(filename) {\n    return filename;\n}\nfunction joinDirectoryPath(filename, directoryPath, separator) {\n    return directoryPath + filename + separator;\n}\nexports.joinDirectoryPath = joinDirectoryPath;\nfunction build(root, options) {\n    const { relativePaths, includeBasePath } = options;\n    return relativePaths && root\n        ? joinPathWithRelativePath(root, options)\n        : includeBasePath\n            ? joinPathWithBasePath\n            : joinPath;\n}\nexports.build = build;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.build = void 0;\nfunction pushDirectoryWithRelativePath(root) {\n    return function (directoryPath, paths) {\n        paths.push(directoryPath.substring(root.length) || \".\");\n    };\n}\nfunction pushDirectoryFilterWithRelativePath(root) {\n    return function (directoryPath, paths, filters) {\n        const relativePath = directoryPath.substring(root.length) || \".\";\n        if (filters.every((filter) => filter(relativePath, true))) {\n            paths.push(relativePath);\n        }\n    };\n}\nconst pushDirectory = (directoryPath, paths) => {\n    paths.push(directoryPath || \".\");\n};\nconst pushDirectoryFilter = (directoryPath, paths, filters) => {\n    const path = directoryPath || \".\";\n    if (filters.every((filter) => filter(path, true))) {\n        paths.push(path);\n    }\n};\nconst empty = () => { };\nfunction build(root, options) {\n    const { includeDirs, filters, relativePaths } = options;\n    if (!includeDirs)\n        return empty;\n    if (relativePaths)\n        return filters && filters.length\n            ? pushDirectoryFilterWithRelativePath(root)\n            : pushDirectoryWithRelativePath(root);\n    return filters && filters.length ? pushDirectoryFilter : pushDirectory;\n}\nexports.build = build;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.build = void 0;\nconst pushFileFilterAndCount = (filename, _paths, counts, filters) => {\n    if (filters.every((filter) => filter(filename, false)))\n        counts.files++;\n};\nconst pushFileFilter = (filename, paths, _counts, filters) => {\n    if (filters.every((filter) => filter(filename, false)))\n        paths.push(filename);\n};\nconst pushFileCount = (_filename, _paths, counts, _filters) => {\n    counts.files++;\n};\nconst pushFile = (filename, paths) => {\n    paths.push(filename);\n};\nconst empty = () => { };\nfunction build(options) {\n    const { excludeFiles, filters, onlyCounts } = options;\n    if (excludeFiles)\n        return empty;\n    if (filters && filters.length) {\n        return onlyCounts ? pushFileFilterAndCount : pushFileFilter;\n    }\n    else if (onlyCounts) {\n        return pushFileCount;\n    }\n    else {\n        return pushFile;\n    }\n}\nexports.build = build;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.build = void 0;\nconst getArray = (paths) => {\n    return paths;\n};\nconst getArrayGroup = () => {\n    return [\"\"].slice(0, 0);\n};\nfunction build(options) {\n    return options.group ? getArrayGroup : getArray;\n}\nexports.build = build;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.build = void 0;\nconst groupFiles = (groups, directory, files) => {\n    groups.push({ directory, files, dir: directory });\n};\nconst empty = () => { };\nfunction build(options) {\n    return options.group ? groupFiles : empty;\n}\nexports.build = build;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.build = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst path_1 = require(\"path\");\nconst resolveSymlinksAsync = function (path, state, callback) {\n    const { queue, options: { suppressErrors }, } = state;\n    queue.enqueue();\n    fs_1.default.realpath(path, (error, resolvedPath) => {\n        if (error)\n            return queue.dequeue(suppressErrors ? null : error, state);\n        fs_1.default.stat(resolvedPath, (error, stat) => {\n            if (error)\n                return queue.dequeue(suppressErrors ? null : error, state);\n            if (stat.isDirectory() && isRecursive(path, resolvedPath, state))\n                return queue.dequeue(null, state);\n            callback(stat, resolvedPath);\n            queue.dequeue(null, state);\n        });\n    });\n};\nconst resolveSymlinks = function (path, state, callback) {\n    const { queue, options: { suppressErrors }, } = state;\n    queue.enqueue();\n    try {\n        const resolvedPath = fs_1.default.realpathSync(path);\n        const stat = fs_1.default.statSync(resolvedPath);\n        if (stat.isDirectory() && isRecursive(path, resolvedPath, state))\n            return;\n        callback(stat, resolvedPath);\n    }\n    catch (e) {\n        if (!suppressErrors)\n            throw e;\n    }\n};\nfunction build(options, isSynchronous) {\n    if (!options.resolveSymlinks || options.excludeSymlinks)\n        return null;\n    return isSynchronous ? resolveSymlinks : resolveSymlinksAsync;\n}\nexports.build = build;\nfunction isRecursive(path, resolved, state) {\n    if (state.options.useRealPaths)\n        return isRecursiveUsingRealPaths(resolved, state);\n    let parent = (0, path_1.dirname)(path);\n    let depth = 1;\n    while (parent !== state.root && depth < 2) {\n        const resolvedPath = state.symlinks.get(parent);\n        const isSameRoot = !!resolvedPath &&\n            (resolvedPath === resolved ||\n                resolvedPath.startsWith(resolved) ||\n                resolved.startsWith(resolvedPath));\n        if (isSameRoot)\n            depth++;\n        else\n            parent = (0, path_1.dirname)(parent);\n    }\n    state.symlinks.set(path, resolved);\n    return depth > 1;\n}\nfunction isRecursiveUsingRealPaths(resolved, state) {\n    return state.visited.includes(resolved + state.options.pathSeparator);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.build = void 0;\nconst onlyCountsSync = (state) => {\n    return state.counts;\n};\nconst groupsSync = (state) => {\n    return state.groups;\n};\nconst defaultSync = (state) => {\n    return state.paths;\n};\nconst limitFilesSync = (state) => {\n    return state.paths.slice(0, state.options.maxFiles);\n};\nconst onlyCountsAsync = (state, error, callback) => {\n    report(error, callback, state.counts, state.options.suppressErrors);\n    return null;\n};\nconst defaultAsync = (state, error, callback) => {\n    report(error, callback, state.paths, state.options.suppressErrors);\n    return null;\n};\nconst limitFilesAsync = (state, error, callback) => {\n    report(error, callback, state.paths.slice(0, state.options.maxFiles), state.options.suppressErrors);\n    return null;\n};\nconst groupsAsync = (state, error, callback) => {\n    report(error, callback, state.groups, state.options.suppressErrors);\n    return null;\n};\nfunction report(error, callback, output, suppressErrors) {\n    if (error && !suppressErrors)\n        callback(error, output);\n    else\n        callback(null, output);\n}\nfunction build(options, isSynchronous) {\n    const { onlyCounts, group, maxFiles } = options;\n    if (onlyCounts)\n        return isSynchronous\n            ? onlyCountsSync\n            : onlyCountsAsync;\n    else if (group)\n        return isSynchronous\n            ? groupsSync\n            : groupsAsync;\n    else if (maxFiles)\n        return isSynchronous\n            ? limitFilesSync\n            : limitFilesAsync;\n    else\n        return isSynchronous\n            ? defaultSync\n            : defaultAsync;\n}\nexports.build = build;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.build = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst readdirOpts = { withFileTypes: true };\nconst walkAsync = (state, crawlPath, directoryPath, currentDepth, callback) => {\n    if (currentDepth < 0)\n        return state.queue.dequeue(null, state);\n    state.visited.push(crawlPath);\n    state.counts.directories++;\n    state.queue.enqueue();\n    // Perf: Node >= 10 introduced withFileTypes that helps us\n    // skip an extra fs.stat call.\n    fs_1.default.readdir(crawlPath || \".\", readdirOpts, (error, entries = []) => {\n        callback(entries, directoryPath, currentDepth);\n        state.queue.dequeue(state.options.suppressErrors ? null : error, state);\n    });\n};\nconst walkSync = (state, crawlPath, directoryPath, currentDepth, callback) => {\n    if (currentDepth < 0)\n        return;\n    state.visited.push(crawlPath);\n    state.counts.directories++;\n    let entries = [];\n    try {\n        entries = fs_1.default.readdirSync(crawlPath || \".\", readdirOpts);\n    }\n    catch (e) {\n        if (!state.options.suppressErrors)\n            throw e;\n    }\n    callback(entries, directoryPath, currentDepth);\n};\nfunction build(isSynchronous) {\n    return isSynchronous ? walkSync : walkAsync;\n}\nexports.build = build;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Queue = void 0;\n/**\n * This is a custom stateless queue to track concurrent async fs calls.\n * It increments a counter whenever a call is queued and decrements it\n * as soon as it completes. When the counter hits 0, it calls onQueueEmpty.\n */\nclass Queue {\n    onQueueEmpty;\n    count = 0;\n    constructor(onQueueEmpty) {\n        this.onQueueEmpty = onQueueEmpty;\n    }\n    enqueue() {\n        this.count++;\n    }\n    dequeue(error, output) {\n        if (--this.count <= 0 || error)\n            this.onQueueEmpty(error, output);\n    }\n}\nexports.Queue = Queue;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Counter = void 0;\nclass Counter {\n    _files = 0;\n    _directories = 0;\n    set files(num) {\n        this._files = num;\n    }\n    get files() {\n        return this._files;\n    }\n    set directories(num) {\n        this._directories = num;\n    }\n    get directories() {\n        return this._directories;\n    }\n    /**\n     * @deprecated use `directories` instead\n     */\n    /* c8 ignore next 3 */\n    get dirs() {\n        return this._directories;\n    }\n}\nexports.Counter = Counter;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Walker = void 0;\nconst path_1 = require(\"path\");\nconst utils_1 = require(\"../utils\");\nconst joinPath = __importStar(require(\"./functions/join-path\"));\nconst pushDirectory = __importStar(require(\"./functions/push-directory\"));\nconst pushFile = __importStar(require(\"./functions/push-file\"));\nconst getArray = __importStar(require(\"./functions/get-array\"));\nconst groupFiles = __importStar(require(\"./functions/group-files\"));\nconst resolveSymlink = __importStar(require(\"./functions/resolve-symlink\"));\nconst invokeCallback = __importStar(require(\"./functions/invoke-callback\"));\nconst walkDirectory = __importStar(require(\"./functions/walk-directory\"));\nconst queue_1 = require(\"./queue\");\nconst counter_1 = require(\"./counter\");\nclass Walker {\n    root;\n    isSynchronous;\n    state;\n    joinPath;\n    pushDirectory;\n    pushFile;\n    getArray;\n    groupFiles;\n    resolveSymlink;\n    walkDirectory;\n    callbackInvoker;\n    constructor(root, options, callback) {\n        this.isSynchronous = !callback;\n        this.callbackInvoker = invokeCallback.build(options, this.isSynchronous);\n        this.root = (0, utils_1.normalizePath)(root, options);\n        this.state = {\n            root: (0, utils_1.isRootDirectory)(this.root) ? this.root : this.root.slice(0, -1),\n            // Perf: we explicitly tell the compiler to optimize for String arrays\n            paths: [\"\"].slice(0, 0),\n            groups: [],\n            counts: new counter_1.Counter(),\n            options,\n            queue: new queue_1.Queue((error, state) => this.callbackInvoker(state, error, callback)),\n            symlinks: new Map(),\n            visited: [\"\"].slice(0, 0),\n        };\n        /*\n         * Perf: We conditionally change functions according to options. This gives a slight\n         * performance boost. Since these functions are so small, they are automatically inlined\n         * by the javascript engine so there's no function call overhead (in most cases).\n         */\n        this.joinPath = joinPath.build(this.root, options);\n        this.pushDirectory = pushDirectory.build(this.root, options);\n        this.pushFile = pushFile.build(options);\n        this.getArray = getArray.build(options);\n        this.groupFiles = groupFiles.build(options);\n        this.resolveSymlink = resolveSymlink.build(options, this.isSynchronous);\n        this.walkDirectory = walkDirectory.build(this.isSynchronous);\n    }\n    start() {\n        this.walkDirectory(this.state, this.root, this.root, this.state.options.maxDepth, this.walk);\n        return this.isSynchronous ? this.callbackInvoker(this.state, null) : null;\n    }\n    walk = (entries, directoryPath, depth) => {\n        const { paths, options: { filters, resolveSymlinks, excludeSymlinks, exclude, maxFiles, signal, useRealPaths, pathSeparator, }, } = this.state;\n        if ((signal && signal.aborted) || (maxFiles && paths.length > maxFiles))\n            return;\n        this.pushDirectory(directoryPath, paths, filters);\n        const files = this.getArray(this.state.paths);\n        for (let i = 0; i < entries.length; ++i) {\n            const entry = entries[i];\n            if (entry.isFile() ||\n                (entry.isSymbolicLink() && !resolveSymlinks && !excludeSymlinks)) {\n                const filename = this.joinPath(entry.name, directoryPath);\n                this.pushFile(filename, files, this.state.counts, filters);\n            }\n            else if (entry.isDirectory()) {\n                let path = joinPath.joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);\n                if (exclude && exclude(entry.name, path))\n                    continue;\n                this.walkDirectory(this.state, path, path, depth - 1, this.walk);\n            }\n            else if (entry.isSymbolicLink() && this.resolveSymlink) {\n                let path = joinPath.joinPathWithBasePath(entry.name, directoryPath);\n                this.resolveSymlink(path, this.state, (stat, resolvedPath) => {\n                    if (stat.isDirectory()) {\n                        resolvedPath = (0, utils_1.normalizePath)(resolvedPath, this.state.options);\n                        if (exclude &&\n                            exclude(entry.name, useRealPaths ? resolvedPath : path + pathSeparator))\n                            return;\n                        this.walkDirectory(this.state, resolvedPath, useRealPaths ? resolvedPath : path + pathSeparator, depth - 1, this.walk);\n                    }\n                    else {\n                        resolvedPath = useRealPaths ? resolvedPath : path;\n                        const filename = (0, path_1.basename)(resolvedPath);\n                        const directoryPath = (0, utils_1.normalizePath)((0, path_1.dirname)(resolvedPath), this.state.options);\n                        resolvedPath = this.joinPath(filename, directoryPath);\n                        this.pushFile(resolvedPath, files, this.state.counts, filters);\n                    }\n                });\n            }\n        }\n        this.groupFiles(this.state.groups, directoryPath, files);\n    };\n}\nexports.Walker = Walker;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callback = exports.promise = void 0;\nconst walker_1 = require(\"./walker\");\nfunction promise(root, options) {\n    return new Promise((resolve, reject) => {\n        callback(root, options, (err, output) => {\n            if (err)\n                return reject(err);\n            resolve(output);\n        });\n    });\n}\nexports.promise = promise;\nfunction callback(root, options, callback) {\n    let walker = new walker_1.Walker(root, options, callback);\n    walker.start();\n}\nexports.callback = callback;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sync = void 0;\nconst walker_1 = require(\"./walker\");\nfunction sync(root, options) {\n    const walker = new walker_1.Walker(root, options);\n    return walker.start();\n}\nexports.sync = sync;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.APIBuilder = void 0;\nconst async_1 = require(\"../api/async\");\nconst sync_1 = require(\"../api/sync\");\nclass APIBuilder {\n    root;\n    options;\n    constructor(root, options) {\n        this.root = root;\n        this.options = options;\n    }\n    withPromise() {\n        return (0, async_1.promise)(this.root, this.options);\n    }\n    withCallback(cb) {\n        (0, async_1.callback)(this.root, this.options, cb);\n    }\n    sync() {\n        return (0, sync_1.sync)(this.root, this.options);\n    }\n}\nexports.APIBuilder = APIBuilder;\n","'use strict';\n\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst SEP = '/';\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR,\n  SEP\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,\n  SEP: '\\\\'\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","/*global navigator*/\n'use strict';\n\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.isWindows = () => {\n  if (typeof navigator !== 'undefined' && navigator.platform) {\n    const platform = navigator.platform.toLowerCase();\n    return platform === 'win32' || platform === 'windows';\n  }\n\n  if (typeof process !== 'undefined' && process.platform) {\n    return process.platform === 'win32';\n  }\n\n  return false;\n};\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n\nexports.basename = (path, { windows } = {}) => {\n  const segs = path.split(windows ? /[\\\\/]/ : '/');\n  const last = segs[segs.length - 1];\n\n  if (last === '') {\n    return segs[segs.length - 2];\n  }\n\n  return last;\n};\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(opts.windows);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.output = (prev.output || prev.value) + tok.value;\n      prev.value += tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(opts.windows);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = opts.windows;\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(utils.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nconst pico = require('./lib/picomatch');\nconst utils = require('./lib/utils');\n\nfunction picomatch(glob, options, returnState = false) {\n  // default to os.platform()\n  if (options && (options.windows === null || options.windows === undefined)) {\n    // don't mutate the original options object\n    options = { ...options, windows: utils.isWindows() };\n  }\n\n  return pico(glob, options, returnState);\n}\n\nObject.assign(picomatch, pico);\nmodule.exports = picomatch;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Builder = void 0;\nconst path_1 = require(\"path\");\nconst api_builder_1 = require(\"./api-builder\");\nvar pm = null;\n/* c8 ignore next 6 */\ntry {\n    require.resolve(\"picomatch\");\n    pm = require(\"picomatch\");\n}\ncatch (_e) {\n    // do nothing\n}\nclass Builder {\n    globCache = {};\n    options = {\n        maxDepth: Infinity,\n        suppressErrors: true,\n        pathSeparator: path_1.sep,\n        filters: [],\n    };\n    globFunction;\n    constructor(options) {\n        this.options = { ...this.options, ...options };\n        this.globFunction = this.options.globFunction;\n    }\n    group() {\n        this.options.group = true;\n        return this;\n    }\n    withPathSeparator(separator) {\n        this.options.pathSeparator = separator;\n        return this;\n    }\n    withBasePath() {\n        this.options.includeBasePath = true;\n        return this;\n    }\n    withRelativePaths() {\n        this.options.relativePaths = true;\n        return this;\n    }\n    withDirs() {\n        this.options.includeDirs = true;\n        return this;\n    }\n    withMaxDepth(depth) {\n        this.options.maxDepth = depth;\n        return this;\n    }\n    withMaxFiles(limit) {\n        this.options.maxFiles = limit;\n        return this;\n    }\n    withFullPaths() {\n        this.options.resolvePaths = true;\n        this.options.includeBasePath = true;\n        return this;\n    }\n    withErrors() {\n        this.options.suppressErrors = false;\n        return this;\n    }\n    withSymlinks({ resolvePaths = true } = {}) {\n        this.options.resolveSymlinks = true;\n        this.options.useRealPaths = resolvePaths;\n        return this.withFullPaths();\n    }\n    withAbortSignal(signal) {\n        this.options.signal = signal;\n        return this;\n    }\n    normalize() {\n        this.options.normalizePath = true;\n        return this;\n    }\n    filter(predicate) {\n        this.options.filters.push(predicate);\n        return this;\n    }\n    onlyDirs() {\n        this.options.excludeFiles = true;\n        this.options.includeDirs = true;\n        return this;\n    }\n    exclude(predicate) {\n        this.options.exclude = predicate;\n        return this;\n    }\n    onlyCounts() {\n        this.options.onlyCounts = true;\n        return this;\n    }\n    crawl(root) {\n        return new api_builder_1.APIBuilder(root || \".\", this.options);\n    }\n    withGlobFunction(fn) {\n        // cast this since we don't have the new type params yet\n        this.globFunction = fn;\n        return this;\n    }\n    /**\n     * @deprecated Pass options using the constructor instead:\n     * ```ts\n     * new fdir(options).crawl(\"/path/to/root\");\n     * ```\n     * This method will be removed in v7.0\n     */\n    /* c8 ignore next 4 */\n    crawlWithOptions(root, options) {\n        this.options = { ...this.options, ...options };\n        return new api_builder_1.APIBuilder(root || \".\", this.options);\n    }\n    glob(...patterns) {\n        if (this.globFunction) {\n            return this.globWithOptions(patterns);\n        }\n        return this.globWithOptions(patterns, ...[{ dot: true }]);\n    }\n    globWithOptions(patterns, ...options) {\n        const globFn = (this.globFunction || pm);\n        /* c8 ignore next 5 */\n        if (!globFn) {\n            throw new Error(\"Please specify a glob function to use glob matching.\");\n        }\n        var isMatch = this.globCache[patterns.join(\"\\0\")];\n        if (!isMatch) {\n            isMatch = globFn(patterns, ...options);\n            this.globCache[patterns.join(\"\\0\")] = isMatch;\n        }\n        this.options.filters.push((path) => isMatch(path));\n        return this;\n    }\n}\nexports.Builder = Builder;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fdir = void 0;\nconst builder_1 = require(\"./builder\");\nObject.defineProperty(exports, \"fdir\", { enumerable: true, get: function () { return builder_1.Builder; } });\n__exportStar(require(\"./types\"), exports);\n","\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  convertPathToPattern: () => convertPathToPattern,\n  escapePath: () => escapePath,\n  glob: () => glob,\n  globSync: () => globSync,\n  isDynamicPattern: () => isDynamicPattern\n});\nmodule.exports = __toCommonJS(index_exports);\nvar import_node_path = __toESM(require(\"path\"));\nvar import_fdir = require(\"fdir\");\nvar import_picomatch2 = __toESM(require(\"picomatch\"));\n\n// src/utils.ts\nvar import_picomatch = __toESM(require(\"picomatch\"));\nvar ONLY_PARENT_DIRECTORIES = /^(\\/?\\.\\.)+$/;\nfunction getPartialMatcher(patterns, options) {\n  const patternsCount = patterns.length;\n  const patternsParts = Array(patternsCount);\n  const regexes = Array(patternsCount);\n  for (let i = 0; i < patternsCount; i++) {\n    const parts = splitPattern(patterns[i]);\n    patternsParts[i] = parts;\n    const partsCount = parts.length;\n    const partRegexes = Array(partsCount);\n    for (let j = 0; j < partsCount; j++) {\n      partRegexes[j] = import_picomatch.default.makeRe(parts[j], options);\n    }\n    regexes[i] = partRegexes;\n  }\n  return (input) => {\n    const inputParts = input.split(\"/\");\n    if (inputParts[0] === \"..\" && ONLY_PARENT_DIRECTORIES.test(input)) {\n      return true;\n    }\n    for (let i = 0; i < patterns.length; i++) {\n      const patternParts = patternsParts[i];\n      const regex = regexes[i];\n      const inputPatternCount = inputParts.length;\n      const minParts = Math.min(inputPatternCount, patternParts.length);\n      let j = 0;\n      while (j < minParts) {\n        const part = patternParts[j];\n        if (part.includes(\"/\")) {\n          return true;\n        }\n        const match = regex[j].test(inputParts[j]);\n        if (!match) {\n          break;\n        }\n        if (part === \"**\") {\n          return true;\n        }\n        j++;\n      }\n      if (j === inputPatternCount) {\n        return true;\n      }\n    }\n    return false;\n  };\n}\nvar splitPatternOptions = { parts: true };\nfunction splitPattern(path2) {\n  var _a;\n  const result = import_picomatch.default.scan(path2, splitPatternOptions);\n  return ((_a = result.parts) == null ? void 0 : _a.length) ? result.parts : [path2];\n}\nvar isWin = process.platform === \"win32\";\nvar ESCAPED_WIN32_BACKSLASHES = /\\\\(?![()[\\]{}!+@])/g;\nfunction convertPosixPathToPattern(path2) {\n  return escapePosixPath(path2);\n}\nfunction convertWin32PathToPattern(path2) {\n  return escapeWin32Path(path2).replace(ESCAPED_WIN32_BACKSLASHES, \"/\");\n}\nvar convertPathToPattern = isWin ? convertWin32PathToPattern : convertPosixPathToPattern;\nvar POSIX_UNESCAPED_GLOB_SYMBOLS = /(?<!\\\\)([()[\\]{}*?|]|^!|[!+@](?=\\()|\\\\(?![()[\\]{}!*+?@|]))/g;\nvar WIN32_UNESCAPED_GLOB_SYMBOLS = /(?<!\\\\)([()[\\]{}]|^!|[!+@](?=\\())/g;\nvar escapePosixPath = (path2) => path2.replace(POSIX_UNESCAPED_GLOB_SYMBOLS, \"\\\\$&\");\nvar escapeWin32Path = (path2) => path2.replace(WIN32_UNESCAPED_GLOB_SYMBOLS, \"\\\\$&\");\nvar escapePath = isWin ? escapeWin32Path : escapePosixPath;\nfunction isDynamicPattern(pattern, options) {\n  if ((options == null ? void 0 : options.caseSensitiveMatch) === false) {\n    return true;\n  }\n  const scan = import_picomatch.default.scan(pattern);\n  return scan.isGlob || scan.negated;\n}\nfunction log(...tasks) {\n  console.log(`[tinyglobby ${(/* @__PURE__ */ new Date()).toLocaleTimeString(\"es\")}]`, ...tasks);\n}\n\n// src/index.ts\nvar PARENT_DIRECTORY = /^(\\/?\\.\\.)+/;\nvar ESCAPING_BACKSLASHES = /\\\\(?=[()[\\]{}!*+?@|])/g;\nvar BACKSLASHES = /\\\\/g;\nfunction normalizePattern(pattern, expandDirectories, cwd, props, isIgnore) {\n  var _a;\n  let result = pattern;\n  if (pattern.endsWith(\"/\")) {\n    result = pattern.slice(0, -1);\n  }\n  if (!result.endsWith(\"*\") && expandDirectories) {\n    result += \"/**\";\n  }\n  if (import_node_path.default.isAbsolute(result.replace(ESCAPING_BACKSLASHES, \"\"))) {\n    result = import_node_path.posix.relative(escapePath(cwd), result);\n  } else {\n    result = import_node_path.posix.normalize(result);\n  }\n  const parentDirectoryMatch = PARENT_DIRECTORY.exec(result);\n  if (parentDirectoryMatch == null ? void 0 : parentDirectoryMatch[0]) {\n    const potentialRoot = import_node_path.posix.join(cwd, parentDirectoryMatch[0]);\n    if (props.root.length > potentialRoot.length) {\n      props.root = potentialRoot;\n      props.depthOffset = -(parentDirectoryMatch[0].length + 1) / 3;\n    }\n  } else if (!isIgnore && props.depthOffset >= 0) {\n    const parts = splitPattern(result);\n    (_a = props.commonPath) != null ? _a : props.commonPath = parts;\n    const newCommonPath = [];\n    const length = Math.min(props.commonPath.length, parts.length);\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === \"**\" && !parts[i + 1]) {\n        newCommonPath.pop();\n        break;\n      }\n      if (part !== props.commonPath[i] || isDynamicPattern(part) || i === parts.length - 1) {\n        break;\n      }\n      newCommonPath.push(part);\n    }\n    props.depthOffset = newCommonPath.length;\n    props.commonPath = newCommonPath;\n    props.root = newCommonPath.length > 0 ? import_node_path.default.posix.join(cwd, ...newCommonPath) : cwd;\n  }\n  return result;\n}\nfunction processPatterns({ patterns, ignore = [], expandDirectories = true }, cwd, props) {\n  if (typeof patterns === \"string\") {\n    patterns = [patterns];\n  } else if (!patterns) {\n    patterns = [\"**/*\"];\n  }\n  if (typeof ignore === \"string\") {\n    ignore = [ignore];\n  }\n  const matchPatterns = [];\n  const ignorePatterns = [];\n  for (const pattern of ignore) {\n    if (!pattern) {\n      continue;\n    }\n    if (pattern[0] !== \"!\" || pattern[1] === \"(\") {\n      ignorePatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, true));\n    }\n  }\n  for (const pattern of patterns) {\n    if (!pattern) {\n      continue;\n    }\n    if (pattern[0] !== \"!\" || pattern[1] === \"(\") {\n      matchPatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, false));\n    } else if (pattern[1] !== \"!\" || pattern[2] === \"(\") {\n      ignorePatterns.push(normalizePattern(pattern.slice(1), expandDirectories, cwd, props, true));\n    }\n  }\n  return { match: matchPatterns, ignore: ignorePatterns };\n}\nfunction getRelativePath(path2, cwd, root) {\n  return import_node_path.posix.relative(cwd, `${root}/${path2}`) || \".\";\n}\nfunction processPath(path2, cwd, root, isDirectory, absolute) {\n  const relativePath = absolute ? path2.slice(root === \"/\" ? 1 : root.length + 1) || \".\" : path2;\n  if (root === cwd) {\n    return isDirectory && relativePath !== \".\" ? relativePath.slice(0, -1) : relativePath;\n  }\n  return getRelativePath(relativePath, cwd, root);\n}\nfunction formatPaths(paths, cwd, root) {\n  for (let i = paths.length - 1; i >= 0; i--) {\n    const path2 = paths[i];\n    paths[i] = getRelativePath(path2, cwd, root) + (!path2 || path2.endsWith(\"/\") ? \"/\" : \"\");\n  }\n  return paths;\n}\nfunction crawl(options, cwd, sync) {\n  if (process.env.TINYGLOBBY_DEBUG) {\n    options.debug = true;\n  }\n  if (options.debug) {\n    log(\"globbing with options:\", options, \"cwd:\", cwd);\n  }\n  if (Array.isArray(options.patterns) && options.patterns.length === 0) {\n    return sync ? [] : Promise.resolve([]);\n  }\n  const props = {\n    root: cwd,\n    commonPath: null,\n    depthOffset: 0\n  };\n  const processed = processPatterns(options, cwd, props);\n  const nocase = options.caseSensitiveMatch === false;\n  if (options.debug) {\n    log(\"internal processing patterns:\", processed);\n  }\n  const matcher = (0, import_picomatch2.default)(processed.match, {\n    dot: options.dot,\n    nocase,\n    ignore: processed.ignore\n  });\n  const ignore = (0, import_picomatch2.default)(processed.ignore, {\n    dot: options.dot,\n    nocase\n  });\n  const partialMatcher = getPartialMatcher(processed.match, {\n    dot: options.dot,\n    nocase\n  });\n  const fdirOptions = {\n    // use relative paths in the matcher\n    filters: [\n      options.debug ? (p, isDirectory) => {\n        const path2 = processPath(p, cwd, props.root, isDirectory, options.absolute);\n        const matches = matcher(path2);\n        if (matches) {\n          log(`matched ${path2}`);\n        }\n        return matches;\n      } : (p, isDirectory) => matcher(processPath(p, cwd, props.root, isDirectory, options.absolute))\n    ],\n    exclude: options.debug ? (_, p) => {\n      const relativePath = processPath(p, cwd, props.root, true, true);\n      const skipped = relativePath !== \".\" && !partialMatcher(relativePath) || ignore(relativePath);\n      if (skipped) {\n        log(`skipped ${p}`);\n      } else {\n        log(`crawling ${p}`);\n      }\n      return skipped;\n    } : (_, p) => {\n      const relativePath = processPath(p, cwd, props.root, true, true);\n      return relativePath !== \".\" && !partialMatcher(relativePath) || ignore(relativePath);\n    },\n    pathSeparator: \"/\",\n    relativePaths: true,\n    resolveSymlinks: true\n  };\n  if (options.deep) {\n    fdirOptions.maxDepth = Math.round(options.deep - props.depthOffset);\n  }\n  if (options.absolute) {\n    fdirOptions.relativePaths = false;\n    fdirOptions.resolvePaths = true;\n    fdirOptions.includeBasePath = true;\n  }\n  if (options.followSymbolicLinks === false) {\n    fdirOptions.resolveSymlinks = false;\n    fdirOptions.excludeSymlinks = true;\n  }\n  if (options.onlyDirectories) {\n    fdirOptions.excludeFiles = true;\n    fdirOptions.includeDirs = true;\n  } else if (options.onlyFiles === false) {\n    fdirOptions.includeDirs = true;\n  }\n  props.root = props.root.replace(BACKSLASHES, \"\");\n  const root = props.root;\n  if (options.debug) {\n    log(\"internal properties:\", props);\n  }\n  const api = new import_fdir.fdir(fdirOptions).crawl(root);\n  if (cwd === root || options.absolute) {\n    return sync ? api.sync() : api.withPromise();\n  }\n  return sync ? formatPaths(api.sync(), cwd, root) : api.withPromise().then((paths) => formatPaths(paths, cwd, root));\n}\nasync function glob(patternsOrOptions, options) {\n  if (patternsOrOptions && (options == null ? void 0 : options.patterns)) {\n    throw new Error(\"Cannot pass patterns as both an argument and an option\");\n  }\n  const opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === \"string\" ? { ...options, patterns: patternsOrOptions } : patternsOrOptions;\n  const cwd = opts.cwd ? import_node_path.default.resolve(opts.cwd).replace(BACKSLASHES, \"/\") : process.cwd().replace(BACKSLASHES, \"/\");\n  return crawl(opts, cwd, false);\n}\nfunction globSync(patternsOrOptions, options) {\n  if (patternsOrOptions && (options == null ? void 0 : options.patterns)) {\n    throw new Error(\"Cannot pass patterns as both an argument and an option\");\n  }\n  const opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === \"string\" ? { ...options, patterns: patternsOrOptions } : patternsOrOptions;\n  const cwd = opts.cwd ? import_node_path.default.resolve(opts.cwd).replace(BACKSLASHES, \"/\") : process.cwd().replace(BACKSLASHES, \"/\");\n  return crawl(opts, cwd, true);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  convertPathToPattern,\n  escapePath,\n  glob,\n  globSync,\n  isDynamicPattern\n});\n","const tty = require('node:tty');\n\n// eslint-disable-next-line no-warning-comments\n// TODO: Use a better method when it's added to Node.js (https://github.com/nodejs/node/pull/40240)\n// Lots of optionals here to support Deno.\nconst hasColors = tty?.WriteStream?.prototype?.hasColors?.() ?? false;\n\nconst format = (open, close) => {\n\tif (!hasColors) {\n\t\treturn input => input;\n\t}\n\n\tconst openCode = `\\u001B[${open}m`;\n\tconst closeCode = `\\u001B[${close}m`;\n\n\treturn input => {\n\t\tconst string = input + ''; // eslint-disable-line no-implicit-coercion -- This is faster.\n\t\tlet index = string.indexOf(closeCode);\n\n\t\tif (index === -1) {\n\t\t\t// Note: Intentionally not using string interpolation for performance reasons.\n\t\t\treturn openCode + string + closeCode;\n\t\t}\n\n\t\t// Handle nested colors.\n\n\t\t// We could have done this, but it's too slow (as of Node.js 22).\n\t\t// return openCode + string.replaceAll(closeCode, openCode) + closeCode;\n\n\t\tlet result = openCode;\n\t\tlet lastIndex = 0;\n\n\t\twhile (index !== -1) {\n\t\t\tresult += string.slice(lastIndex, index) + openCode;\n\t\t\tlastIndex = index + closeCode.length;\n\t\t\tindex = string.indexOf(closeCode, lastIndex);\n\t\t}\n\n\t\tresult += string.slice(lastIndex) + closeCode;\n\n\t\treturn result;\n\t};\n};\n\nconst colors = {};\n\ncolors.reset = format(0, 0);\ncolors.bold = format(1, 22);\ncolors.dim = format(2, 22);\ncolors.italic = format(3, 23);\ncolors.underline = format(4, 24);\ncolors.overline = format(53, 55);\ncolors.inverse = format(7, 27);\ncolors.hidden = format(8, 28);\ncolors.strikethrough = format(9, 29);\n\ncolors.black = format(30, 39);\ncolors.red = format(31, 39);\ncolors.green = format(32, 39);\ncolors.yellow = format(33, 39);\ncolors.blue = format(34, 39);\ncolors.magenta = format(35, 39);\ncolors.cyan = format(36, 39);\ncolors.white = format(37, 39);\ncolors.gray = format(90, 39);\n\ncolors.bgBlack = format(40, 49);\ncolors.bgRed = format(41, 49);\ncolors.bgGreen = format(42, 49);\ncolors.bgYellow = format(43, 49);\ncolors.bgBlue = format(44, 49);\ncolors.bgMagenta = format(45, 49);\ncolors.bgCyan = format(46, 49);\ncolors.bgWhite = format(47, 49);\ncolors.bgGray = format(100, 49);\n\ncolors.redBright = format(91, 39);\ncolors.greenBright = format(92, 39);\ncolors.yellowBright = format(93, 39);\ncolors.blueBright = format(94, 39);\ncolors.magentaBright = format(95, 39);\ncolors.cyanBright = format(96, 39);\ncolors.whiteBright = format(97, 39);\n\ncolors.bgRedBright = format(101, 49);\ncolors.bgGreenBright = format(102, 49);\ncolors.bgYellowBright = format(103, 49);\ncolors.bgBlueBright = format(104, 49);\ncolors.bgMagentaBright = format(105, 49);\ncolors.bgCyanBright = format(106, 49);\ncolors.bgWhiteBright = format(107, 49);\n\nmodule.exports = colors;\n","'use strict'\n\nconst https = require('https')\nconst http = require('http')\nconst { URL } = require('url')\n\nclass HttpProxyAgent extends http.Agent {\n  constructor (options) {\n    const { proxy, proxyRequestOptions, ...opts } = options\n    super(opts)\n    this.proxy = typeof proxy === 'string'\n      ? new URL(proxy)\n      : proxy\n    this.proxyRequestOptions = proxyRequestOptions || {}\n  }\n\n  createConnection (options, callback) {\n    const requestOptions = {\n      ...this.proxyRequestOptions,\n      method: 'CONNECT',\n      host: this.proxy.hostname,\n      port: this.proxy.port,\n      path: `${options.host}:${options.port}`,\n      setHost: false,\n      headers: { ...this.proxyRequestOptions.headers, connection: this.keepAlive ? 'keep-alive' : 'close', host: `${options.host}:${options.port}` },\n      agent: false,\n      timeout: options.timeout || 0\n    }\n\n    if (this.proxy.username || this.proxy.password) {\n      const base64 = Buffer.from(`${decodeURIComponent(this.proxy.username || '')}:${decodeURIComponent(this.proxy.password || '')}`).toString('base64')\n      requestOptions.headers['proxy-authorization'] = `Basic ${base64}`\n    }\n\n    if (this.proxy.protocol === 'https:') {\n      requestOptions.servername = this.proxy.hostname\n    }\n\n    const request = (this.proxy.protocol === 'http:' ? http : https).request(requestOptions)\n    request.once('connect', (response, socket, head) => {\n      request.removeAllListeners()\n      socket.removeAllListeners()\n      if (response.statusCode === 200) {\n        callback(null, socket)\n      } else {\n        socket.destroy()\n        callback(new Error(`Bad response: ${response.statusCode}`), null)\n      }\n    })\n\n    request.once('timeout', () => {\n      request.destroy(new Error('Proxy timeout'))\n    })\n\n    request.once('error', err => {\n      request.removeAllListeners()\n      callback(err, null)\n    })\n\n    request.end()\n  }\n}\n\nclass HttpsProxyAgent extends https.Agent {\n  constructor (options) {\n    const { proxy, proxyRequestOptions, ...opts } = options\n    super(opts)\n    this.proxy = typeof proxy === 'string'\n      ? new URL(proxy)\n      : proxy\n    this.proxyRequestOptions = proxyRequestOptions || {}\n  }\n\n  createConnection (options, callback) {\n    const requestOptions = {\n      ...this.proxyRequestOptions,\n      method: 'CONNECT',\n      host: this.proxy.hostname,\n      port: this.proxy.port,\n      path: `${options.host}:${options.port}`,\n      setHost: false,\n      headers: { ...this.proxyRequestOptions.headers, connection: this.keepAlive ? 'keep-alive' : 'close', host: `${options.host}:${options.port}` },\n      agent: false,\n      timeout: options.timeout || 0\n    }\n\n    if (this.proxy.username || this.proxy.password) {\n      const base64 = Buffer.from(`${decodeURIComponent(this.proxy.username || '')}:${decodeURIComponent(this.proxy.password || '')}`).toString('base64')\n      requestOptions.headers['proxy-authorization'] = `Basic ${base64}`\n    }\n\n    // Necessary for the TLS check with the proxy to succeed.\n    if (this.proxy.protocol === 'https:') {\n      requestOptions.servername = this.proxy.hostname\n    }\n\n    const request = (this.proxy.protocol === 'http:' ? http : https).request(requestOptions)\n    request.once('connect', (response, socket, head) => {\n      request.removeAllListeners()\n      socket.removeAllListeners()\n      if (response.statusCode === 200) {\n        const secureSocket = super.createConnection({ ...options, socket })\n        callback(null, secureSocket)\n      } else {\n        socket.destroy()\n        callback(new Error(`Bad response: ${response.statusCode}`), null)\n      }\n    })\n\n    request.once('timeout', () => {\n      request.destroy(new Error('Proxy timeout'))\n    })\n\n    request.once('error', err => {\n      request.removeAllListeners()\n      callback(err, null)\n    })\n\n    request.end()\n  }\n}\n\nmodule.exports = {\n  HttpProxyAgent,\n  HttpsProxyAgent\n}\n","import mod from './index.js'\n\nexport default mod\nexport const HttpProxyAgent = mod.HttpProxyAgent\nexport const HttpsProxyAgent = mod.HttpsProxyAgent\n","'use strict'\n\nlet _process\nfunction getProcess() {\n  if (_process === undefined) {\n    // Use non-'node:' prefixed require to avoid Webpack errors.\n    // eslint-disable-next-line n/prefer-node-protocol\n    _process = require('process')\n  }\n  return _process\n}\n\nmodule.exports = function isInteractive({ stream = getProcess().stdout } = {}) {\n  if (!(stream && stream.isTTY)) {\n    return false\n  }\n  const { env } = getProcess()\n  return env.TERM !== 'dumb' && !('CI' in env)\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SocketSdk = void 0;\nexports.createUserAgentFromPkgJson = createUserAgentFromPkgJson;\nconst node_events_1 = __importDefault(require(\"node:events\"));\nconst node_fs_1 = require(\"node:fs\");\nconst node_http_1 = __importDefault(require(\"node:http\"));\nconst node_https_1 = __importDefault(require(\"node:https\"));\nconst node_path_1 = __importDefault(require(\"node:path\"));\nconst node_readline_1 = __importDefault(require(\"node:readline\"));\nconst abort_signal_1 = __importDefault(require(\"@socketsecurity/registry/lib/constants/abort-signal\"));\n// @ts-ignore\nconst package_json_1 = __importDefault(require(\"../package.json\"));\nconst DEFAULT_USER_AGENT = createUserAgentFromPkgJson(package_json_1.default);\nclass ResponseError extends Error {\n    response;\n    constructor(response, message = '') {\n        const statusCode = response.statusCode ?? 'unknown';\n        const statusMessage = response.statusMessage ?? 'No status message';\n        super(`Socket API ${message || 'Request failed'} (${statusCode}): ${statusMessage}`);\n        this.name = 'ResponseError';\n        this.response = response;\n        Error.captureStackTrace(this, ResponseError);\n    }\n}\nasync function createDeleteRequest(baseUrl, urlPath, options) {\n    const req = getHttpModule(baseUrl)\n        .request(`${baseUrl}${urlPath}`, {\n        method: 'DELETE',\n        ...options\n    })\n        .end();\n    return await getResponse(req);\n}\nasync function createGetRequest(baseUrl, urlPath, options) {\n    const req = getHttpModule(baseUrl)\n        .request(`${baseUrl}${urlPath}`, {\n        method: 'GET',\n        ...options\n    })\n        .end();\n    return await getResponse(req);\n}\nasync function createPostRequest(baseUrl, urlPath, postJson, options) {\n    const req = getHttpModule(baseUrl)\n        .request(`${baseUrl}${urlPath}`, {\n        method: 'POST',\n        ...options\n    })\n        .end(JSON.stringify(postJson));\n    return await getResponse(req);\n}\nfunction createRequestBodyForFilepaths(filepaths, basePath) {\n    const requestBody = [];\n    for (const absPath of filepaths) {\n        const relPath = node_path_1.default.relative(basePath, absPath);\n        const filename = node_path_1.default.basename(absPath);\n        requestBody.push(`Content-Disposition: form-data; name=\"${relPath}\"; filename=\"${filename}\"\\r\\n`, `Content-Type: application/octet-stream\\r\\n\\r\\n`, (0, node_fs_1.createReadStream)(absPath));\n    }\n    return requestBody;\n}\nfunction createRequestBodyForJson(jsonData, basename = 'data.json') {\n    const ext = node_path_1.default.extname(basename);\n    const name = node_path_1.default.basename(basename, ext);\n    return [\n        `Content-Disposition: form-data; name=\"${name}\"; filename=\"${basename}\"\\r\\n`,\n        'Content-Type: application/json\\r\\n\\r\\n',\n        JSON.stringify(jsonData),\n        // New line after file content.\n        '\\r\\n'\n    ];\n}\nasync function createUploadRequest(baseUrl, urlPath, requestBodyNoBoundaries, options) {\n    // Generate a unique boundary for multipart encoding.\n    const boundary = `NodeMultipartBoundary${Date.now()}`;\n    const boundarySep = `--${boundary}\\r\\n`;\n    const finalBoundary = `--${boundary}--\\r\\n`;\n    const requestBody = [\n        ...requestBodyNoBoundaries.flatMap(part => [\n            boundarySep,\n            ...(Array.isArray(part) ? part : [part])\n        ]),\n        finalBoundary\n    ];\n    const url = new URL(urlPath, baseUrl);\n    const req = getHttpModule(baseUrl).request(url, {\n        method: 'POST',\n        ...options,\n        headers: {\n            ...options?.headers,\n            'Content-Type': `multipart/form-data; boundary=${boundary}`\n        }\n    });\n    let aborted = false;\n    req.on('error', _err => {\n        aborted = true;\n    });\n    req.on('close', () => {\n        aborted = true;\n    });\n    try {\n        // Send the request body (headers + files).\n        for (const part of requestBody) {\n            if (aborted) {\n                break;\n            }\n            if (typeof part === 'string') {\n                req.write(part);\n            }\n            else if (typeof part?.pipe === 'function') {\n                part.pipe(req, { end: false });\n                // Wait for file streaming to complete.\n                // eslint-disable-next-line no-await-in-loop\n                await node_events_1.default.once(part, 'end');\n                if (!aborted) {\n                    // Ensure a new line after file content.\n                    req.write('\\r\\n');\n                }\n            }\n            else {\n                throw new TypeError('Socket API - Invalid multipart part, expected string or stream');\n            }\n        }\n    }\n    catch (e) {\n        req.destroy(e);\n        throw e;\n    }\n    finally {\n        if (!aborted) {\n            // Close request after writing all data.\n            req.end();\n        }\n    }\n    return await getResponse(req);\n}\nasync function getErrorResponseBody(response) {\n    const chunks = [];\n    response.on('data', (chunk) => chunks.push(chunk));\n    try {\n        await node_events_1.default.once(response, 'end');\n        return Buffer.concat(chunks).toString('utf8');\n    }\n    catch {\n        return '(there was an error reading the body content)';\n    }\n}\nfunction getHttpModule(baseUrl) {\n    const { protocol } = new URL(baseUrl);\n    return protocol === 'https:' ? node_https_1.default : node_http_1.default;\n}\nasync function getResponse(req) {\n    try {\n        const { 0: res } = (await node_events_1.default.once(req, 'response', {\n            signal: abort_signal_1.default\n        }));\n        if (!isResponseOk(res)) {\n            throw new ResponseError(res, `${req.method} request failed`);\n        }\n        return res;\n    }\n    catch (e) {\n        req.destroy();\n        throw e;\n    }\n}\nasync function getResponseJson(response) {\n    let data = '';\n    for await (const chunk of response) {\n        data += chunk;\n    }\n    try {\n        return JSON.parse(data);\n    }\n    catch (e) {\n        throw new SyntaxError(`Socket API - Invalid JSON response:\\n${data}\\n→ ${e?.message || 'Unknown error'}`, { cause: e });\n    }\n}\nfunction isResponseOk(response) {\n    const { statusCode } = response;\n    return (typeof statusCode === 'number' && statusCode >= 200 && statusCode <= 299);\n}\nfunction resolveAbsPaths(filepaths, pathsRelativeTo) {\n    const basePath = resolveBasePath(pathsRelativeTo);\n    // Node's path.resolve will process path segments from right to left until\n    // it creates a valid absolute path. So if `pathsRelativeTo` is an absolute\n    // path, process.cwd() is not used, which is the common expectation. If none\n    // of the paths resolve then it defaults to process.cwd().\n    return filepaths.map(p => node_path_1.default.resolve(basePath, p));\n}\nfunction resolveBasePath(pathsRelativeTo = '.') {\n    // Node's path.resolve will process path segments from right to left until\n    // it creates a valid absolute path. So if `pathsRelativeTo` is an absolute\n    // path, process.cwd() is not used, which is the common expectation. If none\n    // of the paths resolve then it defaults to process.cwd().\n    return node_path_1.default.resolve(process.cwd(), pathsRelativeTo);\n}\n/**\n * Package.json data to base the User-Agent on\n */\nfunction createUserAgentFromPkgJson(pkgData) {\n    const { homepage } = pkgData;\n    const name = pkgData.name.replace('@', '').replace('/', '-');\n    return `${name}/${pkgData.version}${homepage ? ` (${homepage})` : ''}`;\n}\n// https://github.com/sindresorhus/got/blob/v14.4.6/documentation/2-options.md#agent\nconst agentNames = new Set(['http', 'https', 'http2']);\nclass SocketSdk {\n    #baseUrl;\n    #reqOptions;\n    /**\n     * @throws {SocketSdkAuthError}\n     */\n    constructor(apiToken, options) {\n        const { agent: agentOrObj, baseUrl = 'https://api.socket.dev/v0/', userAgent } = { __proto__: null, ...options };\n        const agentKeys = agentOrObj ? Object.keys(agentOrObj) : [];\n        const agent = (agentKeys.length && agentKeys.every(k => agentNames.has(k))\n            ? agentOrObj.https\n            : agentOrObj);\n        this.#baseUrl = baseUrl;\n        this.#reqOptions = {\n            ...(agent ? { agent } : {}),\n            headers: {\n                Authorization: `Basic ${btoa(`${apiToken}:`)}`,\n                'User-Agent': userAgent ?? DEFAULT_USER_AGENT\n            },\n            signal: abort_signal_1.default\n        };\n    }\n    async #createBatchPurlRequest(queryParams, componentsObj) {\n        // Adds the first 'abort' listener to abortSignal.\n        const req = getHttpModule(this.#baseUrl)\n            .request(`${this.#baseUrl}purl?${new URLSearchParams(queryParams ?? '')}`, {\n            method: 'POST',\n            ...this.#reqOptions\n        })\n            .end(JSON.stringify(componentsObj));\n        return await getResponse(req);\n    }\n    async *#createBatchPurlGenerator(queryParams, componentsObj) {\n        let res;\n        try {\n            res = await this.#createBatchPurlRequest(queryParams, componentsObj);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n        const rli = node_readline_1.default.createInterface({\n            input: res,\n            crlfDelay: Infinity,\n            signal: abort_signal_1.default\n        });\n        for await (const line of rli) {\n            yield this.#handleApiSuccess(JSON.parse(line));\n        }\n    }\n    async #handleApiError(error) {\n        if (!(error instanceof ResponseError)) {\n            throw new Error('Unexpected Socket API error', {\n                cause: error\n            });\n        }\n        const statusCode = error.response.statusCode;\n        if (statusCode >= 500) {\n            throw new Error(`Socket API server error (${statusCode})`, {\n                cause: error\n            });\n        }\n        // The error payload may give a meaningful hint as to what went wrong.\n        const bodyStr = await getErrorResponseBody(error.response);\n        // Try to parse the body as JSON, fallback to treating as plain text.\n        let body;\n        try {\n            const parsed = JSON.parse(bodyStr);\n            // A 400 should return an actionable message.\n            // TODO: Do we care about the body.error.details object?\n            if (typeof parsed?.error?.message === 'string') {\n                body = parsed.error.message;\n            }\n        }\n        catch {\n            body = bodyStr;\n        }\n        return {\n            success: false,\n            status: statusCode,\n            error: error.message ?? '',\n            cause: body\n        };\n    }\n    #handleApiSuccess(data) {\n        return {\n            success: true,\n            status: 200,\n            data: data\n        };\n    }\n    async batchPackageFetch(queryParams, componentsObj) {\n        let res;\n        try {\n            res = await this.#createBatchPurlRequest(queryParams, componentsObj);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n        // Parse the newline delimited JSON response.\n        const rl = node_readline_1.default.createInterface({\n            input: res,\n            crlfDelay: Infinity\n        });\n        const results = [];\n        for await (const line of rl) {\n            if (line.trim()) {\n                results.push(JSON.parse(line));\n            }\n        }\n        return this.#handleApiSuccess(results);\n    }\n    async *batchPackageStream(queryParams, componentsObj, options) {\n        const { chunkSize = 5, concurrencyLimit = 10 } = {\n            __proto__: null,\n            ...options\n        };\n        // The createBatchPurlGenerator method will add 2 'abort' event listeners to\n        // abortSignal so we multiply the concurrencyLimit by 2.\n        const neededMaxListeners = concurrencyLimit * 2;\n        // Increase abortSignal max listeners count to avoid Node's MaxListenersExceededWarning.\n        const oldAbortSignalMaxListeners = node_events_1.default.getMaxListeners(abort_signal_1.default);\n        let abortSignalMaxListeners = oldAbortSignalMaxListeners;\n        if (oldAbortSignalMaxListeners < neededMaxListeners) {\n            abortSignalMaxListeners = oldAbortSignalMaxListeners + neededMaxListeners;\n            node_events_1.default.setMaxListeners(abortSignalMaxListeners, abort_signal_1.default);\n        }\n        const { components } = componentsObj;\n        const { length: componentsCount } = components;\n        const running = [];\n        let index = 0;\n        const enqueueGen = () => {\n            if (index >= componentsCount) {\n                // No more work to do.\n                return;\n            }\n            const generator = this.#createBatchPurlGenerator(queryParams, {\n                // Chunk components.\n                components: components.slice(index, index + chunkSize)\n            });\n            continueGen(generator);\n            index += chunkSize;\n        };\n        const continueGen = (generator) => {\n            let resolveFn;\n            running.push({\n                generator,\n                promise: new Promise(resolve => (resolveFn = resolve))\n            });\n            void generator\n                .next()\n                .then(iteratorResult => resolveFn({ generator, iteratorResult }));\n        };\n        // Start initial batch of generators.\n        while (running.length < concurrencyLimit && index < componentsCount) {\n            enqueueGen();\n        }\n        while (running.length > 0) {\n            // eslint-disable-next-line no-await-in-loop\n            const { generator, iteratorResult } = await Promise.race(running.map(entry => entry.promise));\n            // Remove generator.\n            running.splice(running.findIndex(entry => entry.generator === generator), 1);\n            if (iteratorResult.done) {\n                // Start a new generator if available.\n                enqueueGen();\n            }\n            else {\n                yield iteratorResult.value;\n                // Keep fetching values from this generator.\n                continueGen(generator);\n            }\n        }\n        // Reset abortSignal max listeners count.\n        if (abortSignalMaxListeners > oldAbortSignalMaxListeners) {\n            node_events_1.default.setMaxListeners(oldAbortSignalMaxListeners, abort_signal_1.default);\n        }\n    }\n    async createDependenciesSnapshot(params, filepaths, pathsRelativeTo = '.') {\n        const basePath = resolveBasePath(pathsRelativeTo);\n        const absFilepaths = resolveAbsPaths(filepaths, basePath);\n        try {\n            const data = await getResponseJson(await createUploadRequest(this.#baseUrl, `dependencies/upload?${new URLSearchParams(params)}`, createRequestBodyForFilepaths(absFilepaths, basePath), this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async createOrgFullScan(orgSlug, queryParams, filepaths, pathsRelativeTo = '.') {\n        const basePath = resolveBasePath(pathsRelativeTo);\n        const absFilepaths = resolveAbsPaths(filepaths, basePath);\n        try {\n            const data = await getResponseJson(await createUploadRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/full-scans?${new URLSearchParams(queryParams ?? '')}`, createRequestBodyForFilepaths(absFilepaths, basePath), this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async createOrgRepo(orgSlug, params) {\n        try {\n            const data = await getResponseJson(await createPostRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/repos`, params, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async createReportFromFilepaths(filepaths, pathsRelativeTo = '.', issueRules) {\n        const basePath = resolveBasePath(pathsRelativeTo);\n        const absFilepaths = resolveAbsPaths(filepaths, basePath);\n        try {\n            const data = await createUploadRequest(this.#baseUrl, 'report/upload', [\n                ...createRequestBodyForFilepaths(absFilepaths, basePath),\n                ...(issueRules\n                    ? createRequestBodyForJson(issueRules, 'issueRules')\n                    : [])\n            ], {\n                ...this.#reqOptions,\n                method: 'PUT'\n            });\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    // Alias to preserve backwards compatibility.\n    async createReportFromFilePaths(filepaths, pathsRelativeTo = '.', issueRules) {\n        return await this.createReportFromFilepaths(filepaths, pathsRelativeTo, issueRules);\n    }\n    async deleteOrgFullScan(orgSlug, fullScanId) {\n        try {\n            const data = await getResponseJson(await createDeleteRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/full-scans/${encodeURIComponent(fullScanId)}`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async deleteOrgRepo(orgSlug, repoSlug) {\n        try {\n            const data = await getResponseJson(await createDeleteRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/repos/${encodeURIComponent(repoSlug)}`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getAuditLogEvents(orgSlug, queryParams) {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/audit-log?${new URLSearchParams(queryParams ?? '')}`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getIssuesByNPMPackage(pkgName, version) {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `npm/${encodeURIComponent(pkgName)}/${encodeURIComponent(version)}/issues`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getOrgAnalytics(time) {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `analytics/org/${encodeURIComponent(time)}`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getOrganizations() {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, 'organizations', this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getOrgFullScan(orgSlug, fullScanId, file) {\n        try {\n            const req = getHttpModule(this.#baseUrl)\n                .request(`${this.#baseUrl}orgs/${encodeURIComponent(orgSlug)}/full-scans/${encodeURIComponent(fullScanId)}`, {\n                method: 'GET',\n                ...this.#reqOptions\n            })\n                .end();\n            const res = await getResponse(req);\n            if (file) {\n                res.pipe((0, node_fs_1.createWriteStream)(file));\n            }\n            else {\n                res.pipe(process.stdout);\n            }\n            return this.#handleApiSuccess(res);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getOrgFullScanList(orgSlug, queryParams) {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/full-scans?${new URLSearchParams(queryParams ?? '')}`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getOrgFullScanMetadata(orgSlug, fullScanId) {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/full-scans/${encodeURIComponent(fullScanId)}/metadata`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getOrgLicensePolicy(orgSlug) {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/settings/license-policy`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getOrgRepo(orgSlug, repoSlug) {\n        const orgSlugParam = encodeURIComponent(orgSlug);\n        const repoSlugParam = encodeURIComponent(repoSlug);\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${orgSlugParam}/repos/${repoSlugParam}`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getOrgRepoList(orgSlug, queryParams) {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/repos?${new URLSearchParams(queryParams ?? '')}`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getOrgSecurityPolicy(orgSlug) {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/settings/security-policy`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getQuota() {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, 'quota', this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getRepoAnalytics(repo, time) {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `analytics/repo/${encodeURIComponent(repo)}/${encodeURIComponent(time)}`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getReport(id) {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `report/view/${encodeURIComponent(id)}`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getReportList() {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, 'report/list', this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getReportSupportedFiles() {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, 'report/supported', this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async getScoreByNPMPackage(pkgName, version) {\n        try {\n            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `npm/${encodeURIComponent(pkgName)}/${encodeURIComponent(version)}/score`, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async postSettings(selectors) {\n        try {\n            const data = await getResponseJson(await createPostRequest(this.#baseUrl, 'settings', { json: selectors }, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async searchDependencies(params) {\n        try {\n            const data = await getResponseJson(await createPostRequest(this.#baseUrl, 'dependencies/search', params, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n    async updateOrgRepo(orgSlug, repoSlug, params) {\n        try {\n            const data = await getResponseJson(await createPostRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/repos/${encodeURIComponent(repoSlug)}`, params, this.#reqOptions));\n            return this.#handleApiSuccess(data);\n        }\n        catch (e) {\n            return await this.#handleApiError(e);\n        }\n    }\n}\nexports.SocketSdk = SocketSdk;\n//# sourceMappingURL=index.js.map","import require$$0$1, { format } from 'util';\nimport { normalize as normalize$1, resolve } from 'path';\nimport { readFileSync } from 'fs';\nimport path$1 from 'node:path';\nimport process$2 from 'node:process';\nimport { fileURLToPath } from 'node:url';\nimport fs$1 from 'node:fs';\nimport require$$0$2 from 'os';\nimport require$$0 from 'url';\nfunction camelCase$1(str) {\n    const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();\n    if (!isCamelCase) {\n        str = str.toLowerCase();\n    }\n    if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {\n        return str;\n    }\n    else {\n        let camelcase = '';\n        let nextChrUpper = false;\n        const leadingHyphens = str.match(/^-+/);\n        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {\n            let chr = str.charAt(i);\n            if (nextChrUpper) {\n                nextChrUpper = false;\n                chr = chr.toUpperCase();\n            }\n            if (i !== 0 && (chr === '-' || chr === '_')) {\n                nextChrUpper = true;\n            }\n            else if (chr !== '-' && chr !== '_') {\n                camelcase += chr;\n            }\n        }\n        return camelcase;\n    }\n}\nfunction decamelize$1(str, joinString) {\n    const lowercase = str.toLowerCase();\n    joinString = joinString || '-';\n    let notCamelcase = '';\n    for (let i = 0; i < str.length; i++) {\n        const chrLower = lowercase.charAt(i);\n        const chrString = str.charAt(i);\n        if (chrLower !== chrString && i > 0) {\n            notCamelcase += `${joinString}${lowercase.charAt(i)}`;\n        }\n        else {\n            notCamelcase += chrString;\n        }\n    }\n    return notCamelcase;\n}\nfunction looksLikeNumber(x) {\n    if (x === null || x === undefined)\n        return false;\n    if (typeof x === 'number')\n        return true;\n    if (/^0x[0-9a-f]+$/i.test(x))\n        return true;\n    if (/^0[^.]/.test(x))\n        return false;\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n}\nfunction tokenizeArgString(argString) {\n    if (Array.isArray(argString)) {\n        return argString.map(e => typeof e !== 'string' ? e + '' : e);\n    }\n    argString = argString.trim();\n    let i = 0;\n    let prevC = null;\n    let c = null;\n    let opening = null;\n    const args = [];\n    for (let ii = 0; ii < argString.length; ii++) {\n        prevC = c;\n        c = argString.charAt(ii);\n        if (c === ' ' && !opening) {\n            if (!(prevC === ' ')) {\n                i++;\n            }\n            continue;\n        }\n        if (c === opening) {\n            opening = null;\n        }\n        else if ((c === \"'\" || c === '\"') && !opening) {\n            opening = c;\n        }\n        if (!args[i])\n            args[i] = '';\n        args[i] += c;\n    }\n    return args;\n}\nvar DefaultValuesForTypeKey;\n(function (DefaultValuesForTypeKey) {\n    DefaultValuesForTypeKey[\"BOOLEAN\"] = \"boolean\";\n    DefaultValuesForTypeKey[\"STRING\"] = \"string\";\n    DefaultValuesForTypeKey[\"NUMBER\"] = \"number\";\n    DefaultValuesForTypeKey[\"ARRAY\"] = \"array\";\n})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));\nlet mixin;\nclass YargsParser {\n    constructor(_mixin) {\n        mixin = _mixin;\n    }\n    parse(argsInput, options) {\n        const opts = Object.assign({\n            alias: undefined,\n            array: undefined,\n            boolean: undefined,\n            config: undefined,\n            configObjects: undefined,\n            configuration: undefined,\n            coerce: undefined,\n            count: undefined,\n            default: undefined,\n            envPrefix: undefined,\n            narg: undefined,\n            normalize: undefined,\n            string: undefined,\n            number: undefined,\n            __: undefined,\n            key: undefined\n        }, options);\n        const args = tokenizeArgString(argsInput);\n        const inputIsString = typeof argsInput === 'string';\n        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n        const configuration = Object.assign({\n            'boolean-negation': true,\n            'camel-case-expansion': true,\n            'combine-arrays': false,\n            'dot-notation': true,\n            'duplicate-arguments-array': true,\n            'flatten-duplicate-arrays': true,\n            'greedy-arrays': true,\n            'halt-at-non-option': false,\n            'nargs-eats-options': false,\n            'negation-prefix': 'no-',\n            'parse-numbers': true,\n            'parse-positional-numbers': true,\n            'populate--': false,\n            'set-placeholder-key': false,\n            'short-option-groups': true,\n            'strip-aliased': false,\n            'strip-dashed': false,\n            'unknown-options-as-args': false\n        }, opts.configuration);\n        const defaults = Object.assign(Object.create(null), opts.default);\n        const configObjects = opts.configObjects || [];\n        const envPrefix = opts.envPrefix;\n        const notFlagsOption = configuration['populate--'];\n        const notFlagsArgv = notFlagsOption ? '--' : '_';\n        const newAliases = Object.create(null);\n        const defaulted = Object.create(null);\n        const __ = opts.__ || mixin.format;\n        const flags = {\n            aliases: Object.create(null),\n            arrays: Object.create(null),\n            bools: Object.create(null),\n            strings: Object.create(null),\n            numbers: Object.create(null),\n            counts: Object.create(null),\n            normalize: Object.create(null),\n            configs: Object.create(null),\n            nargs: Object.create(null),\n            coercions: Object.create(null),\n            keys: []\n        };\n        const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {\n            const key = typeof opt === 'object' ? opt.key : opt;\n            const assignment = Object.keys(opt).map(function (key) {\n                const arrayFlagKeys = {\n                    boolean: 'bools',\n                    string: 'strings',\n                    number: 'numbers'\n                };\n                return arrayFlagKeys[key];\n            }).filter(Boolean).pop();\n            if (assignment) {\n                flags[assignment][key] = true;\n            }\n            flags.arrays[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {\n            flags.bools[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.string || []).filter(Boolean).forEach(function (key) {\n            flags.strings[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.number || []).filter(Boolean).forEach(function (key) {\n            flags.numbers[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.count || []).filter(Boolean).forEach(function (key) {\n            flags.counts[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {\n            flags.normalize[key] = true;\n            flags.keys.push(key);\n        });\n        if (typeof opts.narg === 'object') {\n            Object.entries(opts.narg).forEach(([key, value]) => {\n                if (typeof value === 'number') {\n                    flags.nargs[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.coerce === 'object') {\n            Object.entries(opts.coerce).forEach(([key, value]) => {\n                if (typeof value === 'function') {\n                    flags.coercions[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.config !== 'undefined') {\n            if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n                [].concat(opts.config).filter(Boolean).forEach(function (key) {\n                    flags.configs[key] = true;\n                });\n            }\n            else if (typeof opts.config === 'object') {\n                Object.entries(opts.config).forEach(([key, value]) => {\n                    if (typeof value === 'boolean' || typeof value === 'function') {\n                        flags.configs[key] = value;\n                    }\n                });\n            }\n        }\n        extendAliases(opts.key, aliases, opts.default, flags.arrays);\n        Object.keys(defaults).forEach(function (key) {\n            (flags.aliases[key] || []).forEach(function (alias) {\n                defaults[alias] = defaults[key];\n            });\n        });\n        let error = null;\n        checkConfiguration();\n        let notFlags = [];\n        const argv = Object.assign(Object.create(null), { _: [] });\n        const argvReturn = {};\n        for (let i = 0; i < args.length; i++) {\n            const arg = args[i];\n            const truncatedArg = arg.replace(/^-{3,}/, '---');\n            let broken;\n            let key;\n            let letters;\n            let m;\n            let next;\n            let value;\n            if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {\n                pushPositional(arg);\n            }\n            else if (truncatedArg.match(/^---+(=|$)/)) {\n                pushPositional(arg);\n                continue;\n            }\n            else if (arg.match(/^--.+=/) || (!configuration['short-option-groups'] && arg.match(/^-.+=/))) {\n                m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/);\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    if (checkAllAliases(m[1], flags.arrays)) {\n                        i = eatArray(i, m[1], args, m[2]);\n                    }\n                    else if (checkAllAliases(m[1], flags.nargs) !== false) {\n                        i = eatNargs(i, m[1], args, m[2]);\n                    }\n                    else {\n                        setArg(m[1], m[2], true);\n                    }\n                }\n            }\n            else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n                m = arg.match(negatedBoolean);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);\n                }\n            }\n            else if (arg.match(/^--.+/) || (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))) {\n                m = arg.match(/^--?(.+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (checkAllAliases(key, flags.arrays)) {\n                        i = eatArray(i, key, args);\n                    }\n                    else if (checkAllAliases(key, flags.nargs) !== false) {\n                        i = eatNargs(i, key, args);\n                    }\n                    else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!next.match(/^-/) ||\n                            next.match(negative)) &&\n                            !checkAllAliases(key, flags.bools) &&\n                            !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n            }\n            else if (arg.match(/^-.\\..+=/)) {\n                m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    setArg(m[1], m[2]);\n                }\n            }\n            else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n                next = args[i + 1];\n                m = arg.match(/^-(.\\..+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (next !== undefined && !next.match(/^-/) &&\n                        !checkAllAliases(key, flags.bools) &&\n                        !checkAllAliases(key, flags.counts)) {\n                        setArg(key, next);\n                        i++;\n                    }\n                    else {\n                        setArg(key, defaultValue(key));\n                    }\n                }\n            }\n            else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n                letters = arg.slice(1, -1).split('');\n                broken = false;\n                for (let j = 0; j < letters.length; j++) {\n                    next = arg.slice(j + 2);\n                    if (letters[j + 1] && letters[j + 1] === '=') {\n                        value = arg.slice(j + 3);\n                        key = letters[j];\n                        if (checkAllAliases(key, flags.arrays)) {\n                            i = eatArray(i, key, args, value);\n                        }\n                        else if (checkAllAliases(key, flags.nargs) !== false) {\n                            i = eatNargs(i, key, args, value);\n                        }\n                        else {\n                            setArg(key, value);\n                        }\n                        broken = true;\n                        break;\n                    }\n                    if (next === '-') {\n                        setArg(letters[j], next);\n                        continue;\n                    }\n                    if (/[A-Za-z]/.test(letters[j]) &&\n                        /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) &&\n                        checkAllAliases(next, flags.bools) === false) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    else {\n                        setArg(letters[j], defaultValue(letters[j]));\n                    }\n                }\n                key = arg.slice(-1)[0];\n                if (!broken && key !== '-') {\n                    if (checkAllAliases(key, flags.arrays)) {\n                        i = eatArray(i, key, args);\n                    }\n                    else if (checkAllAliases(key, flags.nargs) !== false) {\n                        i = eatNargs(i, key, args);\n                    }\n                    else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n                            next.match(negative)) &&\n                            !checkAllAliases(key, flags.bools) &&\n                            !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n            }\n            else if (arg.match(/^-[0-9]$/) &&\n                arg.match(negative) &&\n                checkAllAliases(arg.slice(1), flags.bools)) {\n                key = arg.slice(1);\n                setArg(key, defaultValue(key));\n            }\n            else if (arg === '--') {\n                notFlags = args.slice(i + 1);\n                break;\n            }\n            else if (configuration['halt-at-non-option']) {\n                notFlags = args.slice(i);\n                break;\n            }\n            else {\n                pushPositional(arg);\n            }\n        }\n        applyEnvVars(argv, true); \n        applyEnvVars(argv, false);\n        setConfig(argv);\n        setConfigObjects();\n        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n        applyCoercions(argv);\n        if (configuration['set-placeholder-key'])\n            setPlaceholderKeys(argv);\n        Object.keys(flags.counts).forEach(function (key) {\n            if (!hasKey(argv, key.split('.')))\n                setArg(key, 0);\n        });\n        if (notFlagsOption && notFlags.length)\n            argv[notFlagsArgv] = [];\n        notFlags.forEach(function (key) {\n            argv[notFlagsArgv].push(key);\n        });\n        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n            Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n                delete argv[key];\n            });\n        }\n        if (configuration['strip-aliased']) {\n            [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n                if (configuration['camel-case-expansion'] && alias.includes('-')) {\n                    delete argv[alias.split('.').map(prop => camelCase$1(prop)).join('.')];\n                }\n                delete argv[alias];\n            });\n        }\n        function pushPositional(arg) {\n            const maybeCoercedNumber = maybeCoerceNumber('_', arg);\n            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {\n                argv._.push(maybeCoercedNumber);\n            }\n        }\n        function eatNargs(i, key, args, argAfterEqualSign) {\n            let ii;\n            let toEat = checkAllAliases(key, flags.nargs);\n            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;\n            if (toEat === 0) {\n                if (!isUndefined(argAfterEqualSign)) {\n                    error = Error(__('Argument unexpected for: %s', key));\n                }\n                setArg(key, defaultValue(key));\n                return i;\n            }\n            let available = isUndefined(argAfterEqualSign) ? 0 : 1;\n            if (configuration['nargs-eats-options']) {\n                if (args.length - (i + 1) + available < toEat) {\n                    error = Error(__('Not enough arguments following: %s', key));\n                }\n                available = toEat;\n            }\n            else {\n                for (ii = i + 1; ii < args.length; ii++) {\n                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))\n                        available++;\n                    else\n                        break;\n                }\n                if (available < toEat)\n                    error = Error(__('Not enough arguments following: %s', key));\n            }\n            let consumed = Math.min(available, toEat);\n            if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n                setArg(key, argAfterEqualSign);\n                consumed--;\n            }\n            for (ii = i + 1; ii < (consumed + i + 1); ii++) {\n                setArg(key, args[ii]);\n            }\n            return (i + consumed);\n        }\n        function eatArray(i, key, args, argAfterEqualSign) {\n            let argsToSet = [];\n            let next = argAfterEqualSign || args[i + 1];\n            const nargsCount = checkAllAliases(key, flags.nargs);\n            if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {\n                argsToSet.push(true);\n            }\n            else if (isUndefined(next) ||\n                (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {\n                if (defaults[key] !== undefined) {\n                    const defVal = defaults[key];\n                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];\n                }\n            }\n            else {\n                if (!isUndefined(argAfterEqualSign)) {\n                    argsToSet.push(processValue(key, argAfterEqualSign, true));\n                }\n                for (let ii = i + 1; ii < args.length; ii++) {\n                    if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||\n                        (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount))\n                        break;\n                    next = args[ii];\n                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))\n                        break;\n                    i = ii;\n                    argsToSet.push(processValue(key, next, inputIsString));\n                }\n            }\n            if (typeof nargsCount === 'number' && ((nargsCount && argsToSet.length < nargsCount) ||\n                (isNaN(nargsCount) && argsToSet.length === 0))) {\n                error = Error(__('Not enough arguments following: %s', key));\n            }\n            setArg(key, argsToSet);\n            return i;\n        }\n        function setArg(key, val, shouldStripQuotes = inputIsString) {\n            if (/-/.test(key) && configuration['camel-case-expansion']) {\n                const alias = key.split('.').map(function (prop) {\n                    return camelCase$1(prop);\n                }).join('.');\n                addNewAlias(key, alias);\n            }\n            const value = processValue(key, val, shouldStripQuotes);\n            const splitKey = key.split('.');\n            setKey(argv, splitKey, value);\n            if (flags.aliases[key]) {\n                flags.aliases[key].forEach(function (x) {\n                    const keyProperties = x.split('.');\n                    setKey(argv, keyProperties, value);\n                });\n            }\n            if (splitKey.length > 1 && configuration['dot-notation']) {\n                (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n                    let keyProperties = x.split('.');\n                    const a = [].concat(splitKey);\n                    a.shift(); \n                    keyProperties = keyProperties.concat(a);\n                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {\n                        setKey(argv, keyProperties, value);\n                    }\n                });\n            }\n            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n                const keys = [key].concat(flags.aliases[key] || []);\n                keys.forEach(function (key) {\n                    Object.defineProperty(argvReturn, key, {\n                        enumerable: true,\n                        get() {\n                            return val;\n                        },\n                        set(value) {\n                            val = typeof value === 'string' ? mixin.normalize(value) : value;\n                        }\n                    });\n                });\n            }\n        }\n        function addNewAlias(key, alias) {\n            if (!(flags.aliases[key] && flags.aliases[key].length)) {\n                flags.aliases[key] = [alias];\n                newAliases[alias] = true;\n            }\n            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n                addNewAlias(alias, key);\n            }\n        }\n        function processValue(key, val, shouldStripQuotes) {\n            if (shouldStripQuotes) {\n                val = stripQuotes(val);\n            }\n            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n                if (typeof val === 'string')\n                    val = val === 'true';\n            }\n            let value = Array.isArray(val)\n                ? val.map(function (v) { return maybeCoerceNumber(key, v); })\n                : maybeCoerceNumber(key, val);\n            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n                value = increment();\n            }\n            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n                if (Array.isArray(val))\n                    value = val.map((val) => { return mixin.normalize(val); });\n                else\n                    value = mixin.normalize(val);\n            }\n            return value;\n        }\n        function maybeCoerceNumber(key, value) {\n            if (!configuration['parse-positional-numbers'] && key === '_')\n                return value;\n            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));\n                if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) {\n                    value = Number(value);\n                }\n            }\n            return value;\n        }\n        function setConfig(argv) {\n            const configLookup = Object.create(null);\n            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n            Object.keys(flags.configs).forEach(function (configKey) {\n                const configPath = argv[configKey] || configLookup[configKey];\n                if (configPath) {\n                    try {\n                        let config = null;\n                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);\n                        const resolveConfig = flags.configs[configKey];\n                        if (typeof resolveConfig === 'function') {\n                            try {\n                                config = resolveConfig(resolvedConfigPath);\n                            }\n                            catch (e) {\n                                config = e;\n                            }\n                            if (config instanceof Error) {\n                                error = config;\n                                return;\n                            }\n                        }\n                        else {\n                            config = mixin.require(resolvedConfigPath);\n                        }\n                        setConfigObject(config);\n                    }\n                    catch (ex) {\n                        if (ex.name === 'PermissionDenied')\n                            error = ex;\n                        else if (argv[configKey])\n                            error = Error(__('Invalid JSON config file: %s', configPath));\n                    }\n                }\n            });\n        }\n        function setConfigObject(config, prev) {\n            Object.keys(config).forEach(function (key) {\n                const value = config[key];\n                const fullKey = prev ? prev + '.' + key : key;\n                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n                    setConfigObject(value, fullKey);\n                }\n                else {\n                    if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {\n                        setArg(fullKey, value);\n                    }\n                }\n            });\n        }\n        function setConfigObjects() {\n            if (typeof configObjects !== 'undefined') {\n                configObjects.forEach(function (configObject) {\n                    setConfigObject(configObject);\n                });\n            }\n        }\n        function applyEnvVars(argv, configOnly) {\n            if (typeof envPrefix === 'undefined')\n                return;\n            const prefix = typeof envPrefix === 'string' ? envPrefix : '';\n            const env = mixin.env();\n            Object.keys(env).forEach(function (envVar) {\n                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n                    const keys = envVar.split('__').map(function (key, i) {\n                        if (i === 0) {\n                            key = key.substring(prefix.length);\n                        }\n                        return camelCase$1(key);\n                    });\n                    if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {\n                        setArg(keys.join('.'), env[envVar]);\n                    }\n                }\n            });\n        }\n        function applyCoercions(argv) {\n            let coerce;\n            const applied = new Set();\n            Object.keys(argv).forEach(function (key) {\n                if (!applied.has(key)) { \n                    coerce = checkAllAliases(key, flags.coercions);\n                    if (typeof coerce === 'function') {\n                        try {\n                            const value = maybeCoerceNumber(key, coerce(argv[key]));\n                            ([].concat(flags.aliases[key] || [], key)).forEach(ali => {\n                                applied.add(ali);\n                                argv[ali] = value;\n                            });\n                        }\n                        catch (err) {\n                            error = err;\n                        }\n                    }\n                }\n            });\n        }\n        function setPlaceholderKeys(argv) {\n            flags.keys.forEach((key) => {\n                if (~key.indexOf('.'))\n                    return;\n                if (typeof argv[key] === 'undefined')\n                    argv[key] = undefined;\n            });\n            return argv;\n        }\n        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {\n            Object.keys(defaults).forEach(function (key) {\n                if (!hasKey(obj, key.split('.'))) {\n                    setKey(obj, key.split('.'), defaults[key]);\n                    if (canLog)\n                        defaulted[key] = true;\n                    (aliases[key] || []).forEach(function (x) {\n                        if (hasKey(obj, x.split('.')))\n                            return;\n                        setKey(obj, x.split('.'), defaults[key]);\n                    });\n                }\n            });\n        }\n        function hasKey(obj, keys) {\n            let o = obj;\n            if (!configuration['dot-notation'])\n                keys = [keys.join('.')];\n            keys.slice(0, -1).forEach(function (key) {\n                o = (o[key] || {});\n            });\n            const key = keys[keys.length - 1];\n            if (typeof o !== 'object')\n                return false;\n            else\n                return key in o;\n        }\n        function setKey(obj, keys, value) {\n            let o = obj;\n            if (!configuration['dot-notation'])\n                keys = [keys.join('.')];\n            keys.slice(0, -1).forEach(function (key) {\n                key = sanitizeKey(key);\n                if (typeof o === 'object' && o[key] === undefined) {\n                    o[key] = {};\n                }\n                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n                    if (Array.isArray(o[key])) {\n                        o[key].push({});\n                    }\n                    else {\n                        o[key] = [o[key], {}];\n                    }\n                    o = o[key][o[key].length - 1];\n                }\n                else {\n                    o = o[key];\n                }\n            });\n            const key = sanitizeKey(keys[keys.length - 1]);\n            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n            const isValueArray = Array.isArray(value);\n            let duplicate = configuration['duplicate-arguments-array'];\n            if (!duplicate && checkAllAliases(key, flags.nargs)) {\n                duplicate = true;\n                if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {\n                    o[key] = undefined;\n                }\n            }\n            if (value === increment()) {\n                o[key] = increment(o[key]);\n            }\n            else if (Array.isArray(o[key])) {\n                if (duplicate && isTypeArray && isValueArray) {\n                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n                }\n                else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n                    o[key] = value;\n                }\n                else {\n                    o[key] = o[key].concat([value]);\n                }\n            }\n            else if (o[key] === undefined && isTypeArray) {\n                o[key] = isValueArray ? value : [value];\n            }\n            else if (duplicate && !(o[key] === undefined ||\n                checkAllAliases(key, flags.counts) ||\n                checkAllAliases(key, flags.bools))) {\n                o[key] = [o[key], value];\n            }\n            else {\n                o[key] = value;\n            }\n        }\n        function extendAliases(...args) {\n            args.forEach(function (obj) {\n                Object.keys(obj || {}).forEach(function (key) {\n                    if (flags.aliases[key])\n                        return;\n                    flags.aliases[key] = [].concat(aliases[key] || []);\n                    flags.aliases[key].concat(key).forEach(function (x) {\n                        if (/-/.test(x) && configuration['camel-case-expansion']) {\n                            const c = camelCase$1(x);\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    flags.aliases[key].concat(key).forEach(function (x) {\n                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n                            const c = decamelize$1(x, '-');\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    flags.aliases[key].forEach(function (x) {\n                        flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n                            return x !== y;\n                        }));\n                    });\n                });\n            });\n        }\n        function checkAllAliases(key, flag) {\n            const toCheck = [].concat(flags.aliases[key] || [], key);\n            const keys = Object.keys(flag);\n            const setAlias = toCheck.find(key => keys.includes(key));\n            return setAlias ? flag[setAlias] : false;\n        }\n        function hasAnyFlag(key) {\n            const flagsKeys = Object.keys(flags);\n            const toCheck = [].concat(flagsKeys.map(k => flags[k]));\n            return toCheck.some(function (flag) {\n                return Array.isArray(flag) ? flag.includes(key) : flag[key];\n            });\n        }\n        function hasFlagsMatching(arg, ...patterns) {\n            const toCheck = [].concat(...patterns);\n            return toCheck.some(function (pattern) {\n                const match = arg.match(pattern);\n                return match && hasAnyFlag(match[1]);\n            });\n        }\n        function hasAllShortFlags(arg) {\n            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n                return false;\n            }\n            let hasAllFlags = true;\n            let next;\n            const letters = arg.slice(1).split('');\n            for (let j = 0; j < letters.length; j++) {\n                next = arg.slice(j + 2);\n                if (!hasAnyFlag(letters[j])) {\n                    hasAllFlags = false;\n                    break;\n                }\n                if ((letters[j + 1] && letters[j + 1] === '=') ||\n                    next === '-' ||\n                    (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) ||\n                    (letters[j + 1] && letters[j + 1].match(/\\W/))) {\n                    break;\n                }\n            }\n            return hasAllFlags;\n        }\n        function isUnknownOptionAsArg(arg) {\n            return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n        }\n        function isUnknownOption(arg) {\n            arg = arg.replace(/^-{3,}/, '--');\n            if (arg.match(negative)) {\n                return false;\n            }\n            if (hasAllShortFlags(arg)) {\n                return false;\n            }\n            const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/;\n            const normalFlag = /^-+([^=]+?)$/;\n            const flagEndingInHyphen = /^-+([^=]+?)-$/;\n            const flagEndingInDigits = /^-+([^=]+?\\d+)$/;\n            const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/;\n            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n        }\n        function defaultValue(key) {\n            if (!checkAllAliases(key, flags.bools) &&\n                !checkAllAliases(key, flags.counts) &&\n                `${key}` in defaults) {\n                return defaults[key];\n            }\n            else {\n                return defaultForType(guessType(key));\n            }\n        }\n        function defaultForType(type) {\n            const def = {\n                [DefaultValuesForTypeKey.BOOLEAN]: true,\n                [DefaultValuesForTypeKey.STRING]: '',\n                [DefaultValuesForTypeKey.NUMBER]: undefined,\n                [DefaultValuesForTypeKey.ARRAY]: []\n            };\n            return def[type];\n        }\n        function guessType(key) {\n            let type = DefaultValuesForTypeKey.BOOLEAN;\n            if (checkAllAliases(key, flags.strings))\n                type = DefaultValuesForTypeKey.STRING;\n            else if (checkAllAliases(key, flags.numbers))\n                type = DefaultValuesForTypeKey.NUMBER;\n            else if (checkAllAliases(key, flags.bools))\n                type = DefaultValuesForTypeKey.BOOLEAN;\n            else if (checkAllAliases(key, flags.arrays))\n                type = DefaultValuesForTypeKey.ARRAY;\n            return type;\n        }\n        function isUndefined(num) {\n            return num === undefined;\n        }\n        function checkConfiguration() {\n            Object.keys(flags.counts).find(key => {\n                if (checkAllAliases(key, flags.arrays)) {\n                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));\n                    return true;\n                }\n                else if (checkAllAliases(key, flags.nargs)) {\n                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));\n                    return true;\n                }\n                return false;\n            });\n        }\n        return {\n            aliases: Object.assign({}, flags.aliases),\n            argv: Object.assign(argvReturn, argv),\n            configuration: configuration,\n            defaulted: Object.assign({}, defaulted),\n            error: error,\n            newAliases: Object.assign({}, newAliases)\n        };\n    }\n}\nfunction combineAliases(aliases) {\n    const aliasArrays = [];\n    const combined = Object.create(null);\n    let change = true;\n    Object.keys(aliases).forEach(function (key) {\n        aliasArrays.push([].concat(aliases[key], key));\n    });\n    while (change) {\n        change = false;\n        for (let i = 0; i < aliasArrays.length; i++) {\n            for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n                const intersect = aliasArrays[i].filter(function (v) {\n                    return aliasArrays[ii].indexOf(v) !== -1;\n                });\n                if (intersect.length) {\n                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n                    aliasArrays.splice(ii, 1);\n                    change = true;\n                    break;\n                }\n            }\n        }\n    }\n    aliasArrays.forEach(function (aliasArray) {\n        aliasArray = aliasArray.filter(function (v, i, self) {\n            return self.indexOf(v) === i;\n        });\n        const lastAlias = aliasArray.pop();\n        if (lastAlias !== undefined && typeof lastAlias === 'string') {\n            combined[lastAlias] = aliasArray;\n        }\n    });\n    return combined;\n}\nfunction increment(orig) {\n    return orig !== undefined ? orig + 1 : 1;\n}\nfunction sanitizeKey(key) {\n    if (key === '__proto__')\n        return '___proto___';\n    return key;\n}\nfunction stripQuotes(val) {\n    return (typeof val === 'string' &&\n        (val[0] === \"'\" || val[0] === '\"') &&\n        val[val.length - 1] === val[0])\n        ? val.substring(1, val.length - 1)\n        : val;\n}\nvar _a, _b, _c;\nconst minNodeVersion = (process && process.env && process.env.YARGS_MIN_NODE_VERSION)\n    ? Number(process.env.YARGS_MIN_NODE_VERSION)\n    : 12;\nconst nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);\nif (nodeVersion) {\n    const major = Number(nodeVersion.match(/^([^.]+)/)[1]);\n    if (major < minNodeVersion) {\n        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);\n    }\n}\nconst env$2 = process ? process.env : {};\nconst parser = new YargsParser({\n    cwd: process.cwd,\n    env: () => {\n        return env$2;\n    },\n    format,\n    normalize: normalize$1,\n    resolve,\n    require: (path) => {\n        if (typeof require !== 'undefined') {\n            return require(path);\n        }\n        else if (path.match(/\\.json$/)) {\n            return JSON.parse(readFileSync(path, 'utf8'));\n        }\n        else {\n            throw Error('only .json config files are supported in ESM');\n        }\n    }\n});\nconst yargsParser = function Parser(args, opts) {\n    const result = parser.parse(args.slice(), opts);\n    return result.argv;\n};\nyargsParser.detailed = function (args, opts) {\n    return parser.parse(args.slice(), opts);\n};\nyargsParser.camelCase = camelCase$1;\nyargsParser.decamelize = decamelize$1;\nyargsParser.looksLikeNumber = looksLikeNumber;\nconst isObject$3 = value => typeof value === 'object' && value !== null;\nconst isObjectCustom$1 = value =>\n\tisObject$3(value)\n\t&& !(value instanceof RegExp)\n\t&& !(value instanceof Error)\n\t&& !(value instanceof Date);\nconst mapObjectSkip$1 = Symbol('mapObjectSkip');\nconst _mapObject = (object, mapper, options, isSeen = new WeakMap()) => {\n\toptions = {\n\t\tdeep: false,\n\t\ttarget: {},\n\t\t...options,\n\t};\n\tif (isSeen.has(object)) {\n\t\treturn isSeen.get(object);\n\t}\n\tisSeen.set(object, options.target);\n\tconst {target} = options;\n\tdelete options.target;\n\tconst mapArray = array => array.map(element => isObjectCustom$1(element) ? _mapObject(element, mapper, options, isSeen) : element);\n\tif (Array.isArray(object)) {\n\t\treturn mapArray(object);\n\t}\n\tfor (const [key, value] of Object.entries(object)) {\n\t\tconst mapResult = mapper(key, value, object);\n\t\tif (mapResult === mapObjectSkip$1) {\n\t\t\tcontinue;\n\t\t}\n\t\tlet [newKey, newValue, {shouldRecurse = true} = {}] = mapResult;\n\t\tif (newKey === '__proto__') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (options.deep && shouldRecurse && isObjectCustom$1(newValue)) {\n\t\t\tnewValue = Array.isArray(newValue)\n\t\t\t\t? mapArray(newValue)\n\t\t\t\t: _mapObject(newValue, mapper, options, isSeen);\n\t\t}\n\t\ttarget[newKey] = newValue;\n\t}\n\treturn target;\n};\nfunction mapObject$2(object, mapper, options) {\n\tif (!isObject$3(object)) {\n\t\tthrow new TypeError(`Expected an object, got \\`${object}\\` (${typeof object})`);\n\t}\n\treturn _mapObject(object, mapper, options);\n}\nconst UPPERCASE = /[\\p{Lu}]/u;\nconst LOWERCASE = /[\\p{Ll}]/u;\nconst LEADING_CAPITAL = /^[\\p{Lu}](?![\\p{Lu}])/gu;\nconst IDENTIFIER$1 = /([\\p{Alpha}\\p{N}_]|$)/u;\nconst SEPARATORS = /[_.\\- ]+/;\nconst LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);\nconst SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER$1.source, 'gu');\nconst NUMBERS_AND_IDENTIFIER = new RegExp('\\\\d+' + IDENTIFIER$1.source, 'gu');\nconst preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase) => {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\tlet isLastLastCharPreserved = false;\n\tfor (let index = 0; index < string.length; index++) {\n\t\tconst character = string[index];\n\t\tisLastLastCharPreserved = index > 2 ? string[index - 3] === '-' : true;\n\t\tif (isLastCharLower && UPPERCASE.test(character)) {\n\t\t\tstring = string.slice(0, index) + '-' + string.slice(index);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\tindex++;\n\t\t} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase)) {\n\t\t\tstring = string.slice(0, index - 1) + '-' + string.slice(index - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;\n\t\t}\n\t}\n\treturn string;\n};\nconst preserveConsecutiveUppercase = (input, toLowerCase) => {\n\tLEADING_CAPITAL.lastIndex = 0;\n\treturn input.replaceAll(LEADING_CAPITAL, match => toLowerCase(match));\n};\nconst postProcess = (input, toUpperCase) => {\n\tSEPARATORS_AND_IDENTIFIER.lastIndex = 0;\n\tNUMBERS_AND_IDENTIFIER.lastIndex = 0;\n\treturn input\n\t\t.replaceAll(NUMBERS_AND_IDENTIFIER, (match, pattern, offset) => ['_', '-'].includes(input.charAt(offset + match.length)) ? match : toUpperCase(match))\n\t\t.replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier));\n};\nfunction camelCase(input, options) {\n\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t}\n\toptions = {\n\t\tpascalCase: false,\n\t\tpreserveConsecutiveUppercase: false,\n\t\t...options,\n\t};\n\tif (Array.isArray(input)) {\n\t\tinput = input.map(x => x.trim())\n\t\t\t.filter(x => x.length)\n\t\t\t.join('-');\n\t} else {\n\t\tinput = input.trim();\n\t}\n\tif (input.length === 0) {\n\t\treturn '';\n\t}\n\tconst toLowerCase = options.locale === false\n\t\t? string => string.toLowerCase()\n\t\t: string => string.toLocaleLowerCase(options.locale);\n\tconst toUpperCase = options.locale === false\n\t\t? string => string.toUpperCase()\n\t\t: string => string.toLocaleUpperCase(options.locale);\n\tif (input.length === 1) {\n\t\tif (SEPARATORS.test(input)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn options.pascalCase ? toUpperCase(input) : toLowerCase(input);\n\t}\n\tconst hasUpperCase = input !== toLowerCase(input);\n\tif (hasUpperCase) {\n\t\tinput = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);\n\t}\n\tinput = input.replace(LEADING_SEPARATORS, '');\n\tinput = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);\n\tif (options.pascalCase) {\n\t\tinput = toUpperCase(input.charAt(0)) + input.slice(1);\n\t}\n\treturn postProcess(input, toUpperCase);\n}\nclass QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\t\t\treturn this.delete(key);\n\t\t}\n\t\treturn false;\n\t}\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\t\treturn this._getItemValue(key, item);\n\t}\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\t\treturn this;\n\t}\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\t\treturn false;\n\t}\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\t\tthis.maxSize = newSize;\n\t}\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\nconst has$1 = (array, key) => array.some(element => {\n\tif (typeof element === 'string') {\n\t\treturn element === key;\n\t}\n\telement.lastIndex = 0;\n\treturn element.test(key);\n});\nconst cache$2 = new QuickLRU({maxSize: 100_000});\nconst isObject$2 = value =>\n\ttypeof value === 'object'\n\t\t&& value !== null\n\t\t&& !(value instanceof RegExp)\n\t\t&& !(value instanceof Error)\n\t\t&& !(value instanceof Date);\nconst transform$1 = (input, options = {}) => {\n\tif (!isObject$2(input)) {\n\t\treturn input;\n\t}\n\tconst {\n\t\texclude,\n\t\tpascalCase = false,\n\t\tstopPaths,\n\t\tdeep = false,\n\t\tpreserveConsecutiveUppercase = false,\n\t} = options;\n\tconst stopPathsSet = new Set(stopPaths);\n\tconst makeMapper = parentPath => (key, value) => {\n\t\tif (deep && isObject$2(value)) {\n\t\t\tconst path = parentPath === undefined ? key : `${parentPath}.${key}`;\n\t\t\tif (!stopPathsSet.has(path)) {\n\t\t\t\tvalue = mapObject$2(value, makeMapper(path));\n\t\t\t}\n\t\t}\n\t\tif (!(exclude && has$1(exclude, key))) {\n\t\t\tconst cacheKey = pascalCase ? `${key}_` : key;\n\t\t\tif (cache$2.has(cacheKey)) {\n\t\t\t\tkey = cache$2.get(cacheKey);\n\t\t\t} else {\n\t\t\t\tconst returnValue = camelCase(key, {pascalCase, locale: false, preserveConsecutiveUppercase});\n\t\t\t\tif (key.length < 100) { \n\t\t\t\t\tcache$2.set(cacheKey, returnValue);\n\t\t\t\t}\n\t\t\t\tkey = returnValue;\n\t\t\t}\n\t\t}\n\t\treturn [key, value];\n\t};\n\treturn mapObject$2(input, makeMapper(undefined));\n};\nfunction camelcaseKeys(input, options) {\n\tif (Array.isArray(input)) {\n\t\treturn Object.keys(input).map(key => transform$1(input[key], options));\n\t}\n\treturn transform$1(input, options);\n}\nfunction trimNewlines(string) {\n\tlet start = 0;\n\tlet end = string.length;\n\twhile (start < end && (string[start] === '\\r' || string[start] === '\\n')) {\n\t\tstart++;\n\t}\n\twhile (end > start && (string[end - 1] === '\\r' || string[end - 1] === '\\n')) {\n\t\tend--;\n\t}\n\treturn (start > 0 || end < string.length) ? string.slice(start, end) : string;\n}\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\nvar minIndent = string => {\n\tconst match = string.match(/^[ \\t]*(?=\\S)/gm);\n\tif (!match) {\n\t\treturn 0;\n\t}\n\treturn match.reduce((r, a) => Math.min(r, a.length), Infinity);\n};\nconst minIndent$1 = getDefaultExportFromCjs(minIndent);\nfunction stripIndent(string) {\n\tconst indent = minIndent$1(string);\n\tif (indent === 0) {\n\t\treturn string;\n\t}\n\tconst regex = new RegExp(`^[ \\\\t]{${indent}}`, 'gm');\n\treturn string.replace(regex, '');\n}\nfunction indentString(string, count = 1, options = {}) {\n\tconst {\n\t\tindent = ' ',\n\t\tincludeEmptyLines = false\n\t} = options;\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``\n\t\t);\n\t}\n\tif (typeof count !== 'number') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count}\\``\n\t\t);\n\t}\n\tif (count < 0) {\n\t\tthrow new RangeError(\n\t\t\t`Expected \\`count\\` to be at least 0, got \\`${count}\\``\n\t\t);\n\t}\n\tif (typeof indent !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof indent}\\``\n\t\t);\n\t}\n\tif (count === 0) {\n\t\treturn string;\n\t}\n\tconst regex = includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n\treturn string.replace(regex, indent.repeat(count));\n}\nfunction redent(string, count = 0, options = {}) {\n\treturn indentString(stripIndent(string), count, options);\n}\nconst debug$1 = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {};\nvar debug_1 = debug$1;\nconst SEMVER_SPEC_VERSION = '2.0.0';\nconst MAX_LENGTH$1 = 256;\nconst MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER ||\n 9007199254740991;\nconst MAX_SAFE_COMPONENT_LENGTH = 16;\nconst MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;\nconst RELEASE_TYPES = [\n  'major',\n  'premajor',\n  'minor',\n  'preminor',\n  'patch',\n  'prepatch',\n  'prerelease',\n];\nvar constants$1 = {\n  MAX_LENGTH: MAX_LENGTH$1,\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,\n  RELEASE_TYPES,\n  SEMVER_SPEC_VERSION,\n  FLAG_INCLUDE_PRERELEASE: 0b001,\n  FLAG_LOOSE: 0b010,\n};\nvar re$1 = {exports: {}};\n(function (module, exports) {\n\tconst {\n\t  MAX_SAFE_COMPONENT_LENGTH,\n\t  MAX_SAFE_BUILD_LENGTH,\n\t  MAX_LENGTH,\n\t} = constants$1;\n\tconst debug = debug_1;\n\texports = module.exports = {};\n\tconst re = exports.re = [];\n\tconst safeRe = exports.safeRe = [];\n\tconst src = exports.src = [];\n\tconst t = exports.t = {};\n\tlet R = 0;\n\tconst LETTERDASHNUMBER = '[a-zA-Z0-9-]';\n\tconst safeRegexReplacements = [\n\t  ['\\\\s', 1],\n\t  ['\\\\d', MAX_LENGTH],\n\t  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],\n\t];\n\tconst makeSafeRegex = (value) => {\n\t  for (const [token, max] of safeRegexReplacements) {\n\t    value = value\n\t      .split(`${token}*`).join(`${token}{0,${max}}`)\n\t      .split(`${token}+`).join(`${token}{1,${max}}`);\n\t  }\n\t  return value\n\t};\n\tconst createToken = (name, value, isGlobal) => {\n\t  const safe = makeSafeRegex(value);\n\t  const index = R++;\n\t  debug(name, index, value);\n\t  t[name] = index;\n\t  src[index] = value;\n\t  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);\n\t  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);\n\t};\n\tcreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*');\n\tcreateToken('NUMERICIDENTIFIERLOOSE', '\\\\d+');\n\tcreateToken('NONNUMERICIDENTIFIER', `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);\n\tcreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n\t                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n\t                   `(${src[t.NUMERICIDENTIFIER]})`);\n\tcreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n\t                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n\t                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);\n\tcreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n\t}|${src[t.NONNUMERICIDENTIFIER]})`);\n\tcreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n\t}|${src[t.NONNUMERICIDENTIFIER]})`);\n\tcreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n\t}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`);\n\tcreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n\t}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);\n\tcreateToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);\n\tcreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n\t}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`);\n\tcreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n\t}${src[t.PRERELEASE]}?${\n\t  src[t.BUILD]}?`);\n\tcreateToken('FULL', `^${src[t.FULLPLAIN]}$`);\n\tcreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n\t}${src[t.PRERELEASELOOSE]}?${\n\t  src[t.BUILD]}?`);\n\tcreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);\n\tcreateToken('GTLT', '((?:<|>)?=?)');\n\tcreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\n\tcreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`);\n\tcreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n\t                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n\t                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n\t                   `(?:${src[t.PRERELEASE]})?${\n\t                     src[t.BUILD]}?` +\n\t                   `)?)?`);\n\tcreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n\t                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n\t                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n\t                        `(?:${src[t.PRERELEASELOOSE]})?${\n\t                          src[t.BUILD]}?` +\n\t                        `)?)?`);\n\tcreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`);\n\tcreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`);\n\tcreateToken('COERCEPLAIN', `${'(^|[^\\\\d])' +\n\t              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n\t              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n\t              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);\n\tcreateToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`);\n\tcreateToken('COERCEFULL', src[t.COERCEPLAIN] +\n\t              `(?:${src[t.PRERELEASE]})?` +\n\t              `(?:${src[t.BUILD]})?` +\n\t              `(?:$|[^\\\\d])`);\n\tcreateToken('COERCERTL', src[t.COERCE], true);\n\tcreateToken('COERCERTLFULL', src[t.COERCEFULL], true);\n\tcreateToken('LONETILDE', '(?:~>?)');\n\tcreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true);\n\texports.tildeTrimReplace = '$1~';\n\tcreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);\n\tcreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);\n\tcreateToken('LONECARET', '(?:\\\\^)');\n\tcreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true);\n\texports.caretTrimReplace = '$1^';\n\tcreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);\n\tcreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);\n\tcreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`);\n\tcreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`);\n\tcreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n\t}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);\n\texports.comparatorTrimReplace = '$1$2$3';\n\tcreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n\t                   `\\\\s+-\\\\s+` +\n\t                   `(${src[t.XRANGEPLAIN]})` +\n\t                   `\\\\s*$`);\n\tcreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n\t                        `\\\\s+-\\\\s+` +\n\t                        `(${src[t.XRANGEPLAINLOOSE]})` +\n\t                        `\\\\s*$`);\n\tcreateToken('STAR', '(<|>)?=?\\\\s*\\\\*');\n\tcreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$');\n\tcreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$'); \n} (re$1, re$1.exports));\nvar reExports = re$1.exports;\nconst looseOption = Object.freeze({ loose: true });\nconst emptyOpts = Object.freeze({ });\nconst parseOptions$1 = options => {\n  if (!options) {\n    return emptyOpts\n  }\n  if (typeof options !== 'object') {\n    return looseOption\n  }\n  return options\n};\nvar parseOptions_1 = parseOptions$1;\nconst numeric = /^[0-9]+$/;\nconst compareIdentifiers$1 = (a, b) => {\n  const anum = numeric.test(a);\n  const bnum = numeric.test(b);\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n};\nconst rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);\nvar identifiers = {\n  compareIdentifiers: compareIdentifiers$1,\n  rcompareIdentifiers,\n};\nconst debug = debug_1;\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$1;\nconst { safeRe: re, t } = reExports;\nconst parseOptions = parseOptions_1;\nconst { compareIdentifiers } = identifiers;\nlet SemVer$1 = class SemVer {\n  constructor (version, options) {\n    options = parseOptions(options);\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version;\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`)\n    }\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n    debug('SemVer', version, options);\n    this.options = options;\n    this.loose = !!options.loose;\n    this.includePrerelease = !!options.includePrerelease;\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n    this.raw = version;\n    this.major = +m[1];\n    this.minor = +m[2];\n    this.patch = +m[3];\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n    if (!m[4]) {\n      this.prerelease = [];\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id;\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      });\n    }\n    this.build = m[5] ? m[5].split('.') : [];\n    this.format();\n  }\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`;\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`;\n    }\n    return this.version\n  }\n  toString () {\n    return this.version\n  }\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other);\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options);\n    }\n    if (other.version === this.version) {\n      return 0\n    }\n    return this.compareMain(other) || this.comparePre(other)\n  }\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    }\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    }\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n    let i = 0;\n    do {\n      const a = this.prerelease[i];\n      const b = other.prerelease[i];\n      debug('prerelease compare', i, a, b);\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options);\n    }\n    let i = 0;\n    do {\n      const a = this.build[i];\n      const b = other.build[i];\n      debug('prerelease compare', i, a, b);\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n  inc (release, identifier, identifierBase) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0;\n        this.patch = 0;\n        this.minor = 0;\n        this.major++;\n        this.inc('pre', identifier, identifierBase);\n        break\n      case 'preminor':\n        this.prerelease.length = 0;\n        this.patch = 0;\n        this.minor++;\n        this.inc('pre', identifier, identifierBase);\n        break\n      case 'prepatch':\n        this.prerelease.length = 0;\n        this.inc('patch', identifier, identifierBase);\n        this.inc('pre', identifier, identifierBase);\n        break\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier, identifierBase);\n        }\n        this.inc('pre', identifier, identifierBase);\n        break\n      case 'major':\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++;\n        }\n        this.minor = 0;\n        this.patch = 0;\n        this.prerelease = [];\n        break\n      case 'minor':\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++;\n        }\n        this.patch = 0;\n        this.prerelease = [];\n        break\n      case 'patch':\n        if (this.prerelease.length === 0) {\n          this.patch++;\n        }\n        this.prerelease = [];\n        break\n      case 'pre': {\n        const base = Number(identifierBase) ? 1 : 0;\n        if (!identifier && identifierBase === false) {\n          throw new Error('invalid increment argument: identifier is empty')\n        }\n        if (this.prerelease.length === 0) {\n          this.prerelease = [base];\n        } else {\n          let i = this.prerelease.length;\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++;\n              i = -2;\n            }\n          }\n          if (i === -1) {\n            if (identifier === this.prerelease.join('.') && identifierBase === false) {\n              throw new Error('invalid increment argument: identifier already exists')\n            }\n            this.prerelease.push(base);\n          }\n        }\n        if (identifier) {\n          let prerelease = [identifier, base];\n          if (identifierBase === false) {\n            prerelease = [identifier];\n          }\n          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = prerelease;\n            }\n          } else {\n            this.prerelease = prerelease;\n          }\n        }\n        break\n      }\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.raw = this.format();\n    if (this.build.length) {\n      this.raw += `+${this.build.join('.')}`;\n    }\n    return this\n  }\n};\nvar semver = SemVer$1;\nconst SemVer = semver;\nconst parse$6 = (version, options, throwErrors = false) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    if (!throwErrors) {\n      return null\n    }\n    throw er\n  }\n};\nvar parse_1 = parse$6;\nconst parse$5 = parse_1;\nconst valid$1 = (version, options) => {\n  const v = parse$5(version, options);\n  return v ? v.version : null\n};\nvar valid_1 = valid$1;\nconst parse$4 = parse_1;\nconst clean = (version, options) => {\n  const s = parse$4(version.trim().replace(/^[=v]+/, ''), options);\n  return s ? s.version : null\n};\nvar clean_1 = clean;\nconst require$$1$3 = [\n\t\"0BSD\",\n\t\"AAL\",\n\t\"ADSL\",\n\t\"AFL-1.1\",\n\t\"AFL-1.2\",\n\t\"AFL-2.0\",\n\t\"AFL-2.1\",\n\t\"AFL-3.0\",\n\t\"AGPL-1.0-only\",\n\t\"AGPL-1.0-or-later\",\n\t\"AGPL-3.0-only\",\n\t\"AGPL-3.0-or-later\",\n\t\"AMDPLPA\",\n\t\"AML\",\n\t\"AMPAS\",\n\t\"ANTLR-PD\",\n\t\"ANTLR-PD-fallback\",\n\t\"APAFML\",\n\t\"APL-1.0\",\n\t\"APSL-1.0\",\n\t\"APSL-1.1\",\n\t\"APSL-1.2\",\n\t\"APSL-2.0\",\n\t\"ASWF-Digital-Assets-1.0\",\n\t\"ASWF-Digital-Assets-1.1\",\n\t\"Abstyles\",\n\t\"AdaCore-doc\",\n\t\"Adobe-2006\",\n\t\"Adobe-Glyph\",\n\t\"Adobe-Utopia\",\n\t\"Afmparse\",\n\t\"Aladdin\",\n\t\"Apache-1.0\",\n\t\"Apache-1.1\",\n\t\"Apache-2.0\",\n\t\"App-s2p\",\n\t\"Arphic-1999\",\n\t\"Artistic-1.0\",\n\t\"Artistic-1.0-Perl\",\n\t\"Artistic-1.0-cl8\",\n\t\"Artistic-2.0\",\n\t\"BSD-1-Clause\",\n\t\"BSD-2-Clause\",\n\t\"BSD-2-Clause-Patent\",\n\t\"BSD-2-Clause-Views\",\n\t\"BSD-3-Clause\",\n\t\"BSD-3-Clause-Attribution\",\n\t\"BSD-3-Clause-Clear\",\n\t\"BSD-3-Clause-HP\",\n\t\"BSD-3-Clause-LBNL\",\n\t\"BSD-3-Clause-Modification\",\n\t\"BSD-3-Clause-No-Military-License\",\n\t\"BSD-3-Clause-No-Nuclear-License\",\n\t\"BSD-3-Clause-No-Nuclear-License-2014\",\n\t\"BSD-3-Clause-No-Nuclear-Warranty\",\n\t\"BSD-3-Clause-Open-MPI\",\n\t\"BSD-3-Clause-Sun\",\n\t\"BSD-3-Clause-flex\",\n\t\"BSD-4-Clause\",\n\t\"BSD-4-Clause-Shortened\",\n\t\"BSD-4-Clause-UC\",\n\t\"BSD-4.3RENO\",\n\t\"BSD-4.3TAHOE\",\n\t\"BSD-Advertising-Acknowledgement\",\n\t\"BSD-Attribution-HPND-disclaimer\",\n\t\"BSD-Inferno-Nettverk\",\n\t\"BSD-Protection\",\n\t\"BSD-Source-Code\",\n\t\"BSD-Systemics\",\n\t\"BSL-1.0\",\n\t\"BUSL-1.1\",\n\t\"Baekmuk\",\n\t\"Bahyph\",\n\t\"Barr\",\n\t\"Beerware\",\n\t\"BitTorrent-1.0\",\n\t\"BitTorrent-1.1\",\n\t\"Bitstream-Charter\",\n\t\"Bitstream-Vera\",\n\t\"BlueOak-1.0.0\",\n\t\"Boehm-GC\",\n\t\"Borceux\",\n\t\"Brian-Gladman-3-Clause\",\n\t\"C-UDA-1.0\",\n\t\"CAL-1.0\",\n\t\"CAL-1.0-Combined-Work-Exception\",\n\t\"CATOSL-1.1\",\n\t\"CC-BY-1.0\",\n\t\"CC-BY-2.0\",\n\t\"CC-BY-2.5\",\n\t\"CC-BY-2.5-AU\",\n\t\"CC-BY-3.0\",\n\t\"CC-BY-3.0-AT\",\n\t\"CC-BY-3.0-DE\",\n\t\"CC-BY-3.0-IGO\",\n\t\"CC-BY-3.0-NL\",\n\t\"CC-BY-3.0-US\",\n\t\"CC-BY-4.0\",\n\t\"CC-BY-NC-1.0\",\n\t\"CC-BY-NC-2.0\",\n\t\"CC-BY-NC-2.5\",\n\t\"CC-BY-NC-3.0\",\n\t\"CC-BY-NC-3.0-DE\",\n\t\"CC-BY-NC-4.0\",\n\t\"CC-BY-NC-ND-1.0\",\n\t\"CC-BY-NC-ND-2.0\",\n\t\"CC-BY-NC-ND-2.5\",\n\t\"CC-BY-NC-ND-3.0\",\n\t\"CC-BY-NC-ND-3.0-DE\",\n\t\"CC-BY-NC-ND-3.0-IGO\",\n\t\"CC-BY-NC-ND-4.0\",\n\t\"CC-BY-NC-SA-1.0\",\n\t\"CC-BY-NC-SA-2.0\",\n\t\"CC-BY-NC-SA-2.0-DE\",\n\t\"CC-BY-NC-SA-2.0-FR\",\n\t\"CC-BY-NC-SA-2.0-UK\",\n\t\"CC-BY-NC-SA-2.5\",\n\t\"CC-BY-NC-SA-3.0\",\n\t\"CC-BY-NC-SA-3.0-DE\",\n\t\"CC-BY-NC-SA-3.0-IGO\",\n\t\"CC-BY-NC-SA-4.0\",\n\t\"CC-BY-ND-1.0\",\n\t\"CC-BY-ND-2.0\",\n\t\"CC-BY-ND-2.5\",\n\t\"CC-BY-ND-3.0\",\n\t\"CC-BY-ND-3.0-DE\",\n\t\"CC-BY-ND-4.0\",\n\t\"CC-BY-SA-1.0\",\n\t\"CC-BY-SA-2.0\",\n\t\"CC-BY-SA-2.0-UK\",\n\t\"CC-BY-SA-2.1-JP\",\n\t\"CC-BY-SA-2.5\",\n\t\"CC-BY-SA-3.0\",\n\t\"CC-BY-SA-3.0-AT\",\n\t\"CC-BY-SA-3.0-DE\",\n\t\"CC-BY-SA-3.0-IGO\",\n\t\"CC-BY-SA-4.0\",\n\t\"CC-PDDC\",\n\t\"CC0-1.0\",\n\t\"CDDL-1.0\",\n\t\"CDDL-1.1\",\n\t\"CDL-1.0\",\n\t\"CDLA-Permissive-1.0\",\n\t\"CDLA-Permissive-2.0\",\n\t\"CDLA-Sharing-1.0\",\n\t\"CECILL-1.0\",\n\t\"CECILL-1.1\",\n\t\"CECILL-2.0\",\n\t\"CECILL-2.1\",\n\t\"CECILL-B\",\n\t\"CECILL-C\",\n\t\"CERN-OHL-1.1\",\n\t\"CERN-OHL-1.2\",\n\t\"CERN-OHL-P-2.0\",\n\t\"CERN-OHL-S-2.0\",\n\t\"CERN-OHL-W-2.0\",\n\t\"CFITSIO\",\n\t\"CMU-Mach\",\n\t\"CNRI-Jython\",\n\t\"CNRI-Python\",\n\t\"CNRI-Python-GPL-Compatible\",\n\t\"COIL-1.0\",\n\t\"CPAL-1.0\",\n\t\"CPL-1.0\",\n\t\"CPOL-1.02\",\n\t\"CUA-OPL-1.0\",\n\t\"Caldera\",\n\t\"ClArtistic\",\n\t\"Clips\",\n\t\"Community-Spec-1.0\",\n\t\"Condor-1.1\",\n\t\"Cornell-Lossless-JPEG\",\n\t\"Cronyx\",\n\t\"Crossword\",\n\t\"CrystalStacker\",\n\t\"Cube\",\n\t\"D-FSL-1.0\",\n\t\"DL-DE-BY-2.0\",\n\t\"DL-DE-ZERO-2.0\",\n\t\"DOC\",\n\t\"DRL-1.0\",\n\t\"DSDP\",\n\t\"Dotseqn\",\n\t\"ECL-1.0\",\n\t\"ECL-2.0\",\n\t\"EFL-1.0\",\n\t\"EFL-2.0\",\n\t\"EPICS\",\n\t\"EPL-1.0\",\n\t\"EPL-2.0\",\n\t\"EUDatagrid\",\n\t\"EUPL-1.0\",\n\t\"EUPL-1.1\",\n\t\"EUPL-1.2\",\n\t\"Elastic-2.0\",\n\t\"Entessa\",\n\t\"ErlPL-1.1\",\n\t\"Eurosym\",\n\t\"FBM\",\n\t\"FDK-AAC\",\n\t\"FSFAP\",\n\t\"FSFUL\",\n\t\"FSFULLR\",\n\t\"FSFULLRWD\",\n\t\"FTL\",\n\t\"Fair\",\n\t\"Ferguson-Twofish\",\n\t\"Frameworx-1.0\",\n\t\"FreeBSD-DOC\",\n\t\"FreeImage\",\n\t\"Furuseth\",\n\t\"GD\",\n\t\"GFDL-1.1-invariants-only\",\n\t\"GFDL-1.1-invariants-or-later\",\n\t\"GFDL-1.1-no-invariants-only\",\n\t\"GFDL-1.1-no-invariants-or-later\",\n\t\"GFDL-1.1-only\",\n\t\"GFDL-1.1-or-later\",\n\t\"GFDL-1.2-invariants-only\",\n\t\"GFDL-1.2-invariants-or-later\",\n\t\"GFDL-1.2-no-invariants-only\",\n\t\"GFDL-1.2-no-invariants-or-later\",\n\t\"GFDL-1.2-only\",\n\t\"GFDL-1.2-or-later\",\n\t\"GFDL-1.3-invariants-only\",\n\t\"GFDL-1.3-invariants-or-later\",\n\t\"GFDL-1.3-no-invariants-only\",\n\t\"GFDL-1.3-no-invariants-or-later\",\n\t\"GFDL-1.3-only\",\n\t\"GFDL-1.3-or-later\",\n\t\"GL2PS\",\n\t\"GLWTPL\",\n\t\"GPL-1.0-only\",\n\t\"GPL-1.0-or-later\",\n\t\"GPL-2.0-only\",\n\t\"GPL-2.0-or-later\",\n\t\"GPL-3.0-only\",\n\t\"GPL-3.0-or-later\",\n\t\"Giftware\",\n\t\"Glide\",\n\t\"Glulxe\",\n\t\"Graphics-Gems\",\n\t\"HP-1986\",\n\t\"HP-1989\",\n\t\"HPND\",\n\t\"HPND-DEC\",\n\t\"HPND-Markus-Kuhn\",\n\t\"HPND-Pbmplus\",\n\t\"HPND-UC\",\n\t\"HPND-doc\",\n\t\"HPND-doc-sell\",\n\t\"HPND-export-US\",\n\t\"HPND-export-US-modify\",\n\t\"HPND-sell-regexpr\",\n\t\"HPND-sell-variant\",\n\t\"HPND-sell-variant-MIT-disclaimer\",\n\t\"HTMLTIDY\",\n\t\"HaskellReport\",\n\t\"Hippocratic-2.1\",\n\t\"IBM-pibs\",\n\t\"ICU\",\n\t\"IEC-Code-Components-EULA\",\n\t\"IJG\",\n\t\"IJG-short\",\n\t\"IPA\",\n\t\"IPL-1.0\",\n\t\"ISC\",\n\t\"ImageMagick\",\n\t\"Imlib2\",\n\t\"Info-ZIP\",\n\t\"Inner-Net-2.0\",\n\t\"Intel\",\n\t\"Intel-ACPI\",\n\t\"Interbase-1.0\",\n\t\"JPL-image\",\n\t\"JPNIC\",\n\t\"JSON\",\n\t\"Jam\",\n\t\"JasPer-2.0\",\n\t\"Kastrup\",\n\t\"Kazlib\",\n\t\"Knuth-CTAN\",\n\t\"LAL-1.2\",\n\t\"LAL-1.3\",\n\t\"LGPL-2.0-only\",\n\t\"LGPL-2.0-or-later\",\n\t\"LGPL-2.1-only\",\n\t\"LGPL-2.1-or-later\",\n\t\"LGPL-3.0-only\",\n\t\"LGPL-3.0-or-later\",\n\t\"LGPLLR\",\n\t\"LOOP\",\n\t\"LPL-1.0\",\n\t\"LPL-1.02\",\n\t\"LPPL-1.0\",\n\t\"LPPL-1.1\",\n\t\"LPPL-1.2\",\n\t\"LPPL-1.3a\",\n\t\"LPPL-1.3c\",\n\t\"LZMA-SDK-9.11-to-9.20\",\n\t\"LZMA-SDK-9.22\",\n\t\"Latex2e\",\n\t\"Latex2e-translated-notice\",\n\t\"Leptonica\",\n\t\"LiLiQ-P-1.1\",\n\t\"LiLiQ-R-1.1\",\n\t\"LiLiQ-Rplus-1.1\",\n\t\"Libpng\",\n\t\"Linux-OpenIB\",\n\t\"Linux-man-pages-1-para\",\n\t\"Linux-man-pages-copyleft\",\n\t\"Linux-man-pages-copyleft-2-para\",\n\t\"Linux-man-pages-copyleft-var\",\n\t\"Lucida-Bitmap-Fonts\",\n\t\"MIT\",\n\t\"MIT-0\",\n\t\"MIT-CMU\",\n\t\"MIT-Festival\",\n\t\"MIT-Modern-Variant\",\n\t\"MIT-Wu\",\n\t\"MIT-advertising\",\n\t\"MIT-enna\",\n\t\"MIT-feh\",\n\t\"MIT-open-group\",\n\t\"MIT-testregex\",\n\t\"MITNFA\",\n\t\"MMIXware\",\n\t\"MPEG-SSG\",\n\t\"MPL-1.0\",\n\t\"MPL-1.1\",\n\t\"MPL-2.0\",\n\t\"MPL-2.0-no-copyleft-exception\",\n\t\"MS-LPL\",\n\t\"MS-PL\",\n\t\"MS-RL\",\n\t\"MTLL\",\n\t\"MakeIndex\",\n\t\"Martin-Birgmeier\",\n\t\"McPhee-slideshow\",\n\t\"Minpack\",\n\t\"MirOS\",\n\t\"Motosoto\",\n\t\"MulanPSL-1.0\",\n\t\"MulanPSL-2.0\",\n\t\"Multics\",\n\t\"Mup\",\n\t\"NAIST-2003\",\n\t\"NASA-1.3\",\n\t\"NBPL-1.0\",\n\t\"NCGL-UK-2.0\",\n\t\"NCSA\",\n\t\"NGPL\",\n\t\"NICTA-1.0\",\n\t\"NIST-PD\",\n\t\"NIST-PD-fallback\",\n\t\"NIST-Software\",\n\t\"NLOD-1.0\",\n\t\"NLOD-2.0\",\n\t\"NLPL\",\n\t\"NOSL\",\n\t\"NPL-1.0\",\n\t\"NPL-1.1\",\n\t\"NPOSL-3.0\",\n\t\"NRL\",\n\t\"NTP\",\n\t\"NTP-0\",\n\t\"Naumen\",\n\t\"Net-SNMP\",\n\t\"NetCDF\",\n\t\"Newsletr\",\n\t\"Nokia\",\n\t\"Noweb\",\n\t\"O-UDA-1.0\",\n\t\"OCCT-PL\",\n\t\"OCLC-2.0\",\n\t\"ODC-By-1.0\",\n\t\"ODbL-1.0\",\n\t\"OFFIS\",\n\t\"OFL-1.0\",\n\t\"OFL-1.0-RFN\",\n\t\"OFL-1.0-no-RFN\",\n\t\"OFL-1.1\",\n\t\"OFL-1.1-RFN\",\n\t\"OFL-1.1-no-RFN\",\n\t\"OGC-1.0\",\n\t\"OGDL-Taiwan-1.0\",\n\t\"OGL-Canada-2.0\",\n\t\"OGL-UK-1.0\",\n\t\"OGL-UK-2.0\",\n\t\"OGL-UK-3.0\",\n\t\"OGTSL\",\n\t\"OLDAP-1.1\",\n\t\"OLDAP-1.2\",\n\t\"OLDAP-1.3\",\n\t\"OLDAP-1.4\",\n\t\"OLDAP-2.0\",\n\t\"OLDAP-2.0.1\",\n\t\"OLDAP-2.1\",\n\t\"OLDAP-2.2\",\n\t\"OLDAP-2.2.1\",\n\t\"OLDAP-2.2.2\",\n\t\"OLDAP-2.3\",\n\t\"OLDAP-2.4\",\n\t\"OLDAP-2.5\",\n\t\"OLDAP-2.6\",\n\t\"OLDAP-2.7\",\n\t\"OLDAP-2.8\",\n\t\"OLFL-1.3\",\n\t\"OML\",\n\t\"OPL-1.0\",\n\t\"OPL-UK-3.0\",\n\t\"OPUBL-1.0\",\n\t\"OSET-PL-2.1\",\n\t\"OSL-1.0\",\n\t\"OSL-1.1\",\n\t\"OSL-2.0\",\n\t\"OSL-2.1\",\n\t\"OSL-3.0\",\n\t\"OpenPBS-2.3\",\n\t\"OpenSSL\",\n\t\"PADL\",\n\t\"PDDL-1.0\",\n\t\"PHP-3.0\",\n\t\"PHP-3.01\",\n\t\"PSF-2.0\",\n\t\"Parity-6.0.0\",\n\t\"Parity-7.0.0\",\n\t\"Plexus\",\n\t\"PolyForm-Noncommercial-1.0.0\",\n\t\"PolyForm-Small-Business-1.0.0\",\n\t\"PostgreSQL\",\n\t\"Python-2.0\",\n\t\"Python-2.0.1\",\n\t\"QPL-1.0\",\n\t\"QPL-1.0-INRIA-2004\",\n\t\"Qhull\",\n\t\"RHeCos-1.1\",\n\t\"RPL-1.1\",\n\t\"RPL-1.5\",\n\t\"RPSL-1.0\",\n\t\"RSA-MD\",\n\t\"RSCPL\",\n\t\"Rdisc\",\n\t\"Ruby\",\n\t\"SAX-PD\",\n\t\"SCEA\",\n\t\"SGI-B-1.0\",\n\t\"SGI-B-1.1\",\n\t\"SGI-B-2.0\",\n\t\"SGI-OpenGL\",\n\t\"SGP4\",\n\t\"SHL-0.5\",\n\t\"SHL-0.51\",\n\t\"SISSL\",\n\t\"SISSL-1.2\",\n\t\"SL\",\n\t\"SMLNJ\",\n\t\"SMPPL\",\n\t\"SNIA\",\n\t\"SPL-1.0\",\n\t\"SSH-OpenSSH\",\n\t\"SSH-short\",\n\t\"SSPL-1.0\",\n\t\"SWL\",\n\t\"Saxpath\",\n\t\"SchemeReport\",\n\t\"Sendmail\",\n\t\"Sendmail-8.23\",\n\t\"SimPL-2.0\",\n\t\"Sleepycat\",\n\t\"Soundex\",\n\t\"Spencer-86\",\n\t\"Spencer-94\",\n\t\"Spencer-99\",\n\t\"SugarCRM-1.1.3\",\n\t\"SunPro\",\n\t\"Symlinks\",\n\t\"TAPR-OHL-1.0\",\n\t\"TCL\",\n\t\"TCP-wrappers\",\n\t\"TMate\",\n\t\"TORQUE-1.1\",\n\t\"TOSL\",\n\t\"TPDL\",\n\t\"TPL-1.0\",\n\t\"TTWL\",\n\t\"TTYP0\",\n\t\"TU-Berlin-1.0\",\n\t\"TU-Berlin-2.0\",\n\t\"TermReadKey\",\n\t\"UCAR\",\n\t\"UCL-1.0\",\n\t\"UPL-1.0\",\n\t\"URT-RLE\",\n\t\"Unicode-DFS-2015\",\n\t\"Unicode-DFS-2016\",\n\t\"Unicode-TOU\",\n\t\"UnixCrypt\",\n\t\"Unlicense\",\n\t\"VOSTROM\",\n\t\"VSL-1.0\",\n\t\"Vim\",\n\t\"W3C\",\n\t\"W3C-19980720\",\n\t\"W3C-20150513\",\n\t\"WTFPL\",\n\t\"Watcom-1.0\",\n\t\"Widget-Workshop\",\n\t\"Wsuipa\",\n\t\"X11\",\n\t\"X11-distribute-modifications-variant\",\n\t\"XFree86-1.1\",\n\t\"XSkat\",\n\t\"Xdebug-1.03\",\n\t\"Xerox\",\n\t\"Xfig\",\n\t\"Xnet\",\n\t\"YPL-1.0\",\n\t\"YPL-1.1\",\n\t\"ZPL-1.1\",\n\t\"ZPL-2.0\",\n\t\"ZPL-2.1\",\n\t\"Zed\",\n\t\"Zeeff\",\n\t\"Zend-2.0\",\n\t\"Zimbra-1.3\",\n\t\"Zimbra-1.4\",\n\t\"Zlib\",\n\t\"blessing\",\n\t\"bzip2-1.0.6\",\n\t\"check-cvs\",\n\t\"checkmk\",\n\t\"copyleft-next-0.3.0\",\n\t\"copyleft-next-0.3.1\",\n\t\"curl\",\n\t\"diffmark\",\n\t\"dtoa\",\n\t\"dvipdfm\",\n\t\"eGenix\",\n\t\"etalab-2.0\",\n\t\"fwlw\",\n\t\"gSOAP-1.3b\",\n\t\"gnuplot\",\n\t\"iMatix\",\n\t\"libpng-2.0\",\n\t\"libselinux-1.0\",\n\t\"libtiff\",\n\t\"libutil-David-Nugent\",\n\t\"lsof\",\n\t\"magaz\",\n\t\"metamail\",\n\t\"mpi-permissive\",\n\t\"mpich2\",\n\t\"mplus\",\n\t\"pnmstitch\",\n\t\"psfrag\",\n\t\"psutils\",\n\t\"python-ldap\",\n\t\"snprintf\",\n\t\"ssh-keyscan\",\n\t\"swrule\",\n\t\"ulem\",\n\t\"w3m\",\n\t\"xinetd\",\n\t\"xlock\",\n\t\"xpp\",\n\t\"zlib-acknowledgement\"\n];\nconst require$$1$2 = [\n\t\"AGPL-1.0\",\n\t\"AGPL-3.0\",\n\t\"BSD-2-Clause-FreeBSD\",\n\t\"BSD-2-Clause-NetBSD\",\n\t\"GFDL-1.1\",\n\t\"GFDL-1.2\",\n\t\"GFDL-1.3\",\n\t\"GPL-1.0\",\n\t\"GPL-1.0+\",\n\t\"GPL-2.0\",\n\t\"GPL-2.0+\",\n\t\"GPL-2.0-with-GCC-exception\",\n\t\"GPL-2.0-with-autoconf-exception\",\n\t\"GPL-2.0-with-bison-exception\",\n\t\"GPL-2.0-with-classpath-exception\",\n\t\"GPL-2.0-with-font-exception\",\n\t\"GPL-3.0\",\n\t\"GPL-3.0+\",\n\t\"GPL-3.0-with-GCC-exception\",\n\t\"GPL-3.0-with-autoconf-exception\",\n\t\"LGPL-2.0\",\n\t\"LGPL-2.0+\",\n\t\"LGPL-2.1\",\n\t\"LGPL-2.1+\",\n\t\"LGPL-3.0\",\n\t\"LGPL-3.0+\",\n\t\"Nunit\",\n\t\"StandardML-NJ\",\n\t\"bzip2-1.0.5\",\n\t\"eCos-2.0\",\n\t\"wxWindows\"\n];\nconst require$$2 = [\n\t\"389-exception\",\n\t\"Asterisk-exception\",\n\t\"Autoconf-exception-2.0\",\n\t\"Autoconf-exception-3.0\",\n\t\"Autoconf-exception-generic\",\n\t\"Autoconf-exception-generic-3.0\",\n\t\"Autoconf-exception-macro\",\n\t\"Bison-exception-2.2\",\n\t\"Bootloader-exception\",\n\t\"Classpath-exception-2.0\",\n\t\"CLISP-exception-2.0\",\n\t\"cryptsetup-OpenSSL-exception\",\n\t\"DigiRule-FOSS-exception\",\n\t\"eCos-exception-2.0\",\n\t\"Fawkes-Runtime-exception\",\n\t\"FLTK-exception\",\n\t\"Font-exception-2.0\",\n\t\"freertos-exception-2.0\",\n\t\"GCC-exception-2.0\",\n\t\"GCC-exception-2.0-note\",\n\t\"GCC-exception-3.1\",\n\t\"GNAT-exception\",\n\t\"GNU-compiler-exception\",\n\t\"gnu-javamail-exception\",\n\t\"GPL-3.0-interface-exception\",\n\t\"GPL-3.0-linking-exception\",\n\t\"GPL-3.0-linking-source-exception\",\n\t\"GPL-CC-1.0\",\n\t\"GStreamer-exception-2005\",\n\t\"GStreamer-exception-2008\",\n\t\"i2p-gpl-java-exception\",\n\t\"KiCad-libraries-exception\",\n\t\"LGPL-3.0-linking-exception\",\n\t\"libpri-OpenH323-exception\",\n\t\"Libtool-exception\",\n\t\"Linux-syscall-note\",\n\t\"LLGPL\",\n\t\"LLVM-exception\",\n\t\"LZMA-exception\",\n\t\"mif-exception\",\n\t\"OCaml-LGPL-linking-exception\",\n\t\"OCCT-exception-1.0\",\n\t\"OpenJDK-assembly-exception-1.0\",\n\t\"openvpn-openssl-exception\",\n\t\"PS-or-PDF-font-exception-20170817\",\n\t\"QPL-1.0-INRIA-2004-exception\",\n\t\"Qt-GPL-exception-1.0\",\n\t\"Qt-LGPL-exception-1.1\",\n\t\"Qwt-exception-1.0\",\n\t\"SANE-exception\",\n\t\"SHL-2.0\",\n\t\"SHL-2.1\",\n\t\"stunnel-exception\",\n\t\"SWI-exception\",\n\t\"Swift-exception\",\n\t\"Texinfo-exception\",\n\t\"u-boot-exception-2.0\",\n\t\"UBDL-exception\",\n\t\"Universal-FOSS-exception-1.0\",\n\t\"vsftpd-openssl-exception\",\n\t\"WxWindows-exception-3.1\",\n\t\"x11vnc-openssl-exception\"\n];\nvar licenses = []\n  .concat(require$$1$3)\n  .concat(require$$1$2);\nvar exceptions = require$$2;\nvar scan$1 = function (source) {\n  var index = 0;\n  function hasMore () {\n    return index < source.length\n  }\n  function read (value) {\n    if (value instanceof RegExp) {\n      var chars = source.slice(index);\n      var match = chars.match(value);\n      if (match) {\n        index += match[0].length;\n        return match[0]\n      }\n    } else {\n      if (source.indexOf(value, index) === index) {\n        index += value.length;\n        return value\n      }\n    }\n  }\n  function skipWhitespace () {\n    read(/[ ]*/);\n  }\n  function operator () {\n    var string;\n    var possibilities = ['WITH', 'AND', 'OR', '(', ')', ':', '+'];\n    for (var i = 0; i < possibilities.length; i++) {\n      string = read(possibilities[i]);\n      if (string) {\n        break\n      }\n    }\n    if (string === '+' && index > 1 && source[index - 2] === ' ') {\n      throw new Error('Space before `+`')\n    }\n    return string && {\n      type: 'OPERATOR',\n      string: string\n    }\n  }\n  function idstring () {\n    return read(/[A-Za-z0-9-.]+/)\n  }\n  function expectIdstring () {\n    var string = idstring();\n    if (!string) {\n      throw new Error('Expected idstring at offset ' + index)\n    }\n    return string\n  }\n  function documentRef () {\n    if (read('DocumentRef-')) {\n      var string = expectIdstring();\n      return { type: 'DOCUMENTREF', string: string }\n    }\n  }\n  function licenseRef () {\n    if (read('LicenseRef-')) {\n      var string = expectIdstring();\n      return { type: 'LICENSEREF', string: string }\n    }\n  }\n  function identifier () {\n    var begin = index;\n    var string = idstring();\n    if (licenses.indexOf(string) !== -1) {\n      return {\n        type: 'LICENSE',\n        string: string\n      }\n    } else if (exceptions.indexOf(string) !== -1) {\n      return {\n        type: 'EXCEPTION',\n        string: string\n      }\n    }\n    index = begin;\n  }\n  function parseToken () {\n    return (\n      operator() ||\n      documentRef() ||\n      licenseRef() ||\n      identifier()\n    )\n  }\n  var tokens = [];\n  while (hasMore()) {\n    skipWhitespace();\n    if (!hasMore()) {\n      break\n    }\n    var token = parseToken();\n    if (!token) {\n      throw new Error('Unexpected `' + source[index] +\n                      '` at offset ' + index)\n    }\n    tokens.push(token);\n  }\n  return tokens\n};\nvar parse$3 = function (tokens) {\n  var index = 0;\n  function hasMore () {\n    return index < tokens.length\n  }\n  function token () {\n    return hasMore() ? tokens[index] : null\n  }\n  function next () {\n    if (!hasMore()) {\n      throw new Error()\n    }\n    index++;\n  }\n  function parseOperator (operator) {\n    var t = token();\n    if (t && t.type === 'OPERATOR' && operator === t.string) {\n      next();\n      return t.string\n    }\n  }\n  function parseWith () {\n    if (parseOperator('WITH')) {\n      var t = token();\n      if (t && t.type === 'EXCEPTION') {\n        next();\n        return t.string\n      }\n      throw new Error('Expected exception after `WITH`')\n    }\n  }\n  function parseLicenseRef () {\n    var begin = index;\n    var string = '';\n    var t = token();\n    if (t.type === 'DOCUMENTREF') {\n      next();\n      string += 'DocumentRef-' + t.string + ':';\n      if (!parseOperator(':')) {\n        throw new Error('Expected `:` after `DocumentRef-...`')\n      }\n    }\n    t = token();\n    if (t.type === 'LICENSEREF') {\n      next();\n      string += 'LicenseRef-' + t.string;\n      return { license: string }\n    }\n    index = begin;\n  }\n  function parseLicense () {\n    var t = token();\n    if (t && t.type === 'LICENSE') {\n      next();\n      var node = { license: t.string };\n      if (parseOperator('+')) {\n        node.plus = true;\n      }\n      var exception = parseWith();\n      if (exception) {\n        node.exception = exception;\n      }\n      return node\n    }\n  }\n  function parseParenthesizedExpression () {\n    var left = parseOperator('(');\n    if (!left) {\n      return\n    }\n    var expr = parseExpression();\n    if (!parseOperator(')')) {\n      throw new Error('Expected `)`')\n    }\n    return expr\n  }\n  function parseAtom () {\n    return (\n      parseParenthesizedExpression() ||\n      parseLicenseRef() ||\n      parseLicense()\n    )\n  }\n  function makeBinaryOpParser (operator, nextParser) {\n    return function parseBinaryOp () {\n      var left = nextParser();\n      if (!left) {\n        return\n      }\n      if (!parseOperator(operator)) {\n        return left\n      }\n      var right = parseBinaryOp();\n      if (!right) {\n        throw new Error('Expected expression')\n      }\n      return {\n        left: left,\n        conjunction: operator.toLowerCase(),\n        right: right\n      }\n    }\n  }\n  var parseAnd = makeBinaryOpParser('AND', parseAtom);\n  var parseExpression = makeBinaryOpParser('OR', parseAnd);\n  var node = parseExpression();\n  if (!node || hasMore()) {\n    throw new Error('Syntax error')\n  }\n  return node\n};\nvar scan = scan$1;\nvar parse$2 = parse$3;\nvar spdxExpressionParse = function (source) {\n  return parse$2(scan(source))\n};\nvar parse$1 = spdxExpressionParse;\nvar spdxLicenseIds = require$$1$3;\nfunction valid (string) {\n  try {\n    parse$1(string);\n    return true\n  } catch (error) {\n    return false\n  }\n}\nfunction sortTranspositions(a, b) {\n  var length = b[0].length - a[0].length;\n  if (length !== 0) return length\n  return a[0].toUpperCase().localeCompare(b[0].toUpperCase())\n}\nvar transpositions = [\n  ['APGL', 'AGPL'],\n  ['Gpl', 'GPL'],\n  ['GLP', 'GPL'],\n  ['APL', 'Apache'],\n  ['ISD', 'ISC'],\n  ['GLP', 'GPL'],\n  ['IST', 'ISC'],\n  ['Claude', 'Clause'],\n  [' or later', '+'],\n  [' International', ''],\n  ['GNU', 'GPL'],\n  ['GUN', 'GPL'],\n  ['+', ''],\n  ['GNU GPL', 'GPL'],\n  ['GNU LGPL', 'LGPL'],\n  ['GNU/GPL', 'GPL'],\n  ['GNU GLP', 'GPL'],\n  ['GNU LESSER GENERAL PUBLIC LICENSE', 'LGPL'],\n  ['GNU Lesser General Public License', 'LGPL'],\n  ['GNU LESSER GENERAL PUBLIC LICENSE', 'LGPL-2.1'],\n  ['GNU Lesser General Public License', 'LGPL-2.1'],\n  ['LESSER GENERAL PUBLIC LICENSE', 'LGPL'],\n  ['Lesser General Public License', 'LGPL'],\n  ['LESSER GENERAL PUBLIC LICENSE', 'LGPL-2.1'],\n  ['Lesser General Public License', 'LGPL-2.1'],\n  ['GNU General Public License', 'GPL'],\n  ['Gnu public license', 'GPL'],\n  ['GNU Public License', 'GPL'],\n  ['GNU GENERAL PUBLIC LICENSE', 'GPL'],\n  ['MTI', 'MIT'],\n  ['Mozilla Public License', 'MPL'],\n  ['Universal Permissive License', 'UPL'],\n  ['WTH', 'WTF'],\n  ['WTFGPL', 'WTFPL'],\n  ['-License', '']\n].sort(sortTranspositions);\nvar TRANSPOSED = 0;\nvar CORRECT = 1;\nvar transforms = [\n  function (argument) {\n    return argument.toUpperCase()\n  },\n  function (argument) {\n    return argument.trim()\n  },\n  function (argument) {\n    return argument.replace(/\\./g, '')\n  },\n  function (argument) {\n    return argument.replace(/\\s+/g, '')\n  },\n  function (argument) {\n    return argument.replace(/\\s+/g, '-')\n  },\n  function (argument) {\n    return argument.replace('v', '-')\n  },\n  function (argument) {\n    return argument.replace(/,?\\s*(\\d)/, '-$1')\n  },\n  function (argument) {\n    return argument.replace(/,?\\s*(\\d)/, '-$1.0')\n  },\n  function (argument) {\n    return argument\n      .replace(/,?\\s*(V\\.|v\\.|V|v|Version|version)\\s*(\\d)/, '-$2')\n  },\n  function (argument) {\n    return argument\n      .replace(/,?\\s*(V\\.|v\\.|V|v|Version|version)\\s*(\\d)/, '-$2.0')\n  },\n  function (argument) {\n    return argument[0].toUpperCase() + argument.slice(1)\n  },\n  function (argument) {\n    return argument.replace('/', '-')\n  },\n  function (argument) {\n    return argument\n      .replace(/\\s*V\\s*(\\d)/, '-$1')\n      .replace(/(\\d)$/, '$1.0')\n  },\n  function (argument) {\n    if (argument.indexOf('3.0') !== -1) {\n      return argument + '-or-later'\n    } else {\n      return argument + '-only'\n    }\n  },\n  function (argument) {\n    return argument + 'only'\n  },\n  function (argument) {\n    return argument.replace(/(\\d)$/, '-$1.0')\n  },\n  function (argument) {\n    return argument.replace(/(-| )?(\\d)$/, '-$2-Clause')\n  },\n  function (argument) {\n    return argument.replace(/(-| )clause(-| )(\\d)/, '-$3-Clause')\n  },\n  function (argument) {\n    return argument.replace(/\\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i, 'BSD-3-Clause')\n  },\n  function (argument) {\n    return argument.replace(/\\bSimplified(-| )?BSD((-| )License)?/i, 'BSD-2-Clause')\n  },\n  function (argument) {\n    return argument.replace(/\\b(Free|Net)(-| )?BSD((-| )License)?/i, 'BSD-2-Clause-$1BSD')\n  },\n  function (argument) {\n    return argument.replace(/\\bClear(-| )?BSD((-| )License)?/i, 'BSD-3-Clause-Clear')\n  },\n  function (argument) {\n    return argument.replace(/\\b(Old|Original)(-| )?BSD((-| )License)?/i, 'BSD-4-Clause')\n  },\n  function (argument) {\n    return 'CC-' + argument\n  },\n  function (argument) {\n    return 'CC-' + argument + '-4.0'\n  },\n  function (argument) {\n    return argument\n      .replace('Attribution', 'BY')\n      .replace('NonCommercial', 'NC')\n      .replace('NoDerivatives', 'ND')\n      .replace(/ (\\d)/, '-$1')\n      .replace(/ ?International/, '')\n  },\n  function (argument) {\n    return 'CC-' +\n      argument\n        .replace('Attribution', 'BY')\n        .replace('NonCommercial', 'NC')\n        .replace('NoDerivatives', 'ND')\n        .replace(/ (\\d)/, '-$1')\n        .replace(/ ?International/, '') +\n      '-4.0'\n  }\n];\nvar licensesWithVersions = spdxLicenseIds\n  .map(function (id) {\n    var match = /^(.*)-\\d+\\.\\d+$/.exec(id);\n    return match\n      ? [match[0], match[1]]\n      : [id, null]\n  })\n  .reduce(function (objectMap, item) {\n    var key = item[1];\n    objectMap[key] = objectMap[key] || [];\n    objectMap[key].push(item[0]);\n    return objectMap\n  }, {});\nvar licensesWithOneVersion = Object.keys(licensesWithVersions)\n  .map(function makeEntries (key) {\n    return [key, licensesWithVersions[key]]\n  })\n  .filter(function identifySoleVersions (item) {\n    return (\n      item[1].length === 1 &&\n      item[0] !== null &&\n      item[0] !== 'APL'\n    )\n  })\n  .map(function createLastResorts (item) {\n    return [item[0], item[1][0]]\n  });\nlicensesWithVersions = undefined;\nvar lastResorts = [\n  ['UNLI', 'Unlicense'],\n  ['WTF', 'WTFPL'],\n  ['2 CLAUSE', 'BSD-2-Clause'],\n  ['2-CLAUSE', 'BSD-2-Clause'],\n  ['3 CLAUSE', 'BSD-3-Clause'],\n  ['3-CLAUSE', 'BSD-3-Clause'],\n  ['AFFERO', 'AGPL-3.0-or-later'],\n  ['AGPL', 'AGPL-3.0-or-later'],\n  ['APACHE', 'Apache-2.0'],\n  ['ARTISTIC', 'Artistic-2.0'],\n  ['Affero', 'AGPL-3.0-or-later'],\n  ['BEER', 'Beerware'],\n  ['BOOST', 'BSL-1.0'],\n  ['BSD', 'BSD-2-Clause'],\n  ['CDDL', 'CDDL-1.1'],\n  ['ECLIPSE', 'EPL-1.0'],\n  ['FUCK', 'WTFPL'],\n  ['GNU', 'GPL-3.0-or-later'],\n  ['LGPL', 'LGPL-3.0-or-later'],\n  ['GPLV1', 'GPL-1.0-only'],\n  ['GPL-1', 'GPL-1.0-only'],\n  ['GPLV2', 'GPL-2.0-only'],\n  ['GPL-2', 'GPL-2.0-only'],\n  ['GPL', 'GPL-3.0-or-later'],\n  ['MIT +NO-FALSE-ATTRIBS', 'MITNFA'],\n  ['MIT', 'MIT'],\n  ['MPL', 'MPL-2.0'],\n  ['X11', 'X11'],\n  ['ZLIB', 'Zlib']\n].concat(licensesWithOneVersion).sort(sortTranspositions);\nvar SUBSTRING = 0;\nvar IDENTIFIER = 1;\nvar validTransformation = function (identifier) {\n  for (var i = 0; i < transforms.length; i++) {\n    var transformed = transforms[i](identifier).trim();\n    if (transformed !== identifier && valid(transformed)) {\n      return transformed\n    }\n  }\n  return null\n};\nvar validLastResort = function (identifier) {\n  var upperCased = identifier.toUpperCase();\n  for (var i = 0; i < lastResorts.length; i++) {\n    var lastResort = lastResorts[i];\n    if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {\n      return lastResort[IDENTIFIER]\n    }\n  }\n  return null\n};\nvar anyCorrection = function (identifier, check) {\n  for (var i = 0; i < transpositions.length; i++) {\n    var transposition = transpositions[i];\n    var transposed = transposition[TRANSPOSED];\n    if (identifier.indexOf(transposed) > -1) {\n      var corrected = identifier.replace(\n        transposed,\n        transposition[CORRECT]\n      );\n      var checked = check(corrected);\n      if (checked !== null) {\n        return checked\n      }\n    }\n  }\n  return null\n};\nvar spdxCorrect = function (identifier, options) {\n  options = options || {};\n  var upgrade = options.upgrade === undefined ? true : !!options.upgrade;\n  function postprocess (value) {\n    return upgrade ? upgradeGPLs(value) : value\n  }\n  var validArugment = (\n    typeof identifier === 'string' &&\n    identifier.trim().length !== 0\n  );\n  if (!validArugment) {\n    throw Error('Invalid argument. Expected non-empty string.')\n  }\n  identifier = identifier.trim();\n  if (valid(identifier)) {\n    return postprocess(identifier)\n  }\n  var noPlus = identifier.replace(/\\+$/, '').trim();\n  if (valid(noPlus)) {\n    return postprocess(noPlus)\n  }\n  var transformed = validTransformation(identifier);\n  if (transformed !== null) {\n    return postprocess(transformed)\n  }\n  transformed = anyCorrection(identifier, function (argument) {\n    if (valid(argument)) {\n      return argument\n    }\n    return validTransformation(argument)\n  });\n  if (transformed !== null) {\n    return postprocess(transformed)\n  }\n  transformed = validLastResort(identifier);\n  if (transformed !== null) {\n    return postprocess(transformed)\n  }\n  transformed = anyCorrection(identifier, validLastResort);\n  if (transformed !== null) {\n    return postprocess(transformed)\n  }\n  return null\n};\nfunction upgradeGPLs (value) {\n  if ([\n    'GPL-1.0', 'LGPL-1.0', 'AGPL-1.0',\n    'GPL-2.0', 'LGPL-2.0', 'AGPL-2.0',\n    'LGPL-2.1'\n  ].indexOf(value) !== -1) {\n    return value + '-only'\n  } else if ([\n    'GPL-1.0+', 'GPL-2.0+', 'GPL-3.0+',\n    'LGPL-2.0+', 'LGPL-2.1+', 'LGPL-3.0+',\n    'AGPL-1.0+', 'AGPL-3.0+'\n  ].indexOf(value) !== -1) {\n    return value.replace(/\\+$/, '-or-later')\n  } else if (['GPL-3.0', 'LGPL-3.0', 'AGPL-3.0'].indexOf(value) !== -1) {\n    return value + '-or-later'\n  } else {\n    return value\n  }\n}\nvar parse = spdxExpressionParse;\nvar correct = spdxCorrect;\nvar genericWarning = (\n  'license should be ' +\n  'a valid SPDX license expression (without \"LicenseRef\"), ' +\n  '\"UNLICENSED\", or ' +\n  '\"SEE LICENSE IN <filename>\"'\n);\nvar fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;\nfunction startsWith(prefix, string) {\n  return string.slice(0, prefix.length) === prefix;\n}\nfunction usesLicenseRef(ast) {\n  if (ast.hasOwnProperty('license')) {\n    var license = ast.license;\n    return (\n      startsWith('LicenseRef', license) ||\n      startsWith('DocumentRef', license)\n    );\n  } else {\n    return (\n      usesLicenseRef(ast.left) ||\n      usesLicenseRef(ast.right)\n    );\n  }\n}\nvar validateNpmPackageLicense = function(argument) {\n  var ast;\n  try {\n    ast = parse(argument);\n  } catch (e) {\n    var match;\n    if (\n      argument === 'UNLICENSED' ||\n      argument === 'UNLICENCED'\n    ) {\n      return {\n        validForOldPackages: true,\n        validForNewPackages: true,\n        unlicensed: true\n      };\n    } else if (match = fileReferenceRE.exec(argument)) {\n      return {\n        validForOldPackages: true,\n        validForNewPackages: true,\n        inFile: match[1]\n      };\n    } else {\n      var result = {\n        validForOldPackages: false,\n        validForNewPackages: false,\n        warnings: [genericWarning]\n      };\n      if (argument.trim().length !== 0) {\n        var corrected = correct(argument);\n        if (corrected) {\n          result.warnings.push(\n            'license is similar to the valid expression \"' + corrected + '\"'\n          );\n        }\n      }\n      return result;\n    }\n  }\n  if (usesLicenseRef(ast)) {\n    return {\n      validForNewPackages: false,\n      validForOldPackages: false,\n      spdx: true,\n      warnings: [genericWarning]\n    };\n  } else {\n    return {\n      validForNewPackages: true,\n      validForOldPackages: true,\n      spdx: true\n    };\n  }\n};\nvar commonjs = {};\nObject.defineProperty(commonjs, \"__esModule\", { value: true });\ncommonjs.LRUCache = void 0;\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\nif (typeof AC === 'undefined') {\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            this.signal.reason = reason;\n            this.signal.aborted = true;\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\nconst shouldWarn = (code) => !warned.has(code);\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\nlet LRUCache$1 = class LRUCache {\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    ttl;\n    ttlResolution;\n    ttlAutopurge;\n    updateAgeOnGet;\n    updateAgeOnHas;\n    allowStale;\n    noDisposeOnSet;\n    noUpdateTTL;\n    maxEntrySize;\n    sizeCalculation;\n    noDeleteOnFetchRejection;\n    noDeleteOnStaleGet;\n    allowStaleOnFetchAbort;\n    allowStaleOnFetchRejection;\n    ignoreFetchAbort;\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    static unsafeExposeInternals(c) {\n        return {\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    get max() {\n        return this.#max;\n    }\n    get maxSize() {\n        return this.#maxSize;\n    }\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    get size() {\n        return this.#size;\n    }\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get dispose() {\n        return this.#dispose;\n    }\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.delete(this.#keyList[index]);\n                    }\n                }, ttl + 1);\n                if (t.unref) {\n                    t.unref();\n                }\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                if (t.unref) {\n                    t.unref();\n                }\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    [Symbol.toStringTag] = 'LRUCache';\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.delete(this.#keyList[i]);\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            this.delete(k);\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.delete(k);\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.delete(k);\n                }\n                else if (!allowStaleAborted) {\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.delete(k);\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    delete(k) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.clear();\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, 'delete');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, 'delete']);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    clear() {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, 'delete');\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, 'delete']);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n};\ncommonjs.LRUCache = LRUCache$1;\nconst maybeJoin = (...args) => args.every(arg => arg) ? args.join('') : '';\nconst maybeEncode = (arg) => arg ? encodeURIComponent(arg) : '';\nconst formatHashFragment = (f) => f.toLowerCase().replace(/^\\W+|\\/|\\W+$/g, '').replace(/\\W+/g, '-');\nconst defaults = {\n  sshtemplate: ({ domain, user, project, committish }) =>\n    `git@${domain}:${user}/${project}.git${maybeJoin('#', committish)}`,\n  sshurltemplate: ({ domain, user, project, committish }) =>\n    `git+ssh://git@${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  edittemplate: ({ domain, user, project, committish, editpath, path }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', editpath, '/', maybeEncode(committish || 'HEAD'), '/', path)}`,\n  browsetemplate: ({ domain, user, project, committish, treepath }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}`,\n  browsetreetemplate: ({ domain, user, project, committish, treepath, path, fragment, hashformat }) =>\n    `https://${domain}/${user}/${project}/${treepath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,\n  browseblobtemplate: ({ domain, user, project, committish, blobpath, path, fragment, hashformat }) =>\n    `https://${domain}/${user}/${project}/${blobpath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,\n  docstemplate: ({ domain, user, project, treepath, committish }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}#readme`,\n  httpstemplate: ({ auth, domain, user, project, committish }) =>\n    `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  filetemplate: ({ domain, user, project, committish, path }) =>\n    `https://${domain}/${user}/${project}/raw/${maybeEncode(committish || 'HEAD')}/${path}`,\n  shortcuttemplate: ({ type, user, project, committish }) =>\n    `${type}:${user}/${project}${maybeJoin('#', committish)}`,\n  pathtemplate: ({ user, project, committish }) =>\n    `${user}/${project}${maybeJoin('#', committish)}`,\n  bugstemplate: ({ domain, user, project }) =>\n    `https://${domain}/${user}/${project}/issues`,\n  hashformat: formatHashFragment,\n};\nconst hosts$1 = {};\nhosts$1.github = {\n  protocols: ['git:', 'http:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],\n  domain: 'github.com',\n  treepath: 'tree',\n  blobpath: 'blob',\n  editpath: 'edit',\n  filetemplate: ({ auth, user, project, committish, path }) =>\n    `https://${maybeJoin(auth, '@')}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || 'HEAD')}/${path}`,\n  gittemplate: ({ auth, domain, user, project, committish }) =>\n    `git://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  tarballtemplate: ({ domain, user, project, committish }) =>\n    `https://codeload.${domain}/${user}/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,\n  extract: (url) => {\n    let [, user, project, type, committish] = url.pathname.split('/', 5);\n    if (type && type !== 'tree') {\n      return\n    }\n    if (!type) {\n      committish = url.hash.slice(1);\n    }\n    if (project && project.endsWith('.git')) {\n      project = project.slice(0, -4);\n    }\n    if (!user || !project) {\n      return\n    }\n    return { user, project, committish }\n  },\n};\nhosts$1.bitbucket = {\n  protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],\n  domain: 'bitbucket.org',\n  treepath: 'src',\n  blobpath: 'src',\n  editpath: '?mode=edit',\n  edittemplate: ({ domain, user, project, committish, treepath, path, editpath }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish || 'HEAD'), '/', path, editpath)}`,\n  tarballtemplate: ({ domain, user, project, committish }) =>\n    `https://${domain}/${user}/${project}/get/${maybeEncode(committish || 'HEAD')}.tar.gz`,\n  extract: (url) => {\n    let [, user, project, aux] = url.pathname.split('/', 4);\n    if (['get'].includes(aux)) {\n      return\n    }\n    if (project && project.endsWith('.git')) {\n      project = project.slice(0, -4);\n    }\n    if (!user || !project) {\n      return\n    }\n    return { user, project, committish: url.hash.slice(1) }\n  },\n};\nhosts$1.gitlab = {\n  protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],\n  domain: 'gitlab.com',\n  treepath: 'tree',\n  blobpath: 'tree',\n  editpath: '-/edit',\n  httpstemplate: ({ auth, domain, user, project, committish }) =>\n    `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  tarballtemplate: ({ domain, user, project, committish }) =>\n    `https://${domain}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || 'HEAD')}`,\n  extract: (url) => {\n    const path = url.pathname.slice(1);\n    if (path.includes('/-/') || path.includes('/archive.tar.gz')) {\n      return\n    }\n    const segments = path.split('/');\n    let project = segments.pop();\n    if (project.endsWith('.git')) {\n      project = project.slice(0, -4);\n    }\n    const user = segments.join('/');\n    if (!user || !project) {\n      return\n    }\n    return { user, project, committish: url.hash.slice(1) }\n  },\n};\nhosts$1.gist = {\n  protocols: ['git:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],\n  domain: 'gist.github.com',\n  editpath: 'edit',\n  sshtemplate: ({ domain, project, committish }) =>\n    `git@${domain}:${project}.git${maybeJoin('#', committish)}`,\n  sshurltemplate: ({ domain, project, committish }) =>\n    `git+ssh://git@${domain}/${project}.git${maybeJoin('#', committish)}`,\n  edittemplate: ({ domain, user, project, committish, editpath }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', maybeEncode(committish))}/${editpath}`,\n  browsetemplate: ({ domain, project, committish }) =>\n    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,\n  browsetreetemplate: ({ domain, project, committish, path, hashformat }) =>\n    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,\n  browseblobtemplate: ({ domain, project, committish, path, hashformat }) =>\n    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,\n  docstemplate: ({ domain, project, committish }) =>\n    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,\n  httpstemplate: ({ domain, project, committish }) =>\n    `git+https://${domain}/${project}.git${maybeJoin('#', committish)}`,\n  filetemplate: ({ user, project, committish, path }) =>\n    `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin('/', maybeEncode(committish))}/${path}`,\n  shortcuttemplate: ({ type, project, committish }) =>\n    `${type}:${project}${maybeJoin('#', committish)}`,\n  pathtemplate: ({ project, committish }) =>\n    `${project}${maybeJoin('#', committish)}`,\n  bugstemplate: ({ domain, project }) =>\n    `https://${domain}/${project}`,\n  gittemplate: ({ domain, project, committish }) =>\n    `git://${domain}/${project}.git${maybeJoin('#', committish)}`,\n  tarballtemplate: ({ project, committish }) =>\n    `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,\n  extract: (url) => {\n    let [, user, project, aux] = url.pathname.split('/', 4);\n    if (aux === 'raw') {\n      return\n    }\n    if (!project) {\n      if (!user) {\n        return\n      }\n      project = user;\n      user = null;\n    }\n    if (project.endsWith('.git')) {\n      project = project.slice(0, -4);\n    }\n    return { user, project, committish: url.hash.slice(1) }\n  },\n  hashformat: function (fragment) {\n    return fragment && 'file-' + formatHashFragment(fragment)\n  },\n};\nhosts$1.sourcehut = {\n  protocols: ['git+ssh:', 'https:'],\n  domain: 'git.sr.ht',\n  treepath: 'tree',\n  blobpath: 'tree',\n  filetemplate: ({ domain, user, project, committish, path }) =>\n    `https://${domain}/${user}/${project}/blob/${maybeEncode(committish) || 'HEAD'}/${path}`,\n  httpstemplate: ({ domain, user, project, committish }) =>\n    `https://${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  tarballtemplate: ({ domain, user, project, committish }) =>\n    `https://${domain}/${user}/${project}/archive/${maybeEncode(committish) || 'HEAD'}.tar.gz`,\n  bugstemplate: ({ user, project }) => null,\n  extract: (url) => {\n    let [, user, project, aux] = url.pathname.split('/', 4);\n    if (['archive'].includes(aux)) {\n      return\n    }\n    if (project && project.endsWith('.git')) {\n      project = project.slice(0, -4);\n    }\n    if (!user || !project) {\n      return\n    }\n    return { user, project, committish: url.hash.slice(1) }\n  },\n};\nfor (const [name, host] of Object.entries(hosts$1)) {\n  hosts$1[name] = Object.assign({}, defaults, host);\n}\nvar hosts_1 = hosts$1;\nconst url$2 = require$$0;\nconst lastIndexOfBefore = (str, char, beforeChar) => {\n  const startPosition = str.indexOf(beforeChar);\n  return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity)\n};\nconst safeUrl = (u) => {\n  try {\n    return new url$2.URL(u)\n  } catch {\n  }\n};\nconst correctProtocol = (arg, protocols) => {\n  const firstColon = arg.indexOf(':');\n  const proto = arg.slice(0, firstColon + 1);\n  if (Object.prototype.hasOwnProperty.call(protocols, proto)) {\n    return arg\n  }\n  const firstAt = arg.indexOf('@');\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`\n    } else {\n      return arg\n    }\n  }\n  const doubleSlash = arg.indexOf('//');\n  if (doubleSlash === firstColon + 1) {\n    return arg\n  }\n  return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`\n};\nconst correctUrl = (giturl) => {\n  const firstAt = lastIndexOfBefore(giturl, '@', '#');\n  const lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#');\n  if (lastColonBeforeHash > firstAt) {\n    giturl = giturl.slice(0, lastColonBeforeHash) + '/' + giturl.slice(lastColonBeforeHash + 1);\n  }\n  if (lastIndexOfBefore(giturl, ':', '#') === -1 && giturl.indexOf('//') === -1) {\n    giturl = `git+ssh://${giturl}`;\n  }\n  return giturl\n};\nvar parseUrl$2 = (giturl, protocols) => {\n  const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl;\n  return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol))\n};\nconst parseUrl$1 = parseUrl$2;\nconst isGitHubShorthand = (arg) => {\n  const firstHash = arg.indexOf('#');\n  const firstSlash = arg.indexOf('/');\n  const secondSlash = arg.indexOf('/', firstSlash + 1);\n  const firstColon = arg.indexOf(':');\n  const firstSpace = /\\s/.exec(arg);\n  const firstAt = arg.indexOf('@');\n  const spaceOnlyAfterHash = !firstSpace || (firstHash > -1 && firstSpace.index > firstHash);\n  const atOnlyAfterHash = firstAt === -1 || (firstHash > -1 && firstAt > firstHash);\n  const colonOnlyAfterHash = firstColon === -1 || (firstHash > -1 && firstColon > firstHash);\n  const secondSlashOnlyAfterHash = secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash);\n  const hasSlash = firstSlash > 0;\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/');\n  const doesNotStartWithDot = !arg.startsWith('.');\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash &&\n    doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash &&\n    secondSlashOnlyAfterHash\n};\nvar fromUrl$1 = (giturl, opts, { gitHosts, protocols }) => {\n  if (!giturl) {\n    return\n  }\n  const correctedUrl = isGitHubShorthand(giturl) ? `github:${giturl}` : giturl;\n  const parsed = parseUrl$1(correctedUrl, protocols);\n  if (!parsed) {\n    return\n  }\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];\n  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.')\n    ? parsed.hostname.slice(4)\n    : parsed.hostname];\n  const gitHostName = gitHostShortcut || gitHostDomain;\n  if (!gitHostName) {\n    return\n  }\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];\n  let auth = null;\n  if (protocols[parsed.protocol]?.auth && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`;\n  }\n  let committish = null;\n  let user = null;\n  let project = null;\n  let defaultRepresentation = null;\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname;\n      const firstAt = pathname.indexOf('@');\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1);\n      }\n      const lastSlash = pathname.lastIndexOf('/');\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash));\n        if (!user) {\n          user = null;\n        }\n        project = decodeURIComponent(pathname.slice(lastSlash + 1));\n      } else {\n        project = decodeURIComponent(pathname);\n      }\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4);\n      }\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1));\n      }\n      defaultRepresentation = 'shortcut';\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return\n      }\n      const segments = gitHostInfo.extract(parsed);\n      if (!segments) {\n        return\n      }\n      user = segments.user && decodeURIComponent(segments.user);\n      project = decodeURIComponent(segments.project);\n      committish = decodeURIComponent(segments.committish);\n      defaultRepresentation = protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1);\n    }\n  } catch (err) {\n    if (err instanceof URIError) {\n      return\n    } else {\n      throw err\n    }\n  }\n  return [gitHostName, user, auth, project, committish, defaultRepresentation, opts]\n};\nconst { LRUCache } = commonjs;\nconst hosts = hosts_1;\nconst fromUrl = fromUrl$1;\nconst parseUrl = parseUrl$2;\nconst cache$1 = new LRUCache({ max: 1000 });\nclass GitHost {\n  constructor (type, user, auth, project, committish, defaultRepresentation, opts = {}) {\n    Object.assign(this, GitHost.#gitHosts[type], {\n      type,\n      user,\n      auth,\n      project,\n      committish,\n      default: defaultRepresentation,\n      opts,\n    });\n  }\n  static #gitHosts = { byShortcut: {}, byDomain: {} }\n  static #protocols = {\n    'git+ssh:': { name: 'sshurl' },\n    'ssh:': { name: 'sshurl' },\n    'git+https:': { name: 'https', auth: true },\n    'git:': { auth: true },\n    'http:': { auth: true },\n    'https:': { auth: true },\n    'git+http:': { auth: true },\n  }\n  static addHost (name, host) {\n    GitHost.#gitHosts[name] = host;\n    GitHost.#gitHosts.byDomain[host.domain] = name;\n    GitHost.#gitHosts.byShortcut[`${name}:`] = name;\n    GitHost.#protocols[`${name}:`] = { name };\n  }\n  static fromUrl (giturl, opts) {\n    if (typeof giturl !== 'string') {\n      return\n    }\n    const key = giturl + JSON.stringify(opts || {});\n    if (!cache$1.has(key)) {\n      const hostArgs = fromUrl(giturl, opts, {\n        gitHosts: GitHost.#gitHosts,\n        protocols: GitHost.#protocols,\n      });\n      cache$1.set(key, hostArgs ? new GitHost(...hostArgs) : undefined);\n    }\n    return cache$1.get(key)\n  }\n  static parseUrl (url) {\n    return parseUrl(url)\n  }\n  #fill (template, opts) {\n    if (typeof template !== 'function') {\n      return null\n    }\n    const options = { ...this, ...this.opts, ...opts };\n    if (!options.path) {\n      options.path = '';\n    }\n    if (options.path.startsWith('/')) {\n      options.path = options.path.slice(1);\n    }\n    if (options.noCommittish) {\n      options.committish = null;\n    }\n    const result = template(options);\n    return options.noGitPlus && result.startsWith('git+') ? result.slice(4) : result\n  }\n  hash () {\n    return this.committish ? `#${this.committish}` : ''\n  }\n  ssh (opts) {\n    return this.#fill(this.sshtemplate, opts)\n  }\n  sshurl (opts) {\n    return this.#fill(this.sshurltemplate, opts)\n  }\n  browse (path, ...args) {\n    if (typeof path !== 'string') {\n      return this.#fill(this.browsetemplate, path)\n    }\n    if (typeof args[0] !== 'string') {\n      return this.#fill(this.browsetreetemplate, { ...args[0], path })\n    }\n    return this.#fill(this.browsetreetemplate, { ...args[1], fragment: args[0], path })\n  }\n  browseFile (path, ...args) {\n    if (typeof args[0] !== 'string') {\n      return this.#fill(this.browseblobtemplate, { ...args[0], path })\n    }\n    return this.#fill(this.browseblobtemplate, { ...args[1], fragment: args[0], path })\n  }\n  docs (opts) {\n    return this.#fill(this.docstemplate, opts)\n  }\n  bugs (opts) {\n    return this.#fill(this.bugstemplate, opts)\n  }\n  https (opts) {\n    return this.#fill(this.httpstemplate, opts)\n  }\n  git (opts) {\n    return this.#fill(this.gittemplate, opts)\n  }\n  shortcut (opts) {\n    return this.#fill(this.shortcuttemplate, opts)\n  }\n  path (opts) {\n    return this.#fill(this.pathtemplate, opts)\n  }\n  tarball (opts) {\n    return this.#fill(this.tarballtemplate, { ...opts, noCommittish: false })\n  }\n  file (path, opts) {\n    return this.#fill(this.filetemplate, { ...opts, path })\n  }\n  edit (path, opts) {\n    return this.#fill(this.edittemplate, { ...opts, path })\n  }\n  getDefaultRepresentation () {\n    return this.default\n  }\n  toString (opts) {\n    if (this.default && typeof this[this.default] === 'function') {\n      return this[this.default](opts)\n    }\n    return this.sshurl(opts)\n  }\n}\nfor (const [name, host] of Object.entries(hosts)) {\n  GitHost.addHost(name, host);\n}\nvar lib$3 = GitHost;\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\nvar concatty = function concatty(a, b) {\n    var arr = [];\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n    return arr;\n};\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\nvar implementation$1 = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n    };\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n    return bound;\n};\nvar implementation = implementation$1;\nvar functionBind = Function.prototype.bind || implementation;\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = functionBind;\nvar hasown = bind.call(call, $hasOwn);\nvar assert = true;\nvar async_hooks = \">= 8\";\nvar buffer_ieee754 = \">= 0.5 && < 0.9.7\";\nvar buffer = true;\nvar child_process = true;\nvar cluster = \">= 0.5\";\nvar console$1 = true;\nvar constants = true;\nvar crypto = true;\nvar _debug_agent = \">= 1 && < 8\";\nvar _debugger = \"< 8\";\nvar dgram = true;\nvar diagnostics_channel = [\n\t\">= 14.17 && < 15\",\n\t\">= 15.1\"\n];\nvar dns = true;\nvar domain = \">= 0.7.12\";\nvar events = true;\nvar freelist = \"< 6\";\nvar fs = true;\nvar _http_agent = \">= 0.11.1\";\nvar _http_client = \">= 0.11.1\";\nvar _http_common = \">= 0.11.1\";\nvar _http_incoming = \">= 0.11.1\";\nvar _http_outgoing = \">= 0.11.1\";\nvar _http_server = \">= 0.11.1\";\nvar http = true;\nvar http2 = \">= 8.8\";\nvar https = true;\nvar inspector = \">= 8\";\nvar _linklist = \"< 8\";\nvar module = true;\nvar net = true;\nvar os$2 = true;\nvar path = true;\nvar perf_hooks = \">= 8.5\";\nvar process$1 = \">= 1\";\nvar punycode = \">= 0.5\";\nvar querystring = true;\nvar readline = true;\nvar repl = true;\nvar smalloc = \">= 0.11.5 && < 3\";\nvar _stream_duplex = \">= 0.9.4\";\nvar _stream_transform = \">= 0.9.4\";\nvar _stream_wrap = \">= 1.4.1\";\nvar _stream_passthrough = \">= 0.9.4\";\nvar _stream_readable = \">= 0.9.4\";\nvar _stream_writable = \">= 0.9.4\";\nvar stream = true;\nvar string_decoder = true;\nvar sys = [\n\t\">= 0.4 && < 0.7\",\n\t\">= 0.8\"\n];\nvar timers = true;\nvar _tls_common = \">= 0.11.13\";\nvar _tls_legacy = \">= 0.11.3 && < 10\";\nvar _tls_wrap = \">= 0.11.3\";\nvar tls = true;\nvar trace_events = \">= 10\";\nvar tty = true;\nvar url$1 = true;\nvar util$1 = true;\nvar v8 = \">= 1\";\nvar vm = true;\nvar wasi = [\n\t\">= 13.4 && < 13.5\",\n\t\">= 18.17 && < 19\",\n\t\">= 20\"\n];\nvar worker_threads = \">= 11.7\";\nvar zlib = \">= 0.5\";\nconst require$$1$1 = {\n\tassert: assert,\n\t\"node:assert\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t\"assert/strict\": \">= 15\",\n\t\"node:assert/strict\": \">= 16\",\n\tasync_hooks: async_hooks,\n\t\"node:async_hooks\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tbuffer_ieee754: buffer_ieee754,\n\tbuffer: buffer,\n\t\"node:buffer\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tchild_process: child_process,\n\t\"node:child_process\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tcluster: cluster,\n\t\"node:cluster\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tconsole: console$1,\n\t\"node:console\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tconstants: constants,\n\t\"node:constants\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tcrypto: crypto,\n\t\"node:crypto\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_debug_agent: _debug_agent,\n\t_debugger: _debugger,\n\tdgram: dgram,\n\t\"node:dgram\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tdiagnostics_channel: diagnostics_channel,\n\t\"node:diagnostics_channel\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tdns: dns,\n\t\"node:dns\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t\"dns/promises\": \">= 15\",\n\t\"node:dns/promises\": \">= 16\",\n\tdomain: domain,\n\t\"node:domain\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tevents: events,\n\t\"node:events\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tfreelist: freelist,\n\tfs: fs,\n\t\"node:fs\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t\"fs/promises\": [\n\t\">= 10 && < 10.1\",\n\t\">= 14\"\n],\n\t\"node:fs/promises\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_http_agent: _http_agent,\n\t\"node:_http_agent\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_http_client: _http_client,\n\t\"node:_http_client\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_http_common: _http_common,\n\t\"node:_http_common\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_http_incoming: _http_incoming,\n\t\"node:_http_incoming\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_http_outgoing: _http_outgoing,\n\t\"node:_http_outgoing\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_http_server: _http_server,\n\t\"node:_http_server\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\thttp: http,\n\t\"node:http\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\thttp2: http2,\n\t\"node:http2\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\thttps: https,\n\t\"node:https\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tinspector: inspector,\n\t\"node:inspector\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t\"inspector/promises\": [\n\t\">= 19\"\n],\n\t\"node:inspector/promises\": [\n\t\">= 19\"\n],\n\t_linklist: _linklist,\n\tmodule: module,\n\t\"node:module\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tnet: net,\n\t\"node:net\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t\"node-inspect/lib/_inspect\": \">= 7.6 && < 12\",\n\t\"node-inspect/lib/internal/inspect_client\": \">= 7.6 && < 12\",\n\t\"node-inspect/lib/internal/inspect_repl\": \">= 7.6 && < 12\",\n\tos: os$2,\n\t\"node:os\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tpath: path,\n\t\"node:path\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t\"path/posix\": \">= 15.3\",\n\t\"node:path/posix\": \">= 16\",\n\t\"path/win32\": \">= 15.3\",\n\t\"node:path/win32\": \">= 16\",\n\tperf_hooks: perf_hooks,\n\t\"node:perf_hooks\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tprocess: process$1,\n\t\"node:process\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tpunycode: punycode,\n\t\"node:punycode\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tquerystring: querystring,\n\t\"node:querystring\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\treadline: readline,\n\t\"node:readline\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t\"readline/promises\": \">= 17\",\n\t\"node:readline/promises\": \">= 17\",\n\trepl: repl,\n\t\"node:repl\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tsmalloc: smalloc,\n\t_stream_duplex: _stream_duplex,\n\t\"node:_stream_duplex\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_stream_transform: _stream_transform,\n\t\"node:_stream_transform\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_stream_wrap: _stream_wrap,\n\t\"node:_stream_wrap\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_stream_passthrough: _stream_passthrough,\n\t\"node:_stream_passthrough\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_stream_readable: _stream_readable,\n\t\"node:_stream_readable\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_stream_writable: _stream_writable,\n\t\"node:_stream_writable\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tstream: stream,\n\t\"node:stream\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t\"stream/consumers\": \">= 16.7\",\n\t\"node:stream/consumers\": \">= 16.7\",\n\t\"stream/promises\": \">= 15\",\n\t\"node:stream/promises\": \">= 16\",\n\t\"stream/web\": \">= 16.5\",\n\t\"node:stream/web\": \">= 16.5\",\n\tstring_decoder: string_decoder,\n\t\"node:string_decoder\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tsys: sys,\n\t\"node:sys\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t\"test/reporters\": \">= 19.9 && < 20.2\",\n\t\"node:test/reporters\": [\n\t\">= 18.17 && < 19\",\n\t\">= 19.9\",\n\t\">= 20\"\n],\n\t\"node:test\": [\n\t\">= 16.17 && < 17\",\n\t\">= 18\"\n],\n\ttimers: timers,\n\t\"node:timers\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t\"timers/promises\": \">= 15\",\n\t\"node:timers/promises\": \">= 16\",\n\t_tls_common: _tls_common,\n\t\"node:_tls_common\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t_tls_legacy: _tls_legacy,\n\t_tls_wrap: _tls_wrap,\n\t\"node:_tls_wrap\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\ttls: tls,\n\t\"node:tls\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\ttrace_events: trace_events,\n\t\"node:trace_events\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\ttty: tty,\n\t\"node:tty\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\turl: url$1,\n\t\"node:url\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tutil: util$1,\n\t\"node:util\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\t\"util/types\": \">= 15.3\",\n\t\"node:util/types\": \">= 16\",\n\t\"v8/tools/arguments\": \">= 10 && < 12\",\n\t\"v8/tools/codemap\": [\n\t\">= 4.4 && < 5\",\n\t\">= 5.2 && < 12\"\n],\n\t\"v8/tools/consarray\": [\n\t\">= 4.4 && < 5\",\n\t\">= 5.2 && < 12\"\n],\n\t\"v8/tools/csvparser\": [\n\t\">= 4.4 && < 5\",\n\t\">= 5.2 && < 12\"\n],\n\t\"v8/tools/logreader\": [\n\t\">= 4.4 && < 5\",\n\t\">= 5.2 && < 12\"\n],\n\t\"v8/tools/profile_view\": [\n\t\">= 4.4 && < 5\",\n\t\">= 5.2 && < 12\"\n],\n\t\"v8/tools/splaytree\": [\n\t\">= 4.4 && < 5\",\n\t\">= 5.2 && < 12\"\n],\n\tv8: v8,\n\t\"node:v8\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tvm: vm,\n\t\"node:vm\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\twasi: wasi,\n\t\"node:wasi\": [\n\t\">= 18.17 && < 19\",\n\t\">= 20\"\n],\n\tworker_threads: worker_threads,\n\t\"node:worker_threads\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n],\n\tzlib: zlib,\n\t\"node:zlib\": [\n\t\">= 14.18 && < 15\",\n\t\">= 16\"\n]\n};\nvar hasOwn = hasown;\nfunction specifierIncluded(current, specifier) {\n\tvar nodeParts = current.split('.');\n\tvar parts = specifier.split(' ');\n\tvar op = parts.length > 1 ? parts[0] : '=';\n\tvar versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');\n\tfor (var i = 0; i < 3; ++i) {\n\t\tvar cur = parseInt(nodeParts[i] || 0, 10);\n\t\tvar ver = parseInt(versionParts[i] || 0, 10);\n\t\tif (cur === ver) {\n\t\t\tcontinue; \n\t\t}\n\t\tif (op === '<') {\n\t\t\treturn cur < ver;\n\t\t}\n\t\tif (op === '>=') {\n\t\t\treturn cur >= ver;\n\t\t}\n\t\treturn false;\n\t}\n\treturn op === '>=';\n}\nfunction matchesRange(current, range) {\n\tvar specifiers = range.split(/ ?&& ?/);\n\tif (specifiers.length === 0) {\n\t\treturn false;\n\t}\n\tfor (var i = 0; i < specifiers.length; ++i) {\n\t\tif (!specifierIncluded(current, specifiers[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nfunction versionIncluded(nodeVersion, specifierValue) {\n\tif (typeof specifierValue === 'boolean') {\n\t\treturn specifierValue;\n\t}\n\tvar current = typeof nodeVersion === 'undefined'\n\t\t? process.versions && process.versions.node\n\t\t: nodeVersion;\n\tif (typeof current !== 'string') {\n\t\tthrow new TypeError(typeof nodeVersion === 'undefined' ? 'Unable to determine current node version' : 'If provided, a valid node version is required');\n\t}\n\tif (specifierValue && typeof specifierValue === 'object') {\n\t\tfor (var i = 0; i < specifierValue.length; ++i) {\n\t\t\tif (matchesRange(current, specifierValue[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\treturn matchesRange(current, specifierValue);\n}\nvar data = require$$1$1;\nvar isCoreModule = function isCore(x, nodeVersion) {\n\treturn hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);\n};\nvar extract_description = extractDescription$1;\nfunction extractDescription$1 (d) {\n  if (!d) {\n    return\n  }\n  if (d === 'ERROR: No README data found!') {\n    return\n  }\n  d = d.trim().split('\\n');\n  let s = 0;\n  while (d[s] && d[s].trim().match(/^(#|$)/)) {\n    s++;\n  }\n  const l = d.length;\n  let e = s + 1;\n  while (e < l && d[e].trim()) {\n    e++;\n  }\n  return d.slice(s, e).join(' ').trim()\n}\nvar topLevel = {\n\tdependancies: \"dependencies\",\n\tdependecies: \"dependencies\",\n\tdepdenencies: \"dependencies\",\n\tdevEependencies: \"devDependencies\",\n\tdepends: \"dependencies\",\n\t\"dev-dependencies\": \"devDependencies\",\n\tdevDependences: \"devDependencies\",\n\tdevDepenencies: \"devDependencies\",\n\tdevdependencies: \"devDependencies\",\n\trepostitory: \"repository\",\n\trepo: \"repository\",\n\tprefereGlobal: \"preferGlobal\",\n\thompage: \"homepage\",\n\thampage: \"homepage\",\n\tautohr: \"author\",\n\tautor: \"author\",\n\tcontributers: \"contributors\",\n\tpublicationConfig: \"publishConfig\",\n\tscript: \"scripts\"\n};\nvar bugs = {\n\tweb: \"url\",\n\tname: \"url\"\n};\nvar script = {\n\tserver: \"start\",\n\ttests: \"test\"\n};\nconst require$$7 = {\n\ttopLevel: topLevel,\n\tbugs: bugs,\n\tscript: script\n};\nvar isValidSemver = valid_1;\nvar cleanSemver = clean_1;\nvar validateLicense = validateNpmPackageLicense;\nvar hostedGitInfo = lib$3;\nvar isBuiltinModule = isCoreModule;\nvar depTypes = ['dependencies', 'devDependencies', 'optionalDependencies'];\nvar extractDescription = extract_description;\nvar url = require$$0;\nvar typos = require$$7;\nvar isEmail = str => str.includes('@') && (str.indexOf('@') < str.lastIndexOf('.'));\nvar fixer$1 = {\n  warn: function () {},\n  fixRepositoryField: function (data) {\n    if (data.repositories) {\n      this.warn('repositories');\n      data.repository = data.repositories[0];\n    }\n    if (!data.repository) {\n      return this.warn('missingRepository')\n    }\n    if (typeof data.repository === 'string') {\n      data.repository = {\n        type: 'git',\n        url: data.repository,\n      };\n    }\n    var r = data.repository.url || '';\n    if (r) {\n      var hosted = hostedGitInfo.fromUrl(r);\n      if (hosted) {\n        r = data.repository.url\n          = hosted.getDefaultRepresentation() === 'shortcut' ? hosted.https() : hosted.toString();\n      }\n    }\n    if (r.match(/github.com\\/[^/]+\\/[^/]+\\.git\\.git$/)) {\n      this.warn('brokenGitUrl', r);\n    }\n  },\n  fixTypos: function (data) {\n    Object.keys(typos.topLevel).forEach(function (d) {\n      if (Object.prototype.hasOwnProperty.call(data, d)) {\n        this.warn('typo', d, typos.topLevel[d]);\n      }\n    }, this);\n  },\n  fixScriptsField: function (data) {\n    if (!data.scripts) {\n      return\n    }\n    if (typeof data.scripts !== 'object') {\n      this.warn('nonObjectScripts');\n      delete data.scripts;\n      return\n    }\n    Object.keys(data.scripts).forEach(function (k) {\n      if (typeof data.scripts[k] !== 'string') {\n        this.warn('nonStringScript');\n        delete data.scripts[k];\n      } else if (typos.script[k] && !data.scripts[typos.script[k]]) {\n        this.warn('typo', k, typos.script[k], 'scripts');\n      }\n    }, this);\n  },\n  fixFilesField: function (data) {\n    var files = data.files;\n    if (files && !Array.isArray(files)) {\n      this.warn('nonArrayFiles');\n      delete data.files;\n    } else if (data.files) {\n      data.files = data.files.filter(function (file) {\n        if (!file || typeof file !== 'string') {\n          this.warn('invalidFilename', file);\n          return false\n        } else {\n          return true\n        }\n      }, this);\n    }\n  },\n  fixBinField: function (data) {\n    if (!data.bin) {\n      return\n    }\n    if (typeof data.bin === 'string') {\n      var b = {};\n      var match;\n      if (match = data.name.match(/^@[^/]+[/](.*)$/)) {\n        b[match[1]] = data.bin;\n      } else {\n        b[data.name] = data.bin;\n      }\n      data.bin = b;\n    }\n  },\n  fixManField: function (data) {\n    if (!data.man) {\n      return\n    }\n    if (typeof data.man === 'string') {\n      data.man = [data.man];\n    }\n  },\n  fixBundleDependenciesField: function (data) {\n    var bdd = 'bundledDependencies';\n    var bd = 'bundleDependencies';\n    if (data[bdd] && !data[bd]) {\n      data[bd] = data[bdd];\n      delete data[bdd];\n    }\n    if (data[bd] && !Array.isArray(data[bd])) {\n      this.warn('nonArrayBundleDependencies');\n      delete data[bd];\n    } else if (data[bd]) {\n      data[bd] = data[bd].filter(function (filtered) {\n        if (!filtered || typeof filtered !== 'string') {\n          this.warn('nonStringBundleDependency', filtered);\n          return false\n        } else {\n          if (!data.dependencies) {\n            data.dependencies = {};\n          }\n          if (!Object.prototype.hasOwnProperty.call(data.dependencies, filtered)) {\n            this.warn('nonDependencyBundleDependency', filtered);\n            data.dependencies[filtered] = '*';\n          }\n          return true\n        }\n      }, this);\n    }\n  },\n  fixDependencies: function (data, strict) {\n    objectifyDeps(data, this.warn);\n    addOptionalDepsToDeps(data, this.warn);\n    this.fixBundleDependenciesField(data)\n    ;['dependencies', 'devDependencies'].forEach(function (deps) {\n      if (!(deps in data)) {\n        return\n      }\n      if (!data[deps] || typeof data[deps] !== 'object') {\n        this.warn('nonObjectDependencies', deps);\n        delete data[deps];\n        return\n      }\n      Object.keys(data[deps]).forEach(function (d) {\n        var r = data[deps][d];\n        if (typeof r !== 'string') {\n          this.warn('nonStringDependency', d, JSON.stringify(r));\n          delete data[deps][d];\n        }\n        var hosted = hostedGitInfo.fromUrl(data[deps][d]);\n        if (hosted) {\n          data[deps][d] = hosted.toString();\n        }\n      }, this);\n    }, this);\n  },\n  fixModulesField: function (data) {\n    if (data.modules) {\n      this.warn('deprecatedModules');\n      delete data.modules;\n    }\n  },\n  fixKeywordsField: function (data) {\n    if (typeof data.keywords === 'string') {\n      data.keywords = data.keywords.split(/,\\s+/);\n    }\n    if (data.keywords && !Array.isArray(data.keywords)) {\n      delete data.keywords;\n      this.warn('nonArrayKeywords');\n    } else if (data.keywords) {\n      data.keywords = data.keywords.filter(function (kw) {\n        if (typeof kw !== 'string' || !kw) {\n          this.warn('nonStringKeyword');\n          return false\n        } else {\n          return true\n        }\n      }, this);\n    }\n  },\n  fixVersionField: function (data, strict) {\n    var loose = !strict;\n    if (!data.version) {\n      data.version = '';\n      return true\n    }\n    if (!isValidSemver(data.version, loose)) {\n      throw new Error('Invalid version: \"' + data.version + '\"')\n    }\n    data.version = cleanSemver(data.version, loose);\n    return true\n  },\n  fixPeople: function (data) {\n    modifyPeople(data, unParsePerson);\n    modifyPeople(data, parsePerson);\n  },\n  fixNameField: function (data, options) {\n    if (typeof options === 'boolean') {\n      options = { strict: options };\n    } else if (typeof options === 'undefined') {\n      options = {};\n    }\n    var strict = options.strict;\n    if (!data.name && !strict) {\n      data.name = '';\n      return\n    }\n    if (typeof data.name !== 'string') {\n      throw new Error('name field must be a string.')\n    }\n    if (!strict) {\n      data.name = data.name.trim();\n    }\n    ensureValidName(data.name, strict, options.allowLegacyCase);\n    if (isBuiltinModule(data.name)) {\n      this.warn('conflictingName', data.name);\n    }\n  },\n  fixDescriptionField: function (data) {\n    if (data.description && typeof data.description !== 'string') {\n      this.warn('nonStringDescription');\n      delete data.description;\n    }\n    if (data.readme && !data.description) {\n      data.description = extractDescription(data.readme);\n    }\n    if (data.description === undefined) {\n      delete data.description;\n    }\n    if (!data.description) {\n      this.warn('missingDescription');\n    }\n  },\n  fixReadmeField: function (data) {\n    if (!data.readme) {\n      this.warn('missingReadme');\n      data.readme = 'ERROR: No README data found!';\n    }\n  },\n  fixBugsField: function (data) {\n    if (!data.bugs && data.repository && data.repository.url) {\n      var hosted = hostedGitInfo.fromUrl(data.repository.url);\n      if (hosted && hosted.bugs()) {\n        data.bugs = { url: hosted.bugs() };\n      }\n    } else if (data.bugs) {\n      if (typeof data.bugs === 'string') {\n        if (isEmail(data.bugs)) {\n          data.bugs = { email: data.bugs };\n        } else if (url.parse(data.bugs).protocol) {\n          data.bugs = { url: data.bugs };\n        } else {\n          this.warn('nonEmailUrlBugsString');\n        }\n      } else {\n        bugsTypos(data.bugs, this.warn);\n        var oldBugs = data.bugs;\n        data.bugs = {};\n        if (oldBugs.url) {\n          if (typeof (oldBugs.url) === 'string' && url.parse(oldBugs.url).protocol) {\n            data.bugs.url = oldBugs.url;\n          } else {\n            this.warn('nonUrlBugsUrlField');\n          }\n        }\n        if (oldBugs.email) {\n          if (typeof (oldBugs.email) === 'string' && isEmail(oldBugs.email)) {\n            data.bugs.email = oldBugs.email;\n          } else {\n            this.warn('nonEmailBugsEmailField');\n          }\n        }\n      }\n      if (!data.bugs.email && !data.bugs.url) {\n        delete data.bugs;\n        this.warn('emptyNormalizedBugs');\n      }\n    }\n  },\n  fixHomepageField: function (data) {\n    if (!data.homepage && data.repository && data.repository.url) {\n      var hosted = hostedGitInfo.fromUrl(data.repository.url);\n      if (hosted && hosted.docs()) {\n        data.homepage = hosted.docs();\n      }\n    }\n    if (!data.homepage) {\n      return\n    }\n    if (typeof data.homepage !== 'string') {\n      this.warn('nonUrlHomepage');\n      return delete data.homepage\n    }\n    if (!url.parse(data.homepage).protocol) {\n      data.homepage = 'http://' + data.homepage;\n    }\n  },\n  fixLicenseField: function (data) {\n    const license = data.license || data.licence;\n    if (!license) {\n      return this.warn('missingLicense')\n    }\n    if (\n      typeof (license) !== 'string' ||\n      license.length < 1 ||\n      license.trim() === ''\n    ) {\n      return this.warn('invalidLicense')\n    }\n    if (!validateLicense(license).validForNewPackages) {\n      return this.warn('invalidLicense')\n    }\n  },\n};\nfunction isValidScopedPackageName (spec) {\n  if (spec.charAt(0) !== '@') {\n    return false\n  }\n  var rest = spec.slice(1).split('/');\n  if (rest.length !== 2) {\n    return false\n  }\n  return rest[0] && rest[1] &&\n    rest[0] === encodeURIComponent(rest[0]) &&\n    rest[1] === encodeURIComponent(rest[1])\n}\nfunction isCorrectlyEncodedName (spec) {\n  return !spec.match(/[/@\\s+%:]/) &&\n    spec === encodeURIComponent(spec)\n}\nfunction ensureValidName (name, strict, allowLegacyCase) {\n  if (name.charAt(0) === '.' ||\n      !(isValidScopedPackageName(name) || isCorrectlyEncodedName(name)) ||\n      (strict && (!allowLegacyCase) && name !== name.toLowerCase()) ||\n      name.toLowerCase() === 'node_modules' ||\n      name.toLowerCase() === 'favicon.ico') {\n    throw new Error('Invalid name: ' + JSON.stringify(name))\n  }\n}\nfunction modifyPeople (data, fn) {\n  if (data.author) {\n    data.author = fn(data.author);\n  }['maintainers', 'contributors'].forEach(function (set) {\n    if (!Array.isArray(data[set])) {\n      return\n    }\n    data[set] = data[set].map(fn);\n  });\n  return data\n}\nfunction unParsePerson (person) {\n  if (typeof person === 'string') {\n    return person\n  }\n  var name = person.name || '';\n  var u = person.url || person.web;\n  var wrappedUrl = u ? (' (' + u + ')') : '';\n  var e = person.email || person.mail;\n  var wrappedEmail = e ? (' <' + e + '>') : '';\n  return name + wrappedEmail + wrappedUrl\n}\nfunction parsePerson (person) {\n  if (typeof person !== 'string') {\n    return person\n  }\n  var matchedName = person.match(/^([^(<]+)/);\n  var matchedUrl = person.match(/\\(([^()]+)\\)/);\n  var matchedEmail = person.match(/<([^<>]+)>/);\n  var obj = {};\n  if (matchedName && matchedName[0].trim()) {\n    obj.name = matchedName[0].trim();\n  }\n  if (matchedEmail) {\n    obj.email = matchedEmail[1];\n  }\n  if (matchedUrl) {\n    obj.url = matchedUrl[1];\n  }\n  return obj\n}\nfunction addOptionalDepsToDeps (data, warn) {\n  var o = data.optionalDependencies;\n  if (!o) {\n    return\n  }\n  var d = data.dependencies || {};\n  Object.keys(o).forEach(function (k) {\n    d[k] = o[k];\n  });\n  data.dependencies = d;\n}\nfunction depObjectify (deps, type, warn) {\n  if (!deps) {\n    return {}\n  }\n  if (typeof deps === 'string') {\n    deps = deps.trim().split(/[\\n\\r\\s\\t ,]+/);\n  }\n  if (!Array.isArray(deps)) {\n    return deps\n  }\n  warn('deprecatedArrayDependencies', type);\n  var o = {};\n  deps.filter(function (d) {\n    return typeof d === 'string'\n  }).forEach(function (d) {\n    d = d.trim().split(/(:?[@\\s><=])/);\n    var dn = d.shift();\n    var dv = d.join('');\n    dv = dv.trim();\n    dv = dv.replace(/^@/, '');\n    o[dn] = dv;\n  });\n  return o\n}\nfunction objectifyDeps (data, warn) {\n  depTypes.forEach(function (type) {\n    if (!data[type]) {\n      return\n    }\n    data[type] = depObjectify(data[type], type, warn);\n  });\n}\nfunction bugsTypos (bugs, warn) {\n  if (!bugs) {\n    return\n  }\n  Object.keys(bugs).forEach(function (k) {\n    if (typos.bugs[k]) {\n      warn('typo', k, typos.bugs[k], 'bugs');\n      bugs[typos.bugs[k]] = bugs[k];\n      delete bugs[k];\n    }\n  });\n}\nvar repositories = \"'repositories' (plural) Not supported. Please pick one as the 'repository' field\";\nvar missingRepository = \"No repository field.\";\nvar brokenGitUrl = \"Probably broken git url: %s\";\nvar nonObjectScripts = \"scripts must be an object\";\nvar nonStringScript = \"script values must be string commands\";\nvar nonArrayFiles = \"Invalid 'files' member\";\nvar invalidFilename = \"Invalid filename in 'files' list: %s\";\nvar nonArrayBundleDependencies = \"Invalid 'bundleDependencies' list. Must be array of package names\";\nvar nonStringBundleDependency = \"Invalid bundleDependencies member: %s\";\nvar nonDependencyBundleDependency = \"Non-dependency in bundleDependencies: %s\";\nvar nonObjectDependencies = \"%s field must be an object\";\nvar nonStringDependency = \"Invalid dependency: %s %s\";\nvar deprecatedArrayDependencies = \"specifying %s as array is deprecated\";\nvar deprecatedModules = \"modules field is deprecated\";\nvar nonArrayKeywords = \"keywords should be an array of strings\";\nvar nonStringKeyword = \"keywords should be an array of strings\";\nvar conflictingName = \"%s is also the name of a node core module.\";\nvar nonStringDescription = \"'description' field should be a string\";\nvar missingDescription = \"No description\";\nvar missingReadme = \"No README data\";\nvar missingLicense = \"No license field.\";\nvar nonEmailUrlBugsString = \"Bug string field must be url, email, or {email,url}\";\nvar nonUrlBugsUrlField = \"bugs.url field must be a string url. Deleted.\";\nvar nonEmailBugsEmailField = \"bugs.email field must be a string email. Deleted.\";\nvar emptyNormalizedBugs = \"Normalized value of bugs field is an empty object. Deleted.\";\nvar nonUrlHomepage = \"homepage field must be a string url. Deleted.\";\nvar invalidLicense = \"license should be a valid SPDX license expression\";\nvar typo = \"%s should probably be %s.\";\nconst require$$1 = {\n\trepositories: repositories,\n\tmissingRepository: missingRepository,\n\tbrokenGitUrl: brokenGitUrl,\n\tnonObjectScripts: nonObjectScripts,\n\tnonStringScript: nonStringScript,\n\tnonArrayFiles: nonArrayFiles,\n\tinvalidFilename: invalidFilename,\n\tnonArrayBundleDependencies: nonArrayBundleDependencies,\n\tnonStringBundleDependency: nonStringBundleDependency,\n\tnonDependencyBundleDependency: nonDependencyBundleDependency,\n\tnonObjectDependencies: nonObjectDependencies,\n\tnonStringDependency: nonStringDependency,\n\tdeprecatedArrayDependencies: deprecatedArrayDependencies,\n\tdeprecatedModules: deprecatedModules,\n\tnonArrayKeywords: nonArrayKeywords,\n\tnonStringKeyword: nonStringKeyword,\n\tconflictingName: conflictingName,\n\tnonStringDescription: nonStringDescription,\n\tmissingDescription: missingDescription,\n\tmissingReadme: missingReadme,\n\tmissingLicense: missingLicense,\n\tnonEmailUrlBugsString: nonEmailUrlBugsString,\n\tnonUrlBugsUrlField: nonUrlBugsUrlField,\n\tnonEmailBugsEmailField: nonEmailBugsEmailField,\n\temptyNormalizedBugs: emptyNormalizedBugs,\n\tnonUrlHomepage: nonUrlHomepage,\n\tinvalidLicense: invalidLicense,\n\ttypo: typo\n};\nvar util = require$$0$1;\nvar messages = require$$1;\nvar make_warning = function () {\n  var args = Array.prototype.slice.call(arguments, 0);\n  var warningName = args.shift();\n  if (warningName === 'typo') {\n    return makeTypoWarning.apply(null, args)\n  } else {\n    var msgTemplate = messages[warningName] ? messages[warningName] : warningName + \": '%s'\";\n    args.unshift(msgTemplate);\n    return util.format.apply(null, args)\n  }\n};\nfunction makeTypoWarning (providedName, probableName, field) {\n  if (field) {\n    providedName = field + \"['\" + providedName + \"']\";\n    probableName = field + \"['\" + probableName + \"']\";\n  }\n  return util.format(messages.typo, providedName, probableName)\n}\nvar normalize_1 = normalize;\nvar fixer = fixer$1;\nnormalize.fixer = fixer;\nvar makeWarning = make_warning;\nvar fieldsToFix = ['name', 'version', 'description', 'repository', 'modules', 'scripts',\n  'files', 'bin', 'man', 'bugs', 'keywords', 'readme', 'homepage', 'license'];\nvar otherThingsToFix = ['dependencies', 'people', 'typos'];\nvar thingsToFix = fieldsToFix.map(function (fieldName) {\n  return ucFirst(fieldName) + 'Field'\n});\nthingsToFix = thingsToFix.concat(otherThingsToFix);\nfunction normalize (data, warn, strict) {\n  if (warn === true) {\n    warn = null;\n    strict = true;\n  }\n  if (!strict) {\n    strict = false;\n  }\n  if (!warn || data.private) {\n    warn = function (msg) {  };\n  }\n  if (data.scripts &&\n      data.scripts.install === 'node-gyp rebuild' &&\n      !data.scripts.preinstall) {\n    data.gypfile = true;\n  }\n  fixer.warn = function () {\n    warn(makeWarning.apply(null, arguments));\n  };\n  thingsToFix.forEach(function (thingName) {\n    fixer['fix' + ucFirst(thingName)](data, strict);\n  });\n  data._id = data.name + '@' + data.version;\n}\nfunction ucFirst (string) {\n  return string.charAt(0).toUpperCase() + string.slice(1)\n}\nconst normalizePackageData = getDefaultExportFromCjs(normalize_1);\nconst toPath$1 = urlOrPath => urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;\nfunction findUpSync(name, {\n\tcwd = process$2.cwd(),\n\ttype = 'file',\n\tstopAt,\n} = {}) {\n\tlet directory = path$1.resolve(toPath$1(cwd) ?? '');\n\tconst {root} = path$1.parse(directory);\n\tstopAt = path$1.resolve(directory, toPath$1(stopAt) ?? root);\n\twhile (directory && directory !== stopAt && directory !== root) {\n\t\tconst filePath = path$1.isAbsolute(name) ? name : path$1.join(directory, name);\n\t\ttry {\n\t\t\tconst stats = fs$1.statSync(filePath, {throwIfNoEntry: false});\n\t\t\tif ((type === 'file' && stats?.isFile()) || (type === 'directory' && stats?.isDirectory())) {\n\t\t\t\treturn filePath;\n\t\t\t}\n\t\t} catch {}\n\t\tdirectory = path$1.dirname(directory);\n\t}\n}\nvar lib$2 = {};\nvar lib$1 = {};\nvar jsTokens = {};\nObject.defineProperty(jsTokens, \"__esModule\", {\n  value: true\n});\njsTokens.default = /((['\"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\'\"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyus]{1,6}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|(0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?)|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-\\/%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\\](){}])|(\\s+)|(^$|[\\s\\S])/g;\njsTokens.matchToToken = function(match) {\n  var token = {type: \"invalid\", value: match[0], closed: undefined};\n       if (match[ 1]) token.type = \"string\" , token.closed = !!(match[3] || match[4]);\n  else if (match[ 5]) token.type = \"comment\";\n  else if (match[ 6]) token.type = \"comment\", token.closed = !!match[7];\n  else if (match[ 8]) token.type = \"regex\";\n  else if (match[ 9]) token.type = \"number\";\n  else if (match[10]) token.type = \"name\";\n  else if (match[11]) token.type = \"punctuator\";\n  else if (match[12]) token.type = \"whitespace\";\n  return token\n};\nvar lib = {};\nvar identifier = {};\nObject.defineProperty(identifier, \"__esModule\", {\n  value: true\n});\nidentifier.isIdentifierChar = isIdentifierChar;\nidentifier.isIdentifierName = isIdentifierName;\nidentifier.isIdentifierStart = isIdentifierStart;\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\nfunction isIdentifierName(name) {\n  let isFirst = true;\n  for (let i = 0; i < name.length; i++) {\n    let cp = name.charCodeAt(i);\n    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {\n      const trail = name.charCodeAt(++i);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    if (isFirst) {\n      isFirst = false;\n      if (!isIdentifierStart(cp)) {\n        return false;\n      }\n    } else if (!isIdentifierChar(cp)) {\n      return false;\n    }\n  }\n  return !isFirst;\n}\nvar keyword = {};\nObject.defineProperty(keyword, \"__esModule\", {\n  value: true\n});\nkeyword.isKeyword = isKeyword;\nkeyword.isReservedWord = isReservedWord;\nkeyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;\nkeyword.isStrictBindReservedWord = isStrictBindReservedWord;\nkeyword.isStrictReservedWord = isStrictReservedWord;\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\n(function (exports) {\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tObject.defineProperty(exports, \"isIdentifierChar\", {\n\t  enumerable: true,\n\t  get: function () {\n\t    return _identifier.isIdentifierChar;\n\t  }\n\t});\n\tObject.defineProperty(exports, \"isIdentifierName\", {\n\t  enumerable: true,\n\t  get: function () {\n\t    return _identifier.isIdentifierName;\n\t  }\n\t});\n\tObject.defineProperty(exports, \"isIdentifierStart\", {\n\t  enumerable: true,\n\t  get: function () {\n\t    return _identifier.isIdentifierStart;\n\t  }\n\t});\n\tObject.defineProperty(exports, \"isKeyword\", {\n\t  enumerable: true,\n\t  get: function () {\n\t    return _keyword.isKeyword;\n\t  }\n\t});\n\tObject.defineProperty(exports, \"isReservedWord\", {\n\t  enumerable: true,\n\t  get: function () {\n\t    return _keyword.isReservedWord;\n\t  }\n\t});\n\tObject.defineProperty(exports, \"isStrictBindOnlyReservedWord\", {\n\t  enumerable: true,\n\t  get: function () {\n\t    return _keyword.isStrictBindOnlyReservedWord;\n\t  }\n\t});\n\tObject.defineProperty(exports, \"isStrictBindReservedWord\", {\n\t  enumerable: true,\n\t  get: function () {\n\t    return _keyword.isStrictBindReservedWord;\n\t  }\n\t});\n\tObject.defineProperty(exports, \"isStrictReservedWord\", {\n\t  enumerable: true,\n\t  get: function () {\n\t    return _keyword.isStrictReservedWord;\n\t  }\n\t});\n\tvar _identifier = identifier;\n\tvar _keyword = keyword;\n} (lib));\nvar chalk$1 = {exports: {}};\nvar matchOperatorsRe$1 = /[|\\\\{}()[\\]^$+*?.]/g;\nvar escapeStringRegexp$1 = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\treturn str.replace(matchOperatorsRe$1, '\\\\$&');\n};\nvar ansiStyles$1 = {exports: {}};\nvar conversions$2 = {exports: {}};\nvar colorName = {\r\t\"aliceblue\": [240, 248, 255],\r\t\"antiquewhite\": [250, 235, 215],\r\t\"aqua\": [0, 255, 255],\r\t\"aquamarine\": [127, 255, 212],\r\t\"azure\": [240, 255, 255],\r\t\"beige\": [245, 245, 220],\r\t\"bisque\": [255, 228, 196],\r\t\"black\": [0, 0, 0],\r\t\"blanchedalmond\": [255, 235, 205],\r\t\"blue\": [0, 0, 255],\r\t\"blueviolet\": [138, 43, 226],\r\t\"brown\": [165, 42, 42],\r\t\"burlywood\": [222, 184, 135],\r\t\"cadetblue\": [95, 158, 160],\r\t\"chartreuse\": [127, 255, 0],\r\t\"chocolate\": [210, 105, 30],\r\t\"coral\": [255, 127, 80],\r\t\"cornflowerblue\": [100, 149, 237],\r\t\"cornsilk\": [255, 248, 220],\r\t\"crimson\": [220, 20, 60],\r\t\"cyan\": [0, 255, 255],\r\t\"darkblue\": [0, 0, 139],\r\t\"darkcyan\": [0, 139, 139],\r\t\"darkgoldenrod\": [184, 134, 11],\r\t\"darkgray\": [169, 169, 169],\r\t\"darkgreen\": [0, 100, 0],\r\t\"darkgrey\": [169, 169, 169],\r\t\"darkkhaki\": [189, 183, 107],\r\t\"darkmagenta\": [139, 0, 139],\r\t\"darkolivegreen\": [85, 107, 47],\r\t\"darkorange\": [255, 140, 0],\r\t\"darkorchid\": [153, 50, 204],\r\t\"darkred\": [139, 0, 0],\r\t\"darksalmon\": [233, 150, 122],\r\t\"darkseagreen\": [143, 188, 143],\r\t\"darkslateblue\": [72, 61, 139],\r\t\"darkslategray\": [47, 79, 79],\r\t\"darkslategrey\": [47, 79, 79],\r\t\"darkturquoise\": [0, 206, 209],\r\t\"darkviolet\": [148, 0, 211],\r\t\"deeppink\": [255, 20, 147],\r\t\"deepskyblue\": [0, 191, 255],\r\t\"dimgray\": [105, 105, 105],\r\t\"dimgrey\": [105, 105, 105],\r\t\"dodgerblue\": [30, 144, 255],\r\t\"firebrick\": [178, 34, 34],\r\t\"floralwhite\": [255, 250, 240],\r\t\"forestgreen\": [34, 139, 34],\r\t\"fuchsia\": [255, 0, 255],\r\t\"gainsboro\": [220, 220, 220],\r\t\"ghostwhite\": [248, 248, 255],\r\t\"gold\": [255, 215, 0],\r\t\"goldenrod\": [218, 165, 32],\r\t\"gray\": [128, 128, 128],\r\t\"green\": [0, 128, 0],\r\t\"greenyellow\": [173, 255, 47],\r\t\"grey\": [128, 128, 128],\r\t\"honeydew\": [240, 255, 240],\r\t\"hotpink\": [255, 105, 180],\r\t\"indianred\": [205, 92, 92],\r\t\"indigo\": [75, 0, 130],\r\t\"ivory\": [255, 255, 240],\r\t\"khaki\": [240, 230, 140],\r\t\"lavender\": [230, 230, 250],\r\t\"lavenderblush\": [255, 240, 245],\r\t\"lawngreen\": [124, 252, 0],\r\t\"lemonchiffon\": [255, 250, 205],\r\t\"lightblue\": [173, 216, 230],\r\t\"lightcoral\": [240, 128, 128],\r\t\"lightcyan\": [224, 255, 255],\r\t\"lightgoldenrodyellow\": [250, 250, 210],\r\t\"lightgray\": [211, 211, 211],\r\t\"lightgreen\": [144, 238, 144],\r\t\"lightgrey\": [211, 211, 211],\r\t\"lightpink\": [255, 182, 193],\r\t\"lightsalmon\": [255, 160, 122],\r\t\"lightseagreen\": [32, 178, 170],\r\t\"lightskyblue\": [135, 206, 250],\r\t\"lightslategray\": [119, 136, 153],\r\t\"lightslategrey\": [119, 136, 153],\r\t\"lightsteelblue\": [176, 196, 222],\r\t\"lightyellow\": [255, 255, 224],\r\t\"lime\": [0, 255, 0],\r\t\"limegreen\": [50, 205, 50],\r\t\"linen\": [250, 240, 230],\r\t\"magenta\": [255, 0, 255],\r\t\"maroon\": [128, 0, 0],\r\t\"mediumaquamarine\": [102, 205, 170],\r\t\"mediumblue\": [0, 0, 205],\r\t\"mediumorchid\": [186, 85, 211],\r\t\"mediumpurple\": [147, 112, 219],\r\t\"mediumseagreen\": [60, 179, 113],\r\t\"mediumslateblue\": [123, 104, 238],\r\t\"mediumspringgreen\": [0, 250, 154],\r\t\"mediumturquoise\": [72, 209, 204],\r\t\"mediumvioletred\": [199, 21, 133],\r\t\"midnightblue\": [25, 25, 112],\r\t\"mintcream\": [245, 255, 250],\r\t\"mistyrose\": [255, 228, 225],\r\t\"moccasin\": [255, 228, 181],\r\t\"navajowhite\": [255, 222, 173],\r\t\"navy\": [0, 0, 128],\r\t\"oldlace\": [253, 245, 230],\r\t\"olive\": [128, 128, 0],\r\t\"olivedrab\": [107, 142, 35],\r\t\"orange\": [255, 165, 0],\r\t\"orangered\": [255, 69, 0],\r\t\"orchid\": [218, 112, 214],\r\t\"palegoldenrod\": [238, 232, 170],\r\t\"palegreen\": [152, 251, 152],\r\t\"paleturquoise\": [175, 238, 238],\r\t\"palevioletred\": [219, 112, 147],\r\t\"papayawhip\": [255, 239, 213],\r\t\"peachpuff\": [255, 218, 185],\r\t\"peru\": [205, 133, 63],\r\t\"pink\": [255, 192, 203],\r\t\"plum\": [221, 160, 221],\r\t\"powderblue\": [176, 224, 230],\r\t\"purple\": [128, 0, 128],\r\t\"rebeccapurple\": [102, 51, 153],\r\t\"red\": [255, 0, 0],\r\t\"rosybrown\": [188, 143, 143],\r\t\"royalblue\": [65, 105, 225],\r\t\"saddlebrown\": [139, 69, 19],\r\t\"salmon\": [250, 128, 114],\r\t\"sandybrown\": [244, 164, 96],\r\t\"seagreen\": [46, 139, 87],\r\t\"seashell\": [255, 245, 238],\r\t\"sienna\": [160, 82, 45],\r\t\"silver\": [192, 192, 192],\r\t\"skyblue\": [135, 206, 235],\r\t\"slateblue\": [106, 90, 205],\r\t\"slategray\": [112, 128, 144],\r\t\"slategrey\": [112, 128, 144],\r\t\"snow\": [255, 250, 250],\r\t\"springgreen\": [0, 255, 127],\r\t\"steelblue\": [70, 130, 180],\r\t\"tan\": [210, 180, 140],\r\t\"teal\": [0, 128, 128],\r\t\"thistle\": [216, 191, 216],\r\t\"tomato\": [255, 99, 71],\r\t\"turquoise\": [64, 224, 208],\r\t\"violet\": [238, 130, 238],\r\t\"wheat\": [245, 222, 179],\r\t\"white\": [255, 255, 255],\r\t\"whitesmoke\": [245, 245, 245],\r\t\"yellow\": [255, 255, 0],\r\t\"yellowgreen\": [154, 205, 50]\r};\nvar cssKeywords = colorName;\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n\tif (cssKeywords.hasOwnProperty(key)) {\n\t\treverseKeywords[cssKeywords[key]] = key;\n\t}\n}\nvar convert$1 = conversions$2.exports = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\nfor (var model in convert$1) {\n\tif (convert$1.hasOwnProperty(model)) {\n\t\tif (!('channels' in convert$1[model])) {\n\t\t\tthrow new Error('missing channels property: ' + model);\n\t\t}\n\t\tif (!('labels' in convert$1[model])) {\n\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t}\n\t\tif (convert$1[model].labels.length !== convert$1[model].channels) {\n\t\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t\t}\n\t\tvar channels = convert$1[model].channels;\n\t\tvar labels = convert$1[model].labels;\n\t\tdelete convert$1[model].channels;\n\t\tdelete convert$1[model].labels;\n\t\tObject.defineProperty(convert$1[model], 'channels', {value: channels});\n\t\tObject.defineProperty(convert$1[model], 'labels', {value: labels});\n\t}\n}\nconvert$1.rgb.hsl = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar min = Math.min(r, g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar s;\n\tvar l;\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\th = Math.min(h * 60, 360);\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\tl = (min + max) / 2;\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\treturn [h, s * 100, l * 100];\n};\nconvert$1.rgb.hsv = function (rgb) {\n\tvar rdif;\n\tvar gdif;\n\tvar bdif;\n\tvar h;\n\tvar s;\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar v = Math.max(r, g, b);\n\tvar diff = v - Math.min(r, g, b);\n\tvar diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\tif (diff === 0) {\n\t\th = s = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\nconvert$1.rgb.hwb = function (rgb) {\n\tvar r = rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar h = convert$1.rgb.hsl(rgb)[0];\n\tvar w = 1 / 255 * Math.min(r, Math.min(g, b));\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\treturn [h, w * 100, b * 100];\n};\nconvert$1.rgb.cmyk = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar c;\n\tvar m;\n\tvar y;\n\tvar k;\n\tk = Math.min(1 - r, 1 - g, 1 - b);\n\tc = (1 - r - k) / (1 - k) || 0;\n\tm = (1 - g - k) / (1 - k) || 0;\n\ty = (1 - b - k) / (1 - k) || 0;\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\nfunction comparativeDistance(x, y) {\n\treturn (\n\t\tMath.pow(x[0] - y[0], 2) +\n\t\tMath.pow(x[1] - y[1], 2) +\n\t\tMath.pow(x[2] - y[2], 2)\n\t);\n}\nconvert$1.rgb.keyword = function (rgb) {\n\tvar reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\tvar currentClosestDistance = Infinity;\n\tvar currentClosestKeyword;\n\tfor (var keyword in cssKeywords) {\n\t\tif (cssKeywords.hasOwnProperty(keyword)) {\n\t\t\tvar value = cssKeywords[keyword];\n\t\t\tvar distance = comparativeDistance(rgb, value);\n\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\tcurrentClosestDistance = distance;\n\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t}\n\t\t}\n\t}\n\treturn currentClosestKeyword;\n};\nconvert$1.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\nconvert$1.rgb.xyz = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\tvar x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tvar y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tvar z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\treturn [x * 100, y * 100, z * 100];\n};\nconvert$1.rgb.lab = function (rgb) {\n\tvar xyz = convert$1.rgb.xyz(rgb);\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\treturn [l, a, b];\n};\nconvert$1.hsl.rgb = function (hsl) {\n\tvar h = hsl[0] / 360;\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar rgb;\n\tvar val;\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\tt1 = 2 * l - t2;\n\trgb = [0, 0, 0];\n\tfor (var i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\t\trgb[i] = val * 255;\n\t}\n\treturn rgb;\n};\nconvert$1.hsl.hsv = function (hsl) {\n\tvar h = hsl[0];\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar smin = s;\n\tvar lmin = Math.max(l, 0.01);\n\tvar sv;\n\tvar v;\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tv = (l + s) / 2;\n\tsv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\treturn [h, sv * 100, v * 100];\n};\nconvert$1.hsv.rgb = function (hsv) {\n\tvar h = hsv[0] / 60;\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar hi = Math.floor(h) % 6;\n\tvar f = h - Math.floor(h);\n\tvar p = 255 * v * (1 - s);\n\tvar q = 255 * v * (1 - (s * f));\n\tvar t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\nconvert$1.hsv.hsl = function (hsv) {\n\tvar h = hsv[0];\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar vmin = Math.max(v, 0.01);\n\tvar lmin;\n\tvar sl;\n\tvar l;\n\tl = (2 - s) * v;\n\tlmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\treturn [h, sl * 100, l * 100];\n};\nconvert$1.hwb.rgb = function (hwb) {\n\tvar h = hwb[0] / 360;\n\tvar wh = hwb[1] / 100;\n\tvar bl = hwb[2] / 100;\n\tvar ratio = wh + bl;\n\tvar i;\n\tvar v;\n\tvar f;\n\tvar n;\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\ti = Math.floor(6 * h);\n\tv = 1 - bl;\n\tf = 6 * h - i;\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\tn = wh + f * (v - wh); \n\tvar r;\n\tvar g;\n\tvar b;\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v; g = n; b = wh; break;\n\t\tcase 1: r = n; g = v; b = wh; break;\n\t\tcase 2: r = wh; g = v; b = n; break;\n\t\tcase 3: r = wh; g = n; b = v; break;\n\t\tcase 4: r = n; g = wh; b = v; break;\n\t\tcase 5: r = v; g = wh; b = n; break;\n\t}\n\treturn [r * 255, g * 255, b * 255];\n};\nconvert$1.cmyk.rgb = function (cmyk) {\n\tvar c = cmyk[0] / 100;\n\tvar m = cmyk[1] / 100;\n\tvar y = cmyk[2] / 100;\n\tvar k = cmyk[3] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\tr = 1 - Math.min(1, c * (1 - k) + k);\n\tg = 1 - Math.min(1, m * (1 - k) + k);\n\tb = 1 - Math.min(1, y * (1 - k) + k);\n\treturn [r * 255, g * 255, b * 255];\n};\nconvert$1.xyz.rgb = function (xyz) {\n\tvar x = xyz[0] / 100;\n\tvar y = xyz[1] / 100;\n\tvar z = xyz[2] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\tr = r > 0.0031308\n\t\t? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r * 12.92;\n\tg = g > 0.0031308\n\t\t? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g * 12.92;\n\tb = b > 0.0031308\n\t\t? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b * 12.92;\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\treturn [r * 255, g * 255, b * 255];\n};\nconvert$1.xyz.lab = function (xyz) {\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\treturn [l, a, b];\n};\nconvert$1.lab.xyz = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar x;\n\tvar y;\n\tvar z;\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\tvar y2 = Math.pow(y, 3);\n\tvar x2 = Math.pow(x, 3);\n\tvar z2 = Math.pow(z, 3);\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\treturn [x, y, z];\n};\nconvert$1.lab.lch = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar hr;\n\tvar h;\n\tvar c;\n\thr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\tc = Math.sqrt(a * a + b * b);\n\treturn [l, c, h];\n};\nconvert$1.lch.lab = function (lch) {\n\tvar l = lch[0];\n\tvar c = lch[1];\n\tvar h = lch[2];\n\tvar a;\n\tvar b;\n\tvar hr;\n\thr = h / 360 * 2 * Math.PI;\n\ta = c * Math.cos(hr);\n\tb = c * Math.sin(hr);\n\treturn [l, a, b];\n};\nconvert$1.rgb.ansi16 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tvar value = 1 in arguments ? arguments[1] : convert$1.rgb.hsv(args)[2]; \n\tvalue = Math.round(value / 50);\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\tvar ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\treturn ansi;\n};\nconvert$1.hsv.ansi16 = function (args) {\n\treturn convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);\n};\nconvert$1.rgb.ansi256 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\tvar ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\treturn ansi;\n};\nconvert$1.ansi16.rgb = function (args) {\n\tvar color = args % 10;\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\t\tcolor = color / 10.5 * 255;\n\t\treturn [color, color, color];\n\t}\n\tvar mult = (~~(args > 50) + 1) * 0.5;\n\tvar r = ((color & 1) * mult) * 255;\n\tvar g = (((color >> 1) & 1) * mult) * 255;\n\tvar b = (((color >> 2) & 1) * mult) * 255;\n\treturn [r, g, b];\n};\nconvert$1.ansi256.rgb = function (args) {\n\tif (args >= 232) {\n\t\tvar c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\targs -= 16;\n\tvar rem;\n\tvar r = Math.floor(args / 36) / 5 * 255;\n\tvar g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tvar b = (rem % 6) / 5 * 255;\n\treturn [r, g, b];\n};\nconvert$1.rgb.hex = function (args) {\n\tvar integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\nconvert$1.hex.rgb = function (args) {\n\tvar match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\tvar colorString = match[0];\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(function (char) {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\tvar integer = parseInt(colorString, 16);\n\tvar r = (integer >> 16) & 0xFF;\n\tvar g = (integer >> 8) & 0xFF;\n\tvar b = integer & 0xFF;\n\treturn [r, g, b];\n};\nconvert$1.rgb.hcg = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar max = Math.max(Math.max(r, g), b);\n\tvar min = Math.min(Math.min(r, g), b);\n\tvar chroma = (max - min);\n\tvar grayscale;\n\tvar hue;\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma + 4;\n\t}\n\thue /= 6;\n\thue %= 1;\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\nconvert$1.hsl.hcg = function (hsl) {\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar c = 1;\n\tvar f = 0;\n\tif (l < 0.5) {\n\t\tc = 2.0 * s * l;\n\t} else {\n\t\tc = 2.0 * s * (1.0 - l);\n\t}\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\treturn [hsl[0], c * 100, f * 100];\n};\nconvert$1.hsv.hcg = function (hsv) {\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar c = s * v;\n\tvar f = 0;\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\treturn [hsv[0], c * 100, f * 100];\n};\nconvert$1.hcg.rgb = function (hcg) {\n\tvar h = hcg[0] / 360;\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\tvar pure = [0, 0, 0];\n\tvar hi = (h % 1) * 6;\n\tvar v = hi % 1;\n\tvar w = 1 - v;\n\tvar mg = 0;\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\tmg = (1.0 - c) * g;\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\nconvert$1.hcg.hsv = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\tvar f = 0;\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\treturn [hcg[0], f * 100, v * 100];\n};\nconvert$1.hcg.hsl = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tvar l = g * (1.0 - c) + 0.5 * c;\n\tvar s = 0;\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\treturn [hcg[0], s * 100, l * 100];\n};\nconvert$1.hcg.hwb = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\nconvert$1.hwb.hcg = function (hwb) {\n\tvar w = hwb[1] / 100;\n\tvar b = hwb[2] / 100;\n\tvar v = 1 - b;\n\tvar c = v - w;\n\tvar g = 0;\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\treturn [hwb[0], c * 100, g * 100];\n};\nconvert$1.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\nconvert$1.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\nconvert$1.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\nconvert$1.gray.hsl = convert$1.gray.hsv = function (args) {\n\treturn [0, 0, args[0]];\n};\nconvert$1.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\nconvert$1.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\nconvert$1.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\nconvert$1.gray.hex = function (gray) {\n\tvar val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tvar integer = (val << 16) + (val << 8) + val;\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\nconvert$1.rgb.gray = function (rgb) {\n\tvar val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\nvar conversionsExports = conversions$2.exports;\nvar conversions$1 = conversionsExports;\nfunction buildGraph() {\n\tvar graph = {};\n\tvar models = Object.keys(conversions$1);\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\treturn graph;\n}\nfunction deriveBFS(fromModel) {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; \n\tgraph[fromModel].distance = 0;\n\twhile (queue.length) {\n\t\tvar current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions$1[current]);\n\t\tfor (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar node = graph[adjacent];\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\treturn graph;\n}\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\nfunction wrapConversion(toModel, graph) {\n\tvar path = [graph[toModel].parent, toModel];\n\tvar fn = conversions$1[graph[toModel].parent][toModel];\n\tvar cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions$1[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\tfn.conversion = path;\n\treturn fn;\n}\nvar route$1 = function (fromModel) {\n\tvar graph = deriveBFS(fromModel);\n\tvar conversion = {};\n\tvar models = Object.keys(graph);\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar node = graph[toModel];\n\t\tif (node.parent === null) {\n\t\t\tcontinue;\n\t\t}\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\treturn conversion;\n};\nvar conversions = conversionsExports;\nvar route = route$1;\nvar convert = {};\nvar models = Object.keys(conversions);\nfunction wrapRaw(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\t\treturn fn(args);\n\t};\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\treturn wrappedFn;\n}\nfunction wrapRounded(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\t\tvar result = fn(args);\n\t\tif (typeof result === 'object') {\n\t\t\tfor (var len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\treturn wrappedFn;\n}\nmodels.forEach(function (fromModel) {\n\tconvert[fromModel] = {};\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\tvar routes = route(fromModel);\n\tvar routeModels = Object.keys(routes);\n\trouteModels.forEach(function (toModel) {\n\t\tvar fn = routes[toModel];\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\nvar colorConvert = convert;\nansiStyles$1.exports;\n(function (module) {\n\tconst colorConvert$1 = colorConvert;\n\tconst wrapAnsi16 = (fn, offset) => function () {\n\t\tconst code = fn.apply(colorConvert$1, arguments);\n\t\treturn `\\u001B[${code + offset}m`;\n\t};\n\tconst wrapAnsi256 = (fn, offset) => function () {\n\t\tconst code = fn.apply(colorConvert$1, arguments);\n\t\treturn `\\u001B[${38 + offset};5;${code}m`;\n\t};\n\tconst wrapAnsi16m = (fn, offset) => function () {\n\t\tconst rgb = fn.apply(colorConvert$1, arguments);\n\t\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n\t};\n\tfunction assembleStyles() {\n\t\tconst codes = new Map();\n\t\tconst styles = {\n\t\t\tmodifier: {\n\t\t\t\treset: [0, 0],\n\t\t\t\tbold: [1, 22],\n\t\t\t\tdim: [2, 22],\n\t\t\t\titalic: [3, 23],\n\t\t\t\tunderline: [4, 24],\n\t\t\t\tinverse: [7, 27],\n\t\t\t\thidden: [8, 28],\n\t\t\t\tstrikethrough: [9, 29]\n\t\t\t},\n\t\t\tcolor: {\n\t\t\t\tblack: [30, 39],\n\t\t\t\tred: [31, 39],\n\t\t\t\tgreen: [32, 39],\n\t\t\t\tyellow: [33, 39],\n\t\t\t\tblue: [34, 39],\n\t\t\t\tmagenta: [35, 39],\n\t\t\t\tcyan: [36, 39],\n\t\t\t\twhite: [37, 39],\n\t\t\t\tgray: [90, 39],\n\t\t\t\tredBright: [91, 39],\n\t\t\t\tgreenBright: [92, 39],\n\t\t\t\tyellowBright: [93, 39],\n\t\t\t\tblueBright: [94, 39],\n\t\t\t\tmagentaBright: [95, 39],\n\t\t\t\tcyanBright: [96, 39],\n\t\t\t\twhiteBright: [97, 39]\n\t\t\t},\n\t\t\tbgColor: {\n\t\t\t\tbgBlack: [40, 49],\n\t\t\t\tbgRed: [41, 49],\n\t\t\t\tbgGreen: [42, 49],\n\t\t\t\tbgYellow: [43, 49],\n\t\t\t\tbgBlue: [44, 49],\n\t\t\t\tbgMagenta: [45, 49],\n\t\t\t\tbgCyan: [46, 49],\n\t\t\t\tbgWhite: [47, 49],\n\t\t\t\tbgBlackBright: [100, 49],\n\t\t\t\tbgRedBright: [101, 49],\n\t\t\t\tbgGreenBright: [102, 49],\n\t\t\t\tbgYellowBright: [103, 49],\n\t\t\t\tbgBlueBright: [104, 49],\n\t\t\t\tbgMagentaBright: [105, 49],\n\t\t\t\tbgCyanBright: [106, 49],\n\t\t\t\tbgWhiteBright: [107, 49]\n\t\t\t}\n\t\t};\n\t\tstyles.color.grey = styles.color.gray;\n\t\tfor (const groupName of Object.keys(styles)) {\n\t\t\tconst group = styles[groupName];\n\t\t\tfor (const styleName of Object.keys(group)) {\n\t\t\t\tconst style = group[styleName];\n\t\t\t\tstyles[styleName] = {\n\t\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t\t};\n\t\t\t\tgroup[styleName] = styles[styleName];\n\t\t\t\tcodes.set(style[0], style[1]);\n\t\t\t}\n\t\t\tObject.defineProperty(styles, groupName, {\n\t\t\t\tvalue: group,\n\t\t\t\tenumerable: false\n\t\t\t});\n\t\t\tObject.defineProperty(styles, 'codes', {\n\t\t\t\tvalue: codes,\n\t\t\t\tenumerable: false\n\t\t\t});\n\t\t}\n\t\tconst ansi2ansi = n => n;\n\t\tconst rgb2rgb = (r, g, b) => [r, g, b];\n\t\tstyles.color.close = '\\u001B[39m';\n\t\tstyles.bgColor.close = '\\u001B[49m';\n\t\tstyles.color.ansi = {\n\t\t\tansi: wrapAnsi16(ansi2ansi, 0)\n\t\t};\n\t\tstyles.color.ansi256 = {\n\t\t\tansi256: wrapAnsi256(ansi2ansi, 0)\n\t\t};\n\t\tstyles.color.ansi16m = {\n\t\t\trgb: wrapAnsi16m(rgb2rgb, 0)\n\t\t};\n\t\tstyles.bgColor.ansi = {\n\t\t\tansi: wrapAnsi16(ansi2ansi, 10)\n\t\t};\n\t\tstyles.bgColor.ansi256 = {\n\t\t\tansi256: wrapAnsi256(ansi2ansi, 10)\n\t\t};\n\t\tstyles.bgColor.ansi16m = {\n\t\t\trgb: wrapAnsi16m(rgb2rgb, 10)\n\t\t};\n\t\tfor (let key of Object.keys(colorConvert$1)) {\n\t\t\tif (typeof colorConvert$1[key] !== 'object') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst suite = colorConvert$1[key];\n\t\t\tif (key === 'ansi16') {\n\t\t\t\tkey = 'ansi';\n\t\t\t}\n\t\t\tif ('ansi16' in suite) {\n\t\t\t\tstyles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);\n\t\t\t\tstyles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);\n\t\t\t}\n\t\t\tif ('ansi256' in suite) {\n\t\t\t\tstyles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);\n\t\t\t\tstyles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);\n\t\t\t}\n\t\t\tif ('rgb' in suite) {\n\t\t\t\tstyles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);\n\t\t\t\tstyles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);\n\t\t\t}\n\t\t}\n\t\treturn styles;\n\t}\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tget: assembleStyles\n\t}); \n} (ansiStyles$1));\nvar ansiStylesExports$1 = ansiStyles$1.exports;\nvar hasFlag$3 = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\nconst os$1 = require$$0$2;\nconst hasFlag$2 = hasFlag$3;\nconst env$1 = process.env;\nlet forceColor$1;\nif (hasFlag$2('no-color') ||\n\thasFlag$2('no-colors') ||\n\thasFlag$2('color=false')) {\n\tforceColor$1 = false;\n} else if (hasFlag$2('color') ||\n\thasFlag$2('colors') ||\n\thasFlag$2('color=true') ||\n\thasFlag$2('color=always')) {\n\tforceColor$1 = true;\n}\nif ('FORCE_COLOR' in env$1) {\n\tforceColor$1 = env$1.FORCE_COLOR.length === 0 || parseInt(env$1.FORCE_COLOR, 10) !== 0;\n}\nfunction translateLevel$1(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\nfunction supportsColor$1(stream) {\n\tif (forceColor$1 === false) {\n\t\treturn 0;\n\t}\n\tif (hasFlag$2('color=16m') ||\n\t\thasFlag$2('color=full') ||\n\t\thasFlag$2('color=truecolor')) {\n\t\treturn 3;\n\t}\n\tif (hasFlag$2('color=256')) {\n\t\treturn 2;\n\t}\n\tif (stream && !stream.isTTY && forceColor$1 !== true) {\n\t\treturn 0;\n\t}\n\tconst min = forceColor$1 ? 1 : 0;\n\tif (process.platform === 'win32') {\n\t\tconst osRelease = os$1.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\t\treturn 1;\n\t}\n\tif ('CI' in env$1) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env$1) || env$1.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\t\treturn min;\n\t}\n\tif ('TEAMCITY_VERSION' in env$1) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env$1.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\tif (env$1.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\tif ('TERM_PROGRAM' in env$1) {\n\t\tconst version = parseInt((env$1.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\t\tswitch (env$1.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t}\n\t}\n\tif (/-256(color)?$/i.test(env$1.TERM)) {\n\t\treturn 2;\n\t}\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1.TERM)) {\n\t\treturn 1;\n\t}\n\tif ('COLORTERM' in env$1) {\n\t\treturn 1;\n\t}\n\tif (env$1.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\treturn min;\n}\nfunction getSupportLevel$1(stream) {\n\tconst level = supportsColor$1(stream);\n\treturn translateLevel$1(level);\n}\nvar supportsColor_1$1 = {\n\tsupportsColor: getSupportLevel$1,\n\tstdout: getSupportLevel$1(process.stdout),\n\tstderr: getSupportLevel$1(process.stderr)\n};\nconst TEMPLATE_REGEX$1 = /(?:\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX$1 = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX$1 = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX$1 = /\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.)|([^\\\\])/gi;\nconst ESCAPES$1 = new Map([\n\t['n', '\\n'],\n\t['r', '\\r'],\n\t['t', '\\t'],\n\t['b', '\\b'],\n\t['f', '\\f'],\n\t['v', '\\v'],\n\t['0', '\\0'],\n\t['\\\\', '\\\\'],\n\t['e', '\\u001B'],\n\t['a', '\\u0007']\n]);\nfunction unescape$1(c) {\n\tif ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {\n\t\treturn String.fromCharCode(parseInt(c.slice(1), 16));\n\t}\n\treturn ESCAPES$1.get(c) || c;\n}\nfunction parseArguments$1(name, args) {\n\tconst results = [];\n\tconst chunks = args.trim().split(/\\s*,\\s*/g);\n\tlet matches;\n\tfor (const chunk of chunks) {\n\t\tif (!isNaN(chunk)) {\n\t\t\tresults.push(Number(chunk));\n\t\t} else if ((matches = chunk.match(STRING_REGEX$1))) {\n\t\t\tresults.push(matches[2].replace(ESCAPE_REGEX$1, (m, escape, chr) => escape ? unescape$1(escape) : chr));\n\t\t} else {\n\t\t\tthrow new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n\t\t}\n\t}\n\treturn results;\n}\nfunction parseStyle$1(style) {\n\tSTYLE_REGEX$1.lastIndex = 0;\n\tconst results = [];\n\tlet matches;\n\twhile ((matches = STYLE_REGEX$1.exec(style)) !== null) {\n\t\tconst name = matches[1];\n\t\tif (matches[2]) {\n\t\t\tconst args = parseArguments$1(name, matches[2]);\n\t\t\tresults.push([name].concat(args));\n\t\t} else {\n\t\t\tresults.push([name]);\n\t\t}\n\t}\n\treturn results;\n}\nfunction buildStyle$1(chalk, styles) {\n\tconst enabled = {};\n\tfor (const layer of styles) {\n\t\tfor (const style of layer.styles) {\n\t\t\tenabled[style[0]] = layer.inverse ? null : style.slice(1);\n\t\t}\n\t}\n\tlet current = chalk;\n\tfor (const styleName of Object.keys(enabled)) {\n\t\tif (Array.isArray(enabled[styleName])) {\n\t\t\tif (!(styleName in current)) {\n\t\t\t\tthrow new Error(`Unknown Chalk style: ${styleName}`);\n\t\t\t}\n\t\t\tif (enabled[styleName].length > 0) {\n\t\t\t\tcurrent = current[styleName].apply(current, enabled[styleName]);\n\t\t\t} else {\n\t\t\t\tcurrent = current[styleName];\n\t\t\t}\n\t\t}\n\t}\n\treturn current;\n}\nvar templates$1 = (chalk, tmp) => {\n\tconst styles = [];\n\tconst chunks = [];\n\tlet chunk = [];\n\ttmp.replace(TEMPLATE_REGEX$1, (m, escapeChar, inverse, style, close, chr) => {\n\t\tif (escapeChar) {\n\t\t\tchunk.push(unescape$1(escapeChar));\n\t\t} else if (style) {\n\t\t\tconst str = chunk.join('');\n\t\t\tchunk = [];\n\t\t\tchunks.push(styles.length === 0 ? str : buildStyle$1(chalk, styles)(str));\n\t\t\tstyles.push({inverse, styles: parseStyle$1(style)});\n\t\t} else if (close) {\n\t\t\tif (styles.length === 0) {\n\t\t\t\tthrow new Error('Found extraneous } in Chalk template literal');\n\t\t\t}\n\t\t\tchunks.push(buildStyle$1(chalk, styles)(chunk.join('')));\n\t\t\tchunk = [];\n\t\t\tstyles.pop();\n\t\t} else {\n\t\t\tchunk.push(chr);\n\t\t}\n\t});\n\tchunks.push(chunk.join(''));\n\tif (styles.length > 0) {\n\t\tconst errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\\`}\\`)`;\n\t\tthrow new Error(errMsg);\n\t}\n\treturn chunks.join('');\n};\n(function (module) {\n\tconst escapeStringRegexp = escapeStringRegexp$1;\n\tconst ansiStyles = ansiStylesExports$1;\n\tconst stdoutColor = supportsColor_1$1.stdout;\n\tconst template = templates$1;\n\tconst isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');\n\tconst levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];\n\tconst skipModels = new Set(['gray']);\n\tconst styles = Object.create(null);\n\tfunction applyOptions(obj, options) {\n\t\toptions = options || {};\n\t\tconst scLevel = stdoutColor ? stdoutColor.level : 0;\n\t\tobj.level = options.level === undefined ? scLevel : options.level;\n\t\tobj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;\n\t}\n\tfunction Chalk(options) {\n\t\tif (!this || !(this instanceof Chalk) || this.template) {\n\t\t\tconst chalk = {};\n\t\t\tapplyOptions(chalk, options);\n\t\t\tchalk.template = function () {\n\t\t\t\tconst args = [].slice.call(arguments);\n\t\t\t\treturn chalkTag.apply(null, [chalk.template].concat(args));\n\t\t\t};\n\t\t\tObject.setPrototypeOf(chalk, Chalk.prototype);\n\t\t\tObject.setPrototypeOf(chalk.template, chalk);\n\t\t\tchalk.template.constructor = Chalk;\n\t\t\treturn chalk.template;\n\t\t}\n\t\tapplyOptions(this, options);\n\t}\n\tif (isSimpleWindowsTerm) {\n\t\tansiStyles.blue.open = '\\u001B[94m';\n\t}\n\tfor (const key of Object.keys(ansiStyles)) {\n\t\tansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n\t\tstyles[key] = {\n\t\t\tget() {\n\t\t\t\tconst codes = ansiStyles[key];\n\t\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);\n\t\t\t}\n\t\t};\n\t}\n\tstyles.visible = {\n\t\tget() {\n\t\t\treturn build.call(this, this._styles || [], true, 'visible');\n\t\t}\n\t};\n\tansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');\n\tfor (const model of Object.keys(ansiStyles.color.ansi)) {\n\t\tif (skipModels.has(model)) {\n\t\t\tcontinue;\n\t\t}\n\t\tstyles[model] = {\n\t\t\tget() {\n\t\t\t\tconst level = this.level;\n\t\t\t\treturn function () {\n\t\t\t\t\tconst open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);\n\t\t\t\t\tconst codes = {\n\t\t\t\t\t\topen,\n\t\t\t\t\t\tclose: ansiStyles.color.close,\n\t\t\t\t\t\tcloseRe: ansiStyles.color.closeRe\n\t\t\t\t\t};\n\t\t\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n\tansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');\n\tfor (const model of Object.keys(ansiStyles.bgColor.ansi)) {\n\t\tif (skipModels.has(model)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n\t\tstyles[bgModel] = {\n\t\t\tget() {\n\t\t\t\tconst level = this.level;\n\t\t\t\treturn function () {\n\t\t\t\t\tconst open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);\n\t\t\t\t\tconst codes = {\n\t\t\t\t\t\topen,\n\t\t\t\t\t\tclose: ansiStyles.bgColor.close,\n\t\t\t\t\t\tcloseRe: ansiStyles.bgColor.closeRe\n\t\t\t\t\t};\n\t\t\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n\tconst proto = Object.defineProperties(() => {}, styles);\n\tfunction build(_styles, _empty, key) {\n\t\tconst builder = function () {\n\t\t\treturn applyStyle.apply(builder, arguments);\n\t\t};\n\t\tbuilder._styles = _styles;\n\t\tbuilder._empty = _empty;\n\t\tconst self = this;\n\t\tObject.defineProperty(builder, 'level', {\n\t\t\tenumerable: true,\n\t\t\tget() {\n\t\t\t\treturn self.level;\n\t\t\t},\n\t\t\tset(level) {\n\t\t\t\tself.level = level;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(builder, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tget() {\n\t\t\t\treturn self.enabled;\n\t\t\t},\n\t\t\tset(enabled) {\n\t\t\t\tself.enabled = enabled;\n\t\t\t}\n\t\t});\n\t\tbuilder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';\n\t\tbuilder.__proto__ = proto; \n\t\treturn builder;\n\t}\n\tfunction applyStyle() {\n\t\tconst args = arguments;\n\t\tconst argsLen = args.length;\n\t\tlet str = String(arguments[0]);\n\t\tif (argsLen === 0) {\n\t\t\treturn '';\n\t\t}\n\t\tif (argsLen > 1) {\n\t\t\tfor (let a = 1; a < argsLen; a++) {\n\t\t\t\tstr += ' ' + args[a];\n\t\t\t}\n\t\t}\n\t\tif (!this.enabled || this.level <= 0 || !str) {\n\t\t\treturn this._empty ? '' : str;\n\t\t}\n\t\tconst originalDim = ansiStyles.dim.open;\n\t\tif (isSimpleWindowsTerm && this.hasGrey) {\n\t\t\tansiStyles.dim.open = '';\n\t\t}\n\t\tfor (const code of this._styles.slice().reverse()) {\n\t\t\tstr = code.open + str.replace(code.closeRe, code.open) + code.close;\n\t\t\tstr = str.replace(/\\r?\\n/g, `${code.close}$&${code.open}`);\n\t\t}\n\t\tansiStyles.dim.open = originalDim;\n\t\treturn str;\n\t}\n\tfunction chalkTag(chalk, strings) {\n\t\tif (!Array.isArray(strings)) {\n\t\t\treturn [].slice.call(arguments, 1).join(' ');\n\t\t}\n\t\tconst args = [].slice.call(arguments, 2);\n\t\tconst parts = [strings.raw[0]];\n\t\tfor (let i = 1; i < strings.length; i++) {\n\t\t\tparts.push(String(args[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'));\n\t\t\tparts.push(String(strings.raw[i]));\n\t\t}\n\t\treturn template(chalk, parts.join(''));\n\t}\n\tObject.defineProperties(Chalk.prototype, styles);\n\tmodule.exports = Chalk(); \n\tmodule.exports.supportsColor = stdoutColor;\n\tmodule.exports.default = module.exports; \n} (chalk$1));\nvar chalkExports$1 = chalk$1.exports;\nObject.defineProperty(lib$1, \"__esModule\", {\n  value: true\n});\nlib$1.default = highlight;\nlib$1.shouldHighlight = shouldHighlight;\nvar _jsTokens = jsTokens;\nvar _helperValidatorIdentifier = lib;\nvar _chalk$1 = _interopRequireWildcard$1(chalkExports$1, true);\nfunction _getRequireWildcardCache$1(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache$1 = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard$1(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache$1(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nconst sometimesKeywords = new Set([\"as\", \"async\", \"from\", \"get\", \"of\", \"set\"]);\nfunction getDefs$1(chalk) {\n  return {\n    keyword: chalk.cyan,\n    capitalized: chalk.yellow,\n    jsxIdentifier: chalk.yellow,\n    punctuator: chalk.yellow,\n    number: chalk.magenta,\n    string: chalk.green,\n    regex: chalk.magenta,\n    comment: chalk.grey,\n    invalid: chalk.white.bgRed.bold\n  };\n}\nconst NEWLINE$1 = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\nconst BRACKET = /^[()[\\]{}]$/;\nlet tokenize;\n{\n  const JSX_TAG = /^[a-z][\\w-]*$/i;\n  const getTokenType = function (token, offset, text) {\n    if (token.type === \"name\") {\n      if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {\n        return \"keyword\";\n      }\n      if (JSX_TAG.test(token.value) && (text[offset - 1] === \"<\" || text.slice(offset - 2, offset) == \"</\")) {\n        return \"jsxIdentifier\";\n      }\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n    if (token.type === \"punctuator\" && BRACKET.test(token.value)) {\n      return \"bracket\";\n    }\n    if (token.type === \"invalid\" && (token.value === \"@\" || token.value === \"#\")) {\n      return \"punctuator\";\n    }\n    return token.type;\n  };\n  tokenize = function* (text) {\n    let match;\n    while (match = _jsTokens.default.exec(text)) {\n      const token = _jsTokens.matchToToken(match);\n      yield {\n        type: getTokenType(token, match.index, text),\n        value: token.value\n      };\n    }\n  };\n}\nfunction highlightTokens(defs, text) {\n  let highlighted = \"\";\n  for (const {\n    type,\n    value\n  } of tokenize(text)) {\n    const colorize = defs[type];\n    if (colorize) {\n      highlighted += value.split(NEWLINE$1).map(str => colorize(str)).join(\"\\n\");\n    } else {\n      highlighted += value;\n    }\n  }\n  return highlighted;\n}\nfunction shouldHighlight(options) {\n  return _chalk$1.default.level > 0 || options.forceColor;\n}\nlet chalkWithForcedColor$1 = undefined;\nfunction getChalk$1(forceColor) {\n  if (forceColor) {\n    var _chalkWithForcedColor;\n    (_chalkWithForcedColor = chalkWithForcedColor$1) != null ? _chalkWithForcedColor : chalkWithForcedColor$1 = new _chalk$1.default.constructor({\n      enabled: true,\n      level: 1\n    });\n    return chalkWithForcedColor$1;\n  }\n  return _chalk$1.default;\n}\n{\n  lib$1.getChalk = options => getChalk$1(options.forceColor);\n}\nfunction highlight(code, options = {}) {\n  if (code !== \"\" && shouldHighlight(options)) {\n    const defs = getDefs$1(getChalk$1(options.forceColor));\n    return highlightTokens(defs, code);\n  } else {\n    return code;\n  }\n}\nvar chalk = {exports: {}};\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\nvar escapeStringRegexp = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\nvar ansiStyles = {exports: {}};\nansiStyles.exports;\n(function (module) {\n\tconst colorConvert$1 = colorConvert;\n\tconst wrapAnsi16 = (fn, offset) => function () {\n\t\tconst code = fn.apply(colorConvert$1, arguments);\n\t\treturn `\\u001B[${code + offset}m`;\n\t};\n\tconst wrapAnsi256 = (fn, offset) => function () {\n\t\tconst code = fn.apply(colorConvert$1, arguments);\n\t\treturn `\\u001B[${38 + offset};5;${code}m`;\n\t};\n\tconst wrapAnsi16m = (fn, offset) => function () {\n\t\tconst rgb = fn.apply(colorConvert$1, arguments);\n\t\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n\t};\n\tfunction assembleStyles() {\n\t\tconst codes = new Map();\n\t\tconst styles = {\n\t\t\tmodifier: {\n\t\t\t\treset: [0, 0],\n\t\t\t\tbold: [1, 22],\n\t\t\t\tdim: [2, 22],\n\t\t\t\titalic: [3, 23],\n\t\t\t\tunderline: [4, 24],\n\t\t\t\tinverse: [7, 27],\n\t\t\t\thidden: [8, 28],\n\t\t\t\tstrikethrough: [9, 29]\n\t\t\t},\n\t\t\tcolor: {\n\t\t\t\tblack: [30, 39],\n\t\t\t\tred: [31, 39],\n\t\t\t\tgreen: [32, 39],\n\t\t\t\tyellow: [33, 39],\n\t\t\t\tblue: [34, 39],\n\t\t\t\tmagenta: [35, 39],\n\t\t\t\tcyan: [36, 39],\n\t\t\t\twhite: [37, 39],\n\t\t\t\tgray: [90, 39],\n\t\t\t\tredBright: [91, 39],\n\t\t\t\tgreenBright: [92, 39],\n\t\t\t\tyellowBright: [93, 39],\n\t\t\t\tblueBright: [94, 39],\n\t\t\t\tmagentaBright: [95, 39],\n\t\t\t\tcyanBright: [96, 39],\n\t\t\t\twhiteBright: [97, 39]\n\t\t\t},\n\t\t\tbgColor: {\n\t\t\t\tbgBlack: [40, 49],\n\t\t\t\tbgRed: [41, 49],\n\t\t\t\tbgGreen: [42, 49],\n\t\t\t\tbgYellow: [43, 49],\n\t\t\t\tbgBlue: [44, 49],\n\t\t\t\tbgMagenta: [45, 49],\n\t\t\t\tbgCyan: [46, 49],\n\t\t\t\tbgWhite: [47, 49],\n\t\t\t\tbgBlackBright: [100, 49],\n\t\t\t\tbgRedBright: [101, 49],\n\t\t\t\tbgGreenBright: [102, 49],\n\t\t\t\tbgYellowBright: [103, 49],\n\t\t\t\tbgBlueBright: [104, 49],\n\t\t\t\tbgMagentaBright: [105, 49],\n\t\t\t\tbgCyanBright: [106, 49],\n\t\t\t\tbgWhiteBright: [107, 49]\n\t\t\t}\n\t\t};\n\t\tstyles.color.grey = styles.color.gray;\n\t\tfor (const groupName of Object.keys(styles)) {\n\t\t\tconst group = styles[groupName];\n\t\t\tfor (const styleName of Object.keys(group)) {\n\t\t\t\tconst style = group[styleName];\n\t\t\t\tstyles[styleName] = {\n\t\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t\t};\n\t\t\t\tgroup[styleName] = styles[styleName];\n\t\t\t\tcodes.set(style[0], style[1]);\n\t\t\t}\n\t\t\tObject.defineProperty(styles, groupName, {\n\t\t\t\tvalue: group,\n\t\t\t\tenumerable: false\n\t\t\t});\n\t\t\tObject.defineProperty(styles, 'codes', {\n\t\t\t\tvalue: codes,\n\t\t\t\tenumerable: false\n\t\t\t});\n\t\t}\n\t\tconst ansi2ansi = n => n;\n\t\tconst rgb2rgb = (r, g, b) => [r, g, b];\n\t\tstyles.color.close = '\\u001B[39m';\n\t\tstyles.bgColor.close = '\\u001B[49m';\n\t\tstyles.color.ansi = {\n\t\t\tansi: wrapAnsi16(ansi2ansi, 0)\n\t\t};\n\t\tstyles.color.ansi256 = {\n\t\t\tansi256: wrapAnsi256(ansi2ansi, 0)\n\t\t};\n\t\tstyles.color.ansi16m = {\n\t\t\trgb: wrapAnsi16m(rgb2rgb, 0)\n\t\t};\n\t\tstyles.bgColor.ansi = {\n\t\t\tansi: wrapAnsi16(ansi2ansi, 10)\n\t\t};\n\t\tstyles.bgColor.ansi256 = {\n\t\t\tansi256: wrapAnsi256(ansi2ansi, 10)\n\t\t};\n\t\tstyles.bgColor.ansi16m = {\n\t\t\trgb: wrapAnsi16m(rgb2rgb, 10)\n\t\t};\n\t\tfor (let key of Object.keys(colorConvert$1)) {\n\t\t\tif (typeof colorConvert$1[key] !== 'object') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst suite = colorConvert$1[key];\n\t\t\tif (key === 'ansi16') {\n\t\t\t\tkey = 'ansi';\n\t\t\t}\n\t\t\tif ('ansi16' in suite) {\n\t\t\t\tstyles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);\n\t\t\t\tstyles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);\n\t\t\t}\n\t\t\tif ('ansi256' in suite) {\n\t\t\t\tstyles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);\n\t\t\t\tstyles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);\n\t\t\t}\n\t\t\tif ('rgb' in suite) {\n\t\t\t\tstyles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);\n\t\t\t\tstyles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);\n\t\t\t}\n\t\t}\n\t\treturn styles;\n\t}\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tget: assembleStyles\n\t}); \n} (ansiStyles));\nvar ansiStylesExports = ansiStyles.exports;\nvar hasFlag$1 = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\nconst os = require$$0$2;\nconst hasFlag = hasFlag$1;\nconst env = process.env;\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false')) {\n\tforceColor = false;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n\tforceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\nfunction supportsColor(stream) {\n\tif (forceColor === false) {\n\t\treturn 0;\n\t}\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\tif (stream && !stream.isTTY && forceColor !== true) {\n\t\treturn 0;\n\t}\n\tconst min = forceColor ? 1 : 0;\n\tif (process.platform === 'win32') {\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\t\treturn 1;\n\t}\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\t\treturn min;\n\t}\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t}\n\t}\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\treturn min;\n}\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream);\n\treturn translateLevel(level);\n}\nvar supportsColor_1 = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel(process.stdout),\n\tstderr: getSupportLevel(process.stderr)\n};\nconst TEMPLATE_REGEX = /(?:\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX = /\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.)|([^\\\\])/gi;\nconst ESCAPES = new Map([\n\t['n', '\\n'],\n\t['r', '\\r'],\n\t['t', '\\t'],\n\t['b', '\\b'],\n\t['f', '\\f'],\n\t['v', '\\v'],\n\t['0', '\\0'],\n\t['\\\\', '\\\\'],\n\t['e', '\\u001B'],\n\t['a', '\\u0007']\n]);\nfunction unescape(c) {\n\tif ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {\n\t\treturn String.fromCharCode(parseInt(c.slice(1), 16));\n\t}\n\treturn ESCAPES.get(c) || c;\n}\nfunction parseArguments(name, args) {\n\tconst results = [];\n\tconst chunks = args.trim().split(/\\s*,\\s*/g);\n\tlet matches;\n\tfor (const chunk of chunks) {\n\t\tif (!isNaN(chunk)) {\n\t\t\tresults.push(Number(chunk));\n\t\t} else if ((matches = chunk.match(STRING_REGEX))) {\n\t\t\tresults.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));\n\t\t} else {\n\t\t\tthrow new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n\t\t}\n\t}\n\treturn results;\n}\nfunction parseStyle(style) {\n\tSTYLE_REGEX.lastIndex = 0;\n\tconst results = [];\n\tlet matches;\n\twhile ((matches = STYLE_REGEX.exec(style)) !== null) {\n\t\tconst name = matches[1];\n\t\tif (matches[2]) {\n\t\t\tconst args = parseArguments(name, matches[2]);\n\t\t\tresults.push([name].concat(args));\n\t\t} else {\n\t\t\tresults.push([name]);\n\t\t}\n\t}\n\treturn results;\n}\nfunction buildStyle(chalk, styles) {\n\tconst enabled = {};\n\tfor (const layer of styles) {\n\t\tfor (const style of layer.styles) {\n\t\t\tenabled[style[0]] = layer.inverse ? null : style.slice(1);\n\t\t}\n\t}\n\tlet current = chalk;\n\tfor (const styleName of Object.keys(enabled)) {\n\t\tif (Array.isArray(enabled[styleName])) {\n\t\t\tif (!(styleName in current)) {\n\t\t\t\tthrow new Error(`Unknown Chalk style: ${styleName}`);\n\t\t\t}\n\t\t\tif (enabled[styleName].length > 0) {\n\t\t\t\tcurrent = current[styleName].apply(current, enabled[styleName]);\n\t\t\t} else {\n\t\t\t\tcurrent = current[styleName];\n\t\t\t}\n\t\t}\n\t}\n\treturn current;\n}\nvar templates = (chalk, tmp) => {\n\tconst styles = [];\n\tconst chunks = [];\n\tlet chunk = [];\n\ttmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {\n\t\tif (escapeChar) {\n\t\t\tchunk.push(unescape(escapeChar));\n\t\t} else if (style) {\n\t\t\tconst str = chunk.join('');\n\t\t\tchunk = [];\n\t\t\tchunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));\n\t\t\tstyles.push({inverse, styles: parseStyle(style)});\n\t\t} else if (close) {\n\t\t\tif (styles.length === 0) {\n\t\t\t\tthrow new Error('Found extraneous } in Chalk template literal');\n\t\t\t}\n\t\t\tchunks.push(buildStyle(chalk, styles)(chunk.join('')));\n\t\t\tchunk = [];\n\t\t\tstyles.pop();\n\t\t} else {\n\t\t\tchunk.push(chr);\n\t\t}\n\t});\n\tchunks.push(chunk.join(''));\n\tif (styles.length > 0) {\n\t\tconst errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\\`}\\`)`;\n\t\tthrow new Error(errMsg);\n\t}\n\treturn chunks.join('');\n};\n(function (module) {\n\tconst escapeStringRegexp$1 = escapeStringRegexp;\n\tconst ansiStyles = ansiStylesExports;\n\tconst stdoutColor = supportsColor_1.stdout;\n\tconst template = templates;\n\tconst isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');\n\tconst levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];\n\tconst skipModels = new Set(['gray']);\n\tconst styles = Object.create(null);\n\tfunction applyOptions(obj, options) {\n\t\toptions = options || {};\n\t\tconst scLevel = stdoutColor ? stdoutColor.level : 0;\n\t\tobj.level = options.level === undefined ? scLevel : options.level;\n\t\tobj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;\n\t}\n\tfunction Chalk(options) {\n\t\tif (!this || !(this instanceof Chalk) || this.template) {\n\t\t\tconst chalk = {};\n\t\t\tapplyOptions(chalk, options);\n\t\t\tchalk.template = function () {\n\t\t\t\tconst args = [].slice.call(arguments);\n\t\t\t\treturn chalkTag.apply(null, [chalk.template].concat(args));\n\t\t\t};\n\t\t\tObject.setPrototypeOf(chalk, Chalk.prototype);\n\t\t\tObject.setPrototypeOf(chalk.template, chalk);\n\t\t\tchalk.template.constructor = Chalk;\n\t\t\treturn chalk.template;\n\t\t}\n\t\tapplyOptions(this, options);\n\t}\n\tif (isSimpleWindowsTerm) {\n\t\tansiStyles.blue.open = '\\u001B[94m';\n\t}\n\tfor (const key of Object.keys(ansiStyles)) {\n\t\tansiStyles[key].closeRe = new RegExp(escapeStringRegexp$1(ansiStyles[key].close), 'g');\n\t\tstyles[key] = {\n\t\t\tget() {\n\t\t\t\tconst codes = ansiStyles[key];\n\t\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);\n\t\t\t}\n\t\t};\n\t}\n\tstyles.visible = {\n\t\tget() {\n\t\t\treturn build.call(this, this._styles || [], true, 'visible');\n\t\t}\n\t};\n\tansiStyles.color.closeRe = new RegExp(escapeStringRegexp$1(ansiStyles.color.close), 'g');\n\tfor (const model of Object.keys(ansiStyles.color.ansi)) {\n\t\tif (skipModels.has(model)) {\n\t\t\tcontinue;\n\t\t}\n\t\tstyles[model] = {\n\t\t\tget() {\n\t\t\t\tconst level = this.level;\n\t\t\t\treturn function () {\n\t\t\t\t\tconst open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);\n\t\t\t\t\tconst codes = {\n\t\t\t\t\t\topen,\n\t\t\t\t\t\tclose: ansiStyles.color.close,\n\t\t\t\t\t\tcloseRe: ansiStyles.color.closeRe\n\t\t\t\t\t};\n\t\t\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n\tansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp$1(ansiStyles.bgColor.close), 'g');\n\tfor (const model of Object.keys(ansiStyles.bgColor.ansi)) {\n\t\tif (skipModels.has(model)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n\t\tstyles[bgModel] = {\n\t\t\tget() {\n\t\t\t\tconst level = this.level;\n\t\t\t\treturn function () {\n\t\t\t\t\tconst open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);\n\t\t\t\t\tconst codes = {\n\t\t\t\t\t\topen,\n\t\t\t\t\t\tclose: ansiStyles.bgColor.close,\n\t\t\t\t\t\tcloseRe: ansiStyles.bgColor.closeRe\n\t\t\t\t\t};\n\t\t\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n\tconst proto = Object.defineProperties(() => {}, styles);\n\tfunction build(_styles, _empty, key) {\n\t\tconst builder = function () {\n\t\t\treturn applyStyle.apply(builder, arguments);\n\t\t};\n\t\tbuilder._styles = _styles;\n\t\tbuilder._empty = _empty;\n\t\tconst self = this;\n\t\tObject.defineProperty(builder, 'level', {\n\t\t\tenumerable: true,\n\t\t\tget() {\n\t\t\t\treturn self.level;\n\t\t\t},\n\t\t\tset(level) {\n\t\t\t\tself.level = level;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(builder, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tget() {\n\t\t\t\treturn self.enabled;\n\t\t\t},\n\t\t\tset(enabled) {\n\t\t\t\tself.enabled = enabled;\n\t\t\t}\n\t\t});\n\t\tbuilder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';\n\t\tbuilder.__proto__ = proto; \n\t\treturn builder;\n\t}\n\tfunction applyStyle() {\n\t\tconst args = arguments;\n\t\tconst argsLen = args.length;\n\t\tlet str = String(arguments[0]);\n\t\tif (argsLen === 0) {\n\t\t\treturn '';\n\t\t}\n\t\tif (argsLen > 1) {\n\t\t\tfor (let a = 1; a < argsLen; a++) {\n\t\t\t\tstr += ' ' + args[a];\n\t\t\t}\n\t\t}\n\t\tif (!this.enabled || this.level <= 0 || !str) {\n\t\t\treturn this._empty ? '' : str;\n\t\t}\n\t\tconst originalDim = ansiStyles.dim.open;\n\t\tif (isSimpleWindowsTerm && this.hasGrey) {\n\t\t\tansiStyles.dim.open = '';\n\t\t}\n\t\tfor (const code of this._styles.slice().reverse()) {\n\t\t\tstr = code.open + str.replace(code.closeRe, code.open) + code.close;\n\t\t\tstr = str.replace(/\\r?\\n/g, `${code.close}$&${code.open}`);\n\t\t}\n\t\tansiStyles.dim.open = originalDim;\n\t\treturn str;\n\t}\n\tfunction chalkTag(chalk, strings) {\n\t\tif (!Array.isArray(strings)) {\n\t\t\treturn [].slice.call(arguments, 1).join(' ');\n\t\t}\n\t\tconst args = [].slice.call(arguments, 2);\n\t\tconst parts = [strings.raw[0]];\n\t\tfor (let i = 1; i < strings.length; i++) {\n\t\t\tparts.push(String(args[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'));\n\t\t\tparts.push(String(strings.raw[i]));\n\t\t}\n\t\treturn template(chalk, parts.join(''));\n\t}\n\tObject.defineProperties(Chalk.prototype, styles);\n\tmodule.exports = Chalk(); \n\tmodule.exports.supportsColor = stdoutColor;\n\tmodule.exports.default = module.exports; \n} (chalk));\nvar chalkExports = chalk.exports;\nObject.defineProperty(lib$2, \"__esModule\", {\n  value: true\n});\nvar codeFrameColumns_1 = lib$2.codeFrameColumns = codeFrameColumns;\nlib$2.default = _default;\nvar _highlight = lib$1;\nvar _chalk = _interopRequireWildcard(chalkExports, true);\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nlet chalkWithForcedColor = undefined;\nfunction getChalk(forceColor) {\n  if (forceColor) {\n    var _chalkWithForcedColor;\n    (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new _chalk.default.constructor({\n      enabled: true,\n      level: 1\n    });\n    return chalkWithForcedColor;\n  }\n  return _chalk.default;\n}\nlet deprecationWarningShown = false;\nfunction getDefs(chalk) {\n  return {\n    gutter: chalk.grey,\n    marker: chalk.red.bold,\n    message: chalk.red.bold\n  };\n}\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\nfunction getMarkerLines(loc, source, opts) {\n  const startLoc = Object.assign({\n    column: 0,\n    line: -1\n  }, loc.start);\n  const endLoc = Object.assign({}, startLoc, loc.end);\n  const {\n    linesAbove = 2,\n    linesBelow = 3\n  } = opts || {};\n  const startLine = startLoc.line;\n  const startColumn = startLoc.column;\n  const endLine = endLoc.line;\n  const endColumn = endLoc.column;\n  let start = Math.max(startLine - (linesAbove + 1), 0);\n  let end = Math.min(source.length, endLine + linesBelow);\n  if (startLine === -1) {\n    start = 0;\n  }\n  if (endLine === -1) {\n    end = source.length;\n  }\n  const lineDiff = endLine - startLine;\n  const markerLines = {};\n  if (lineDiff) {\n    for (let i = 0; i <= lineDiff; i++) {\n      const lineNumber = i + startLine;\n      if (!startColumn) {\n        markerLines[lineNumber] = true;\n      } else if (i === 0) {\n        const sourceLength = source[lineNumber - 1].length;\n        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];\n      } else if (i === lineDiff) {\n        markerLines[lineNumber] = [0, endColumn];\n      } else {\n        const sourceLength = source[lineNumber - i].length;\n        markerLines[lineNumber] = [0, sourceLength];\n      }\n    }\n  } else {\n    if (startColumn === endColumn) {\n      if (startColumn) {\n        markerLines[startLine] = [startColumn, 0];\n      } else {\n        markerLines[startLine] = true;\n      }\n    } else {\n      markerLines[startLine] = [startColumn, endColumn - startColumn];\n    }\n  }\n  return {\n    start,\n    end,\n    markerLines\n  };\n}\nfunction codeFrameColumns(rawLines, loc, opts = {}) {\n  const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);\n  const chalk = getChalk(opts.forceColor);\n  const defs = getDefs(chalk);\n  const maybeHighlight = (chalkFn, string) => {\n    return highlighted ? chalkFn(string) : string;\n  };\n  const lines = rawLines.split(NEWLINE);\n  const {\n    start,\n    end,\n    markerLines\n  } = getMarkerLines(loc, lines, opts);\n  const hasColumns = loc.start && typeof loc.start.column === \"number\";\n  const numberMaxWidth = String(end).length;\n  const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;\n  let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {\n    const number = start + 1 + index;\n    const paddedNumber = ` ${number}`.slice(-numberMaxWidth);\n    const gutter = ` ${paddedNumber} |`;\n    const hasMarker = markerLines[number];\n    const lastMarkerLine = !markerLines[number + 1];\n    if (hasMarker) {\n      let markerLine = \"\";\n      if (Array.isArray(hasMarker)) {\n        const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\\t]/g, \" \");\n        const numberOfMarkers = hasMarker[1] || 1;\n        markerLine = [\"\\n \", maybeHighlight(defs.gutter, gutter.replace(/\\d/g, \" \")), \" \", markerSpacing, maybeHighlight(defs.marker, \"^\").repeat(numberOfMarkers)].join(\"\");\n        if (lastMarkerLine && opts.message) {\n          markerLine += \" \" + maybeHighlight(defs.message, opts.message);\n        }\n      }\n      return [maybeHighlight(defs.marker, \">\"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : \"\", markerLine].join(\"\");\n    } else {\n      return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : \"\"}`;\n    }\n  }).join(\"\\n\");\n  if (opts.message && !hasColumns) {\n    frame = `${\" \".repeat(numberMaxWidth + 1)}${opts.message}\\n${frame}`;\n  }\n  if (highlighted) {\n    return chalk.reset(frame);\n  } else {\n    return frame;\n  }\n}\nfunction _default(rawLines, lineNumber, colNumber, opts = {}) {\n  if (!deprecationWarningShown) {\n    deprecationWarningShown = true;\n    const message = \"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";\n    if (process.emitWarning) {\n      process.emitWarning(message, \"DeprecationWarning\");\n    } else {\n      const deprecationError = new Error(message);\n      deprecationError.name = \"DeprecationWarning\";\n      console.warn(new Error(message));\n    }\n  }\n  colNumber = Math.max(colNumber, 0);\n  const location = {\n    start: {\n      column: colNumber,\n      line: lineNumber\n    }\n  };\n  return codeFrameColumns(rawLines, location, opts);\n}\nconst safeLastIndexOf = (string, searchString, index) =>\n\tindex < 0 ? -1 : string.lastIndexOf(searchString, index);\nfunction getPosition(text, textIndex) {\n\tconst lineBreakBefore = safeLastIndexOf(text, '\\n', textIndex - 1);\n\tconst column = textIndex - lineBreakBefore - 1;\n\tlet line = 0;\n\tfor (\n\t\tlet index = lineBreakBefore;\n\t\tindex >= 0;\n\t\tindex = safeLastIndexOf(text, '\\n', index - 1)\n\t) {\n\t\tline++;\n\t}\n\treturn {line, column};\n}\nfunction indexToLineColumn(text, textIndex, {oneBased = false} = {}) {\n\tif (textIndex < 0 || (textIndex >= text.length && text.length > 0)) {\n\t\tthrow new RangeError('Index out of bounds');\n\t}\n\tconst position = getPosition(text, textIndex);\n\treturn oneBased ? {line: position.line + 1, column: position.column + 1} : position;\n}\nconst getCodePoint = character => `\\\\u{${character.codePointAt(0).toString(16)}}`;\nclass JSONError extends Error {\n\tname = 'JSONError';\n\tfileName;\n\tcodeFrame;\n\trawCodeFrame;\n\t#message;\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.#message = message;\n\t\tError.captureStackTrace?.(this, JSONError);\n\t}\n\tget message() {\n\t\tconst {fileName, codeFrame} = this;\n\t\treturn `${this.#message}${fileName ? ` in ${fileName}` : ''}${codeFrame ? `\\n\\n${codeFrame}\\n` : ''}`;\n\t}\n\tset message(message) {\n\t\tthis.#message = message;\n\t}\n}\nconst generateCodeFrame = (string, location, highlightCode = true) =>\n\tcodeFrameColumns_1(string, {start: location}, {highlightCode});\nconst getErrorLocation = (string, message) => {\n\tconst match = message.match(/in JSON at position (?<index>\\d+)(?: \\(line (?<line>\\d+) column (?<column>\\d+)\\))?$/);\n\tif (!match) {\n\t\treturn;\n\t}\n\tlet {index, line, column} = match.groups;\n\tif (line && column) {\n\t\treturn {line: Number(line), column: Number(column)};\n\t}\n\tindex = Number(index);\n\tif (index === string.length) {\n\t\tconst {line, column} = indexToLineColumn(string, string.length - 1, {oneBased: true});\n\t\treturn {line, column: column + 1};\n\t}\n\treturn indexToLineColumn(string, index, {oneBased: true});\n};\nconst addCodePointToUnexpectedToken = message => message.replace(\n\t/(?<=^Unexpected token )(?<quote>')?(.)\\k<quote>/,\n\t(_, _quote, token) => `\"${token}\"(${getCodePoint(token)})`,\n);\nfunction parseJson(string, reviver, fileName) {\n\tif (typeof reviver === 'string') {\n\t\tfileName = reviver;\n\t\treviver = undefined;\n\t}\n\tlet message;\n\ttry {\n\t\treturn JSON.parse(string, reviver);\n\t} catch (error) {\n\t\tmessage = error.message;\n\t}\n\tlet location;\n\tif (string) {\n\t\tlocation = getErrorLocation(string, message);\n\t\tmessage = addCodePointToUnexpectedToken(message);\n\t} else {\n\t\tmessage += ' while parsing empty string';\n\t}\n\tconst jsonError = new JSONError(message);\n\tjsonError.fileName = fileName;\n\tif (location) {\n\t\tjsonError.codeFrame = generateCodeFrame(string, location);\n\t\tjsonError.rawCodeFrame = generateCodeFrame(string, location, /* highlightCode */ false);\n\t}\n\tthrow jsonError;\n}\nfunction toPath(urlOrPath) {\n\treturn urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;\n}\nconst getPackagePath = cwd => path$1.resolve(toPath(cwd) ?? '.', 'package.json');\nconst _readPackage = (file, normalize) => {\n\tconst json = typeof file === 'string'\n\t\t? parseJson(file)\n\t\t: file;\n\tif (normalize) {\n\t\tnormalizePackageData(json);\n\t}\n\treturn json;\n};\nfunction readPackageSync({cwd, normalize = true} = {}) {\n\tconst packageFile = fs$1.readFileSync(getPackagePath(cwd), 'utf8');\n\treturn _readPackage(packageFile, normalize);\n}\nfunction readPackageUpSync(options) {\n\tconst filePath = findUpSync('package.json', options);\n\tif (!filePath) {\n\t\treturn;\n\t}\n\treturn {\n\t\tpackageJson: readPackageSync({...options, cwd: path$1.dirname(filePath)}),\n\t\tpath: filePath,\n\t};\n}\nconst handlePreserveConsecutiveUppercase = (decamelized, separator) => {\n\t// Lowercase all single uppercase characters. As we\n\t// want to preserve uppercase sequences, we cannot\n\t// simply lowercase the separated string at the end.\n\t// `data_For_USACounties` → `data_for_USACounties`\n\tdecamelized = decamelized.replace(\n\t\t/((?<![\\p{Uppercase_Letter}\\d])[\\p{Uppercase_Letter}\\d](?![\\p{Uppercase_Letter}\\d]))/gu,\n\t\t$0 => $0.toLowerCase(),\n\t);\n\t// Remaining uppercase sequences will be separated from lowercase sequences.\n\t// `data_For_USACounties` → `data_for_USA_counties`\n\treturn decamelized.replace(\n\t\t/(\\p{Uppercase_Letter}+)(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)/gu,\n\t\t(_, $1, $2) => $1 + separator + $2.toLowerCase(),\n\t);\n};\nfunction decamelize(\n\ttext,\n\t{\n\t\tseparator = '_',\n\t\tpreserveConsecutiveUppercase = false,\n\t} = {},\n) {\n\tif (!(typeof text === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError(\n\t\t\t'The `text` and `separator` arguments should be of type `string`',\n\t\t);\n\t}\n\t// Checking the second character is done later on. Therefore process shorter strings here.\n\tif (text.length < 2) {\n\t\treturn preserveConsecutiveUppercase ? text : text.toLowerCase();\n\t}\n\tconst replacement = `$1${separator}$2`;\n\t// Split lowercase sequences followed by uppercase character.\n\t// `dataForUSACounties` → `data_For_USACounties`\n\t// `myURLstring → `my_URLstring`\n\tconst decamelized = text.replace(\n\t\t/([\\p{Lowercase_Letter}\\d])(\\p{Uppercase_Letter})/gu,\n\t\treplacement,\n\t);\n\tif (preserveConsecutiveUppercase) {\n\t\treturn handlePreserveConsecutiveUppercase(decamelized, separator);\n\t}\n\t// Split multiple uppercase characters followed by one or more lowercase characters.\n\t// `my_URLstring` → `my_ur_lstring`\n\treturn decamelized\n\t\t.replace(\n\t\t\t/(\\p{Uppercase_Letter})(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)/gu,\n\t\t\treplacement,\n\t\t)\n\t\t.toLowerCase();\n}\nvar minimistOptions = {exports: {}};\nvar toString$1 = Object.prototype.toString;\nvar isPlainObj = function (x) {\n\tvar prototype;\n\treturn toString$1.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));\n};\nvar arrify$1 = function (val) {\n\tif (val === null || val === undefined) {\n\t\treturn [];\n\t}\n\treturn Array.isArray(val) ? val : [val];\n};\nvar toString = Object.prototype.toString;\nvar kindOf$1 = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\nconst isPlainObject = isPlainObj;\nconst arrify = arrify$1;\nconst kindOf = kindOf$1;\nconst push = (obj, prop, value) => {\n\tif (!obj[prop]) {\n\t\tobj[prop] = [];\n\t}\n\tobj[prop].push(value);\n};\nconst insert = (obj, prop, key, value) => {\n\tif (!obj[prop]) {\n\t\tobj[prop] = {};\n\t}\n\tobj[prop][key] = value;\n};\nconst prettyPrint = output => {\n\treturn Array.isArray(output) ?\n\t\t`[${output.map(prettyPrint).join(', ')}]` :\n\t\tkindOf(output) === 'string' ? JSON.stringify(output) : output;\n};\nconst resolveType = value => {\n\tif (Array.isArray(value) && value.length > 0) {\n\t\tconst [element] = value;\n\t\treturn `${kindOf(element)}-array`;\n\t}\n\treturn kindOf(value);\n};\nconst normalizeExpectedType = (type, defaultValue) => {\n\tconst inferredType = type === 'array' ? 'string-array' : type;\n\tif (arrayTypes.includes(inferredType) && Array.isArray(defaultValue) && defaultValue.length === 0) {\n\t\treturn 'array';\n\t}\n\treturn inferredType;\n};\nconst passthroughOptions = ['stopEarly', 'unknown', '--'];\nconst primitiveTypes = ['string', 'boolean', 'number'];\nconst arrayTypes = primitiveTypes.map(t => `${t}-array`);\nconst availableTypes = [...primitiveTypes, 'array', ...arrayTypes];\nconst buildOptions = options => {\n\toptions = options || {};\n\tconst result = {};\n\tpassthroughOptions.forEach(key => {\n\t\tif (options[key]) {\n\t\t\tresult[key] = options[key];\n\t\t}\n\t});\n\tObject.keys(options).forEach(key => {\n\t\tlet value = options[key];\n\t\tif (key === 'arguments') {\n\t\t\tkey = '_';\n\t\t}\n\t\t// If short form is used\n\t\t// convert it to long form\n\t\t// e.g. { 'name': 'string' }\n\t\tif (typeof value === 'string') {\n\t\t\tvalue = {type: value};\n\t\t}\n\t\tif (isPlainObject(value)) {\n\t\t\tconst props = value;\n\t\t\tconst {type} = props;\n\t\t\tif (type) {\n\t\t\t\tif (!availableTypes.includes(type)) {\n\t\t\t\t\tthrow new TypeError(`Expected type of \"${key}\" to be one of ${prettyPrint(availableTypes)}, got ${prettyPrint(type)}`);\n\t\t\t\t}\n\t\t\t\tif (arrayTypes.includes(type)) {\n\t\t\t\t\tconst [elementType] = type.split('-');\n\t\t\t\t\tpush(result, 'array', {key, [elementType]: true});\n\t\t\t\t} else {\n\t\t\t\t\tpush(result, type, key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ({}.hasOwnProperty.call(props, 'default')) {\n\t\t\t\tconst {default: defaultValue} = props;\n\t\t\t\tconst defaultType = resolveType(defaultValue);\n\t\t\t\tconst expectedType = normalizeExpectedType(type, defaultValue);\n\t\t\t\tif (expectedType && expectedType !== defaultType) {\n\t\t\t\t\tthrow new TypeError(`Expected \"${key}\" default value to be of type \"${expectedType}\", got ${prettyPrint(defaultType)}`);\n\t\t\t\t}\n\t\t\t\tinsert(result, 'default', key, defaultValue);\n\t\t\t}\n\t\t\tarrify(props.alias).forEach(alias => {\n\t\t\t\tinsert(result, 'alias', alias, key);\n\t\t\t});\n\t\t}\n\t});\n\treturn result;\n};\nminimistOptions.exports = buildOptions;\nminimistOptions.exports.default = buildOptions;\nvar minimistOptionsExports = minimistOptions.exports;\nconst constructParserOptions = /*@__PURE__*/getDefaultExportFromCjs(minimistOptionsExports);\nvar mapObj = {exports: {}};\nconst isObject$1 = value => typeof value === 'object' && value !== null;\nconst mapObjectSkip = Symbol('skip');\n// Customized for this use-case\nconst isObjectCustom = value =>\n\tisObject$1(value) &&\n\t!(value instanceof RegExp) &&\n\t!(value instanceof Error) &&\n\t!(value instanceof Date);\nconst mapObject = (object, mapper, options, isSeen = new WeakMap()) => {\n\toptions = {\n\t\tdeep: false,\n\t\ttarget: {},\n\t\t...options\n\t};\n\tif (isSeen.has(object)) {\n\t\treturn isSeen.get(object);\n\t}\n\tisSeen.set(object, options.target);\n\tconst {target} = options;\n\tdelete options.target;\n\tconst mapArray = array => array.map(element => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element);\n\tif (Array.isArray(object)) {\n\t\treturn mapArray(object);\n\t}\n\tfor (const [key, value] of Object.entries(object)) {\n\t\tconst mapResult = mapper(key, value, object);\n\t\tif (mapResult === mapObjectSkip) {\n\t\t\tcontinue;\n\t\t}\n\t\tlet [newKey, newValue, {shouldRecurse = true} = {}] = mapResult;\n\t\t// Drop `__proto__` keys.\n\t\tif (newKey === '__proto__') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (options.deep && shouldRecurse && isObjectCustom(newValue)) {\n\t\t\tnewValue = Array.isArray(newValue) ?\n\t\t\t\tmapArray(newValue) :\n\t\t\t\tmapObject(newValue, mapper, options, isSeen);\n\t\t}\n\t\ttarget[newKey] = newValue;\n\t}\n\treturn target;\n};\nmapObj.exports = (object, mapper, options) => {\n\tif (!isObject$1(object)) {\n\t\tthrow new TypeError(`Expected an object, got \\`${object}\\` (${typeof object})`);\n\t}\n\treturn mapObject(object, mapper, options);\n};\nmapObj.exports.mapObjectSkip = mapObjectSkip;\nvar mapObjExports = mapObj.exports;\nconst mapObject$1 = /*@__PURE__*/getDefaultExportFromCjs(mapObjExports);\nconst has = (array, key) => array.some(element => {\n\tif (typeof element === 'string') {\n\t\treturn element === key;\n\t}\n\telement.lastIndex = 0;\n\treturn element.test(key);\n});\nconst cache = new QuickLRU({maxSize: 100_000});\n// Reproduces behavior from `map-obj`.\nconst isObject = value =>\n\ttypeof value === 'object'\n\t\t&& value !== null\n\t\t&& !(value instanceof RegExp)\n\t\t&& !(value instanceof Error)\n\t\t&& !(value instanceof Date);\nconst transform = (input, options = {}) => {\n\tif (!isObject(input)) {\n\t\treturn input;\n\t}\n\tconst {\n\t\tseparator = '_',\n\t\texclude,\n\t\tdeep = false,\n\t} = options;\n\tconst makeMapper = parentPath => (key, value) => {\n\t\tif (deep && isObject(value)) {\n\t\t\tvalue = mapObject$1(value, makeMapper());\n\t\t}\n\t\tif (!(exclude && has(exclude, key))) {\n\t\t\tconst cacheKey = `${separator}${key}`;\n\t\t\tif (cache.has(cacheKey)) {\n\t\t\t\tkey = cache.get(cacheKey);\n\t\t\t} else {\n\t\t\t\tconst returnValue = decamelize(key, {separator});\n\t\t\t\tif (key.length < 100) { // Prevent abuse\n\t\t\t\t\tcache.set(cacheKey, returnValue);\n\t\t\t\t}\n\t\t\t\tkey = returnValue;\n\t\t\t}\n\t\t}\n\t\treturn [key, value];\n\t};\n\treturn mapObject$1(input, makeMapper());\n};\nfunction decamelizeKeys(input, options) {\n\tif (Array.isArray(input)) {\n\t\treturn Object.keys(input).map(key => transform(input[key], options));\n\t}\n\treturn transform(input, options);\n}\nexport { readPackageUpSync as a, constructParserOptions as b, camelcaseKeys as c, decamelizeKeys as d, decamelize as e, normalizePackageData as n, redent as r, trimNewlines as t, yargsParser as y };\n","import { e as decamelize } from './dependencies.js';\n\nconst decamelizeFlagKey = flagKey => `--${decamelize(flagKey, {separator: '-'})}`;\n\nconst joinFlagKeys = (flagKeys, prefix = '--') => `\\`${prefix}${flagKeys.join(`\\`, \\`${prefix}`)}\\``;\n\nexport { decamelizeFlagKey, joinFlagKeys };\n","import process from 'node:process';\nimport { dirname } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport { a as readPackageUpSync } from './dependencies.js';\nimport { joinFlagKeys, decamelizeFlagKey } from './utils.js';\n\nconst validateOptions = options => {\n\tconst invalidOptionFilters = {\n\t\tflags: {\n\t\t\tkeyContainsDashes: {\n\t\t\t\tfilter: ([flagKey]) => flagKey.includes('-') && flagKey !== '--',\n\t\t\t\tmessage: flagKeys => `Flag keys may not contain '-'. Invalid flags: ${joinFlagKeys(flagKeys, '')}`,\n\t\t\t},\n\t\t\taliasIsSet: {\n\t\t\t\tfilter: ([, flag]) => Object.hasOwn(flag, 'alias'),\n\t\t\t\tmessage: flagKeys => `The option \\`alias\\` has been renamed to \\`shortFlag\\`. The following flags need to be updated: ${joinFlagKeys(flagKeys)}`,\n\t\t\t},\n\t\t\tchoicesNotAnArray: {\n\t\t\t\tfilter: ([, flag]) => Object.hasOwn(flag, 'choices') && !Array.isArray(flag.choices),\n\t\t\t\tmessage: flagKeys => `The option \\`choices\\` must be an array. Invalid flags: ${joinFlagKeys(flagKeys)}`,\n\t\t\t},\n\t\t\tchoicesNotMatchFlagType: {\n\t\t\t\tfilter: ([, flag]) => flag.type && Array.isArray(flag.choices) && flag.choices.some(choice => typeof choice !== flag.type),\n\t\t\t\tmessage(flagKeys) {\n\t\t\t\t\tconst flagKeysAndTypes = flagKeys.map(flagKey => `(\\`${decamelizeFlagKey(flagKey)}\\`, type: '${options.flags[flagKey].type}')`);\n\t\t\t\t\treturn `Each value of the option \\`choices\\` must be of the same type as its flag. Invalid flags: ${flagKeysAndTypes.join(', ')}`;\n\t\t\t\t},\n\t\t\t},\n\t\t\tdefaultNotInChoices: {\n\t\t\t\tfilter: ([, flag]) => flag.default && Array.isArray(flag.choices) && ![flag.default].flat().every(value => flag.choices.includes(value)),\n\t\t\t\tmessage: flagKeys => `Each value of the option \\`default\\` must exist within the option \\`choices\\`. Invalid flags: ${joinFlagKeys(flagKeys)}`,\n\t\t\t},\n\t\t},\n\t};\n\n\tconst errorMessages = [];\n\n\tfor (const [optionKey, filters] of Object.entries(invalidOptionFilters)) {\n\t\tconst optionEntries = Object.entries(options[optionKey]);\n\n\t\tfor (const {filter, message} of Object.values(filters)) {\n\t\t\tconst invalidOptions = optionEntries.filter(option => filter(option));\n\t\t\tconst invalidOptionKeys = invalidOptions.map(([key]) => key);\n\n\t\t\tif (invalidOptions.length > 0) {\n\t\t\t\terrorMessages.push(message(invalidOptionKeys));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errorMessages.length > 0) {\n\t\tthrow new Error(errorMessages.join('\\n'));\n\t}\n};\n\nconst buildOptions = (helpText, options) => {\n\tif (typeof helpText !== 'string') {\n\t\toptions = helpText;\n\t\thelpText = '';\n\t}\n\n\tif (!options.importMeta?.url) {\n\t\tthrow new TypeError('The `importMeta` option is required. Its value must be `import.meta`.');\n\t}\n\n\tconst foundPackage = readPackageUpSync({\n\t\tcwd: dirname(fileURLToPath(options.importMeta.url)),\n\t\tnormalize: false,\n\t});\n\n\tconst parsedOptions = {\n\t\tpkg: foundPackage ? foundPackage.packageJson : {},\n\t\targv: process.argv.slice(2),\n\t\tflags: {},\n\t\tinferType: false,\n\t\tinput: 'string',\n\t\thelp: helpText,\n\t\tautoHelp: true,\n\t\tautoVersion: true,\n\t\tbooleanDefault: false,\n\t\tallowUnknownFlags: true,\n\t\tallowParentFlags: true,\n\t\thelpIndent: 2,\n\t\t...options,\n\t};\n\n\tvalidateOptions(parsedOptions);\n\n\treturn parsedOptions;\n};\n\nexport { buildOptions };\n","import { d as decamelizeKeys, b as constructParserOptions } from './dependencies.js';\n\nconst buildParserFlags = ({flags, booleanDefault}) => {\n\tconst parserFlags = {};\n\n\tfor (const [flagKey, flagValue] of Object.entries(flags)) {\n\t\tconst flag = {...flagValue};\n\n\t\t// `minimist-options` expects `flag.alias`\n\t\tif (flag.shortFlag) {\n\t\t\tflag.alias = flag.shortFlag;\n\t\t\tdelete flag.shortFlag;\n\t\t}\n\n\t\tif (\n\t\t\tbooleanDefault !== undefined\n\t\t\t\t&& flag.type === 'boolean'\n\t\t\t\t&& !Object.hasOwn(flag, 'default')\n\t\t) {\n\t\t\tflag.default = flag.isMultiple ? [booleanDefault] : booleanDefault;\n\t\t}\n\n\t\tif (flag.isMultiple) {\n\t\t\tflag.type = flag.type ? `${flag.type}-array` : 'array';\n\t\t\tflag.default = flag.default ?? [];\n\t\t\tdelete flag.isMultiple;\n\t\t}\n\n\t\tif (Array.isArray(flag.aliases)) {\n\t\t\tif (flag.alias) {\n\t\t\t\tflag.aliases.push(flag.alias);\n\t\t\t}\n\n\t\t\tflag.alias = flag.aliases;\n\t\t\tdelete flag.aliases;\n\t\t}\n\n\t\tparserFlags[flagKey] = flag;\n\t}\n\n\treturn parserFlags;\n};\n\nconst buildParserOptions = options => {\n\tlet parserOptions = buildParserFlags(options);\n\tparserOptions.arguments = options.input;\n\n\tparserOptions = decamelizeKeys(parserOptions, {separator: '-', exclude: ['stopEarly', '--']});\n\n\tif (options.inferType) {\n\t\tdelete parserOptions.arguments;\n\t}\n\n\t// Add --help and --version to known flags if autoHelp or autoVersion are set\n\tif (!options.allowUnknownFlags) {\n\t\tif (options.autoHelp && !parserOptions.help) {\n\t\t\tparserOptions.help = {type: 'boolean'};\n\t\t}\n\n\t\tif (options.autoVersion && !parserOptions.version) {\n\t\t\tparserOptions.version = {type: 'boolean'};\n\t\t}\n\t}\n\n\tparserOptions = constructParserOptions(parserOptions);\n\n\tparserOptions.configuration = {\n\t\t...parserOptions.configuration,\n\t\t'greedy-arrays': false,\n\t};\n\n\tif (parserOptions['--']) {\n\t\tparserOptions.configuration['populate--'] = true;\n\t}\n\n\tif (!options.allowUnknownFlags) {\n\t\t// Collect unknown options in `argv._` to be checked later.\n\t\tparserOptions.configuration['unknown-options-as-args'] = true;\n\t}\n\n\treturn parserOptions;\n};\n\nexport { buildParserOptions };\n","import process from 'node:process';\nimport { decamelizeFlagKey } from './utils.js';\n\nconst validateFlags = (flags, options) => {\n\tfor (const [flagKey, flagValue] of Object.entries(options.flags)) {\n\t\tif (flagKey !== '--' && !flagValue.isMultiple && Array.isArray(flags[flagKey])) {\n\t\t\tthrow new Error(`The flag --${flagKey} can only be set once.`);\n\t\t}\n\t}\n};\n\nconst validateChoicesByFlag = (flagKey, flagValue, receivedInput) => {\n\tconst {choices, isRequired} = flagValue;\n\n\tif (!choices) {\n\t\treturn;\n\t}\n\n\tconst valueMustBeOneOf = `Value must be one of: [\\`${choices.join('`, `')}\\`]`;\n\n\tif (!receivedInput) {\n\t\tif (isRequired) {\n\t\t\treturn `Flag \\`${decamelizeFlagKey(flagKey)}\\` has no value. ${valueMustBeOneOf}`;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (Array.isArray(receivedInput)) {\n\t\tconst unknownValues = receivedInput.filter(index => !choices.includes(index));\n\n\t\tif (unknownValues.length > 0) {\n\t\t\tconst valuesText = unknownValues.length > 1 ? 'values' : 'value';\n\n\t\t\treturn `Unknown ${valuesText} for flag \\`${decamelizeFlagKey(flagKey)}\\`: \\`${unknownValues.join('`, `')}\\`. ${valueMustBeOneOf}`;\n\t\t}\n\t} else if (!choices.includes(receivedInput)) {\n\t\treturn `Unknown value for flag \\`${decamelizeFlagKey(flagKey)}\\`: \\`${receivedInput}\\`. ${valueMustBeOneOf}`;\n\t}\n};\n\nconst validateChoices = (flags, receivedFlags) => {\n\tconst errors = [];\n\n\tfor (const [flagKey, flagValue] of Object.entries(flags)) {\n\t\tconst receivedInput = receivedFlags[flagKey];\n\t\tconst errorMessage = validateChoicesByFlag(flagKey, flagValue, receivedInput);\n\n\t\tif (errorMessage) {\n\t\t\terrors.push(errorMessage);\n\t\t}\n\t}\n\n\tif (errors.length > 0) {\n\t\tthrow new Error(`${errors.join('\\n')}`);\n\t}\n};\n\nconst validate = (flags, options) => {\n\tvalidateFlags(flags, options);\n\tvalidateChoices(options.flags, flags);\n};\n\nconst reportUnknownFlags = unknownFlags => {\n\tconsole.error([\n\t\t`Unknown flag${unknownFlags.length > 1 ? 's' : ''}`,\n\t\t...unknownFlags,\n\t].join('\\n'));\n};\n\nconst checkUnknownFlags = input => {\n\tconst unknownFlags = input.filter(item => typeof item === 'string' && item.startsWith('-'));\n\tif (unknownFlags.length > 0) {\n\t\treportUnknownFlags(unknownFlags);\n\t\tprocess.exit(2);\n\t}\n};\n\nconst isFlagMissing = (flagName, definedFlags, receivedFlags, input) => {\n\tconst flag = definedFlags[flagName];\n\tlet isFlagRequired = true;\n\n\tif (typeof flag.isRequired === 'function') {\n\t\tisFlagRequired = flag.isRequired(receivedFlags, input);\n\t\tif (typeof isFlagRequired !== 'boolean') {\n\t\t\tthrow new TypeError(`Return value for isRequired callback should be of type boolean, but ${typeof isFlagRequired} was returned.`);\n\t\t}\n\t}\n\n\tif (receivedFlags[flagName] === undefined) {\n\t\treturn isFlagRequired;\n\t}\n\n\treturn flag.isMultiple && receivedFlags[flagName].length === 0 && isFlagRequired;\n};\n\nconst reportMissingRequiredFlags = missingRequiredFlags => {\n\tconsole.error(`Missing required flag${missingRequiredFlags.length > 1 ? 's' : ''}`);\n\tfor (const flag of missingRequiredFlags) {\n\t\tconsole.error(`\\t${decamelizeFlagKey(flag.key)}${flag.shortFlag ? `, -${flag.shortFlag}` : ''}`);\n\t}\n};\n\nconst checkMissingRequiredFlags = (flags, receivedFlags, input) => {\n\tconst missingRequiredFlags = [];\n\tif (flags === undefined) {\n\t\treturn [];\n\t}\n\n\tfor (const flagName of Object.keys(flags)) {\n\t\tif (flags[flagName].isRequired && isFlagMissing(flagName, flags, receivedFlags, input)) {\n\t\t\tmissingRequiredFlags.push({key: flagName, ...flags[flagName]});\n\t\t}\n\t}\n\n\tif (missingRequiredFlags.length > 0) {\n\t\treportMissingRequiredFlags(missingRequiredFlags);\n\t\tprocess.exit(2);\n\t}\n};\n\nexport { checkMissingRequiredFlags, checkUnknownFlags, validate };\n","import process from 'node:process';\nimport { y as yargsParser, t as trimNewlines, r as redent, n as normalizePackageData, c as camelcaseKeys } from './dependencies.js';\nimport { buildOptions } from './options.js';\nimport { buildParserOptions } from './parser.js';\nimport { checkUnknownFlags, validate, checkMissingRequiredFlags } from './validate.js';\n\nconst buildResult = (options, parserOptions) => {\n\tconst {pkg: package_} = options;\n\tconst argv = yargsParser(options.argv, parserOptions);\n\tlet help = '';\n\n\tif (options.help) {\n\t\thelp = trimNewlines((options.help || '').replace(/\\t+\\n*$/, ''));\n\n\t\tif (help.includes('\\n')) {\n\t\t\thelp = redent(help, options.helpIndent);\n\t\t}\n\n\t\thelp = `\\n${help}`;\n\t}\n\n\tnormalizePackageData(package_);\n\n\tlet {description} = options;\n\tif (!description && description !== false) {\n\t\t({description} = package_);\n\t}\n\n\tdescription &&= help ? redent(`\\n${description}\\n`, options.helpIndent) : `\\n${description}`;\n\thelp = `${description || ''}${help}\\n`;\n\n\tconst showHelp = code => {\n\t\tconsole.log(help);\n\t\tprocess.exit(typeof code === 'number' ? code : 2);\n\t};\n\n\tconst showVersion = () => {\n\t\tconsole.log(typeof options.version === 'string' ? options.version : package_.version);\n\t\tprocess.exit(0);\n\t};\n\n\tif (argv._.length === 0 && options.argv.length === 1) {\n\t\tif (argv.version === true && options.autoVersion) {\n\t\t\tshowVersion();\n\t\t} else if (argv.help === true && options.autoHelp) {\n\t\t\tshowHelp(0);\n\t\t}\n\t}\n\n\tconst input = argv._;\n\tdelete argv._;\n\n\tif (!options.allowUnknownFlags) {\n\t\tcheckUnknownFlags(input);\n\t}\n\n\tconst flags = camelcaseKeys(argv, {exclude: ['--', /^\\w$/]});\n\tconst unnormalizedFlags = {...flags};\n\n\tvalidate(flags, options);\n\n\tfor (const flagValue of Object.values(options.flags)) {\n\t\tif (Array.isArray(flagValue.aliases)) {\n\t\t\tfor (const alias of flagValue.aliases) {\n\t\t\t\tdelete flags[alias];\n\t\t\t}\n\t\t}\n\n\t\tdelete flags[flagValue.shortFlag];\n\t}\n\n\tcheckMissingRequiredFlags(options.flags, flags, input);\n\n\treturn {\n\t\tinput,\n\t\tflags,\n\t\tunnormalizedFlags,\n\t\tpkg: package_,\n\t\thelp,\n\t\tshowHelp,\n\t\tshowVersion,\n\t};\n};\n\nconst meow = (helpText, options = {}) => {\n\tconst parsedOptions = buildOptions(helpText, options);\n\tconst parserOptions = buildParserOptions(parsedOptions);\n\tconst result = buildResult(parsedOptions, parserOptions);\n\n\tprocess.title = result.pkg.bin ? Object.keys(result.pkg.bin).at(0) : result.pkg.name;\n\n\treturn result;\n};\n\nexport { meow as default };\n","// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\n// Max safe length for a build identifier. The max length minus 6 characters for\n// the shortest version with a build 0.0.0+BUILD.\nconst MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6\n\nconst RELEASE_TYPES = [\n  'major',\n  'premajor',\n  'minor',\n  'preminor',\n  'patch',\n  'prepatch',\n  'prerelease',\n]\n\nmodule.exports = {\n  MAX_LENGTH,\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_SAFE_INTEGER,\n  RELEASE_TYPES,\n  SEMVER_SPEC_VERSION,\n  FLAG_INCLUDE_PRERELEASE: 0b001,\n  FLAG_LOOSE: 0b010,\n}\n","const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n","const {\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_LENGTH,\n} = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst safeRe = exports.safeRe = []\nconst src = exports.src = []\nconst safeSrc = exports.safeSrc = []\nconst t = exports.t = {}\nlet R = 0\n\nconst LETTERDASHNUMBER = '[a-zA-Z0-9-]'\n\n// Replace some greedy regex tokens to prevent regex dos issues. These regex are\n// used internally via the safeRe object since all inputs in this library get\n// normalized first to trim and collapse all extra whitespace. The original\n// regexes are exported for userland consumption and lower level usage. A\n// future breaking change could export the safer regex only with a note that\n// all input should have extra whitespace removed.\nconst safeRegexReplacements = [\n  ['\\\\s', 1],\n  ['\\\\d', MAX_LENGTH],\n  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],\n]\n\nconst makeSafeRegex = (value) => {\n  for (const [token, max] of safeRegexReplacements) {\n    value = value\n      .split(`${token}*`).join(`${token}{0,${max}}`)\n      .split(`${token}+`).join(`${token}{1,${max}}`)\n  }\n  return value\n}\n\nconst createToken = (name, value, isGlobal) => {\n  const safe = makeSafeRegex(value)\n  const index = R++\n  debug(name, index, value)\n  t[name] = index\n  src[index] = value\n  safeSrc[index] = safe\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '\\\\d+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCEPLAIN', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)\ncreateToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`)\ncreateToken('COERCEFULL', src[t.COERCEPLAIN] +\n              `(?:${src[t.PRERELEASE]})?` +\n              `(?:${src[t.BUILD]})?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\ncreateToken('COERCERTLFULL', src[t.COERCEFULL], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$')\n","// parse out just the options we care about\nconst looseOption = Object.freeze({ loose: true })\nconst emptyOpts = Object.freeze({ })\nconst parseOptions = options => {\n  if (!options) {\n    return emptyOpts\n  }\n\n  if (typeof options !== 'object') {\n    return looseOption\n  }\n\n  return options\n}\nmodule.exports = parseOptions\n","const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers,\n}\n","const debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { safeRe: re, safeSrc: src, t } = require('../internal/re')\n\nconst parseOptions = require('../internal/parse-options')\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n        version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('build compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier, identifierBase) {\n    if (release.startsWith('pre')) {\n      if (!identifier && identifierBase === false) {\n        throw new Error('invalid increment argument: identifier is empty')\n      }\n      // Avoid an invalid semver results\n      if (identifier) {\n        const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`)\n        const match = `-${identifier}`.match(r)\n        if (!match || match[1] !== identifier) {\n          throw new Error(`invalid identifier: ${identifier}`)\n        }\n      }\n    }\n\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier, identifierBase)\n        this.inc('pre', identifier, identifierBase)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier, identifierBase)\n        }\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'release':\n        if (this.prerelease.length === 0) {\n          throw new Error(`version ${this.raw} is not a prerelease`)\n        }\n        this.prerelease.length = 0\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre': {\n        const base = Number(identifierBase) ? 1 : 0\n\n        if (this.prerelease.length === 0) {\n          this.prerelease = [base]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            if (identifier === this.prerelease.join('.') && identifierBase === false) {\n              throw new Error('invalid increment argument: identifier already exists')\n            }\n            this.prerelease.push(base)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          let prerelease = [identifier, base]\n          if (identifierBase === false) {\n            prerelease = [identifier]\n          }\n          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = prerelease\n            }\n          } else {\n            this.prerelease = prerelease\n          }\n        }\n        break\n      }\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.raw = this.format()\n    if (this.build.length) {\n      this.raw += `+${this.build.join('.')}`\n    }\n    return this\n  }\n}\n\nmodule.exports = SemVer\n","const SemVer = require('../classes/semver')\nconst parse = (version, options, throwErrors = false) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    if (!throwErrors) {\n      return null\n    }\n    throw er\n  }\n}\n\nmodule.exports = parse\n","const parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n","const parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n","const SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier, identifierBase) => {\n  if (typeof (options) === 'string') {\n    identifierBase = identifier\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(\n      version instanceof SemVer ? version.version : version,\n      options\n    ).inc(release, identifier, identifierBase).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n","const parse = require('./parse.js')\n\nconst diff = (version1, version2) => {\n  const v1 = parse(version1, null, true)\n  const v2 = parse(version2, null, true)\n  const comparison = v1.compare(v2)\n\n  if (comparison === 0) {\n    return null\n  }\n\n  const v1Higher = comparison > 0\n  const highVersion = v1Higher ? v1 : v2\n  const lowVersion = v1Higher ? v2 : v1\n  const highHasPre = !!highVersion.prerelease.length\n  const lowHasPre = !!lowVersion.prerelease.length\n\n  if (lowHasPre && !highHasPre) {\n    // Going from prerelease -> no prerelease requires some special casing\n\n    // If the low version has only a major, then it will always be a major\n    // Some examples:\n    // 1.0.0-1 -> 1.0.0\n    // 1.0.0-1 -> 1.1.1\n    // 1.0.0-1 -> 2.0.0\n    if (!lowVersion.patch && !lowVersion.minor) {\n      return 'major'\n    }\n\n    // If the main part has no difference\n    if (lowVersion.compareMain(highVersion) === 0) {\n      if (lowVersion.minor && !lowVersion.patch) {\n        return 'minor'\n      }\n      return 'patch'\n    }\n  }\n\n  // add the `pre` prefix if we are going to a prerelease version\n  const prefix = highHasPre ? 'pre' : ''\n\n  if (v1.major !== v2.major) {\n    return prefix + 'major'\n  }\n\n  if (v1.minor !== v2.minor) {\n    return prefix + 'minor'\n  }\n\n  if (v1.patch !== v2.patch) {\n    return prefix + 'patch'\n  }\n\n  // high and low are preleases\n  return 'prerelease'\n}\n\nmodule.exports = diff\n","const SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n","const SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n","const SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n","const parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n","const SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n","const compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n","const compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n","const SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n","const compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n","const compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n","const compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n","const compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n","const compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n","const compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n","const compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n","const compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n","const eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n","const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]\n    let next\n    while ((next = coerceRtlRegex.exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    coerceRtlRegex.lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  const major = match[2]\n  const minor = match[3] || '0'\n  const patch = match[4] || '0'\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''\n\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n}\nmodule.exports = coerce\n","class LRUCache {\n  constructor () {\n    this.max = 1000\n    this.map = new Map()\n  }\n\n  get (key) {\n    const value = this.map.get(key)\n    if (value === undefined) {\n      return undefined\n    } else {\n      // Remove the key from the map and add it to the end\n      this.map.delete(key)\n      this.map.set(key, value)\n      return value\n    }\n  }\n\n  delete (key) {\n    return this.map.delete(key)\n  }\n\n  set (key, value) {\n    const deleted = this.delete(key)\n\n    if (!deleted && value !== undefined) {\n      // If cache is full, delete the least recently used item\n      if (this.map.size >= this.max) {\n        const firstKey = this.map.keys().next().value\n        this.delete(firstKey)\n      }\n\n      this.map.set(key, value)\n    }\n\n    return this\n  }\n}\n\nmodule.exports = LRUCache\n","const SPACE_CHARACTERS = /\\s+/g\n\n// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.formatted = undefined\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First reduce all whitespace as much as possible so we do not have to rely\n    // on potentially slow regexes like \\s*. This is then stored and used for\n    // future error messages as well.\n    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')\n\n    // First, split on ||\n    this.set = this.raw\n      .split('||')\n      // map the range to a 2d array of comparators\n      .map(r => this.parseRange(r.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0) {\n        this.set = [first]\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.formatted = undefined\n  }\n\n  get range () {\n    if (this.formatted === undefined) {\n      this.formatted = ''\n      for (let i = 0; i < this.set.length; i++) {\n        if (i > 0) {\n          this.formatted += '||'\n        }\n        const comps = this.set[i]\n        for (let k = 0; k < comps.length; k++) {\n          if (k > 0) {\n            this.formatted += ' '\n          }\n          this.formatted += comps[k].toString().trim()\n        }\n      }\n    }\n    return this.formatted\n  }\n\n  format () {\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts =\n      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |\n      (this.options.loose && FLAG_LOOSE)\n    const memoKey = memoOpts + ':' + range\n    const cached = cache.get(memoKey)\n    if (cached) {\n      return cached\n    }\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range)\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n    debug('tilde trim', range)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n    debug('caret trim', range)\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        debug('loose invalid filter', comp, this.options)\n        return !!comp.match(re[t.COMPARATORLOOSE])\n      })\n    }\n    debug('range list', rangeList)\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const rangeMap = new Map()\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options))\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp]\n      }\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('')\n    }\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nmodule.exports = Range\n\nconst LRU = require('../internal/lrucache')\nconst cache = new LRU()\n\nconst parseOptions = require('../internal/parse-options')\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  safeRe: re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace,\n} = require('../internal/re')\nconst { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require('../internal/constants')\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n// ~0.0.1 --> >=0.0.1 <0.1.0-0\nconst replaceTildes = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceTilde(c, options))\n    .join(' ')\n}\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\n// ^0.0.1 --> >=0.0.1 <0.0.2-0\n// ^0.1.0 --> >=0.1.0 <0.2.0-0\nconst replaceCarets = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceCaret(c, options))\n    .join(' ')\n}\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp\n    .split(/\\s+/)\n    .map((c) => replaceXRange(c, options))\n    .join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0'\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp\n    .trim()\n    .replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp\n    .trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n// TODO build?\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return `${from} ${to}`.trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n","const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    comp = comp.trim().split(/\\s+/).join(' ')\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    options = parseOptions(options)\n\n    // Special cases where nothing can possibly be lower\n    if (options.includePrerelease &&\n      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {\n      return false\n    }\n    if (!options.includePrerelease &&\n      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {\n      return false\n    }\n\n    // Same direction increasing (> or >=)\n    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {\n      return true\n    }\n    // Same direction decreasing (< or <=)\n    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // same SemVer and both sides are inclusive (<= or >=)\n    if (\n      (this.semver.version === comp.semver.version) &&\n      this.operator.includes('=') && comp.operator.includes('=')) {\n      return true\n    }\n    // opposite directions less than\n    if (cmp(this.semver, '<', comp.semver, options) &&\n      this.operator.startsWith('>') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // opposite directions greater than\n    if (cmp(this.semver, '>', comp.semver, options) &&\n      this.operator.startsWith('<') && comp.operator.startsWith('>')) {\n      return true\n    }\n    return false\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = require('../internal/parse-options')\nconst { safeRe: re, t } = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n","const Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n","const Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin))) {\n      minver = setMin\n    }\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n","const Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n","const SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst { ANY } = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n","// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n","const outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n","const Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2, options)\n}\nmodule.exports = intersects\n","// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let first = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!first) {\n        first = version\n      }\n    } else {\n      if (prev) {\n        set.push([first, prev])\n      }\n      prev = null\n      first = null\n    }\n  }\n  if (first) {\n    set.push([first, null])\n  }\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max) {\n      ranges.push(min)\n    } else if (!max && min === v[0]) {\n      ranges.push('*')\n    } else if (!max) {\n      ranges.push(`>=${min}`)\n    } else if (min === v[0]) {\n      ranges.push(`<=${max}`)\n    } else {\n      ranges.push(`${min} - ${max}`)\n    }\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n","const Range = require('../classes/range.js')\nconst Comparator = require('../classes/comparator.js')\nconst { ANY } = Comparator\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) {\n    return true\n  }\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub) {\n        continue OUTER\n      }\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull) {\n      return false\n    }\n  }\n  return true\n}\n\nconst minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]\nconst minimumVersion = [new Comparator('>=0.0.0')]\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) {\n    return true\n  }\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) {\n      return true\n    } else if (options.includePrerelease) {\n      sub = minimumVersionWithPreRelease\n    } else {\n      sub = minimumVersion\n    }\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) {\n      return true\n    } else {\n      dom = minimumVersion\n    }\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') {\n      gt = higherGT(gt, c, options)\n    } else if (c.operator === '<' || c.operator === '<=') {\n      lt = lowerLT(lt, c, options)\n    } else {\n      eqSet.add(c.semver)\n    }\n  }\n\n  if (eqSet.size > 1) {\n    return null\n  }\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0) {\n      return null\n    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n      return null\n    }\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options)) {\n      return null\n    }\n\n    if (lt && !satisfies(eq, String(lt), options)) {\n      return null\n    }\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt) {\n          return false\n        }\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt) {\n          return false\n        }\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n      return false\n    }\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n    return false\n  }\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n    return false\n  }\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre) {\n    return false\n  }\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n","// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nconst constants = require('./internal/constants')\nconst SemVer = require('./classes/semver')\nconst identifiers = require('./internal/identifiers')\nconst parse = require('./functions/parse')\nconst valid = require('./functions/valid')\nconst clean = require('./functions/clean')\nconst inc = require('./functions/inc')\nconst diff = require('./functions/diff')\nconst major = require('./functions/major')\nconst minor = require('./functions/minor')\nconst patch = require('./functions/patch')\nconst prerelease = require('./functions/prerelease')\nconst compare = require('./functions/compare')\nconst rcompare = require('./functions/rcompare')\nconst compareLoose = require('./functions/compare-loose')\nconst compareBuild = require('./functions/compare-build')\nconst sort = require('./functions/sort')\nconst rsort = require('./functions/rsort')\nconst gt = require('./functions/gt')\nconst lt = require('./functions/lt')\nconst eq = require('./functions/eq')\nconst neq = require('./functions/neq')\nconst gte = require('./functions/gte')\nconst lte = require('./functions/lte')\nconst cmp = require('./functions/cmp')\nconst coerce = require('./functions/coerce')\nconst Comparator = require('./classes/comparator')\nconst Range = require('./classes/range')\nconst satisfies = require('./functions/satisfies')\nconst toComparators = require('./ranges/to-comparators')\nconst maxSatisfying = require('./ranges/max-satisfying')\nconst minSatisfying = require('./ranges/min-satisfying')\nconst minVersion = require('./ranges/min-version')\nconst validRange = require('./ranges/valid')\nconst outside = require('./ranges/outside')\nconst gtr = require('./ranges/gtr')\nconst ltr = require('./ranges/ltr')\nconst intersects = require('./ranges/intersects')\nconst simplifyRange = require('./ranges/simplify')\nconst subset = require('./ranges/subset')\nmodule.exports = {\n  parse,\n  valid,\n  clean,\n  inc,\n  diff,\n  major,\n  minor,\n  patch,\n  prerelease,\n  compare,\n  rcompare,\n  compareLoose,\n  compareBuild,\n  sort,\n  rsort,\n  gt,\n  lt,\n  eq,\n  neq,\n  gte,\n  lte,\n  cmp,\n  coerce,\n  Comparator,\n  Range,\n  satisfies,\n  toComparators,\n  maxSatisfying,\n  minSatisfying,\n  minVersion,\n  validRange,\n  outside,\n  gtr,\n  ltr,\n  intersects,\n  simplifyRange,\n  subset,\n  SemVer,\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n  RELEASE_TYPES: constants.RELEASE_TYPES,\n  compareIdentifiers: identifiers.compareIdentifiers,\n  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n}\n","'use strict';\nconst ansiEscapes = module.exports;\n// TODO: remove this in the next major version\nmodule.exports.default = ansiEscapes;\n\nconst ESC = '\\u001B[';\nconst OSC = '\\u001B]';\nconst BEL = '\\u0007';\nconst SEP = ';';\nconst isTerminalApp = process.env.TERM_PROGRAM === 'Apple_Terminal';\n\nansiEscapes.cursorTo = (x, y) => {\n\tif (typeof x !== 'number') {\n\t\tthrow new TypeError('The `x` argument is required');\n\t}\n\n\tif (typeof y !== 'number') {\n\t\treturn ESC + (x + 1) + 'G';\n\t}\n\n\treturn ESC + (y + 1) + ';' + (x + 1) + 'H';\n};\n\nansiEscapes.cursorMove = (x, y) => {\n\tif (typeof x !== 'number') {\n\t\tthrow new TypeError('The `x` argument is required');\n\t}\n\n\tlet ret = '';\n\n\tif (x < 0) {\n\t\tret += ESC + (-x) + 'D';\n\t} else if (x > 0) {\n\t\tret += ESC + x + 'C';\n\t}\n\n\tif (y < 0) {\n\t\tret += ESC + (-y) + 'A';\n\t} else if (y > 0) {\n\t\tret += ESC + y + 'B';\n\t}\n\n\treturn ret;\n};\n\nansiEscapes.cursorUp = (count = 1) => ESC + count + 'A';\nansiEscapes.cursorDown = (count = 1) => ESC + count + 'B';\nansiEscapes.cursorForward = (count = 1) => ESC + count + 'C';\nansiEscapes.cursorBackward = (count = 1) => ESC + count + 'D';\n\nansiEscapes.cursorLeft = ESC + 'G';\nansiEscapes.cursorSavePosition = isTerminalApp ? '\\u001B7' : ESC + 's';\nansiEscapes.cursorRestorePosition = isTerminalApp ? '\\u001B8' : ESC + 'u';\nansiEscapes.cursorGetPosition = ESC + '6n';\nansiEscapes.cursorNextLine = ESC + 'E';\nansiEscapes.cursorPrevLine = ESC + 'F';\nansiEscapes.cursorHide = ESC + '?25l';\nansiEscapes.cursorShow = ESC + '?25h';\n\nansiEscapes.eraseLines = count => {\n\tlet clear = '';\n\n\tfor (let i = 0; i < count; i++) {\n\t\tclear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : '');\n\t}\n\n\tif (count) {\n\t\tclear += ansiEscapes.cursorLeft;\n\t}\n\n\treturn clear;\n};\n\nansiEscapes.eraseEndLine = ESC + 'K';\nansiEscapes.eraseStartLine = ESC + '1K';\nansiEscapes.eraseLine = ESC + '2K';\nansiEscapes.eraseDown = ESC + 'J';\nansiEscapes.eraseUp = ESC + '1J';\nansiEscapes.eraseScreen = ESC + '2J';\nansiEscapes.scrollUp = ESC + 'S';\nansiEscapes.scrollDown = ESC + 'T';\n\nansiEscapes.clearScreen = '\\u001Bc';\n\nansiEscapes.clearTerminal = process.platform === 'win32' ?\n\t`${ansiEscapes.eraseScreen}${ESC}0f` :\n\t// 1. Erases the screen (Only done in case `2` is not supported)\n\t// 2. Erases the whole screen including scrollback buffer\n\t// 3. Moves cursor to the top-left position\n\t// More info: https://www.real-world-systems.com/docs/ANSIcode.html\n\t`${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;\n\nansiEscapes.beep = BEL;\n\nansiEscapes.link = (text, url) => {\n\treturn [\n\t\tOSC,\n\t\t'8',\n\t\tSEP,\n\t\tSEP,\n\t\turl,\n\t\tBEL,\n\t\ttext,\n\t\tOSC,\n\t\t'8',\n\t\tSEP,\n\t\tSEP,\n\t\tBEL\n\t].join('');\n};\n\nansiEscapes.image = (buffer, options = {}) => {\n\tlet ret = `${OSC}1337;File=inline=1`;\n\n\tif (options.width) {\n\t\tret += `;width=${options.width}`;\n\t}\n\n\tif (options.height) {\n\t\tret += `;height=${options.height}`;\n\t}\n\n\tif (options.preserveAspectRatio === false) {\n\t\tret += ';preserveAspectRatio=0';\n\t}\n\n\treturn ret + ':' + buffer.toString('base64') + BEL;\n};\n\nansiEscapes.iTerm = {\n\tsetCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,\n\n\tannotation: (message, options = {}) => {\n\t\tlet ret = `${OSC}1337;`;\n\n\t\tconst hasX = typeof options.x !== 'undefined';\n\t\tconst hasY = typeof options.y !== 'undefined';\n\t\tif ((hasX || hasY) && !(hasX && hasY && typeof options.length !== 'undefined')) {\n\t\t\tthrow new Error('`x`, `y` and `length` must be defined when `x` or `y` is defined');\n\t\t}\n\n\t\tmessage = message.replace(/\\|/g, '');\n\n\t\tret += options.isHidden ? 'AddHiddenAnnotation=' : 'AddAnnotation=';\n\n\t\tif (options.length > 0) {\n\t\t\tret +=\n\t\t\t\t\t(hasX ?\n\t\t\t\t\t\t[message, options.length, options.x, options.y] :\n\t\t\t\t\t\t[options.length, message]).join('|');\n\t\t} else {\n\t\t\tret += message;\n\t\t}\n\n\t\treturn ret + BEL;\n\t}\n};\n","'use strict';\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n","'use strict';\nconst os = require('os');\nconst tty = require('tty');\nconst hasFlag = require('has-flag');\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n","'use strict';\nconst supportsColor = require('supports-color');\nconst hasFlag = require('has-flag');\n\nfunction parseVersion(versionString) {\n\tif (/^\\d{3,4}$/.test(versionString)) {\n\t\t// Env var doesn't always use dots. example: 4601 => 46.1.0\n\t\tconst m = /(\\d{1,2})(\\d{2})/.exec(versionString);\n\t\treturn {\n\t\t\tmajor: 0,\n\t\t\tminor: parseInt(m[1], 10),\n\t\t\tpatch: parseInt(m[2], 10)\n\t\t};\n\t}\n\n\tconst versions = (versionString || '').split('.').map(n => parseInt(n, 10));\n\treturn {\n\t\tmajor: versions[0],\n\t\tminor: versions[1],\n\t\tpatch: versions[2]\n\t};\n}\n\nfunction supportsHyperlink(stream) {\n\tconst {env} = process;\n\n\tif ('FORCE_HYPERLINK' in env) {\n\t\treturn !(env.FORCE_HYPERLINK.length > 0 && parseInt(env.FORCE_HYPERLINK, 10) === 0);\n\t}\n\n\tif (hasFlag('no-hyperlink') || hasFlag('no-hyperlinks') || hasFlag('hyperlink=false') || hasFlag('hyperlink=never')) {\n\t\treturn false;\n\t}\n\n\tif (hasFlag('hyperlink=true') || hasFlag('hyperlink=always')) {\n\t\treturn true;\n\t}\n\n\t// Netlify does not run a TTY, it does not need `supportsColor` check\n\tif ('NETLIFY' in env) {\n\t\treturn true;\n\t}\n\n\t// If they specify no colors, they probably don't want hyperlinks.\n\tif (!supportsColor.supportsColor(stream)) {\n\t\treturn false;\n\t}\n\n\tif (stream && !stream.isTTY) {\n\t\treturn false;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn false;\n\t}\n\n\tif ('CI' in env) {\n\t\treturn false;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn false;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseVersion(env.TERM_PROGRAM_VERSION);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\tif (version.major === 3) {\n\t\t\t\t\treturn version.minor >= 1;\n\t\t\t\t}\n\n\t\t\t\treturn version.major > 3;\n\t\t\tcase 'WezTerm':\n\t\t\t\treturn version.major >= 20200620;\n\t\t\tcase 'vscode':\n\t\t\t\treturn version.major > 1 || version.major === 1 && version.minor >= 72;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif ('VTE_VERSION' in env) {\n\t\t// 0.50.0 was supposed to support hyperlinks, but throws a segfault\n\t\tif (env.VTE_VERSION === '0.50.0') {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst version = parseVersion(env.VTE_VERSION);\n\t\treturn version.major > 0 || version.minor >= 50;\n\t}\n\n\treturn false;\n}\n\nmodule.exports = {\n\tsupportsHyperlink,\n\tstdout: supportsHyperlink(process.stdout),\n\tstderr: supportsHyperlink(process.stderr)\n};\n","'use strict';\nconst ansiEscapes = require('ansi-escapes');\nconst supportsHyperlinks = require('supports-hyperlinks');\n\nconst terminalLink = (text, url, {target = 'stdout', ...options} = {}) => {\n\tif (!supportsHyperlinks[target]) {\n\t\t// If the fallback has been explicitly disabled, don't modify the text itself.\n\t\tif (options.fallback === false) {\n\t\t\treturn text;\n\t\t}\n\n\t\treturn typeof options.fallback === 'function' ? options.fallback(text, url) : `${text} (\\u200B${url}\\u200B)`;\n\t}\n\n\treturn ansiEscapes.link(text, url);\n};\n\nmodule.exports = (text, url, options = {}) => terminalLink(text, url, options);\n\nmodule.exports.stderr = (text, url, options = {}) => terminalLink(text, url, {target: 'stderr', ...options});\n\nmodule.exports.isSupported = supportsHyperlinks.stdout;\nmodule.exports.stderr.isSupported = supportsHyperlinks.stderr;\n","/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */\nexport function camelCase(str) {\n    // Handle the case where an argument is provided as camel case, e.g., fooBar.\n    // by ensuring that the string isn't already mixed case:\n    const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();\n    if (!isCamelCase) {\n        str = str.toLowerCase();\n    }\n    if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {\n        return str;\n    }\n    else {\n        let camelcase = '';\n        let nextChrUpper = false;\n        const leadingHyphens = str.match(/^-+/);\n        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {\n            let chr = str.charAt(i);\n            if (nextChrUpper) {\n                nextChrUpper = false;\n                chr = chr.toUpperCase();\n            }\n            if (i !== 0 && (chr === '-' || chr === '_')) {\n                nextChrUpper = true;\n            }\n            else if (chr !== '-' && chr !== '_') {\n                camelcase += chr;\n            }\n        }\n        return camelcase;\n    }\n}\nexport function decamelize(str, joinString) {\n    const lowercase = str.toLowerCase();\n    joinString = joinString || '-';\n    let notCamelcase = '';\n    for (let i = 0; i < str.length; i++) {\n        const chrLower = lowercase.charAt(i);\n        const chrString = str.charAt(i);\n        if (chrLower !== chrString && i > 0) {\n            notCamelcase += `${joinString}${lowercase.charAt(i)}`;\n        }\n        else {\n            notCamelcase += chrString;\n        }\n    }\n    return notCamelcase;\n}\nexport function looksLikeNumber(x) {\n    if (x === null || x === undefined)\n        return false;\n    // if loaded from config, may already be a number.\n    if (typeof x === 'number')\n        return true;\n    // hexadecimal.\n    if (/^0x[0-9a-f]+$/i.test(x))\n        return true;\n    // don't treat 0123 as a number; as it drops the leading '0'.\n    if (/^0[^.]/.test(x))\n        return false;\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n}\n","/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */\n// take an un-split argv string and tokenize it.\nexport function tokenizeArgString(argString) {\n    if (Array.isArray(argString)) {\n        return argString.map(e => typeof e !== 'string' ? e + '' : e);\n    }\n    argString = argString.trim();\n    let i = 0;\n    let prevC = null;\n    let c = null;\n    let opening = null;\n    const args = [];\n    for (let ii = 0; ii < argString.length; ii++) {\n        prevC = c;\n        c = argString.charAt(ii);\n        // split on spaces unless we're in quotes.\n        if (c === ' ' && !opening) {\n            if (!(prevC === ' ')) {\n                i++;\n            }\n            continue;\n        }\n        // don't split the string if we're in matching\n        // opening or closing single and double quotes.\n        if (c === opening) {\n            opening = null;\n        }\n        else if ((c === \"'\" || c === '\"') && !opening) {\n            opening = c;\n        }\n        if (!args[i])\n            args[i] = '';\n        args[i] += c;\n    }\n    return args;\n}\n","/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */\nexport var DefaultValuesForTypeKey;\n(function (DefaultValuesForTypeKey) {\n    DefaultValuesForTypeKey[\"BOOLEAN\"] = \"boolean\";\n    DefaultValuesForTypeKey[\"STRING\"] = \"string\";\n    DefaultValuesForTypeKey[\"NUMBER\"] = \"number\";\n    DefaultValuesForTypeKey[\"ARRAY\"] = \"array\";\n})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));\n","/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */\nimport { tokenizeArgString } from './tokenize-arg-string.js';\nimport { DefaultValuesForTypeKey } from './yargs-parser-types.js';\nimport { camelCase, decamelize, looksLikeNumber } from './string-utils.js';\nlet mixin;\nexport class YargsParser {\n    constructor(_mixin) {\n        mixin = _mixin;\n    }\n    parse(argsInput, options) {\n        const opts = Object.assign({\n            alias: undefined,\n            array: undefined,\n            boolean: undefined,\n            config: undefined,\n            configObjects: undefined,\n            configuration: undefined,\n            coerce: undefined,\n            count: undefined,\n            default: undefined,\n            envPrefix: undefined,\n            narg: undefined,\n            normalize: undefined,\n            string: undefined,\n            number: undefined,\n            __: undefined,\n            key: undefined\n        }, options);\n        // allow a string argument to be passed in rather\n        // than an argv array.\n        const args = tokenizeArgString(argsInput);\n        // tokenizeArgString adds extra quotes to args if argsInput is a string\n        // only strip those extra quotes in processValue if argsInput is a string\n        const inputIsString = typeof argsInput === 'string';\n        // aliases might have transitive relationships, normalize this.\n        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n        const configuration = Object.assign({\n            'boolean-negation': true,\n            'camel-case-expansion': true,\n            'combine-arrays': false,\n            'dot-notation': true,\n            'duplicate-arguments-array': true,\n            'flatten-duplicate-arrays': true,\n            'greedy-arrays': true,\n            'halt-at-non-option': false,\n            'nargs-eats-options': false,\n            'negation-prefix': 'no-',\n            'parse-numbers': true,\n            'parse-positional-numbers': true,\n            'populate--': false,\n            'set-placeholder-key': false,\n            'short-option-groups': true,\n            'strip-aliased': false,\n            'strip-dashed': false,\n            'unknown-options-as-args': false\n        }, opts.configuration);\n        const defaults = Object.assign(Object.create(null), opts.default);\n        const configObjects = opts.configObjects || [];\n        const envPrefix = opts.envPrefix;\n        const notFlagsOption = configuration['populate--'];\n        const notFlagsArgv = notFlagsOption ? '--' : '_';\n        const newAliases = Object.create(null);\n        const defaulted = Object.create(null);\n        // allow a i18n handler to be passed in, default to a fake one (util.format).\n        const __ = opts.__ || mixin.format;\n        const flags = {\n            aliases: Object.create(null),\n            arrays: Object.create(null),\n            bools: Object.create(null),\n            strings: Object.create(null),\n            numbers: Object.create(null),\n            counts: Object.create(null),\n            normalize: Object.create(null),\n            configs: Object.create(null),\n            nargs: Object.create(null),\n            coercions: Object.create(null),\n            keys: []\n        };\n        const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {\n            const key = typeof opt === 'object' ? opt.key : opt;\n            // assign to flags[bools|strings|numbers]\n            const assignment = Object.keys(opt).map(function (key) {\n                const arrayFlagKeys = {\n                    boolean: 'bools',\n                    string: 'strings',\n                    number: 'numbers'\n                };\n                return arrayFlagKeys[key];\n            }).filter(Boolean).pop();\n            // assign key to be coerced\n            if (assignment) {\n                flags[assignment][key] = true;\n            }\n            flags.arrays[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {\n            flags.bools[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.string || []).filter(Boolean).forEach(function (key) {\n            flags.strings[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.number || []).filter(Boolean).forEach(function (key) {\n            flags.numbers[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.count || []).filter(Boolean).forEach(function (key) {\n            flags.counts[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {\n            flags.normalize[key] = true;\n            flags.keys.push(key);\n        });\n        if (typeof opts.narg === 'object') {\n            Object.entries(opts.narg).forEach(([key, value]) => {\n                if (typeof value === 'number') {\n                    flags.nargs[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.coerce === 'object') {\n            Object.entries(opts.coerce).forEach(([key, value]) => {\n                if (typeof value === 'function') {\n                    flags.coercions[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.config !== 'undefined') {\n            if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n                ;\n                [].concat(opts.config).filter(Boolean).forEach(function (key) {\n                    flags.configs[key] = true;\n                });\n            }\n            else if (typeof opts.config === 'object') {\n                Object.entries(opts.config).forEach(([key, value]) => {\n                    if (typeof value === 'boolean' || typeof value === 'function') {\n                        flags.configs[key] = value;\n                    }\n                });\n            }\n        }\n        // create a lookup table that takes into account all\n        // combinations of aliases: {f: ['foo'], foo: ['f']}\n        extendAliases(opts.key, aliases, opts.default, flags.arrays);\n        // apply default values to all aliases.\n        Object.keys(defaults).forEach(function (key) {\n            (flags.aliases[key] || []).forEach(function (alias) {\n                defaults[alias] = defaults[key];\n            });\n        });\n        let error = null;\n        checkConfiguration();\n        let notFlags = [];\n        const argv = Object.assign(Object.create(null), { _: [] });\n        // TODO(bcoe): for the first pass at removing object prototype  we didn't\n        // remove all prototypes from objects returned by this API, we might want\n        // to gradually move towards doing so.\n        const argvReturn = {};\n        for (let i = 0; i < args.length; i++) {\n            const arg = args[i];\n            const truncatedArg = arg.replace(/^-{3,}/, '---');\n            let broken;\n            let key;\n            let letters;\n            let m;\n            let next;\n            let value;\n            // any unknown option (except for end-of-options, \"--\")\n            if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {\n                pushPositional(arg);\n                // ---, ---=, ----, etc,\n            }\n            else if (truncatedArg.match(/^---+(=|$)/)) {\n                // options without key name are invalid.\n                pushPositional(arg);\n                continue;\n                // -- separated by =\n            }\n            else if (arg.match(/^--.+=/) || (!configuration['short-option-groups'] && arg.match(/^-.+=/))) {\n                // Using [\\s\\S] instead of . because js doesn't support the\n                // 'dotall' regex modifier. See:\n                // http://stackoverflow.com/a/1068308/13216\n                m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/);\n                // arrays format = '--f=a b c'\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    if (checkAllAliases(m[1], flags.arrays)) {\n                        i = eatArray(i, m[1], args, m[2]);\n                    }\n                    else if (checkAllAliases(m[1], flags.nargs) !== false) {\n                        // nargs format = '--f=monkey washing cat'\n                        i = eatNargs(i, m[1], args, m[2]);\n                    }\n                    else {\n                        setArg(m[1], m[2], true);\n                    }\n                }\n            }\n            else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n                m = arg.match(negatedBoolean);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);\n                }\n                // -- separated by space.\n            }\n            else if (arg.match(/^--.+/) || (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))) {\n                m = arg.match(/^--?(.+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (checkAllAliases(key, flags.arrays)) {\n                        // array format = '--foo a b c'\n                        i = eatArray(i, key, args);\n                    }\n                    else if (checkAllAliases(key, flags.nargs) !== false) {\n                        // nargs format = '--foo a b c'\n                        // should be truthy even if: flags.nargs[key] === 0\n                        i = eatNargs(i, key, args);\n                    }\n                    else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!next.match(/^-/) ||\n                            next.match(negative)) &&\n                            !checkAllAliases(key, flags.bools) &&\n                            !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n                // dot-notation flag separated by '='.\n            }\n            else if (arg.match(/^-.\\..+=/)) {\n                m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    setArg(m[1], m[2]);\n                }\n                // dot-notation flag separated by space.\n            }\n            else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n                next = args[i + 1];\n                m = arg.match(/^-(.\\..+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (next !== undefined && !next.match(/^-/) &&\n                        !checkAllAliases(key, flags.bools) &&\n                        !checkAllAliases(key, flags.counts)) {\n                        setArg(key, next);\n                        i++;\n                    }\n                    else {\n                        setArg(key, defaultValue(key));\n                    }\n                }\n            }\n            else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n                letters = arg.slice(1, -1).split('');\n                broken = false;\n                for (let j = 0; j < letters.length; j++) {\n                    next = arg.slice(j + 2);\n                    if (letters[j + 1] && letters[j + 1] === '=') {\n                        value = arg.slice(j + 3);\n                        key = letters[j];\n                        if (checkAllAliases(key, flags.arrays)) {\n                            // array format = '-f=a b c'\n                            i = eatArray(i, key, args, value);\n                        }\n                        else if (checkAllAliases(key, flags.nargs) !== false) {\n                            // nargs format = '-f=monkey washing cat'\n                            i = eatNargs(i, key, args, value);\n                        }\n                        else {\n                            setArg(key, value);\n                        }\n                        broken = true;\n                        break;\n                    }\n                    if (next === '-') {\n                        setArg(letters[j], next);\n                        continue;\n                    }\n                    // current letter is an alphabetic character and next value is a number\n                    if (/[A-Za-z]/.test(letters[j]) &&\n                        /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) &&\n                        checkAllAliases(next, flags.bools) === false) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    else {\n                        setArg(letters[j], defaultValue(letters[j]));\n                    }\n                }\n                key = arg.slice(-1)[0];\n                if (!broken && key !== '-') {\n                    if (checkAllAliases(key, flags.arrays)) {\n                        // array format = '-f a b c'\n                        i = eatArray(i, key, args);\n                    }\n                    else if (checkAllAliases(key, flags.nargs) !== false) {\n                        // nargs format = '-f a b c'\n                        // should be truthy even if: flags.nargs[key] === 0\n                        i = eatNargs(i, key, args);\n                    }\n                    else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n                            next.match(negative)) &&\n                            !checkAllAliases(key, flags.bools) &&\n                            !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n            }\n            else if (arg.match(/^-[0-9]$/) &&\n                arg.match(negative) &&\n                checkAllAliases(arg.slice(1), flags.bools)) {\n                // single-digit boolean alias, e.g: xargs -0\n                key = arg.slice(1);\n                setArg(key, defaultValue(key));\n            }\n            else if (arg === '--') {\n                notFlags = args.slice(i + 1);\n                break;\n            }\n            else if (configuration['halt-at-non-option']) {\n                notFlags = args.slice(i);\n                break;\n            }\n            else {\n                pushPositional(arg);\n            }\n        }\n        // order of precedence:\n        // 1. command line arg\n        // 2. value from env var\n        // 3. value from config file\n        // 4. value from config objects\n        // 5. configured default value\n        applyEnvVars(argv, true); // special case: check env vars that point to config file\n        applyEnvVars(argv, false);\n        setConfig(argv);\n        setConfigObjects();\n        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n        applyCoercions(argv);\n        if (configuration['set-placeholder-key'])\n            setPlaceholderKeys(argv);\n        // for any counts either not in args or without an explicit default, set to 0\n        Object.keys(flags.counts).forEach(function (key) {\n            if (!hasKey(argv, key.split('.')))\n                setArg(key, 0);\n        });\n        // '--' defaults to undefined.\n        if (notFlagsOption && notFlags.length)\n            argv[notFlagsArgv] = [];\n        notFlags.forEach(function (key) {\n            argv[notFlagsArgv].push(key);\n        });\n        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n            Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n                delete argv[key];\n            });\n        }\n        if (configuration['strip-aliased']) {\n            ;\n            [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n                if (configuration['camel-case-expansion'] && alias.includes('-')) {\n                    delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];\n                }\n                delete argv[alias];\n            });\n        }\n        // Push argument into positional array, applying numeric coercion:\n        function pushPositional(arg) {\n            const maybeCoercedNumber = maybeCoerceNumber('_', arg);\n            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {\n                argv._.push(maybeCoercedNumber);\n            }\n        }\n        // how many arguments should we consume, based\n        // on the nargs option?\n        function eatNargs(i, key, args, argAfterEqualSign) {\n            let ii;\n            let toEat = checkAllAliases(key, flags.nargs);\n            // NaN has a special meaning for the array type, indicating that one or\n            // more values are expected.\n            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;\n            if (toEat === 0) {\n                if (!isUndefined(argAfterEqualSign)) {\n                    error = Error(__('Argument unexpected for: %s', key));\n                }\n                setArg(key, defaultValue(key));\n                return i;\n            }\n            let available = isUndefined(argAfterEqualSign) ? 0 : 1;\n            if (configuration['nargs-eats-options']) {\n                // classic behavior, yargs eats positional and dash arguments.\n                if (args.length - (i + 1) + available < toEat) {\n                    error = Error(__('Not enough arguments following: %s', key));\n                }\n                available = toEat;\n            }\n            else {\n                // nargs will not consume flag arguments, e.g., -abc, --foo,\n                // and terminates when one is observed.\n                for (ii = i + 1; ii < args.length; ii++) {\n                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))\n                        available++;\n                    else\n                        break;\n                }\n                if (available < toEat)\n                    error = Error(__('Not enough arguments following: %s', key));\n            }\n            let consumed = Math.min(available, toEat);\n            if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n                setArg(key, argAfterEqualSign);\n                consumed--;\n            }\n            for (ii = i + 1; ii < (consumed + i + 1); ii++) {\n                setArg(key, args[ii]);\n            }\n            return (i + consumed);\n        }\n        // if an option is an array, eat all non-hyphenated arguments\n        // following it... YUM!\n        // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n        function eatArray(i, key, args, argAfterEqualSign) {\n            let argsToSet = [];\n            let next = argAfterEqualSign || args[i + 1];\n            // If both array and nargs are configured, enforce the nargs count:\n            const nargsCount = checkAllAliases(key, flags.nargs);\n            if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {\n                argsToSet.push(true);\n            }\n            else if (isUndefined(next) ||\n                (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {\n                // for keys without value ==> argsToSet remains an empty []\n                // set user default value, if available\n                if (defaults[key] !== undefined) {\n                    const defVal = defaults[key];\n                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];\n                }\n            }\n            else {\n                // value in --option=value is eaten as is\n                if (!isUndefined(argAfterEqualSign)) {\n                    argsToSet.push(processValue(key, argAfterEqualSign, true));\n                }\n                for (let ii = i + 1; ii < args.length; ii++) {\n                    if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||\n                        (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount))\n                        break;\n                    next = args[ii];\n                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))\n                        break;\n                    i = ii;\n                    argsToSet.push(processValue(key, next, inputIsString));\n                }\n            }\n            // If both array and nargs are configured, create an error if less than\n            // nargs positionals were found. NaN has special meaning, indicating\n            // that at least one value is required (more are okay).\n            if (typeof nargsCount === 'number' && ((nargsCount && argsToSet.length < nargsCount) ||\n                (isNaN(nargsCount) && argsToSet.length === 0))) {\n                error = Error(__('Not enough arguments following: %s', key));\n            }\n            setArg(key, argsToSet);\n            return i;\n        }\n        function setArg(key, val, shouldStripQuotes = inputIsString) {\n            if (/-/.test(key) && configuration['camel-case-expansion']) {\n                const alias = key.split('.').map(function (prop) {\n                    return camelCase(prop);\n                }).join('.');\n                addNewAlias(key, alias);\n            }\n            const value = processValue(key, val, shouldStripQuotes);\n            const splitKey = key.split('.');\n            setKey(argv, splitKey, value);\n            // handle populating aliases of the full key\n            if (flags.aliases[key]) {\n                flags.aliases[key].forEach(function (x) {\n                    const keyProperties = x.split('.');\n                    setKey(argv, keyProperties, value);\n                });\n            }\n            // handle populating aliases of the first element of the dot-notation key\n            if (splitKey.length > 1 && configuration['dot-notation']) {\n                ;\n                (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n                    let keyProperties = x.split('.');\n                    // expand alias with nested objects in key\n                    const a = [].concat(splitKey);\n                    a.shift(); // nuke the old key.\n                    keyProperties = keyProperties.concat(a);\n                    // populate alias only if is not already an alias of the full key\n                    // (already populated above)\n                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {\n                        setKey(argv, keyProperties, value);\n                    }\n                });\n            }\n            // Set normalize getter and setter when key is in 'normalize' but isn't an array\n            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n                const keys = [key].concat(flags.aliases[key] || []);\n                keys.forEach(function (key) {\n                    Object.defineProperty(argvReturn, key, {\n                        enumerable: true,\n                        get() {\n                            return val;\n                        },\n                        set(value) {\n                            val = typeof value === 'string' ? mixin.normalize(value) : value;\n                        }\n                    });\n                });\n            }\n        }\n        function addNewAlias(key, alias) {\n            if (!(flags.aliases[key] && flags.aliases[key].length)) {\n                flags.aliases[key] = [alias];\n                newAliases[alias] = true;\n            }\n            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n                addNewAlias(alias, key);\n            }\n        }\n        function processValue(key, val, shouldStripQuotes) {\n            // strings may be quoted, clean this up as we assign values.\n            if (shouldStripQuotes) {\n                val = stripQuotes(val);\n            }\n            // handle parsing boolean arguments --foo=true --bar false.\n            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n                if (typeof val === 'string')\n                    val = val === 'true';\n            }\n            let value = Array.isArray(val)\n                ? val.map(function (v) { return maybeCoerceNumber(key, v); })\n                : maybeCoerceNumber(key, val);\n            // increment a count given as arg (either no value or value parsed as boolean)\n            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n                value = increment();\n            }\n            // Set normalized value when key is in 'normalize' and in 'arrays'\n            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n                if (Array.isArray(val))\n                    value = val.map((val) => { return mixin.normalize(val); });\n                else\n                    value = mixin.normalize(val);\n            }\n            return value;\n        }\n        function maybeCoerceNumber(key, value) {\n            if (!configuration['parse-positional-numbers'] && key === '_')\n                return value;\n            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));\n                if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) {\n                    value = Number(value);\n                }\n            }\n            return value;\n        }\n        // set args from config.json file, this should be\n        // applied last so that defaults can be applied.\n        function setConfig(argv) {\n            const configLookup = Object.create(null);\n            // expand defaults/aliases, in-case any happen to reference\n            // the config.json file.\n            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n            Object.keys(flags.configs).forEach(function (configKey) {\n                const configPath = argv[configKey] || configLookup[configKey];\n                if (configPath) {\n                    try {\n                        let config = null;\n                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);\n                        const resolveConfig = flags.configs[configKey];\n                        if (typeof resolveConfig === 'function') {\n                            try {\n                                config = resolveConfig(resolvedConfigPath);\n                            }\n                            catch (e) {\n                                config = e;\n                            }\n                            if (config instanceof Error) {\n                                error = config;\n                                return;\n                            }\n                        }\n                        else {\n                            config = mixin.require(resolvedConfigPath);\n                        }\n                        setConfigObject(config);\n                    }\n                    catch (ex) {\n                        // Deno will receive a PermissionDenied error if an attempt is\n                        // made to load config without the --allow-read flag:\n                        if (ex.name === 'PermissionDenied')\n                            error = ex;\n                        else if (argv[configKey])\n                            error = Error(__('Invalid JSON config file: %s', configPath));\n                    }\n                }\n            });\n        }\n        // set args from config object.\n        // it recursively checks nested objects.\n        function setConfigObject(config, prev) {\n            Object.keys(config).forEach(function (key) {\n                const value = config[key];\n                const fullKey = prev ? prev + '.' + key : key;\n                // if the value is an inner object and we have dot-notation\n                // enabled, treat inner objects in config the same as\n                // heavily nested dot notations (foo.bar.apple).\n                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n                    // if the value is an object but not an array, check nested object\n                    setConfigObject(value, fullKey);\n                }\n                else {\n                    // setting arguments via CLI takes precedence over\n                    // values within the config file.\n                    if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {\n                        setArg(fullKey, value);\n                    }\n                }\n            });\n        }\n        // set all config objects passed in opts\n        function setConfigObjects() {\n            if (typeof configObjects !== 'undefined') {\n                configObjects.forEach(function (configObject) {\n                    setConfigObject(configObject);\n                });\n            }\n        }\n        function applyEnvVars(argv, configOnly) {\n            if (typeof envPrefix === 'undefined')\n                return;\n            const prefix = typeof envPrefix === 'string' ? envPrefix : '';\n            const env = mixin.env();\n            Object.keys(env).forEach(function (envVar) {\n                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n                    // get array of nested keys and convert them to camel case\n                    const keys = envVar.split('__').map(function (key, i) {\n                        if (i === 0) {\n                            key = key.substring(prefix.length);\n                        }\n                        return camelCase(key);\n                    });\n                    if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {\n                        setArg(keys.join('.'), env[envVar]);\n                    }\n                }\n            });\n        }\n        function applyCoercions(argv) {\n            let coerce;\n            const applied = new Set();\n            Object.keys(argv).forEach(function (key) {\n                if (!applied.has(key)) { // If we haven't already coerced this option via one of its aliases\n                    coerce = checkAllAliases(key, flags.coercions);\n                    if (typeof coerce === 'function') {\n                        try {\n                            const value = maybeCoerceNumber(key, coerce(argv[key]));\n                            ([].concat(flags.aliases[key] || [], key)).forEach(ali => {\n                                applied.add(ali);\n                                argv[ali] = value;\n                            });\n                        }\n                        catch (err) {\n                            error = err;\n                        }\n                    }\n                }\n            });\n        }\n        function setPlaceholderKeys(argv) {\n            flags.keys.forEach((key) => {\n                // don't set placeholder keys for dot notation options 'foo.bar'.\n                if (~key.indexOf('.'))\n                    return;\n                if (typeof argv[key] === 'undefined')\n                    argv[key] = undefined;\n            });\n            return argv;\n        }\n        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {\n            Object.keys(defaults).forEach(function (key) {\n                if (!hasKey(obj, key.split('.'))) {\n                    setKey(obj, key.split('.'), defaults[key]);\n                    if (canLog)\n                        defaulted[key] = true;\n                    (aliases[key] || []).forEach(function (x) {\n                        if (hasKey(obj, x.split('.')))\n                            return;\n                        setKey(obj, x.split('.'), defaults[key]);\n                    });\n                }\n            });\n        }\n        function hasKey(obj, keys) {\n            let o = obj;\n            if (!configuration['dot-notation'])\n                keys = [keys.join('.')];\n            keys.slice(0, -1).forEach(function (key) {\n                o = (o[key] || {});\n            });\n            const key = keys[keys.length - 1];\n            if (typeof o !== 'object')\n                return false;\n            else\n                return key in o;\n        }\n        function setKey(obj, keys, value) {\n            let o = obj;\n            if (!configuration['dot-notation'])\n                keys = [keys.join('.')];\n            keys.slice(0, -1).forEach(function (key) {\n                // TODO(bcoe): in the next major version of yargs, switch to\n                // Object.create(null) for dot notation:\n                key = sanitizeKey(key);\n                if (typeof o === 'object' && o[key] === undefined) {\n                    o[key] = {};\n                }\n                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n                    // ensure that o[key] is an array, and that the last item is an empty object.\n                    if (Array.isArray(o[key])) {\n                        o[key].push({});\n                    }\n                    else {\n                        o[key] = [o[key], {}];\n                    }\n                    // we want to update the empty object at the end of the o[key] array, so set o to that object\n                    o = o[key][o[key].length - 1];\n                }\n                else {\n                    o = o[key];\n                }\n            });\n            // TODO(bcoe): in the next major version of yargs, switch to\n            // Object.create(null) for dot notation:\n            const key = sanitizeKey(keys[keys.length - 1]);\n            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n            const isValueArray = Array.isArray(value);\n            let duplicate = configuration['duplicate-arguments-array'];\n            // nargs has higher priority than duplicate\n            if (!duplicate && checkAllAliases(key, flags.nargs)) {\n                duplicate = true;\n                if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {\n                    o[key] = undefined;\n                }\n            }\n            if (value === increment()) {\n                o[key] = increment(o[key]);\n            }\n            else if (Array.isArray(o[key])) {\n                if (duplicate && isTypeArray && isValueArray) {\n                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n                }\n                else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n                    o[key] = value;\n                }\n                else {\n                    o[key] = o[key].concat([value]);\n                }\n            }\n            else if (o[key] === undefined && isTypeArray) {\n                o[key] = isValueArray ? value : [value];\n            }\n            else if (duplicate && !(o[key] === undefined ||\n                checkAllAliases(key, flags.counts) ||\n                checkAllAliases(key, flags.bools))) {\n                o[key] = [o[key], value];\n            }\n            else {\n                o[key] = value;\n            }\n        }\n        // extend the aliases list with inferred aliases.\n        function extendAliases(...args) {\n            args.forEach(function (obj) {\n                Object.keys(obj || {}).forEach(function (key) {\n                    // short-circuit if we've already added a key\n                    // to the aliases array, for example it might\n                    // exist in both 'opts.default' and 'opts.key'.\n                    if (flags.aliases[key])\n                        return;\n                    flags.aliases[key] = [].concat(aliases[key] || []);\n                    // For \"--option-name\", also set argv.optionName\n                    flags.aliases[key].concat(key).forEach(function (x) {\n                        if (/-/.test(x) && configuration['camel-case-expansion']) {\n                            const c = camelCase(x);\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    // For \"--optionName\", also set argv['option-name']\n                    flags.aliases[key].concat(key).forEach(function (x) {\n                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n                            const c = decamelize(x, '-');\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    flags.aliases[key].forEach(function (x) {\n                        flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n                            return x !== y;\n                        }));\n                    });\n                });\n            });\n        }\n        function checkAllAliases(key, flag) {\n            const toCheck = [].concat(flags.aliases[key] || [], key);\n            const keys = Object.keys(flag);\n            const setAlias = toCheck.find(key => keys.includes(key));\n            return setAlias ? flag[setAlias] : false;\n        }\n        function hasAnyFlag(key) {\n            const flagsKeys = Object.keys(flags);\n            const toCheck = [].concat(flagsKeys.map(k => flags[k]));\n            return toCheck.some(function (flag) {\n                return Array.isArray(flag) ? flag.includes(key) : flag[key];\n            });\n        }\n        function hasFlagsMatching(arg, ...patterns) {\n            const toCheck = [].concat(...patterns);\n            return toCheck.some(function (pattern) {\n                const match = arg.match(pattern);\n                return match && hasAnyFlag(match[1]);\n            });\n        }\n        // based on a simplified version of the short flag group parsing logic\n        function hasAllShortFlags(arg) {\n            // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n                return false;\n            }\n            let hasAllFlags = true;\n            let next;\n            const letters = arg.slice(1).split('');\n            for (let j = 0; j < letters.length; j++) {\n                next = arg.slice(j + 2);\n                if (!hasAnyFlag(letters[j])) {\n                    hasAllFlags = false;\n                    break;\n                }\n                if ((letters[j + 1] && letters[j + 1] === '=') ||\n                    next === '-' ||\n                    (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) ||\n                    (letters[j + 1] && letters[j + 1].match(/\\W/))) {\n                    break;\n                }\n            }\n            return hasAllFlags;\n        }\n        function isUnknownOptionAsArg(arg) {\n            return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n        }\n        function isUnknownOption(arg) {\n            arg = arg.replace(/^-{3,}/, '--');\n            // ignore negative numbers\n            if (arg.match(negative)) {\n                return false;\n            }\n            // if this is a short option group and all of them are configured, it isn't unknown\n            if (hasAllShortFlags(arg)) {\n                return false;\n            }\n            // e.g. '--count=2'\n            const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/;\n            // e.g. '-a' or '--arg'\n            const normalFlag = /^-+([^=]+?)$/;\n            // e.g. '-a-'\n            const flagEndingInHyphen = /^-+([^=]+?)-$/;\n            // e.g. '-abc123'\n            const flagEndingInDigits = /^-+([^=]+?\\d+)$/;\n            // e.g. '-a/usr/local'\n            const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/;\n            // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n        }\n        // make a best effort to pick a default value\n        // for an option based on name and type.\n        function defaultValue(key) {\n            if (!checkAllAliases(key, flags.bools) &&\n                !checkAllAliases(key, flags.counts) &&\n                `${key}` in defaults) {\n                return defaults[key];\n            }\n            else {\n                return defaultForType(guessType(key));\n            }\n        }\n        // return a default value, given the type of a flag.,\n        function defaultForType(type) {\n            const def = {\n                [DefaultValuesForTypeKey.BOOLEAN]: true,\n                [DefaultValuesForTypeKey.STRING]: '',\n                [DefaultValuesForTypeKey.NUMBER]: undefined,\n                [DefaultValuesForTypeKey.ARRAY]: []\n            };\n            return def[type];\n        }\n        // given a flag, enforce a default type.\n        function guessType(key) {\n            let type = DefaultValuesForTypeKey.BOOLEAN;\n            if (checkAllAliases(key, flags.strings))\n                type = DefaultValuesForTypeKey.STRING;\n            else if (checkAllAliases(key, flags.numbers))\n                type = DefaultValuesForTypeKey.NUMBER;\n            else if (checkAllAliases(key, flags.bools))\n                type = DefaultValuesForTypeKey.BOOLEAN;\n            else if (checkAllAliases(key, flags.arrays))\n                type = DefaultValuesForTypeKey.ARRAY;\n            return type;\n        }\n        function isUndefined(num) {\n            return num === undefined;\n        }\n        // check user configuration settings for inconsistencies\n        function checkConfiguration() {\n            // count keys should not be set as array/narg\n            Object.keys(flags.counts).find(key => {\n                if (checkAllAliases(key, flags.arrays)) {\n                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));\n                    return true;\n                }\n                else if (checkAllAliases(key, flags.nargs)) {\n                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));\n                    return true;\n                }\n                return false;\n            });\n        }\n        return {\n            aliases: Object.assign({}, flags.aliases),\n            argv: Object.assign(argvReturn, argv),\n            configuration: configuration,\n            defaulted: Object.assign({}, defaulted),\n            error: error,\n            newAliases: Object.assign({}, newAliases)\n        };\n    }\n}\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases(aliases) {\n    const aliasArrays = [];\n    const combined = Object.create(null);\n    let change = true;\n    // turn alias lookup hash {key: ['alias1', 'alias2']} into\n    // a simple array ['key', 'alias1', 'alias2']\n    Object.keys(aliases).forEach(function (key) {\n        aliasArrays.push([].concat(aliases[key], key));\n    });\n    // combine arrays until zero changes are\n    // made in an iteration.\n    while (change) {\n        change = false;\n        for (let i = 0; i < aliasArrays.length; i++) {\n            for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n                const intersect = aliasArrays[i].filter(function (v) {\n                    return aliasArrays[ii].indexOf(v) !== -1;\n                });\n                if (intersect.length) {\n                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n                    aliasArrays.splice(ii, 1);\n                    change = true;\n                    break;\n                }\n            }\n        }\n    }\n    // map arrays back to the hash-lookup (de-dupe while\n    // we're at it).\n    aliasArrays.forEach(function (aliasArray) {\n        aliasArray = aliasArray.filter(function (v, i, self) {\n            return self.indexOf(v) === i;\n        });\n        const lastAlias = aliasArray.pop();\n        if (lastAlias !== undefined && typeof lastAlias === 'string') {\n            combined[lastAlias] = aliasArray;\n        }\n    });\n    return combined;\n}\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment(orig) {\n    return orig !== undefined ? orig + 1 : 1;\n}\n// TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\nfunction sanitizeKey(key) {\n    if (key === '__proto__')\n        return '___proto___';\n    return key;\n}\nfunction stripQuotes(val) {\n    return (typeof val === 'string' &&\n        (val[0] === \"'\" || val[0] === '\"') &&\n        val[val.length - 1] === val[0])\n        ? val.substring(1, val.length - 1)\n        : val;\n}\n","/**\n * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js\n * CJS and ESM environments.\n *\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */\nvar _a, _b, _c;\nimport { format } from 'util';\nimport { normalize, resolve } from 'path';\nimport { camelCase, decamelize, looksLikeNumber } from './string-utils.js';\nimport { YargsParser } from './yargs-parser.js';\nimport { readFileSync } from 'fs';\n// See https://github.com/yargs/yargs-parser#supported-nodejs-versions for our\n// version support policy. The YARGS_MIN_NODE_VERSION is used for testing only.\nconst minNodeVersion = (process && process.env && process.env.YARGS_MIN_NODE_VERSION)\n    ? Number(process.env.YARGS_MIN_NODE_VERSION)\n    : 12;\nconst nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);\nif (nodeVersion) {\n    const major = Number(nodeVersion.match(/^([^.]+)/)[1]);\n    if (major < minNodeVersion) {\n        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);\n    }\n}\n// Creates a yargs-parser instance using Node.js standard libraries:\nconst env = process ? process.env : {};\nconst parser = new YargsParser({\n    cwd: process.cwd,\n    env: () => {\n        return env;\n    },\n    format,\n    normalize,\n    resolve,\n    // TODO: figure  out a  way to combine ESM and CJS coverage, such  that\n    // we can exercise all the lines below:\n    require: (path) => {\n        if (typeof require !== 'undefined') {\n            return require(path);\n        }\n        else if (path.match(/\\.json$/)) {\n            // Addresses: https://github.com/yargs/yargs/issues/2040\n            return JSON.parse(readFileSync(path, 'utf8'));\n        }\n        else {\n            throw Error('only .json config files are supported in ESM');\n        }\n    }\n});\nconst yargsParser = function Parser(args, opts) {\n    const result = parser.parse(args.slice(), opts);\n    return result.argv;\n};\nyargsParser.detailed = function (args, opts) {\n    return parser.parse(args.slice(), opts);\n};\nyargsParser.camelCase = camelCase;\nyargsParser.decamelize = decamelize;\nyargsParser.looksLikeNumber = looksLikeNumber;\nexport default yargsParser;\n","exports.replaceDollarWithPercentPair = replaceDollarWithPercentPair\r\nexports.convertToSetCommand = convertToSetCommand\r\nexports.convertToSetCommands = convertToSetCommands\r\n\r\nfunction convertToSetCommand (key, value) {\r\n  var line = ''\r\n  key = key || ''\r\n  key = key.trim()\r\n  value = value || ''\r\n  value = value.trim()\r\n  if (key && value && value.length > 0) {\r\n    line = '@SET ' + key + '=' + replaceDollarWithPercentPair(value) + '\\r\\n'\r\n  }\r\n  return line\r\n}\r\n\r\nfunction extractVariableValuePairs (declarations) {\r\n  var pairs = {}\r\n  declarations.map(function (declaration) {\r\n    var split = declaration.split('=')\r\n    pairs[split[0]] = split[1]\r\n  })\r\n  return pairs\r\n}\r\n\r\nfunction convertToSetCommands (variableString) {\r\n  var variableValuePairs = extractVariableValuePairs(variableString.split(' '))\r\n  var variableDeclarationsAsBatch = ''\r\n  Object.keys(variableValuePairs).forEach(function (key) {\r\n    variableDeclarationsAsBatch += convertToSetCommand(key, variableValuePairs[key])\r\n  })\r\n  return variableDeclarationsAsBatch\r\n}\r\n\r\nfunction replaceDollarWithPercentPair (value) {\r\n  var dollarExpressions = /\\$\\{?([^$@#?\\- \\t{}:]+)\\}?/g\r\n  var result = ''\r\n  var startIndex = 0\r\n  do {\r\n    var match = dollarExpressions.exec(value)\r\n    if (match) {\r\n      var betweenMatches = value.substring(startIndex, match.index) || ''\r\n      result += betweenMatches + '%' + match[1] + '%'\r\n      startIndex = dollarExpressions.lastIndex\r\n    }\r\n  } while (dollarExpressions.lastIndex > 0)\r\n  result += value.slice(startIndex)\r\n  return result\r\n}\r\n","// On windows, create a .cmd file.\n// Read the #! in the file to see what it uses.  The vast majority\n// of the time, this will be either:\n// \"#!/usr/bin/env <prog> <args...>\"\n// or:\n// \"#!<prog> <args...>\"\n//\n// Write a binroot/pkg.bin + \".cmd\" file that has this line in it:\n// @<prog> <args...> %dp0%<target> %*\n\nconst {\n  chmod,\n  mkdir,\n  readFile,\n  stat,\n  unlink,\n  writeFile,\n} = require('fs/promises')\n\nconst { dirname, relative } = require('path')\nconst toBatchSyntax = require('./to-batch-syntax')\n// linting disabled because this regex is really long\n// eslint-disable-next-line max-len\nconst shebangExpr = /^#!\\s*(?:\\/usr\\/bin\\/env\\s+(?:-S\\s+)?((?:[^ \\t=]+=[^ \\t=]+\\s+)*))?([^ \\t]+)(.*)$/\n\nconst cmdShimIfExists = (from, to) =>\n  stat(from).then(() => cmdShim(from, to), () => {})\n\n// Try to unlink, but ignore errors.\n// Any problems will surface later.\nconst rm = path => unlink(path).catch(() => {})\n\nconst cmdShim = (from, to) =>\n  stat(from).then(() => cmdShim_(from, to))\n\nconst cmdShim_ = (from, to) => Promise.all([\n  rm(to),\n  rm(to + '.cmd'),\n  rm(to + '.ps1'),\n]).then(() => writeShim(from, to))\n\nconst writeShim = (from, to) =>\n  // make a cmd file and a sh script\n  // First, check if the bin is a #! of some sort.\n  // If not, then assume it's something that'll be compiled, or some other\n  // sort of script, and just call it directly.\n  mkdir(dirname(to), { recursive: true })\n    .then(() => readFile(from, 'utf8'))\n    .then(data => {\n      const firstLine = data.trim().split(/\\r*\\n/)[0]\n      const shebang = firstLine.match(shebangExpr)\n      if (!shebang) {\n        return writeShim_(from, to)\n      }\n      const vars = shebang[1] || ''\n      const prog = shebang[2]\n      const args = shebang[3] || ''\n      return writeShim_(from, to, prog, args, vars)\n    }, () => writeShim_(from, to))\n\nconst writeShim_ = (from, to, prog, args, variables) => {\n  let shTarget = relative(dirname(to), from)\n  let target = shTarget.split('/').join('\\\\')\n  let longProg\n  let shProg = prog && prog.split('\\\\').join('/')\n  let shLongProg\n  let pwshProg = shProg && `\"${shProg}$exe\"`\n  let pwshLongProg\n  shTarget = shTarget.split('\\\\').join('/')\n  args = args || ''\n  variables = variables || ''\n  if (!prog) {\n    prog = `\"%dp0%\\\\${target}\"`\n    shProg = `\"$basedir/${shTarget}\"`\n    pwshProg = shProg\n    args = ''\n    target = ''\n    shTarget = ''\n  } else {\n    longProg = `\"%dp0%\\\\${prog}.exe\"`\n    shLongProg = `\"$basedir/${prog}\"`\n    pwshLongProg = `\"$basedir/${prog}$exe\"`\n    target = `\"%dp0%\\\\${target}\"`\n    shTarget = `\"$basedir/${shTarget}\"`\n  }\n\n  // Subroutine trick to fix https://github.com/npm/cmd-shim/issues/10\n  // and https://github.com/npm/cli/issues/969\n  const head = '@ECHO off\\r\\n' +\n    'GOTO start\\r\\n' +\n    ':find_dp0\\r\\n' +\n    'SET dp0=%~dp0\\r\\n' +\n    'EXIT /b\\r\\n' +\n    ':start\\r\\n' +\n    'SETLOCAL\\r\\n' +\n    'CALL :find_dp0\\r\\n'\n\n  let cmd\n  if (longProg) {\n    shLongProg = shLongProg.trim()\n    args = args.trim()\n    const variablesBatch = toBatchSyntax.convertToSetCommands(variables)\n    cmd = head\n        + variablesBatch\n        + '\\r\\n'\n        + `IF EXIST ${longProg} (\\r\\n`\n        + `  SET \"_prog=${longProg.replace(/(^\")|(\"$)/g, '')}\"\\r\\n`\n        + ') ELSE (\\r\\n'\n        + `  SET \"_prog=${prog.replace(/(^\")|(\"$)/g, '')}\"\\r\\n`\n        + '  SET PATHEXT=%PATHEXT:;.JS;=;%\\r\\n'\n        + ')\\r\\n'\n        + '\\r\\n'\n        // prevent \"Terminate Batch Job? (Y/n)\" message\n        // https://github.com/npm/cli/issues/969#issuecomment-737496588\n        + 'endLocal & goto #_undefined_# 2>NUL || title %COMSPEC% & '\n        + `\"%_prog%\" ${args} ${target} %*\\r\\n`\n  } else {\n    cmd = `${head}${prog} ${args} ${target} %*\\r\\n`\n  }\n\n  // #!/bin/sh\n  // basedir=`dirname \"$0\"`\n  //\n  // case `uname` in\n  //     *CYGWIN*|*MINGW*|*MSYS*)\n  //       if command -v cygpath > /dev/null 2>&1; then\n  //           basedir=`cygpath -w \"$basedir\"`\n  //       fi\n  //     ;;\n  // esac\n  //\n  // if [ -x \"$basedir/node.exe\" ]; then\n  //   exec \"$basedir/node.exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" \"$@\"\n  // else\n  //   exec node \"$basedir/node_modules/npm/bin/npm-cli.js\" \"$@\"\n  // fi\n\n  let sh = '#!/bin/sh\\n'\n\n  sh = sh\n      + `basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\\\\\,/,g')\")\\n`\n      + '\\n'\n      + 'case `uname` in\\n'\n      + '    *CYGWIN*|*MINGW*|*MSYS*)\\n'\n      + '        if command -v cygpath > /dev/null 2>&1; then\\n'\n      + '            basedir=`cygpath -w \"$basedir\"`\\n'\n      + '        fi\\n'\n      + '    ;;\\n'\n      + 'esac\\n'\n      + '\\n'\n\n  if (shLongProg) {\n    sh = sh\n       + `if [ -x ${shLongProg} ]; then\\n`\n       + `  exec ${variables}${shLongProg} ${args} ${shTarget} \"$@\"\\n`\n       + 'else \\n'\n       + `  exec ${variables}${shProg} ${args} ${shTarget} \"$@\"\\n`\n       + 'fi\\n'\n  } else {\n    sh = sh\n       + `exec ${shProg} ${args} ${shTarget} \"$@\"\\n`\n  }\n\n  // #!/usr/bin/env pwsh\n  // $basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n  //\n  // $ret=0\n  // $exe = \"\"\n  // if ($PSVersionTable.PSVersion -lt \"6.0\" -or $IsWindows) {\n  //   # Fix case when both the Windows and Linux builds of Node\n  //   # are installed in the same directory\n  //   $exe = \".exe\"\n  // }\n  // if (Test-Path \"$basedir/node\") {\n  //   # Suport pipeline input\n  //   if ($MyInvocation.ExpectingInput) {\n  //     input | & \"$basedir/node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   } else {\n  //     & \"$basedir/node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   }\n  //   $ret=$LASTEXITCODE\n  // } else {\n  //   # Support pipeline input\n  //   if ($MyInvocation.ExpectingInput) {\n  //     $input | & \"node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   } else {\n  //     & \"node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   }\n  //   $ret=$LASTEXITCODE\n  // }\n  // exit $ret\n  let pwsh = '#!/usr/bin/env pwsh\\n'\n           + '$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\\n'\n           + '\\n'\n           + '$exe=\"\"\\n'\n           + 'if ($PSVersionTable.PSVersion -lt \"6.0\" -or $IsWindows) {\\n'\n           + '  # Fix case when both the Windows and Linux builds of Node\\n'\n           + '  # are installed in the same directory\\n'\n           + '  $exe=\".exe\"\\n'\n           + '}\\n'\n  if (shLongProg) {\n    pwsh = pwsh\n         + '$ret=0\\n'\n         + `if (Test-Path ${pwshLongProg}) {\\n`\n         + '  # Support pipeline input\\n'\n         + '  if ($MyInvocation.ExpectingInput) {\\n'\n         + `    $input | & ${pwshLongProg} ${args} ${shTarget} $args\\n`\n         + '  } else {\\n'\n         + `    & ${pwshLongProg} ${args} ${shTarget} $args\\n`\n         + '  }\\n'\n         + '  $ret=$LASTEXITCODE\\n'\n         + '} else {\\n'\n         + '  # Support pipeline input\\n'\n         + '  if ($MyInvocation.ExpectingInput) {\\n'\n         + `    $input | & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '  } else {\\n'\n         + `    & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '  }\\n'\n         + '  $ret=$LASTEXITCODE\\n'\n         + '}\\n'\n         + 'exit $ret\\n'\n  } else {\n    pwsh = pwsh\n         + '# Support pipeline input\\n'\n         + 'if ($MyInvocation.ExpectingInput) {\\n'\n         + `  $input | & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '} else {\\n'\n         + `  & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '}\\n'\n         + 'exit $LASTEXITCODE\\n'\n  }\n\n  return Promise.all([\n    writeFile(to + '.ps1', pwsh, 'utf8'),\n    writeFile(to + '.cmd', cmd, 'utf8'),\n    writeFile(to, sh, 'utf8'),\n  ]).then(() => chmodShim(to))\n}\n\nconst chmodShim = to => Promise.all([\n  chmod(to, 0o755),\n  chmod(to + '.cmd', 0o755),\n  chmod(to + '.ps1', 0o755),\n])\n\nmodule.exports = cmdShim\ncmdShim.ifExists = cmdShimIfExists\n","\"use strict\";\n/**\n * This is the Posix implementation of isexe, which uses the file\n * mode and uid/gid values.\n *\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sync = exports.isexe = void 0;\nconst fs_1 = require(\"fs\");\nconst promises_1 = require(\"fs/promises\");\n/**\n * Determine whether a path is executable according to the mode and\n * current (or specified) user and group IDs.\n */\nconst isexe = async (path, options = {}) => {\n    const { ignoreErrors = false } = options;\n    try {\n        return checkStat(await (0, promises_1.stat)(path), options);\n    }\n    catch (e) {\n        const er = e;\n        if (ignoreErrors || er.code === 'EACCES')\n            return false;\n        throw er;\n    }\n};\nexports.isexe = isexe;\n/**\n * Synchronously determine whether a path is executable according to\n * the mode and current (or specified) user and group IDs.\n */\nconst sync = (path, options = {}) => {\n    const { ignoreErrors = false } = options;\n    try {\n        return checkStat((0, fs_1.statSync)(path), options);\n    }\n    catch (e) {\n        const er = e;\n        if (ignoreErrors || er.code === 'EACCES')\n            return false;\n        throw er;\n    }\n};\nexports.sync = sync;\nconst checkStat = (stat, options) => stat.isFile() && checkMode(stat, options);\nconst checkMode = (stat, options) => {\n    const myUid = options.uid ?? process.getuid?.();\n    const myGroups = options.groups ?? process.getgroups?.() ?? [];\n    const myGid = options.gid ?? process.getgid?.() ?? myGroups[0];\n    if (myUid === undefined || myGid === undefined) {\n        throw new Error('cannot get uid or gid');\n    }\n    const groups = new Set([myGid, ...myGroups]);\n    const mod = stat.mode;\n    const uid = stat.uid;\n    const gid = stat.gid;\n    const u = parseInt('100', 8);\n    const g = parseInt('010', 8);\n    const o = parseInt('001', 8);\n    const ug = u | g;\n    return !!(mod & o ||\n        (mod & g && groups.has(gid)) ||\n        (mod & u && uid === myUid) ||\n        (mod & ug && myUid === 0));\n};\n//# sourceMappingURL=posix.js.map","\"use strict\";\n/**\n * This is the Windows implementation of isexe, which uses the file\n * extension and PATHEXT setting.\n *\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sync = exports.isexe = void 0;\nconst fs_1 = require(\"fs\");\nconst promises_1 = require(\"fs/promises\");\n/**\n * Determine whether a path is executable based on the file extension\n * and PATHEXT environment variable (or specified pathExt option)\n */\nconst isexe = async (path, options = {}) => {\n    const { ignoreErrors = false } = options;\n    try {\n        return checkStat(await (0, promises_1.stat)(path), path, options);\n    }\n    catch (e) {\n        const er = e;\n        if (ignoreErrors || er.code === 'EACCES')\n            return false;\n        throw er;\n    }\n};\nexports.isexe = isexe;\n/**\n * Synchronously determine whether a path is executable based on the file\n * extension and PATHEXT environment variable (or specified pathExt option)\n */\nconst sync = (path, options = {}) => {\n    const { ignoreErrors = false } = options;\n    try {\n        return checkStat((0, fs_1.statSync)(path), path, options);\n    }\n    catch (e) {\n        const er = e;\n        if (ignoreErrors || er.code === 'EACCES')\n            return false;\n        throw er;\n    }\n};\nexports.sync = sync;\nconst checkPathExt = (path, options) => {\n    const { pathExt = process.env.PATHEXT || '' } = options;\n    const peSplit = pathExt.split(';');\n    if (peSplit.indexOf('') !== -1) {\n        return true;\n    }\n    for (let i = 0; i < peSplit.length; i++) {\n        const p = peSplit[i].toLowerCase();\n        const ext = path.substring(path.length - p.length).toLowerCase();\n        if (p && ext === p) {\n            return true;\n        }\n    }\n    return false;\n};\nconst checkStat = (stat, path, options) => stat.isFile() && checkPathExt(path, options);\n//# sourceMappingURL=win32.js.map","const { isexe, sync: isexeSync } = require('isexe')\nconst { join, delimiter, sep, posix } = require('path')\n\nconst isWindows = process.platform === 'win32'\n\n// used to check for slashed in commands passed in. always checks for the posix\n// seperator on all platforms, and checks for the current separator when not on\n// a posix platform. don't use the isWindows check for this since that is mocked\n// in tests but we still need the code to actually work when called. that is also\n// why it is ignored from coverage.\n/* istanbul ignore next */\nconst rSlash = new RegExp(`[${posix.sep}${sep === posix.sep ? '' : sep}]`.replace(/(\\\\)/g, '\\\\$1'))\nconst rRel = new RegExp(`^\\\\.${rSlash.source}`)\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, {\n  path: optPath = process.env.PATH,\n  pathExt: optPathExt = process.env.PATHEXT,\n  delimiter: optDelimiter = delimiter,\n}) => {\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(rSlash) ? [''] : [\n    // windows always checks the cwd first\n    ...(isWindows ? [process.cwd()] : []),\n    ...(optPath || /* istanbul ignore next: very unusual */ '').split(optDelimiter),\n  ]\n\n  if (isWindows) {\n    const pathExtExe = optPathExt ||\n      ['.EXE', '.CMD', '.BAT', '.COM'].join(optDelimiter)\n    const pathExt = pathExtExe.split(optDelimiter).flatMap((item) => [item, item.toLowerCase()])\n    if (cmd.includes('.') && pathExt[0] !== '') {\n      pathExt.unshift('')\n    }\n    return { pathEnv, pathExt, pathExtExe }\n  }\n\n  return { pathEnv, pathExt: [''] }\n}\n\nconst getPathPart = (raw, cmd) => {\n  const pathPart = /^\".*\"$/.test(raw) ? raw.slice(1, -1) : raw\n  const prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : ''\n  return prefix + join(pathPart, cmd)\n}\n\nconst which = async (cmd, opt = {}) => {\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (const envPart of pathEnv) {\n    const p = getPathPart(envPart, cmd)\n\n    for (const ext of pathExt) {\n      const withExt = p + ext\n      const is = await isexe(withExt, { pathExt: pathExtExe, ignoreErrors: true })\n      if (is) {\n        if (!opt.all) {\n          return withExt\n        }\n        found.push(withExt)\n      }\n    }\n  }\n\n  if (opt.all && found.length) {\n    return found\n  }\n\n  if (opt.nothrow) {\n    return null\n  }\n\n  throw getNotFoundError(cmd)\n}\n\nconst whichSync = (cmd, opt = {}) => {\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (const pathEnvPart of pathEnv) {\n    const p = getPathPart(pathEnvPart, cmd)\n\n    for (const ext of pathExt) {\n      const withExt = p + ext\n      const is = isexeSync(withExt, { pathExt: pathExtExe, ignoreErrors: true })\n      if (is) {\n        if (!opt.all) {\n          return withExt\n        }\n        found.push(withExt)\n      }\n    }\n  }\n\n  if (opt.all && found.length) {\n    return found\n  }\n\n  if (opt.nothrow) {\n    return null\n  }\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n","import fs from 'node:fs';\n\nlet isDockerCached;\n\nfunction hasDockerEnv() {\n\ttry {\n\t\tfs.statSync('/.dockerenv');\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nfunction hasDockerCGroup() {\n\ttry {\n\t\treturn fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport default function isDocker() {\n\t// TODO: Use `??=` when targeting Node.js 16.\n\tif (isDockerCached === undefined) {\n\t\tisDockerCached = hasDockerEnv() || hasDockerCGroup();\n\t}\n\n\treturn isDockerCached;\n}\n","import fs from 'node:fs';\nimport isDocker from 'is-docker';\n\nlet cachedResult;\n\n// Podman detection\nconst hasContainerEnv = () => {\n\ttry {\n\t\tfs.statSync('/run/.containerenv');\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n};\n\nexport default function isInsideContainer() {\n\t// TODO: Use `??=` when targeting Node.js 16.\n\tif (cachedResult === undefined) {\n\t\tcachedResult = hasContainerEnv() || isDocker();\n\t}\n\n\treturn cachedResult;\n}\n","import process from 'node:process';\nimport os from 'node:os';\nimport fs from 'node:fs';\nimport isInsideContainer from 'is-inside-container';\n\nconst isWsl = () => {\n\tif (process.platform !== 'linux') {\n\t\treturn false;\n\t}\n\n\tif (os.release().toLowerCase().includes('microsoft')) {\n\t\tif (isInsideContainer()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\ttry {\n\t\treturn fs.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft')\n\t\t\t? !isInsideContainer() : false;\n\t} catch {\n\t\treturn false;\n\t}\n};\n\nexport default process.env.__IS_WSL_TEST__ ? isWsl : isWsl();\n","export default function defineLazyProperty(object, propertyName, valueGetter) {\n\tconst define = value => Object.defineProperty(object, propertyName, {value, enumerable: true, writable: true});\n\n\tObject.defineProperty(object, propertyName, {\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t\tget() {\n\t\t\tconst result = valueGetter();\n\t\t\tdefine(result);\n\t\t\treturn result;\n\t\t},\n\t\tset(value) {\n\t\t\tdefine(value);\n\t\t}\n\t});\n\n\treturn object;\n}\n","import {promisify} from 'node:util';\nimport process from 'node:process';\nimport {execFile} from 'node:child_process';\n\nconst execFileAsync = promisify(execFile);\n\nexport default async function defaultBrowserId() {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst {stdout} = await execFileAsync('defaults', ['read', 'com.apple.LaunchServices/com.apple.launchservices.secure', 'LSHandlers']);\n\n\t// `(?!-)` is to prevent matching `LSHandlerRoleAll = \"-\";`.\n\tconst match = /LSHandlerRoleAll = \"(?!-)(?<id>[^\"]+?)\";\\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout);\n\n\treturn match?.groups.id ?? 'com.apple.Safari';\n}\n","import process from 'node:process';\nimport {promisify} from 'node:util';\nimport {execFile, execFileSync} from 'node:child_process';\n\nconst execFileAsync = promisify(execFile);\n\nexport async function runAppleScript(script, {humanReadableOutput = true} = {}) {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst outputArguments = humanReadableOutput ? [] : ['-ss'];\n\n\tconst {stdout} = await execFileAsync('osascript', ['-e', script, outputArguments]);\n\treturn stdout.trim();\n}\n\nexport function runAppleScriptSync(script, {humanReadableOutput = true} = {}) {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst outputArguments = humanReadableOutput ? [] : ['-ss'];\n\n\tconst stdout = execFileSync('osascript', ['-e', script, ...outputArguments], {\n\t\tencoding: 'utf8',\n\t\tstdio: ['ignore', 'pipe', 'ignore'],\n\t\ttimeout: 500,\n\t});\n\n\treturn stdout.trim();\n}\n","import {runAppleScript} from 'run-applescript';\n\nexport default async function bundleName(bundleId) {\n\treturn runAppleScript(`tell application \"Finder\" to set app_path to application file id \"${bundleId}\" as string\\ntell application \"System Events\" to get value of property list item \"CFBundleName\" of property list file (app_path & \":Contents:Info.plist\")`);\n}\n","import {promisify} from 'node:util';\nimport {execFile} from 'node:child_process';\n\nconst execFileAsync = promisify(execFile);\n\n// Windows doesn't have browser IDs in the same way macOS/Linux does so we give fake\n// ones that look real and match the macOS/Linux versions for cross-platform apps.\nconst windowsBrowserProgIds = {\n\tAppXq0fevzme2pys62n3e0fbqa7peapykr8v: {name: 'Edge', id: 'com.microsoft.edge.old'},\n\tMSEdgeDHTML: {name: 'Edge', id: 'com.microsoft.edge'}, // On macOS, it's \"com.microsoft.edgemac\"\n\tMSEdgeHTM: {name: 'Edge', id: 'com.microsoft.edge'}, // Newer Edge/Win10 releases\n\t'IE.HTTP': {name: 'Internet Explorer', id: 'com.microsoft.ie'},\n\tFirefoxURL: {name: 'Firefox', id: 'org.mozilla.firefox'},\n\tChromeHTML: {name: 'Chrome', id: 'com.google.chrome'},\n\tBraveHTML: {name: 'Brave', id: 'com.brave.Browser'},\n\tBraveBHTML: {name: 'Brave Beta', id: 'com.brave.Browser.beta'},\n\tBraveSSHTM: {name: 'Brave Nightly', id: 'com.brave.Browser.nightly'},\n};\n\nexport class UnknownBrowserError extends Error {}\n\nexport default async function defaultBrowser(_execFileAsync = execFileAsync) {\n\tconst {stdout} = await _execFileAsync('reg', [\n\t\t'QUERY',\n\t\t' HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\Shell\\\\Associations\\\\UrlAssociations\\\\http\\\\UserChoice',\n\t\t'/v',\n\t\t'ProgId',\n\t]);\n\n\tconst match = /ProgId\\s*REG_SZ\\s*(?<id>\\S+)/.exec(stdout);\n\tif (!match) {\n\t\tthrow new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);\n\t}\n\n\tconst {id} = match.groups;\n\n\tconst browser = windowsBrowserProgIds[id];\n\tif (!browser) {\n\t\tthrow new UnknownBrowserError(`Unknown browser ID: ${id}`);\n\t}\n\n\treturn browser;\n}\n","import {promisify} from 'node:util';\nimport process from 'node:process';\nimport {execFile} from 'node:child_process';\nimport defaultBrowserId from 'default-browser-id';\nimport bundleName from 'bundle-name';\nimport windows from './windows.js';\n\nconst execFileAsync = promisify(execFile);\n\n// Inlined: https://github.com/sindresorhus/titleize/blob/main/index.js\nconst titleize = string => string.toLowerCase().replaceAll(/(?:^|\\s|-)\\S/g, x => x.toUpperCase());\n\nexport default async function defaultBrowser() {\n\tif (process.platform === 'darwin') {\n\t\tconst id = await defaultBrowserId();\n\t\tconst name = await bundleName(id);\n\t\treturn {name, id};\n\t}\n\n\tif (process.platform === 'linux') {\n\t\tconst {stdout} = await execFileAsync('xdg-mime', ['query', 'default', 'x-scheme-handler/http']);\n\t\tconst id = stdout.trim();\n\t\tconst name = titleize(id.replace(/.desktop$/, '').replace('-', ' '));\n\t\treturn {name, id};\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn windows();\n\t}\n\n\tthrow new Error('Only macOS, Linux, and Windows are supported');\n}\n","import process from 'node:process';\nimport {Buffer} from 'node:buffer';\nimport path from 'node:path';\nimport {fileURLToPath} from 'node:url';\nimport util from 'node:util';\nimport childProcess from 'node:child_process';\nimport fs, {constants as fsConstants} from 'node:fs/promises';\nimport isWsl from 'is-wsl';\nimport defineLazyProperty from 'define-lazy-prop';\nimport defaultBrowser from 'default-browser';\nimport isInsideContainer from 'is-inside-container';\n\nconst execFile = util.promisify(childProcess.execFile);\n\n// Path to included `xdg-open`.\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\nconst localXdgOpenPath = path.join(__dirname, 'xdg-open');\n\nconst {platform, arch} = process;\n\n/**\nGet the mount point for fixed drives in WSL.\n\n@inner\n@returns {string} The mount point.\n*/\nconst getWslDrivesMountPoint = (() => {\n\t// Default value for \"root\" param\n\t// according to https://docs.microsoft.com/en-us/windows/wsl/wsl-config\n\tconst defaultMountPoint = '/mnt/';\n\n\tlet mountPoint;\n\n\treturn async function () {\n\t\tif (mountPoint) {\n\t\t\t// Return memoized mount point value\n\t\t\treturn mountPoint;\n\t\t}\n\n\t\tconst configFilePath = '/etc/wsl.conf';\n\n\t\tlet isConfigFileExists = false;\n\t\ttry {\n\t\t\tawait fs.access(configFilePath, fsConstants.F_OK);\n\t\t\tisConfigFileExists = true;\n\t\t} catch {}\n\n\t\tif (!isConfigFileExists) {\n\t\t\treturn defaultMountPoint;\n\t\t}\n\n\t\tconst configContent = await fs.readFile(configFilePath, {encoding: 'utf8'});\n\t\tconst configMountPoint = /(?<!#.*)root\\s*=\\s*(?<mountPoint>.*)/g.exec(configContent);\n\n\t\tif (!configMountPoint) {\n\t\t\treturn defaultMountPoint;\n\t\t}\n\n\t\tmountPoint = configMountPoint.groups.mountPoint.trim();\n\t\tmountPoint = mountPoint.endsWith('/') ? mountPoint : `${mountPoint}/`;\n\n\t\treturn mountPoint;\n\t};\n})();\n\n/**\nGet the PowerShell executable path in WSL environment.\n\n@returns {Promise<string>} The absolute path to the PowerShell executable in WSL.\n*/\nconst getPowershellPathFromWsl = async () => {\n\tconst mountPoint = await getWslDrivesMountPoint();\n\treturn `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`;\n};\n\n/**\nGet the default browser name in Windows from WSL.\n\n@returns {Promise<string>} Browser name.\n*/\nasync function getWindowsDefaultBrowserFromWsl() {\n\tconst powershellPath = await getPowershellPathFromWsl();\n\tconst rawCommand = '(Get-ItemProperty -Path \"HKCU:\\\\Software\\\\Microsoft\\\\Windows\\\\Shell\\\\Associations\\\\UrlAssociations\\\\http\\\\UserChoice\").ProgId';\n\tconst encodedCommand = Buffer.from(rawCommand, 'utf16le').toString('base64');\n\n\tconst {stdout} = await execFile(\n\t\tpowershellPath,\n\t\t[\n\t\t\t'-NoProfile',\n\t\t\t'-NonInteractive',\n\t\t\t'-ExecutionPolicy',\n\t\t\t'Bypass',\n\t\t\t'-EncodedCommand',\n\t\t\tencodedCommand,\n\t\t],\n\t\t{encoding: 'utf8'},\n\t);\n\n\tconst progId = stdout.trim();\n\n\t// Map ProgId to browser IDs\n\tconst browserMap = {\n\t\tChromeHTML: 'com.google.chrome',\n\t\tMSEdgeHTM: 'com.microsoft.edge',\n\t\tFirefoxURL: 'org.mozilla.firefox',\n\t};\n\n\treturn browserMap[progId] ? {id: browserMap[progId]} : {};\n}\n\nconst pTryEach = async (array, mapper) => {\n\tlet latestError;\n\n\tfor (const item of array) {\n\t\ttry {\n\t\t\treturn await mapper(item); // eslint-disable-line no-await-in-loop\n\t\t} catch (error) {\n\t\t\tlatestError = error;\n\t\t}\n\t}\n\n\tthrow latestError;\n};\n\nconst baseOpen = async options => {\n\toptions = {\n\t\twait: false,\n\t\tbackground: false,\n\t\tnewInstance: false,\n\t\tallowNonzeroExitCode: false,\n\t\t...options,\n\t};\n\n\tif (Array.isArray(options.app)) {\n\t\treturn pTryEach(options.app, singleApp => baseOpen({\n\t\t\t...options,\n\t\t\tapp: singleApp,\n\t\t}));\n\t}\n\n\tlet {name: app, arguments: appArguments = []} = options.app ?? {};\n\tappArguments = [...appArguments];\n\n\tif (Array.isArray(app)) {\n\t\treturn pTryEach(app, appName => baseOpen({\n\t\t\t...options,\n\t\t\tapp: {\n\t\t\t\tname: appName,\n\t\t\t\targuments: appArguments,\n\t\t\t},\n\t\t}));\n\t}\n\n\tif (app === 'browser' || app === 'browserPrivate') {\n\t\t// IDs from default-browser for macOS and windows are the same\n\t\tconst ids = {\n\t\t\t'com.google.chrome': 'chrome',\n\t\t\t'google-chrome.desktop': 'chrome',\n\t\t\t'org.mozilla.firefox': 'firefox',\n\t\t\t'firefox.desktop': 'firefox',\n\t\t\t'com.microsoft.msedge': 'edge',\n\t\t\t'com.microsoft.edge': 'edge',\n\t\t\t'com.microsoft.edgemac': 'edge',\n\t\t\t'microsoft-edge.desktop': 'edge',\n\t\t};\n\n\t\t// Incognito flags for each browser in `apps`.\n\t\tconst flags = {\n\t\t\tchrome: '--incognito',\n\t\t\tfirefox: '--private-window',\n\t\t\tedge: '--inPrivate',\n\t\t};\n\n\t\tconst browser = isWsl ? await getWindowsDefaultBrowserFromWsl() : await defaultBrowser();\n\t\tif (browser.id in ids) {\n\t\t\tconst browserName = ids[browser.id];\n\n\t\t\tif (app === 'browserPrivate') {\n\t\t\t\tappArguments.push(flags[browserName]);\n\t\t\t}\n\n\t\t\treturn baseOpen({\n\t\t\t\t...options,\n\t\t\t\tapp: {\n\t\t\t\t\tname: apps[browserName],\n\t\t\t\t\targuments: appArguments,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tthrow new Error(`${browser.name} is not supported as a default browser`);\n\t}\n\n\tlet command;\n\tconst cliArguments = [];\n\tconst childProcessOptions = {};\n\n\tif (platform === 'darwin') {\n\t\tcommand = 'open';\n\n\t\tif (options.wait) {\n\t\t\tcliArguments.push('--wait-apps');\n\t\t}\n\n\t\tif (options.background) {\n\t\t\tcliArguments.push('--background');\n\t\t}\n\n\t\tif (options.newInstance) {\n\t\t\tcliArguments.push('--new');\n\t\t}\n\n\t\tif (app) {\n\t\t\tcliArguments.push('-a', app);\n\t\t}\n\t} else if (platform === 'win32' || (isWsl && !isInsideContainer() && !app)) {\n\t\tcommand = isWsl\n\t\t\t? await getPowershellPathFromWsl()\n\t\t\t: `${process.env.SYSTEMROOT || process.env.windir || 'C:\\\\Windows'}\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell`;\n\n\t\tcliArguments.push(\n\t\t\t'-NoProfile',\n\t\t\t'-NonInteractive',\n\t\t\t'-ExecutionPolicy',\n\t\t\t'Bypass',\n\t\t\t'-EncodedCommand',\n\t\t);\n\n\t\tif (!isWsl) {\n\t\t\tchildProcessOptions.windowsVerbatimArguments = true;\n\t\t}\n\n\t\tconst encodedArguments = ['Start'];\n\n\t\tif (options.wait) {\n\t\t\tencodedArguments.push('-Wait');\n\t\t}\n\n\t\tif (app) {\n\t\t\t// Double quote with double quotes to ensure the inner quotes are passed through.\n\t\t\t// Inner quotes are delimited for PowerShell interpretation with backticks.\n\t\t\tencodedArguments.push(`\"\\`\"${app}\\`\"\"`);\n\t\t\tif (options.target) {\n\t\t\t\tappArguments.push(options.target);\n\t\t\t}\n\t\t} else if (options.target) {\n\t\t\tencodedArguments.push(`\"${options.target}\"`);\n\t\t}\n\n\t\tif (appArguments.length > 0) {\n\t\t\tappArguments = appArguments.map(argument => `\"\\`\"${argument}\\`\"\"`);\n\t\t\tencodedArguments.push('-ArgumentList', appArguments.join(','));\n\t\t}\n\n\t\t// Using Base64-encoded command, accepted by PowerShell, to allow special characters.\n\t\toptions.target = Buffer.from(encodedArguments.join(' '), 'utf16le').toString('base64');\n\t} else {\n\t\tif (app) {\n\t\t\tcommand = app;\n\t\t} else {\n\t\t\t// When bundled by Webpack, there's no actual package file path and no local `xdg-open`.\n\t\t\tconst isBundled = !__dirname || __dirname === '/';\n\n\t\t\t// Check if local `xdg-open` exists and is executable.\n\t\t\tlet exeLocalXdgOpen = false;\n\t\t\ttry {\n\t\t\t\tawait fs.access(localXdgOpenPath, fsConstants.X_OK);\n\t\t\t\texeLocalXdgOpen = true;\n\t\t\t} catch {}\n\n\t\t\tconst useSystemXdgOpen = process.versions.electron\n\t\t\t\t?? (platform === 'android' || isBundled || !exeLocalXdgOpen);\n\t\t\tcommand = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;\n\t\t}\n\n\t\tif (appArguments.length > 0) {\n\t\t\tcliArguments.push(...appArguments);\n\t\t}\n\n\t\tif (!options.wait) {\n\t\t\t// `xdg-open` will block the process unless stdio is ignored\n\t\t\t// and it's detached from the parent even if it's unref'd.\n\t\t\tchildProcessOptions.stdio = 'ignore';\n\t\t\tchildProcessOptions.detached = true;\n\t\t}\n\t}\n\n\tif (platform === 'darwin' && appArguments.length > 0) {\n\t\tcliArguments.push('--args', ...appArguments);\n\t}\n\n\t// This has to come after `--args`.\n\tif (options.target) {\n\t\tcliArguments.push(options.target);\n\t}\n\n\tconst subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);\n\n\tif (options.wait) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tsubprocess.once('error', reject);\n\n\t\t\tsubprocess.once('close', exitCode => {\n\t\t\t\tif (!options.allowNonzeroExitCode && exitCode > 0) {\n\t\t\t\t\treject(new Error(`Exited with code ${exitCode}`));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresolve(subprocess);\n\t\t\t});\n\t\t});\n\t}\n\n\tsubprocess.unref();\n\n\treturn subprocess;\n};\n\nconst open = (target, options) => {\n\tif (typeof target !== 'string') {\n\t\tthrow new TypeError('Expected a `target`');\n\t}\n\n\treturn baseOpen({\n\t\t...options,\n\t\ttarget,\n\t});\n};\n\nexport const openApp = (name, options) => {\n\tif (typeof name !== 'string' && !Array.isArray(name)) {\n\t\tthrow new TypeError('Expected a valid `name`');\n\t}\n\n\tconst {arguments: appArguments = []} = options ?? {};\n\tif (appArguments !== undefined && appArguments !== null && !Array.isArray(appArguments)) {\n\t\tthrow new TypeError('Expected `appArguments` as Array type');\n\t}\n\n\treturn baseOpen({\n\t\t...options,\n\t\tapp: {\n\t\t\tname,\n\t\t\targuments: appArguments,\n\t\t},\n\t});\n};\n\nfunction detectArchBinary(binary) {\n\tif (typeof binary === 'string' || Array.isArray(binary)) {\n\t\treturn binary;\n\t}\n\n\tconst {[arch]: archBinary} = binary;\n\n\tif (!archBinary) {\n\t\tthrow new Error(`${arch} is not supported`);\n\t}\n\n\treturn archBinary;\n}\n\nfunction detectPlatformBinary({[platform]: platformBinary}, {wsl}) {\n\tif (wsl && isWsl) {\n\t\treturn detectArchBinary(wsl);\n\t}\n\n\tif (!platformBinary) {\n\t\tthrow new Error(`${platform} is not supported`);\n\t}\n\n\treturn detectArchBinary(platformBinary);\n}\n\nexport const apps = {};\n\ndefineLazyProperty(apps, 'chrome', () => detectPlatformBinary({\n\tdarwin: 'google chrome',\n\twin32: 'chrome',\n\tlinux: ['google-chrome', 'google-chrome-stable', 'chromium'],\n}, {\n\twsl: {\n\t\tia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',\n\t\tx64: ['/mnt/c/Program Files/Google/Chrome/Application/chrome.exe', '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe'],\n\t},\n}));\n\ndefineLazyProperty(apps, 'firefox', () => detectPlatformBinary({\n\tdarwin: 'firefox',\n\twin32: 'C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe',\n\tlinux: 'firefox',\n}, {\n\twsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe',\n}));\n\ndefineLazyProperty(apps, 'edge', () => detectPlatformBinary({\n\tdarwin: 'microsoft edge',\n\twin32: 'msedge',\n\tlinux: ['microsoft-edge', 'microsoft-edge-dev'],\n}, {\n\twsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe',\n}));\n\ndefineLazyProperty(apps, 'browser', () => 'browser');\n\ndefineLazyProperty(apps, 'browserPrivate', () => 'browserPrivate');\n\nexport default open;\n","'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n","'use strict'\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n","/* MIT license */\nvar cssKeywords = require('color-name');\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n\tif (cssKeywords.hasOwnProperty(key)) {\n\t\treverseKeywords[cssKeywords[key]] = key;\n\t}\n}\n\nvar convert = module.exports = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\n// hide .channels and .labels properties\nfor (var model in convert) {\n\tif (convert.hasOwnProperty(model)) {\n\t\tif (!('channels' in convert[model])) {\n\t\t\tthrow new Error('missing channels property: ' + model);\n\t\t}\n\n\t\tif (!('labels' in convert[model])) {\n\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t}\n\n\t\tif (convert[model].labels.length !== convert[model].channels) {\n\t\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t\t}\n\n\t\tvar channels = convert[model].channels;\n\t\tvar labels = convert[model].labels;\n\t\tdelete convert[model].channels;\n\t\tdelete convert[model].labels;\n\t\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\t\tObject.defineProperty(convert[model], 'labels', {value: labels});\n\t}\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar min = Math.min(r, g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar s;\n\tvar l;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tvar rdif;\n\tvar gdif;\n\tvar bdif;\n\tvar h;\n\tvar s;\n\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar v = Math.max(r, g, b);\n\tvar diff = v - Math.min(r, g, b);\n\tvar diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = s = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tvar r = rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar h = convert.rgb.hsl(rgb)[0];\n\tvar w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar c;\n\tvar m;\n\tvar y;\n\tvar k;\n\n\tk = Math.min(1 - r, 1 - g, 1 - b);\n\tc = (1 - r - k) / (1 - k) || 0;\n\tm = (1 - g - k) / (1 - k) || 0;\n\ty = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\n/**\n * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n * */\nfunction comparativeDistance(x, y) {\n\treturn (\n\t\tMath.pow(x[0] - y[0], 2) +\n\t\tMath.pow(x[1] - y[1], 2) +\n\t\tMath.pow(x[2] - y[2], 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tvar reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tvar currentClosestDistance = Infinity;\n\tvar currentClosestKeyword;\n\n\tfor (var keyword in cssKeywords) {\n\t\tif (cssKeywords.hasOwnProperty(keyword)) {\n\t\t\tvar value = cssKeywords[keyword];\n\n\t\t\t// Compute comparative distance\n\t\t\tvar distance = comparativeDistance(rgb, value);\n\n\t\t\t// Check if its less, if so set as closest\n\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\tcurrentClosestDistance = distance;\n\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\n\t// assume sRGB\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tvar y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tvar z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tvar xyz = convert.rgb.xyz(rgb);\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tvar h = hsl[0] / 360;\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar rgb;\n\tvar val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tt1 = 2 * l - t2;\n\n\trgb = [0, 0, 0];\n\tfor (var i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tvar h = hsl[0];\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar smin = s;\n\tvar lmin = Math.max(l, 0.01);\n\tvar sv;\n\tvar v;\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tv = (l + s) / 2;\n\tsv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tvar h = hsv[0] / 60;\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar hi = Math.floor(h) % 6;\n\n\tvar f = h - Math.floor(h);\n\tvar p = 255 * v * (1 - s);\n\tvar q = 255 * v * (1 - (s * f));\n\tvar t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tvar h = hsv[0];\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar vmin = Math.max(v, 0.01);\n\tvar lmin;\n\tvar sl;\n\tvar l;\n\n\tl = (2 - s) * v;\n\tlmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tvar h = hwb[0] / 360;\n\tvar wh = hwb[1] / 100;\n\tvar bl = hwb[2] / 100;\n\tvar ratio = wh + bl;\n\tvar i;\n\tvar v;\n\tvar f;\n\tvar n;\n\n\t// wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\ti = Math.floor(6 * h);\n\tv = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tn = wh + f * (v - wh); // linear interpolation\n\n\tvar r;\n\tvar g;\n\tvar b;\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v; g = n; b = wh; break;\n\t\tcase 1: r = n; g = v; b = wh; break;\n\t\tcase 2: r = wh; g = v; b = n; break;\n\t\tcase 3: r = wh; g = n; b = v; break;\n\t\tcase 4: r = n; g = wh; b = v; break;\n\t\tcase 5: r = v; g = wh; b = n; break;\n\t}\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tvar c = cmyk[0] / 100;\n\tvar m = cmyk[1] / 100;\n\tvar y = cmyk[2] / 100;\n\tvar k = cmyk[3] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = 1 - Math.min(1, c * (1 - k) + k);\n\tg = 1 - Math.min(1, m * (1 - k) + k);\n\tb = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tvar x = xyz[0] / 100;\n\tvar y = xyz[1] / 100;\n\tvar z = xyz[2] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar x;\n\tvar y;\n\tvar z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tvar y2 = Math.pow(y, 3);\n\tvar x2 = Math.pow(x, 3);\n\tvar z2 = Math.pow(z, 3);\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar hr;\n\tvar h;\n\tvar c;\n\n\thr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tc = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tvar l = lch[0];\n\tvar c = lch[1];\n\tvar h = lch[2];\n\tvar a;\n\tvar b;\n\tvar hr;\n\n\thr = h / 360 * 2 * Math.PI;\n\ta = c * Math.cos(hr);\n\tb = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tvar value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tvar ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\n\t// we use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tvar ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tvar color = args % 10;\n\n\t// handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tvar mult = (~~(args > 50) + 1) * 0.5;\n\tvar r = ((color & 1) * mult) * 255;\n\tvar g = (((color >> 1) & 1) * mult) * 255;\n\tvar b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// handle greyscale\n\tif (args >= 232) {\n\t\tvar c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tvar rem;\n\tvar r = Math.floor(args / 36) / 5 * 255;\n\tvar g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tvar b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tvar integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tvar match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tvar colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(function (char) {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tvar integer = parseInt(colorString, 16);\n\tvar r = (integer >> 16) & 0xFF;\n\tvar g = (integer >> 8) & 0xFF;\n\tvar b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar max = Math.max(Math.max(r, g), b);\n\tvar min = Math.min(Math.min(r, g), b);\n\tvar chroma = (max - min);\n\tvar grayscale;\n\tvar hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma + 4;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar c = 1;\n\tvar f = 0;\n\n\tif (l < 0.5) {\n\t\tc = 2.0 * s * l;\n\t} else {\n\t\tc = 2.0 * s * (1.0 - l);\n\t}\n\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\n\tvar c = s * v;\n\tvar f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tvar h = hcg[0] / 360;\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tvar pure = [0, 0, 0];\n\tvar hi = (h % 1) * 6;\n\tvar v = hi % 1;\n\tvar w = 1 - v;\n\tvar mg = 0;\n\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar v = c + g * (1.0 - c);\n\tvar f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar l = g * (1.0 - c) + 0.5 * c;\n\tvar s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tvar w = hwb[1] / 100;\n\tvar b = hwb[2] / 100;\n\tvar v = 1 - b;\n\tvar c = v - w;\n\tvar g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = convert.gray.hsv = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tvar val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tvar integer = (val << 16) + (val << 8) + val;\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tvar val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n","var conversions = require('./conversions');\n\n/*\n\tthis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tvar graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tvar models = Object.keys(conversions);\n\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; // unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tvar current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions[current]);\n\n\t\tfor (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tvar path = [graph[toModel].parent, toModel];\n\tvar fn = conversions[graph[toModel].parent][toModel];\n\n\tvar cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tvar graph = deriveBFS(fromModel);\n\tvar conversion = {};\n\n\tvar models = Object.keys(graph);\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// no possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n","var conversions = require('./conversions');\nvar route = require('./route');\n\nvar convert = {};\n\nvar models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\tvar result = fn(args);\n\n\t\t// we're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (var len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(function (fromModel) {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tvar routes = route(fromModel);\n\tvar routeModels = Object.keys(routes);\n\n\trouteModels.forEach(function (toModel) {\n\t\tvar fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n","'use strict';\nconst colorConvert = require('color-convert');\n\nconst wrapAnsi16 = (fn, offset) => function () {\n\tconst code = fn.apply(colorConvert, arguments);\n\treturn `\\u001B[${code + offset}m`;\n};\n\nconst wrapAnsi256 = (fn, offset) => function () {\n\tconst code = fn.apply(colorConvert, arguments);\n\treturn `\\u001B[${38 + offset};5;${code}m`;\n};\n\nconst wrapAnsi16m = (fn, offset) => function () {\n\tconst rgb = fn.apply(colorConvert, arguments);\n\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n};\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\t\t\tgray: [90, 39],\n\n\t\t\t// Bright color\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Fix humans\n\tstyles.color.grey = styles.color.gray;\n\n\tfor (const groupName of Object.keys(styles)) {\n\t\tconst group = styles[groupName];\n\n\t\tfor (const styleName of Object.keys(group)) {\n\t\t\tconst style = group[styleName];\n\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\n\t\tObject.defineProperty(styles, 'codes', {\n\t\t\tvalue: codes,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tconst ansi2ansi = n => n;\n\tconst rgb2rgb = (r, g, b) => [r, g, b];\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tstyles.color.ansi = {\n\t\tansi: wrapAnsi16(ansi2ansi, 0)\n\t};\n\tstyles.color.ansi256 = {\n\t\tansi256: wrapAnsi256(ansi2ansi, 0)\n\t};\n\tstyles.color.ansi16m = {\n\t\trgb: wrapAnsi16m(rgb2rgb, 0)\n\t};\n\n\tstyles.bgColor.ansi = {\n\t\tansi: wrapAnsi16(ansi2ansi, 10)\n\t};\n\tstyles.bgColor.ansi256 = {\n\t\tansi256: wrapAnsi256(ansi2ansi, 10)\n\t};\n\tstyles.bgColor.ansi16m = {\n\t\trgb: wrapAnsi16m(rgb2rgb, 10)\n\t};\n\n\tfor (let key of Object.keys(colorConvert)) {\n\t\tif (typeof colorConvert[key] !== 'object') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst suite = colorConvert[key];\n\n\t\tif (key === 'ansi16') {\n\t\t\tkey = 'ansi';\n\t\t}\n\n\t\tif ('ansi16' in suite) {\n\t\t\tstyles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);\n\t\t\tstyles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);\n\t\t}\n\n\t\tif ('ansi256' in suite) {\n\t\t\tstyles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);\n\t\t\tstyles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);\n\t\t}\n\n\t\tif ('rgb' in suite) {\n\t\t\tstyles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);\n\t\t\tstyles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);\n\t\t}\n\t}\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n","'use strict';\nmodule.exports = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n","'use strict';\nconst os = require('os');\nconst hasFlag = require('has-flag');\n\nconst env = process.env;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false')) {\n\tforceColor = false;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n\tforceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(stream) {\n\tif (forceColor === false) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (stream && !stream.isTTY && forceColor !== true) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor ? 1 : 0;\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors. Windows 10 build 14931 is the first release\n\t\t// that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel(process.stdout),\n\tstderr: getSupportLevel(process.stderr)\n};\n","'use strict';\nconst TEMPLATE_REGEX = /(?:\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX = /\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n\nconst ESCAPES = new Map([\n\t['n', '\\n'],\n\t['r', '\\r'],\n\t['t', '\\t'],\n\t['b', '\\b'],\n\t['f', '\\f'],\n\t['v', '\\v'],\n\t['0', '\\0'],\n\t['\\\\', '\\\\'],\n\t['e', '\\u001B'],\n\t['a', '\\u0007']\n]);\n\nfunction unescape(c) {\n\tif ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {\n\t\treturn String.fromCharCode(parseInt(c.slice(1), 16));\n\t}\n\n\treturn ESCAPES.get(c) || c;\n}\n\nfunction parseArguments(name, args) {\n\tconst results = [];\n\tconst chunks = args.trim().split(/\\s*,\\s*/g);\n\tlet matches;\n\n\tfor (const chunk of chunks) {\n\t\tif (!isNaN(chunk)) {\n\t\t\tresults.push(Number(chunk));\n\t\t} else if ((matches = chunk.match(STRING_REGEX))) {\n\t\t\tresults.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));\n\t\t} else {\n\t\t\tthrow new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction parseStyle(style) {\n\tSTYLE_REGEX.lastIndex = 0;\n\n\tconst results = [];\n\tlet matches;\n\n\twhile ((matches = STYLE_REGEX.exec(style)) !== null) {\n\t\tconst name = matches[1];\n\n\t\tif (matches[2]) {\n\t\t\tconst args = parseArguments(name, matches[2]);\n\t\t\tresults.push([name].concat(args));\n\t\t} else {\n\t\t\tresults.push([name]);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction buildStyle(chalk, styles) {\n\tconst enabled = {};\n\n\tfor (const layer of styles) {\n\t\tfor (const style of layer.styles) {\n\t\t\tenabled[style[0]] = layer.inverse ? null : style.slice(1);\n\t\t}\n\t}\n\n\tlet current = chalk;\n\tfor (const styleName of Object.keys(enabled)) {\n\t\tif (Array.isArray(enabled[styleName])) {\n\t\t\tif (!(styleName in current)) {\n\t\t\t\tthrow new Error(`Unknown Chalk style: ${styleName}`);\n\t\t\t}\n\n\t\t\tif (enabled[styleName].length > 0) {\n\t\t\t\tcurrent = current[styleName].apply(current, enabled[styleName]);\n\t\t\t} else {\n\t\t\t\tcurrent = current[styleName];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn current;\n}\n\nmodule.exports = (chalk, tmp) => {\n\tconst styles = [];\n\tconst chunks = [];\n\tlet chunk = [];\n\n\t// eslint-disable-next-line max-params\n\ttmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {\n\t\tif (escapeChar) {\n\t\t\tchunk.push(unescape(escapeChar));\n\t\t} else if (style) {\n\t\t\tconst str = chunk.join('');\n\t\t\tchunk = [];\n\t\t\tchunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));\n\t\t\tstyles.push({inverse, styles: parseStyle(style)});\n\t\t} else if (close) {\n\t\t\tif (styles.length === 0) {\n\t\t\t\tthrow new Error('Found extraneous } in Chalk template literal');\n\t\t\t}\n\n\t\t\tchunks.push(buildStyle(chalk, styles)(chunk.join('')));\n\t\t\tchunk = [];\n\t\t\tstyles.pop();\n\t\t} else {\n\t\t\tchunk.push(chr);\n\t\t}\n\t});\n\n\tchunks.push(chunk.join(''));\n\n\tif (styles.length > 0) {\n\t\tconst errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\\`}\\`)`;\n\t\tthrow new Error(errMsg);\n\t}\n\n\treturn chunks.join('');\n};\n","'use strict';\nconst escapeStringRegexp = require('escape-string-regexp');\nconst ansiStyles = require('ansi-styles');\nconst stdoutColor = require('supports-color').stdout;\n\nconst template = require('./templates.js');\n\nconst isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');\n\n// `supportsColor.level` → `ansiStyles.color[name]` mapping\nconst levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];\n\n// `color-convert` models to exclude from the Chalk API due to conflicts and such\nconst skipModels = new Set(['gray']);\n\nconst styles = Object.create(null);\n\nfunction applyOptions(obj, options) {\n\toptions = options || {};\n\n\t// Detect level if not set manually\n\tconst scLevel = stdoutColor ? stdoutColor.level : 0;\n\tobj.level = options.level === undefined ? scLevel : options.level;\n\tobj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;\n}\n\nfunction Chalk(options) {\n\t// We check for this.template here since calling `chalk.constructor()`\n\t// by itself will have a `this` of a previously constructed chalk object\n\tif (!this || !(this instanceof Chalk) || this.template) {\n\t\tconst chalk = {};\n\t\tapplyOptions(chalk, options);\n\n\t\tchalk.template = function () {\n\t\t\tconst args = [].slice.call(arguments);\n\t\t\treturn chalkTag.apply(null, [chalk.template].concat(args));\n\t\t};\n\n\t\tObject.setPrototypeOf(chalk, Chalk.prototype);\n\t\tObject.setPrototypeOf(chalk.template, chalk);\n\n\t\tchalk.template.constructor = Chalk;\n\n\t\treturn chalk.template;\n\t}\n\n\tapplyOptions(this, options);\n}\n\n// Use bright blue on Windows as the normal blue color is illegible\nif (isSimpleWindowsTerm) {\n\tansiStyles.blue.open = '\\u001B[94m';\n}\n\nfor (const key of Object.keys(ansiStyles)) {\n\tansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n\n\tstyles[key] = {\n\t\tget() {\n\t\t\tconst codes = ansiStyles[key];\n\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);\n\t\t}\n\t};\n}\n\nstyles.visible = {\n\tget() {\n\t\treturn build.call(this, this._styles || [], true, 'visible');\n\t}\n};\n\nansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');\nfor (const model of Object.keys(ansiStyles.color.ansi)) {\n\tif (skipModels.has(model)) {\n\t\tcontinue;\n\t}\n\n\tstyles[model] = {\n\t\tget() {\n\t\t\tconst level = this.level;\n\t\t\treturn function () {\n\t\t\t\tconst open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);\n\t\t\t\tconst codes = {\n\t\t\t\t\topen,\n\t\t\t\t\tclose: ansiStyles.color.close,\n\t\t\t\t\tcloseRe: ansiStyles.color.closeRe\n\t\t\t\t};\n\t\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n\t\t\t};\n\t\t}\n\t};\n}\n\nansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');\nfor (const model of Object.keys(ansiStyles.bgColor.ansi)) {\n\tif (skipModels.has(model)) {\n\t\tcontinue;\n\t}\n\n\tconst bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n\tstyles[bgModel] = {\n\t\tget() {\n\t\t\tconst level = this.level;\n\t\t\treturn function () {\n\t\t\t\tconst open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);\n\t\t\t\tconst codes = {\n\t\t\t\t\topen,\n\t\t\t\t\tclose: ansiStyles.bgColor.close,\n\t\t\t\t\tcloseRe: ansiStyles.bgColor.closeRe\n\t\t\t\t};\n\t\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n\t\t\t};\n\t\t}\n\t};\n}\n\nconst proto = Object.defineProperties(() => {}, styles);\n\nfunction build(_styles, _empty, key) {\n\tconst builder = function () {\n\t\treturn applyStyle.apply(builder, arguments);\n\t};\n\n\tbuilder._styles = _styles;\n\tbuilder._empty = _empty;\n\n\tconst self = this;\n\n\tObject.defineProperty(builder, 'level', {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn self.level;\n\t\t},\n\t\tset(level) {\n\t\t\tself.level = level;\n\t\t}\n\t});\n\n\tObject.defineProperty(builder, 'enabled', {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn self.enabled;\n\t\t},\n\t\tset(enabled) {\n\t\t\tself.enabled = enabled;\n\t\t}\n\t});\n\n\t// See below for fix regarding invisible grey/dim combination on Windows\n\tbuilder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';\n\n\t// `__proto__` is used because we must return a function, but there is\n\t// no way to create a function with a different prototype\n\tbuilder.__proto__ = proto; // eslint-disable-line no-proto\n\n\treturn builder;\n}\n\nfunction applyStyle() {\n\t// Support varags, but simply cast to string in case there's only one arg\n\tconst args = arguments;\n\tconst argsLen = args.length;\n\tlet str = String(arguments[0]);\n\n\tif (argsLen === 0) {\n\t\treturn '';\n\t}\n\n\tif (argsLen > 1) {\n\t\t// Don't slice `arguments`, it prevents V8 optimizations\n\t\tfor (let a = 1; a < argsLen; a++) {\n\t\t\tstr += ' ' + args[a];\n\t\t}\n\t}\n\n\tif (!this.enabled || this.level <= 0 || !str) {\n\t\treturn this._empty ? '' : str;\n\t}\n\n\t// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,\n\t// see https://github.com/chalk/chalk/issues/58\n\t// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.\n\tconst originalDim = ansiStyles.dim.open;\n\tif (isSimpleWindowsTerm && this.hasGrey) {\n\t\tansiStyles.dim.open = '';\n\t}\n\n\tfor (const code of this._styles.slice().reverse()) {\n\t\t// Replace any instances already present with a re-opening code\n\t\t// otherwise only the part of the string until said closing code\n\t\t// will be colored, and the rest will simply be 'plain'.\n\t\tstr = code.open + str.replace(code.closeRe, code.open) + code.close;\n\n\t\t// Close the styling before a linebreak and reopen\n\t\t// after next line to fix a bleed issue on macOS\n\t\t// https://github.com/chalk/chalk/pull/92\n\t\tstr = str.replace(/\\r?\\n/g, `${code.close}$&${code.open}`);\n\t}\n\n\t// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue\n\tansiStyles.dim.open = originalDim;\n\n\treturn str;\n}\n\nfunction chalkTag(chalk, strings) {\n\tif (!Array.isArray(strings)) {\n\t\t// If chalk() was called by itself or with a string,\n\t\t// return the string itself as a string.\n\t\treturn [].slice.call(arguments, 1).join(' ');\n\t}\n\n\tconst args = [].slice.call(arguments, 2);\n\tconst parts = [strings.raw[0]];\n\n\tfor (let i = 1; i < strings.length; i++) {\n\t\tparts.push(String(args[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'));\n\t\tparts.push(String(strings.raw[i]));\n\t}\n\n\treturn template(chalk, parts.join(''));\n}\n\nObject.defineProperties(Chalk.prototype, styles);\n\nmodule.exports = Chalk(); // eslint-disable-line new-cap\nmodule.exports.supportsColor = stdoutColor;\nmodule.exports.default = module.exports; // For TypeScript\n","'use strict';\n\nmodule.exports = options => {\n\toptions = Object.assign({\n\t\tonlyFirst: false\n\t}, options);\n\n\tconst pattern = [\n\t\t'[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, options.onlyFirst ? undefined : 'g');\n};\n","'use strict';\nconst ansiRegex = require('ansi-regex');\n\nconst stripAnsi = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;\n\nmodule.exports = stripAnsi;\nmodule.exports.default = stripAnsi;\n","const chalk = require(\"chalk\");\nconst stripAnsi = require(\"strip-ansi\");\n\nmodule.exports = (options, data) => {\n  const pad = (text, length) => {\n    if (typeof text === \"undefined\") {\n      text = \"\";\n    }\n\n    return (\n      \"\" +\n      text +\n      new Array(Math.max(length - stripAnsi(\"\" + text).length + 1, 0)).join(\" \")\n    );\n  };\n\n  if (typeof options === \"object\" && Array.isArray(options)) {\n    const tmp = data;\n    data = options;\n    options = tmp;\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (!options.intersectionCharacter) {\n    options.intersectionCharacter = \"+\";\n  }\n\n  let columns;\n  if (options.columns) {\n    columns = options.columns;\n  } else {\n    columns = [];\n    data.forEach(e =>\n      Object.keys(e)\n        .filter(k => {\n          return columns.indexOf(k) === -1;\n        })\n        .forEach(k => {\n          columns.push(k);\n        })\n    );\n  }\n\n  columns = columns.map(e => {\n    if (typeof e === \"string\") {\n      e = {\n        name: e,\n        field: e\n      };\n    }\n\n    e.name = chalk.bold(e.name);\n    e.width = stripAnsi(e.name).length;\n\n    return e;\n  });\n\n  data.forEach(e =>\n    columns.forEach(column => {\n      if (typeof e[column.field] === \"undefined\") {\n        return;\n      }\n\n      column.width = Math.max(\n        column.width,\n        (\"\" + stripAnsi(e[column.field])).length\n      );\n    })\n  );\n\n  let output = [];\n\n  const separator = [\"\"]\n    .concat(columns.map(e => new Array(e.width + 1).join(\"-\")))\n    .concat([\"\"])\n    .join(\"-\" + options.intersectionCharacter + \"-\");\n\n  output.push(separator);\n  output.push(\n    [\"\"]\n      .concat(columns.map(e => pad(e.name, e.width)))\n      .concat([\"\"])\n      .join(\" | \")\n  );\n  output.push(separator);\n  data.forEach(row => {\n    output.push(\n      [\"\"]\n        .concat(columns.map(column => pad(row[column.field], column.width)))\n        .concat([\"\"])\n        .join(\" | \")\n    );\n  });\n  output.push(separator);\n\n  const leftPad = \" \".repeat(options.leftPad) || \"\";\n\n  return (\n    leftPad +\n    output.map(e => e.replace(/^[ -]/, \"\").replace(/[ -]$/, \"\")).join(\"\\n\" + leftPad)\n  );\n};\n","'use strict'\n\nfunction formatPurlErrorMessage(message = '') {\n  const { length } = message\n  let formatted = ''\n  if (length) {\n    // Lower case start of message.\n    const code0 = message.charCodeAt(0)\n    formatted =\n      code0 >= 65 /*'A'*/ || code0 <= 90 /*'Z'*/\n        ? `${message[0].toLowerCase()}${message.slice(1)}`\n        : message\n    // Remove period from end of message.\n    if (\n      length > 1 &&\n      message.charCodeAt(length - 1) === 46 /*'.'*/ &&\n      message.charCodeAt(length - 2) !== 46\n    ) {\n      formatted = formatted.slice(0, -1)\n    }\n  }\n  return `Invalid purl: ${formatted}`\n}\n\nclass PurlError extends Error {\n  constructor(message) {\n    super(formatPurlErrorMessage(message))\n  }\n}\n\nmodule.exports = {\n  formatPurlErrorMessage,\n  PurlError\n}\n","'use strict'\n\nconst { PurlError } = require('./error')\n\nconst { decodeURIComponent: decodeComponent } = globalThis\n\nfunction decodePurlComponent(comp, encodedComponent) {\n  try {\n    return decodeComponent(encodedComponent)\n  } catch {}\n  throw new PurlError(`unable to decode \"${comp}\" component`)\n}\n\nmodule.exports = {\n  decodePurlComponent\n}\n","'use strict'\n\nconst LOOP_SENTINEL = 1_000_000\n\nconst REUSED_SEARCH_PARAMS = new URLSearchParams()\n\nconst REUSED_SEARCH_PARAMS_KEY = '_'\n\nconst REUSED_SEARCH_PARAMS_OFFSET = 2 // '_='.length\n\nmodule.exports = {\n  LOOP_SENTINEL,\n  REUSED_SEARCH_PARAMS,\n  REUSED_SEARCH_PARAMS_KEY,\n  REUSED_SEARCH_PARAMS_OFFSET\n}\n","'use strict'\n\nconst { LOOP_SENTINEL } = require('./constants')\n\nfunction isObject(value) {\n  return value !== null && typeof value === 'object'\n}\n\nfunction recursiveFreeze(value_) {\n  if (\n    value_ === null ||\n    !(typeof value_ === 'object' || typeof value_ === 'function') ||\n    Object.isFrozen(value_)\n  ) {\n    return value_\n  }\n  const queue = [value_]\n  let { length: queueLength } = queue\n  let pos = 0\n  while (pos < queueLength) {\n    if (pos === LOOP_SENTINEL) {\n      throw new Error(\n        'Detected infinite loop in object crawl of recursiveFreeze'\n      )\n    }\n    const obj = queue[pos++]\n    Object.freeze(obj)\n    if (Array.isArray(obj)) {\n      for (let i = 0, { length } = obj; i < length; i += 1) {\n        const item = obj[i]\n        if (\n          item !== null &&\n          (typeof item === 'object' || typeof item === 'function') &&\n          !Object.isFrozen(item)\n        ) {\n          queue[queueLength++] = item\n        }\n      }\n    } else {\n      const keys = Reflect.ownKeys(obj)\n      for (let i = 0, { length } = keys; i < length; i += 1) {\n        const propValue = obj[keys[i]]\n        if (\n          propValue !== null &&\n          (typeof propValue === 'object' || typeof propValue === 'function') &&\n          !Object.isFrozen(propValue)\n        ) {\n          queue[queueLength++] = propValue\n        }\n      }\n    }\n  }\n  return value_\n}\n\nmodule.exports = {\n  isObject,\n  recursiveFreeze\n}\n","'use strict'\n\n// Intl.Collator is faster than String#localeCompare\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare:\n// > When comparing large numbers of strings, such as in sorting large arrays,\n// > it is better to create an Intl.Collator object and use the function provided\n// > by its compare() method.\nlet _localeCompare\nfunction localeCompare(x, y) {\n  if (_localeCompare === undefined) {\n    // Lazily call new Intl.Collator() because in Node it can take 10-14ms.\n    _localeCompare = new Intl.Collator().compare\n  }\n  return _localeCompare(x, y)\n}\n\n// This regexp is valid as of 2024-08-01.\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nconst regexSemverNumberedGroups =\n  /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/\n\nfunction isBlank(str) {\n  for (let i = 0, { length } = str; i < length; i += 1) {\n    const code = str.charCodeAt(i)\n    // biome-ignore format:\n    if (\n      !(\n        // Whitespace characters according to ECMAScript spec:\n        // https://tc39.es/ecma262/#sec-white-space\n        (\n          code === 0x0020 || // Space\n          code === 0x0009 || // Tab\n          code === 0x000a || // Line Feed\n          code === 0x000b || // Vertical Tab\n          code === 0x000c || // Form Feed\n          code === 0x000d || // Carriage Return\n          code === 0x00a0 || // No-Break Space\n          code === 0x1680 || // Ogham Space Mark\n          code === 0x2000 || // En Quad\n          code === 0x2001 || // Em Quad\n          code === 0x2002 || // En Space\n          code === 0x2003 || // Em Space\n          code === 0x2004 || // Three-Per-Em Space\n          code === 0x2005 || // Four-Per-Em Space\n          code === 0x2006 || // Six-Per-Em Space\n          code === 0x2007 || // Figure Space\n          code === 0x2008 || // Punctuation Space\n          code === 0x2009 || // Thin Space\n          code === 0x200a || // Hair Space\n          code === 0x2028 || // Line Separator\n          code === 0x2029 || // Paragraph Separator\n          code === 0x202f || // Narrow No-Break Space\n          code === 0x205f || // Medium Mathematical Space\n          code === 0x3000 || // Ideographic Space\n          code === 0xfeff    // Byte Order Mark\n        )\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isNonEmptyString(value) {\n  return typeof value === 'string' && value.length > 0\n}\n\nfunction isSemverString(value) {\n  return typeof value === 'string' && regexSemverNumberedGroups.test(value)\n}\n\nfunction lowerName(purl) {\n  purl.name = purl.name.toLowerCase()\n}\n\nfunction lowerNamespace(purl) {\n  const { namespace } = purl\n  if (typeof namespace === 'string') {\n    purl.namespace = namespace.toLowerCase()\n  }\n}\n\nfunction lowerVersion(purl) {\n  const { version } = purl\n  if (typeof version === 'string') {\n    purl.version = version.toLowerCase()\n  }\n}\n\nfunction replaceDashesWithUnderscores(str) {\n  // Replace all \"-\" with \"_\"\n  let result = ''\n  let fromIndex = 0\n  let index = 0\n  while ((index = str.indexOf('-', fromIndex)) !== -1) {\n    result = result + str.slice(fromIndex, index) + '_'\n    fromIndex = index + 1\n  }\n  return fromIndex ? result + str.slice(fromIndex) : str\n}\n\nfunction replaceUnderscoresWithDashes(str) {\n  // Replace all \"_\" with \"-\"\n  let result = ''\n  let fromIndex = 0\n  let index = 0\n  while ((index = str.indexOf('_', fromIndex)) !== -1) {\n    result = result + str.slice(fromIndex, index) + '-'\n    fromIndex = index + 1\n  }\n  return fromIndex ? result + str.slice(fromIndex) : str\n}\n\nfunction trimLeadingSlashes(str) {\n  let start = 0\n  while (str.charCodeAt(start) === 47 /*'/'*/) {\n    start += 1\n  }\n  return start === 0 ? str : str.slice(start)\n}\n\nmodule.exports = {\n  isBlank,\n  isNonEmptyString,\n  isSemverString,\n  localeCompare,\n  lowerName,\n  lowerNamespace,\n  lowerVersion,\n  replaceDashesWithUnderscores,\n  replaceUnderscoresWithDashes,\n  trimLeadingSlashes\n}\n","'use strict'\n\nconst {\n  REUSED_SEARCH_PARAMS,\n  REUSED_SEARCH_PARAMS_KEY,\n  REUSED_SEARCH_PARAMS_OFFSET\n} = require('./constants')\nconst { isObject } = require('./objects')\nconst { isNonEmptyString } = require('./strings')\n\nconst { encodeURIComponent: encodeComponent } = globalThis\n\nfunction encodeName(name) {\n  return isNonEmptyString(name)\n    ? encodeComponent(name).replace(/%3A/g, ':')\n    : ''\n}\n\nfunction encodeNamespace(namespace) {\n  return isNonEmptyString(namespace)\n    ? encodeComponent(namespace).replace(/%3A/g, ':').replace(/%2F/g, '/')\n    : ''\n}\n\nfunction encodeQualifierParam(param) {\n  if (isNonEmptyString(param)) {\n    // Param key and value are encoded with `percentEncodeSet` of\n    // 'application/x-www-form-urlencoded' and `spaceAsPlus` of `true`.\n    // https://url.spec.whatwg.org/#urlencoded-serializing\n    REUSED_SEARCH_PARAMS.set(REUSED_SEARCH_PARAMS_KEY, param)\n    return replacePlusSignWithPercentEncodedSpace(\n      REUSED_SEARCH_PARAMS.toString().slice(REUSED_SEARCH_PARAMS_OFFSET)\n    )\n  }\n  return ''\n}\n\nfunction encodeQualifiers(qualifiers) {\n  if (isObject(qualifiers)) {\n    // Sort this list of qualifier strings lexicographically.\n    const qualifiersKeys = Object.keys(qualifiers).sort()\n    const searchParams = new URLSearchParams()\n    for (let i = 0, { length } = qualifiersKeys; i < length; i += 1) {\n      const key = qualifiersKeys[i]\n      searchParams.set(key, qualifiers[key])\n    }\n    return replacePlusSignWithPercentEncodedSpace(searchParams.toString())\n  }\n  return ''\n}\n\nfunction encodeSubpath(subpath) {\n  return isNonEmptyString(subpath)\n    ? encodeComponent(subpath).replace(/%2F/g, '/')\n    : ''\n}\n\nfunction encodeVersion(version) {\n  return isNonEmptyString(version)\n    ? encodeComponent(version).replace(/%3A/g, ':').replace(/%2B/g, '+')\n    : ''\n}\n\nfunction replacePlusSignWithPercentEncodedSpace(str) {\n  // Convert plus signs to %20 for better portability.\n  return str.replace(/\\+/g, '%20')\n}\n\nmodule.exports = {\n  encodeComponent,\n  encodeName,\n  encodeNamespace,\n  encodeVersion,\n  encodeQualifiers,\n  encodeQualifierParam,\n  encodeSubpath\n}\n","'use strict'\n\nfunction createHelpersNamespaceObject(helpers, options_ = {}) {\n  const { comparator, ...defaults } = { __proto__: null, ...options_ }\n  const helperNames = Object.keys(helpers).sort()\n  const propNames = [\n    ...new Set(Object.values(helpers).map(Object.keys).flat())\n  ].sort(comparator)\n  const nsObject = Object.create(null)\n  for (let i = 0, { length } = propNames; i < length; i += 1) {\n    const propName = propNames[i]\n    const helpersForProp = Object.create(null)\n    for (let j = 0, { length: length_j } = helperNames; j < length_j; j += 1) {\n      const helperName = helperNames[j]\n      const helperValue = helpers[helperName][propName] ?? defaults[helperName]\n      if (helperValue !== undefined) {\n        helpersForProp[helperName] = helperValue\n      }\n    }\n    nsObject[propName] = helpersForProp\n  }\n  return nsObject\n}\n\nmodule.exports = {\n  createHelpersNamespaceObject\n}\n","'use strict'\n\nconst { isObject } = require('./objects')\nconst { isBlank } = require('./strings')\n\nfunction normalizeName(rawName) {\n  return typeof rawName === 'string' ? rawName.trim() : undefined\n}\n\nfunction normalizeNamespace(rawNamespace) {\n  return typeof rawNamespace === 'string'\n    ? normalizePath(rawNamespace)\n    : undefined\n}\n\nfunction normalizePath(pathname, callback) {\n  let collapsed = ''\n  let start = 0\n  // Leading and trailing slashes, i.e. '/', are not significant and should be\n  // stripped in the canonical form.\n  while (pathname.charCodeAt(start) === 47 /*'/'*/) {\n    start += 1\n  }\n  let nextIndex = pathname.indexOf('/', start)\n  if (nextIndex === -1) {\n    return pathname.slice(start)\n  }\n  // Discard any empty string segments by collapsing repeated segment\n  // separator slashes, i.e. '/'.\n  while (nextIndex !== -1) {\n    const segment = pathname.slice(start, nextIndex)\n    if (callback === undefined || callback(segment)) {\n      collapsed = collapsed + (collapsed.length === 0 ? '' : '/') + segment\n    }\n    start = nextIndex + 1\n    while (pathname.charCodeAt(start) === 47) {\n      start += 1\n    }\n    nextIndex = pathname.indexOf('/', start)\n  }\n  const lastSegment = pathname.slice(start)\n  if (\n    lastSegment.length !== 0 &&\n    (callback === undefined || callback(lastSegment))\n  ) {\n    collapsed = collapsed + '/' + lastSegment\n  }\n  return collapsed\n}\n\nfunction normalizeQualifiers(rawQualifiers) {\n  let qualifiers\n  for (const { 0: key, 1: value } of qualifiersToEntries(rawQualifiers)) {\n    const strValue = typeof value === 'string' ? value : String(value)\n    const trimmed = strValue.trim()\n    // A key=value pair with an empty value is the same as no key/value\n    // at all for this key.\n    if (trimmed.length === 0) {\n      continue\n    }\n    if (qualifiers === undefined) {\n      qualifiers = { __proto__: null }\n    }\n    // A key is case insensitive. The canonical form is lowercase.\n    qualifiers[key.toLowerCase()] = trimmed\n  }\n  return qualifiers\n}\n\nfunction normalizeSubpath(rawSubpath) {\n  return typeof rawSubpath === 'string'\n    ? normalizePath(rawSubpath, subpathFilter)\n    : undefined\n}\n\nfunction normalizeType(rawType) {\n  // The type must NOT be percent-encoded.\n  // The type is case insensitive. The canonical form is lowercase.\n  return typeof rawType === 'string' ? rawType.trim().toLowerCase() : undefined\n}\n\nfunction normalizeVersion(rawVersion) {\n  return typeof rawVersion === 'string' ? rawVersion.trim() : undefined\n}\n\nfunction qualifiersToEntries(rawQualifiers) {\n  if (isObject(rawQualifiers)) {\n    return rawQualifiers instanceof URLSearchParams\n      ? rawQualifiers.entries()\n      : Object.entries(rawQualifiers)\n  }\n  return typeof rawQualifiers === 'string'\n    ? new URLSearchParams(rawQualifiers).entries()\n    : Object.entries({})\n}\n\nfunction subpathFilter(segment) {\n  // When percent-decoded, a segment\n  //   - must not be any of '.' or '..'\n  //   - must not be empty\n  const { length } = segment\n  if (length === 1 && segment.charCodeAt(0) === 46 /*'.'*/) {\n    return false\n  }\n  if (\n    length === 2 &&\n    segment.charCodeAt(0) === 46 &&\n    segment.charCodeAt(1) === 46\n  ) {\n    return false\n  }\n  return !isBlank(segment)\n}\n\nmodule.exports = {\n  normalizeName,\n  normalizeNamespace,\n  normalizePath,\n  normalizeQualifiers,\n  normalizeSubpath,\n  normalizeType,\n  normalizeVersion\n}\n","'use strict'\n\nfunction isNullishOrEmptyString(value) {\n  return (\n    value === null ||\n    value === undefined ||\n    (typeof value === 'string' && value.length === 0)\n  )\n}\n\nmodule.exports = {\n  isNullishOrEmptyString\n}\n","'use strict'\n\nconst { PurlError } = require('./error')\nconst { isNullishOrEmptyString } = require('./lang')\nconst { isNonEmptyString } = require('./strings')\n\nfunction validateEmptyByType(type, name, value, throws) {\n  if (!isNullishOrEmptyString(value)) {\n    if (throws) {\n      throw new PurlError(`${type} \"${name}\" component must be empty`)\n    }\n    return false\n  }\n  return true\n}\n\nfunction validateName(name, throws) {\n  return (\n    validateRequired('name', name, throws) &&\n    validateStrings('name', name, throws)\n  )\n}\n\nfunction validateNamespace(namespace, throws) {\n  return validateStrings('namespace', namespace, throws)\n}\n\nfunction validateQualifiers(qualifiers, throws) {\n  if (qualifiers === null || qualifiers === undefined) {\n    return true\n  }\n  if (typeof qualifiers !== 'object') {\n    if (throws) {\n      throw new PurlError('\"qualifiers\" must be an object')\n    }\n    return false\n  }\n  const keysIterable =\n    // URL searchParams have an \"keys\" method that returns an iterator.\n    typeof qualifiers.keys === 'function'\n      ? qualifiers.keys()\n      : Object.keys(qualifiers)\n  for (const key of keysIterable) {\n    if (!validateQualifierKey(key, throws)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction validateQualifierKey(key, throws) {\n  // A key cannot start with a number.\n  if (!validateStartsWithoutNumber('qualifier', key, throws)) {\n    return false\n  }\n  // The key must be composed only of ASCII letters and numbers,\n  // '.', '-' and '_' (period, dash and underscore).\n  for (let i = 0, { length } = key; i < length; i += 1) {\n    const code = key.charCodeAt(i)\n    // biome-ignore format:\n    if (\n      !(\n        (\n          (code >= 48 && code <= 57)  || // 0-9\n          (code >= 65 && code <= 90)  || // A-Z\n          (code >= 97 && code <= 122) || // a-z\n          code === 46 || // .\n          code === 45 || // -\n          code === 95    // _\n        )\n      )\n    ) {\n      if (throws) {\n        throw new PurlError(\n          `qualifier \"${key}\" contains an illegal character`\n        )\n      }\n      return false\n    }\n  }\n  return true\n}\n\nfunction validateRequired(name, value, throws) {\n  if (isNullishOrEmptyString(value)) {\n    if (throws) {\n      throw new PurlError(`\"${name}\" is a required component`)\n    }\n    return false\n  }\n  return true\n}\n\nfunction validateRequiredByType(type, name, value, throws) {\n  if (isNullishOrEmptyString(value)) {\n    if (throws) {\n      throw new PurlError(`${type} requires a \"${name}\" component`)\n    }\n    return false\n  }\n  return true\n}\n\nfunction validateStartsWithoutNumber(name, value, throws) {\n  if (isNonEmptyString(value)) {\n    const code = value.charCodeAt(0)\n    if (code >= 48 /*'0'*/ && code <= 57 /*'9'*/) {\n      if (throws) {\n        throw new PurlError(`${name} \"${value}\" cannot start with a number`)\n      }\n      return false\n    }\n  }\n  return true\n}\n\nfunction validateStrings(name, value, throws) {\n  if (value === null || value === undefined || typeof value === 'string') {\n    return true\n  }\n  if (throws) {\n    throw new PurlError(`\"'${name}\" must be a string`)\n  }\n  return false\n}\n\nfunction validateSubpath(subpath, throws) {\n  return validateStrings('subpath', subpath, throws)\n}\n\nfunction validateType(type, throws) {\n  // The type cannot be nullish, an empty string, or start with a number.\n  if (\n    !validateRequired('type', type, throws) ||\n    !validateStrings('type', type, throws) ||\n    !validateStartsWithoutNumber('type', type, throws)\n  ) {\n    return false\n  }\n  // The package type is composed only of ASCII letters and numbers,\n  // '.', '+' and '-' (period, plus, and dash)\n  for (let i = 0, { length } = type; i < length; i += 1) {\n    const code = type.charCodeAt(i)\n    // biome-ignore format:\n    if (\n      !(\n        (\n          (code >= 48 && code <= 57)  || // 0-9\n          (code >= 65 && code <= 90)  || // A-Z\n          (code >= 97 && code <= 122) || // a-z\n          code === 46 || // .\n          code === 43 || // +\n          code === 45    // -\n        )\n      )\n    ) {\n      if (throws) {\n        throw new PurlError(\n          `type \"${type}\" contains an illegal character`\n        )\n      }\n      return false\n    }\n  }\n  return true\n}\n\nfunction validateVersion(version, throws) {\n  return validateStrings('version', version, throws)\n}\n\nmodule.exports = {\n  validateEmptyByType,\n  validateName,\n  validateNamespace,\n  validateQualifiers,\n  validateQualifierKey,\n  validateRequired,\n  validateRequiredByType,\n  validateStartsWithoutNumber,\n  validateStrings,\n  validateSubpath,\n  validateType,\n  validateVersion\n}\n","'use strict'\n\nconst {\n  encodeComponent,\n  encodeName,\n  encodeNamespace,\n  encodeQualifierParam,\n  encodeQualifiers,\n  encodeSubpath,\n  encodeVersion\n} = require('./encode')\nconst { createHelpersNamespaceObject } = require('./helpers')\nconst {\n  normalizeName,\n  normalizeNamespace,\n  normalizeQualifiers,\n  normalizeSubpath,\n  normalizeType,\n  normalizeVersion\n} = require('./normalize')\nconst { isNonEmptyString, localeCompare } = require('./strings')\nconst {\n  validateName,\n  validateNamespace,\n  validateQualifierKey,\n  validateQualifiers,\n  validateSubpath,\n  validateType,\n  validateVersion\n} = require('./validate')\n\nconst PurlComponentEncoder = comp =>\n  isNonEmptyString(comp) ? encodeComponent(comp) : ''\n\nconst PurlComponentStringNormalizer = comp =>\n  typeof comp === 'string' ? comp : undefined\n\nconst PurlComponentValidator = (_comp, _throws) => true\n\nconst componentSortOrderLookup = {\n  __proto__: null,\n  type: 0,\n  namespace: 1,\n  name: 2,\n  version: 3,\n  qualifiers: 4,\n  qualifierKey: 5,\n  qualifierValue: 6,\n  subpath: 7\n}\n\nfunction componentSortOrder(comp) {\n  return componentSortOrderLookup[comp] ?? comp\n}\n\nfunction componentComparator(compA, compB) {\n  return localeCompare(componentSortOrder(compA), componentSortOrder(compB))\n}\n\nmodule.exports = {\n  // Rules for each purl component:\n  // https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst#rules-for-each-purl-component\n  PurlComponent: createHelpersNamespaceObject(\n    {\n      encode: {\n        name: encodeName,\n        namespace: encodeNamespace,\n        version: encodeVersion,\n        qualifiers: encodeQualifiers,\n        qualifierKey: encodeQualifierParam,\n        qualifierValue: encodeQualifierParam,\n        subpath: encodeSubpath\n      },\n      normalize: {\n        type: normalizeType,\n        namespace: normalizeNamespace,\n        name: normalizeName,\n        version: normalizeVersion,\n        qualifiers: normalizeQualifiers,\n        subpath: normalizeSubpath\n      },\n      validate: {\n        type: validateType,\n        namespace: validateNamespace,\n        name: validateName,\n        version: validateVersion,\n        qualifierKey: validateQualifierKey,\n        qualifiers: validateQualifiers,\n        subpath: validateSubpath\n      }\n    },\n    {\n      comparator: componentComparator,\n      encode: PurlComponentEncoder,\n      normalize: PurlComponentStringNormalizer,\n      validate: PurlComponentValidator\n    }\n  )\n}\n","'use strict'\n\nmodule.exports = {\n  // Known qualifiers:\n  // https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst#known-qualifiers-keyvalue-pairs\n  PurlQualifierNames: {\n    __proto__: null,\n    RepositoryUrl: 'repository_url',\n    DownloadUrl: 'download_url',\n    VcsUrl: 'vcs_url',\n    FileName: 'file_name',\n    Checksum: 'checksum'\n  }\n}\n","'use strict'\n\nconst { encodeComponent } = require('./encode')\nconst { PurlError } = require('./error')\nconst { createHelpersNamespaceObject } = require('./helpers')\nconst { isNullishOrEmptyString } = require('./lang')\nconst {\n  isSemverString,\n  lowerName,\n  lowerNamespace,\n  lowerVersion,\n  replaceDashesWithUnderscores,\n  replaceUnderscoresWithDashes\n} = require('./strings')\nconst { validateEmptyByType, validateRequiredByType } = require('./validate')\n\nconst PurlTypNormalizer = purl => purl\nconst PurlTypeValidator = (_purl, _throws) => true\n\nconst getNpmBuiltinNames = (() => {\n  let builtinNames\n  return () => {\n    if (builtinNames === undefined) {\n      builtinNames =\n        // Avoid a require('module') call directly so folks can bundle\n        // for the browser without issues.\n        (typeof module === 'object' &&\n          module !== null &&\n          module.constructor?.builtinModules) ||\n        require('../data/npm/builtin-names.json')\n    }\n    return builtinNames\n  }\n})()\n\nconst getNpmLegacyNames = (() => {\n  let legacyNames\n  return () => {\n    if (legacyNames === undefined) {\n      legacyNames = require('../data/npm/legacy-names.json')\n    }\n    return legacyNames\n  }\n})()\n\nfunction getNpmId(purl) {\n  const { name, namespace } = purl\n  return `${namespace?.length > 0 ? `${namespace}/` : ''}${name}`\n}\n\nconst isNpmBuiltinName = id => getNpmBuiltinNames().includes(id.toLowerCase())\n\nconst isNpmLegacyName = id => getNpmLegacyNames().includes(id)\n\nmodule.exports = {\n  // PURL types:\n  // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst\n  PurlType: createHelpersNamespaceObject(\n    {\n      normalize: {\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#alpm\n        alpm(purl) {\n          lowerNamespace(purl)\n          lowerName(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#apk\n        apk(purl) {\n          lowerNamespace(purl)\n          lowerName(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#bitbucket\n        bitbucket(purl) {\n          lowerNamespace(purl)\n          lowerName(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#bitnami\n        bitnami(purl) {\n          lowerName(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#composer\n        composer(purl) {\n          lowerNamespace(purl)\n          lowerName(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#deb\n        deb(purl) {\n          lowerNamespace(purl)\n          lowerName(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#other-candidate-types-to-define\n        gitlab(purl) {\n          lowerNamespace(purl)\n          lowerName(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#github\n        github(purl) {\n          lowerNamespace(purl)\n          lowerName(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#golang\n        // golang(purl) {\n        //     // Ignore case-insensitive rule because go.mod are case-sensitive.\n        //     // Pending spec change: https://github.com/package-url/purl-spec/pull/196\n        //     lowerNamespace(purl)\n        //     lowerName(purl)\n        //     return purl\n        // },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#hex\n        hex(purl) {\n          lowerNamespace(purl)\n          lowerName(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#huggingface\n        huggingface(purl) {\n          lowerVersion(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#mlflow\n        mlflow(purl) {\n          if (purl.qualifiers?.repository_url?.includes('databricks')) {\n            lowerName(purl)\n          }\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#npm\n        npm(purl) {\n          lowerNamespace(purl)\n          // Ignore lowercasing legacy names because they could be mixed case.\n          // https://github.com/npm/validate-npm-package-name/tree/v6.0.0?tab=readme-ov-file#legacy-names\n          if (!isNpmLegacyName(getNpmId(purl))) {\n            lowerName(purl)\n          }\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#luarocks\n        luarocks(purl) {\n          lowerVersion(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#oci\n        oci(purl) {\n          lowerName(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#pub\n        pub(purl) {\n          lowerName(purl)\n          purl.name = replaceDashesWithUnderscores(purl.name)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#pypi\n        pypi(purl) {\n          lowerNamespace(purl)\n          lowerName(purl)\n          purl.name = replaceUnderscoresWithDashes(purl.name)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#qpkg\n        qpkg(purl) {\n          lowerNamespace(purl)\n          return purl\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#rpm\n        rpm(purl) {\n          lowerNamespace(purl)\n          return purl\n        }\n      },\n      validate: {\n        // TODO: cocoapods name validation\n        // TODO: cpan namespace validation\n        // TODO: swid qualifier validation\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#conan\n        conan(purl, throws) {\n          if (isNullishOrEmptyString(purl.namespace)) {\n            if (purl.qualifiers?.channel) {\n              if (throws) {\n                throw new PurlError(\n                  'conan requires a \"namespace\" component when a \"channel\" qualifier is present'\n                )\n              }\n              return false\n            }\n          } else if (isNullishOrEmptyString(purl.qualifiers)) {\n            if (throws) {\n              throw new PurlError(\n                'conan requires a \"qualifiers\" component when a namespace is present'\n              )\n            }\n            return false\n          }\n          return true\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#cran\n        cran(purl, throws) {\n          return validateRequiredByType('cran', 'version', purl.version, throws)\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#golang\n        golang(purl, throws) {\n          // Still being lenient here since the standard changes aren't official.\n          // Pending spec change: https://github.com/package-url/purl-spec/pull/196\n          const { version } = purl\n          const length = typeof version === 'string' ? version.length : 0\n          // If the version starts with a \"v\" then ensure its a valid semver version.\n          // This, by semver semantics, also supports pseudo-version number.\n          // https://go.dev/doc/modules/version-numbers#pseudo-version-number\n          if (\n            length &&\n            version.charCodeAt(0) === 118 /*'v'*/ &&\n            !isSemverString(version.slice(1))\n          ) {\n            if (throws) {\n              throw new PurlError(\n                'golang \"version\" component starting with a \"v\" must be followed by a valid semver version'\n              )\n            }\n            return false\n          }\n          return true\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#maven\n        maven(purl, throws) {\n          return validateRequiredByType(\n            'maven',\n            'namespace',\n            purl.namespace,\n            throws\n          )\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#mlflow\n        mlflow(purl, throws) {\n          return validateEmptyByType(\n            'mlflow',\n            'namespace',\n            purl.namespace,\n            throws\n          )\n        },\n        // Validation based on\n        // https://github.com/npm/validate-npm-package-name/tree/v6.0.0\n        // ISC License\n        // Copyright (c) 2015, npm, Inc\n        npm(purl, throws) {\n          const { name, namespace } = purl\n          const hasNs = namespace?.length > 0\n          const id = getNpmId(purl)\n          const code0 = id.charCodeAt(0)\n          const compName = hasNs ? 'namespace' : 'name'\n          if (code0 === 46 /*'.'*/) {\n            if (throws) {\n              throw new PurlError(\n                `npm \"${compName}\" component cannot start with a period`\n              )\n            }\n            return false\n          }\n          if (code0 === 95 /*'_'*/) {\n            if (throws) {\n              throw new PurlError(\n                `npm \"${compName}\" component cannot start with an underscore`\n              )\n            }\n            return false\n          }\n          if (name.trim() !== name) {\n            if (throws) {\n              throw new PurlError(\n                'npm \"name\" component cannot contain leading or trailing spaces'\n              )\n            }\n            return false\n          }\n          if (encodeComponent(name) !== name) {\n            if (throws) {\n              throw new PurlError(\n                `npm \"name\" component can only contain URL-friendly characters`\n              )\n            }\n            return false\n          }\n          if (hasNs) {\n            if (namespace.trim() !== namespace) {\n              if (throws) {\n                throw new PurlError(\n                  'npm \"namespace\" component cannot contain leading or trailing spaces'\n                )\n              }\n              return false\n            }\n            if (code0 !== 64 /*'@'*/) {\n              throw new PurlError(\n                `npm \"namespace\" component must start with an \"@\" character`\n              )\n            }\n            const namespaceWithoutAtSign = namespace.slice(1)\n            if (\n              encodeComponent(namespaceWithoutAtSign) !== namespaceWithoutAtSign\n            ) {\n              if (throws) {\n                throw new PurlError(\n                  `npm \"namespace\" component can only contain URL-friendly characters`\n                )\n              }\n              return false\n            }\n          }\n          const loweredId = id.toLowerCase()\n          if (loweredId === 'node_modules' || loweredId === 'favicon.ico') {\n            if (throws) {\n              throw new PurlError(\n                `npm \"${compName}\" component of \"${loweredId}\" is not allowed`\n              )\n            }\n            return false\n          }\n          // The remaining checks are only for modern names.\n          // https://github.com/npm/validate-npm-package-name/tree/v6.0.0?tab=readme-ov-file#naming-rules\n          if (!isNpmLegacyName(id)) {\n            if (id.length > 214) {\n              if (throws) {\n                throw new PurlError(\n                  `npm \"namespace\" and \"name\" components can not collectively be more than 214 characters`\n                )\n              }\n              return false\n            }\n            if (loweredId !== id) {\n              if (throws) {\n                throw new PurlError(\n                  `npm \"name\" component can not contain capital letters`\n                )\n              }\n              return false\n            }\n            if (/[~'!()*]/.test(name)) {\n              if (throws) {\n                throw new PurlError(\n                  `npm \"name\" component can not contain special characters (\"~'!()*\")`\n                )\n              }\n              return false\n            }\n            if (isNpmBuiltinName(id)) {\n              if (throws) {\n                throw new PurlError(\n                  'npm \"name\" component can not be a core module name'\n                )\n              }\n              return false\n            }\n          }\n          return true\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#oci\n        oci(purl, throws) {\n          return validateEmptyByType('oci', 'namespace', purl.namespace, throws)\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#pub\n        pub(purl, throws) {\n          const { name } = purl\n          for (let i = 0, { length } = name; i < length; i += 1) {\n            const code = name.charCodeAt(i)\n            // biome-ignore format:\n            if (\n              !(\n                (\n                  (code >= 48 && code <= 57)  || // 0-9\n                  (code >= 97 && code <= 122) || // a-z\n                  code === 95 // _\n                )\n              )\n            ) {\n              if (throws) {\n                throw new PurlError(\n                  'pub \"name\" component may only contain [a-z0-9_] characters'\n                )\n              }\n              return false\n            }\n          }\n          return true\n        },\n        // https://github.com/package-url/purl-spec/blob/master/PURL-TYPES.rst#swift\n        swift(purl, throws) {\n          return (\n            validateRequiredByType(\n              'swift',\n              'namespace',\n              purl.namespace,\n              throws\n            ) &&\n            validateRequiredByType('swift', 'version', purl.version, throws)\n          )\n        }\n      }\n    },\n    {\n      normalize: PurlTypNormalizer,\n      validate: PurlTypeValidator\n    }\n  )\n}\n","/*!\nCopyright (c) the purl authors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n'use strict'\n\nconst { decodePurlComponent } = require('./decode')\nconst { PurlError } = require('./error')\nconst { isObject, recursiveFreeze } = require('./objects')\nconst { PurlComponent } = require('./purl-component')\nconst { PurlQualifierNames } = require('./purl-qualifier-names')\nconst { PurlType } = require('./purl-type')\nconst { isBlank, isNonEmptyString, trimLeadingSlashes } = require('./strings')\n\nclass PackageURL {\n  static Component = recursiveFreeze(PurlComponent)\n  static KnownQualifierNames = recursiveFreeze(PurlQualifierNames)\n  static Type = recursiveFreeze(PurlType)\n\n  constructor(\n    rawType,\n    rawNamespace,\n    rawName,\n    rawVersion,\n    rawQualifiers,\n    rawSubpath\n  ) {\n    const type = isNonEmptyString(rawType)\n      ? PurlComponent.type.normalize(rawType)\n      : rawType\n    PurlComponent.type.validate(type, true)\n\n    const namespace = isNonEmptyString(rawNamespace)\n      ? PurlComponent.namespace.normalize(rawNamespace)\n      : rawNamespace\n    PurlComponent.namespace.validate(namespace, true)\n\n    const name = isNonEmptyString(rawName)\n      ? PurlComponent.name.normalize(rawName)\n      : rawName\n    PurlComponent.name.validate(name, true)\n\n    const version = isNonEmptyString(rawVersion)\n      ? PurlComponent.version.normalize(rawVersion)\n      : rawVersion\n    PurlComponent.version.validate(version, true)\n\n    const qualifiers =\n      typeof rawQualifiers === 'string' || isObject(rawQualifiers)\n        ? PurlComponent.qualifiers.normalize(rawQualifiers)\n        : rawQualifiers\n    PurlComponent.qualifiers.validate(qualifiers, true)\n\n    const subpath = isNonEmptyString(rawSubpath)\n      ? PurlComponent.subpath.normalize(rawSubpath)\n      : rawSubpath\n    PurlComponent.subpath.validate(subpath, true)\n\n    this.type = type\n    this.name = name\n    this.namespace = namespace ?? undefined\n    this.version = version ?? undefined\n    this.qualifiers = qualifiers ?? undefined\n    this.subpath = subpath ?? undefined\n\n    const typeHelpers = PurlType[type]\n    if (typeHelpers) {\n      typeHelpers.normalize(this)\n      typeHelpers.validate(this, true)\n    }\n  }\n\n  toString() {\n    const { name, namespace, qualifiers, subpath, type, version } = this\n    let purlStr = `pkg:${PurlComponent.type.encode(type)}/`\n    if (namespace) {\n      purlStr = `${purlStr}${PurlComponent.namespace.encode(namespace)}/`\n    }\n    purlStr = `${purlStr}${PurlComponent.name.encode(name)}`\n    if (version) {\n      purlStr = `${purlStr}@${PurlComponent.version.encode(version)}`\n    }\n    if (qualifiers) {\n      purlStr = `${purlStr}?${PurlComponent.qualifiers.encode(qualifiers)}`\n    }\n    if (subpath) {\n      purlStr = `${purlStr}#${PurlComponent.subpath.encode(subpath)}`\n    }\n    return purlStr\n  }\n\n  static fromString(purlStr) {\n    return new PackageURL(...PackageURL.parseString(purlStr))\n  }\n\n  static parseString(purlStr) {\n    // https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst#how-to-parse-a-purl-string-in-its-components\n    if (typeof purlStr !== 'string') {\n      throw new Error('A purl string argument is required.')\n    }\n    if (isBlank(purlStr)) {\n      return [undefined, undefined, undefined, undefined, undefined, undefined]\n    }\n\n    // Split the remainder once from left on ':'.\n    const colonIndex = purlStr.indexOf(':')\n    // Use WHATWG URL to split up the purl string.\n    //   - Split the purl string once from right on '#'\n    //   - Split the remainder once from right on '?'\n    //   - Split the remainder once from left on ':'\n    let url\n    let maybeUrlWithAuth\n    if (colonIndex !== -1) {\n      try {\n        // Since a purl never contains a URL Authority, its scheme\n        // must not be suffixed with double slash as in 'pkg://'\n        // and should use instead 'pkg:'. Purl parsers must accept\n        // URLs such as 'pkg://' and must ignore the '//'\n        const beforeColon = purlStr.slice(0, colonIndex)\n        const afterColon = purlStr.slice(colonIndex + 1)\n        const trimmedAfterColon = trimLeadingSlashes(afterColon)\n        url = new URL(`${beforeColon}:${trimmedAfterColon}`)\n        maybeUrlWithAuth =\n          afterColon.length === trimmedAfterColon.length\n            ? url\n            : new URL(purlStr)\n      } catch (e) {\n        throw new PurlError('failed to parse as URL', {\n          cause: e\n        })\n      }\n    }\n    // The scheme is a constant with the value \"pkg\".\n    if (url?.protocol !== 'pkg:') {\n      throw new PurlError('missing required \"pkg\" scheme component')\n    }\n    // A purl must NOT contain a URL Authority i.e. there is no support for\n    // username, password, host and port components.\n    if (maybeUrlWithAuth.username !== '' || maybeUrlWithAuth.password !== '') {\n      throw new PurlError('cannot contain a \"user:pass@host:port\"')\n    }\n\n    const { pathname } = url\n    const firstSlashIndex = pathname.indexOf('/')\n    const rawType = decodePurlComponent(\n      'type',\n      firstSlashIndex === -1 ? pathname : pathname.slice(0, firstSlashIndex)\n    )\n    if (firstSlashIndex < 1) {\n      return [rawType, undefined, undefined, undefined, undefined, undefined]\n    }\n\n    let rawVersion\n    let atSignIndex =\n      rawType === 'npm'\n        ? // Deviate from the specification to handle a special npm purl type case for\n          // pnpm ids such as 'pkg:npm/next@14.2.10(react-dom@18.3.1(react@18.3.1))(react@18.3.1)'.\n          pathname.indexOf('@', firstSlashIndex + 2)\n        : pathname.lastIndexOf('@')\n    // When a forward slash ('/') is directly preceding an '@' symbol,\n    // then the '@' symbol is NOT considered a version separator.\n    if (\n      atSignIndex !== -1 &&\n      pathname.charCodeAt(atSignIndex - 1) === 47 /*'/'*/\n    ) {\n      atSignIndex = -1\n    }\n    const beforeVersion = pathname.slice(\n      rawType.length + 1,\n      atSignIndex === -1 ? pathname.length : atSignIndex\n    )\n    if (atSignIndex !== -1) {\n      // Split the remainder once from right on '@'.\n      rawVersion = decodePurlComponent(\n        'version',\n        pathname.slice(atSignIndex + 1)\n      )\n    }\n\n    let rawNamespace\n    let rawName\n    const lastSlashIndex = beforeVersion.lastIndexOf('/')\n    if (lastSlashIndex === -1) {\n      // Split the remainder once from right on '/'.\n      rawName = decodePurlComponent('name', beforeVersion)\n    } else {\n      // Split the remainder once from right on '/'.\n      rawName = decodePurlComponent(\n        'name',\n        beforeVersion.slice(lastSlashIndex + 1)\n      )\n      // Split the remainder on '/'.\n      rawNamespace = decodePurlComponent(\n        'namespace',\n        beforeVersion.slice(0, lastSlashIndex)\n      )\n    }\n\n    let rawQualifiers\n    const { searchParams } = url\n    if (searchParams.size !== 0) {\n      searchParams.forEach(value => decodePurlComponent('qualifiers', value))\n      // Split the remainder once from right on '?'.\n      rawQualifiers = searchParams\n    }\n\n    let rawSubpath\n    const { hash } = url\n    if (hash.length !== 0) {\n      // Split the purl string once from right on '#'.\n      rawSubpath = decodePurlComponent('subpath', hash.slice(1))\n    }\n\n    return [\n      rawType,\n      rawNamespace,\n      rawName,\n      rawVersion,\n      rawQualifiers,\n      rawSubpath\n    ]\n  }\n}\n\nfor (const staticProp of ['Component', 'KnownQualifierNames', 'Type']) {\n  Reflect.defineProperty(PackageURL, staticProp, {\n    ...Reflect.getOwnPropertyDescriptor(PackageURL, staticProp),\n    writable: false\n  })\n}\n\nReflect.setPrototypeOf(PackageURL.prototype, null)\n\nmodule.exports = {\n  PackageURL,\n  PurlComponent,\n  PurlQualifierNames,\n  PurlType\n}\n","/*!\nCopyright (c) the purl authors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n'use strict'\n\nconst {\n  PackageURL,\n  PurlComponent,\n  PurlQualifierNames,\n  PurlType\n} = require('./src/package-url')\n\nmodule.exports = {\n  PackageURL,\n  PurlComponent,\n  PurlQualifierNames,\n  PurlType\n}\n","export function getUserAgent() {\n  if (typeof navigator === \"object\" && \"userAgent\" in navigator) {\n    return navigator.userAgent;\n  }\n\n  if (typeof process === \"object\" && process.version !== undefined) {\n    return `Node.js/${process.version.substr(1)} (${process.platform}; ${\n      process.arch\n    })`;\n  }\n\n  return \"<environment undetectable>\";\n}\n","// pkg/dist-src/defaults.js\nimport { getUserAgent } from \"universal-user-agent\";\n\n// pkg/dist-src/version.js\nvar VERSION = \"0.0.0-development\";\n\n// pkg/dist-src/defaults.js\nvar userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;\nvar DEFAULTS = {\n  method: \"GET\",\n  baseUrl: \"https://api.github.com\",\n  headers: {\n    accept: \"application/vnd.github.v3+json\",\n    \"user-agent\": userAgent\n  },\n  mediaType: {\n    format: \"\"\n  }\n};\n\n// pkg/dist-src/util/lowercase-keys.js\nfunction lowercaseKeys(object) {\n  if (!object) {\n    return {};\n  }\n  return Object.keys(object).reduce((newObj, key) => {\n    newObj[key.toLowerCase()] = object[key];\n    return newObj;\n  }, {});\n}\n\n// pkg/dist-src/util/is-plain-object.js\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) return false;\n  if (Object.prototype.toString.call(value) !== \"[object Object]\") return false;\n  const proto = Object.getPrototypeOf(value);\n  if (proto === null) return true;\n  const Ctor = Object.prototype.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor === \"function\" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);\n}\n\n// pkg/dist-src/util/merge-deep.js\nfunction mergeDeep(defaults, options) {\n  const result = Object.assign({}, defaults);\n  Object.keys(options).forEach((key) => {\n    if (isPlainObject(options[key])) {\n      if (!(key in defaults)) Object.assign(result, { [key]: options[key] });\n      else result[key] = mergeDeep(defaults[key], options[key]);\n    } else {\n      Object.assign(result, { [key]: options[key] });\n    }\n  });\n  return result;\n}\n\n// pkg/dist-src/util/remove-undefined-properties.js\nfunction removeUndefinedProperties(obj) {\n  for (const key in obj) {\n    if (obj[key] === void 0) {\n      delete obj[key];\n    }\n  }\n  return obj;\n}\n\n// pkg/dist-src/merge.js\nfunction merge(defaults, route, options) {\n  if (typeof route === \"string\") {\n    let [method, url] = route.split(\" \");\n    options = Object.assign(url ? { method, url } : { url: method }, options);\n  } else {\n    options = Object.assign({}, route);\n  }\n  options.headers = lowercaseKeys(options.headers);\n  removeUndefinedProperties(options);\n  removeUndefinedProperties(options.headers);\n  const mergedOptions = mergeDeep(defaults || {}, options);\n  if (options.url === \"/graphql\") {\n    if (defaults && defaults.mediaType.previews?.length) {\n      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(\n        (preview) => !mergedOptions.mediaType.previews.includes(preview)\n      ).concat(mergedOptions.mediaType.previews);\n    }\n    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, \"\"));\n  }\n  return mergedOptions;\n}\n\n// pkg/dist-src/util/add-query-parameters.js\nfunction addQueryParameters(url, parameters) {\n  const separator = /\\?/.test(url) ? \"&\" : \"?\";\n  const names = Object.keys(parameters);\n  if (names.length === 0) {\n    return url;\n  }\n  return url + separator + names.map((name) => {\n    if (name === \"q\") {\n      return \"q=\" + parameters.q.split(\"+\").map(encodeURIComponent).join(\"+\");\n    }\n    return `${name}=${encodeURIComponent(parameters[name])}`;\n  }).join(\"&\");\n}\n\n// pkg/dist-src/util/extract-url-variable-names.js\nvar urlVariableRegex = /\\{[^{}}]+\\}/g;\nfunction removeNonChars(variableName) {\n  return variableName.replace(/(?:^\\W+)|(?:(?<!\\W)\\W+$)/g, \"\").split(/,/);\n}\nfunction extractUrlVariableNames(url) {\n  const matches = url.match(urlVariableRegex);\n  if (!matches) {\n    return [];\n  }\n  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);\n}\n\n// pkg/dist-src/util/omit.js\nfunction omit(object, keysToOmit) {\n  const result = { __proto__: null };\n  for (const key of Object.keys(object)) {\n    if (keysToOmit.indexOf(key) === -1) {\n      result[key] = object[key];\n    }\n  }\n  return result;\n}\n\n// pkg/dist-src/util/url-template.js\nfunction encodeReserved(str) {\n  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {\n    if (!/%[0-9A-Fa-f]/.test(part)) {\n      part = encodeURI(part).replace(/%5B/g, \"[\").replace(/%5D/g, \"]\");\n    }\n    return part;\n  }).join(\"\");\n}\nfunction encodeUnreserved(str) {\n  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {\n    return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\nfunction encodeValue(operator, value, key) {\n  value = operator === \"+\" || operator === \"#\" ? encodeReserved(value) : encodeUnreserved(value);\n  if (key) {\n    return encodeUnreserved(key) + \"=\" + value;\n  } else {\n    return value;\n  }\n}\nfunction isDefined(value) {\n  return value !== void 0 && value !== null;\n}\nfunction isKeyOperator(operator) {\n  return operator === \";\" || operator === \"&\" || operator === \"?\";\n}\nfunction getValues(context, operator, key, modifier) {\n  var value = context[key], result = [];\n  if (isDefined(value) && value !== \"\") {\n    if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n      value = value.toString();\n      if (modifier && modifier !== \"*\") {\n        value = value.substring(0, parseInt(modifier, 10));\n      }\n      result.push(\n        encodeValue(operator, value, isKeyOperator(operator) ? key : \"\")\n      );\n    } else {\n      if (modifier === \"*\") {\n        if (Array.isArray(value)) {\n          value.filter(isDefined).forEach(function(value2) {\n            result.push(\n              encodeValue(operator, value2, isKeyOperator(operator) ? key : \"\")\n            );\n          });\n        } else {\n          Object.keys(value).forEach(function(k) {\n            if (isDefined(value[k])) {\n              result.push(encodeValue(operator, value[k], k));\n            }\n          });\n        }\n      } else {\n        const tmp = [];\n        if (Array.isArray(value)) {\n          value.filter(isDefined).forEach(function(value2) {\n            tmp.push(encodeValue(operator, value2));\n          });\n        } else {\n          Object.keys(value).forEach(function(k) {\n            if (isDefined(value[k])) {\n              tmp.push(encodeUnreserved(k));\n              tmp.push(encodeValue(operator, value[k].toString()));\n            }\n          });\n        }\n        if (isKeyOperator(operator)) {\n          result.push(encodeUnreserved(key) + \"=\" + tmp.join(\",\"));\n        } else if (tmp.length !== 0) {\n          result.push(tmp.join(\",\"));\n        }\n      }\n    }\n  } else {\n    if (operator === \";\") {\n      if (isDefined(value)) {\n        result.push(encodeUnreserved(key));\n      }\n    } else if (value === \"\" && (operator === \"&\" || operator === \"?\")) {\n      result.push(encodeUnreserved(key) + \"=\");\n    } else if (value === \"\") {\n      result.push(\"\");\n    }\n  }\n  return result;\n}\nfunction parseUrl(template) {\n  return {\n    expand: expand.bind(null, template)\n  };\n}\nfunction expand(template, context) {\n  var operators = [\"+\", \"#\", \".\", \"/\", \";\", \"?\", \"&\"];\n  template = template.replace(\n    /\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g,\n    function(_, expression, literal) {\n      if (expression) {\n        let operator = \"\";\n        const values = [];\n        if (operators.indexOf(expression.charAt(0)) !== -1) {\n          operator = expression.charAt(0);\n          expression = expression.substr(1);\n        }\n        expression.split(/,/g).forEach(function(variable) {\n          var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n        });\n        if (operator && operator !== \"+\") {\n          var separator = \",\";\n          if (operator === \"?\") {\n            separator = \"&\";\n          } else if (operator !== \"#\") {\n            separator = operator;\n          }\n          return (values.length !== 0 ? operator : \"\") + values.join(separator);\n        } else {\n          return values.join(\",\");\n        }\n      } else {\n        return encodeReserved(literal);\n      }\n    }\n  );\n  if (template === \"/\") {\n    return template;\n  } else {\n    return template.replace(/\\/$/, \"\");\n  }\n}\n\n// pkg/dist-src/parse.js\nfunction parse(options) {\n  let method = options.method.toUpperCase();\n  let url = (options.url || \"/\").replace(/:([a-z]\\w+)/g, \"{$1}\");\n  let headers = Object.assign({}, options.headers);\n  let body;\n  let parameters = omit(options, [\n    \"method\",\n    \"baseUrl\",\n    \"url\",\n    \"headers\",\n    \"request\",\n    \"mediaType\"\n  ]);\n  const urlVariableNames = extractUrlVariableNames(url);\n  url = parseUrl(url).expand(parameters);\n  if (!/^http/.test(url)) {\n    url = options.baseUrl + url;\n  }\n  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat(\"baseUrl\");\n  const remainingParameters = omit(parameters, omittedParameters);\n  const isBinaryRequest = /application\\/octet-stream/i.test(headers.accept);\n  if (!isBinaryRequest) {\n    if (options.mediaType.format) {\n      headers.accept = headers.accept.split(/,/).map(\n        (format) => format.replace(\n          /application\\/vnd(\\.\\w+)(\\.v3)?(\\.\\w+)?(\\+json)?$/,\n          `application/vnd$1$2.${options.mediaType.format}`\n        )\n      ).join(\",\");\n    }\n    if (url.endsWith(\"/graphql\")) {\n      if (options.mediaType.previews?.length) {\n        const previewsFromAcceptHeader = headers.accept.match(/(?<![\\w-])[\\w-]+(?=-preview)/g) || [];\n        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {\n          const format = options.mediaType.format ? `.${options.mediaType.format}` : \"+json\";\n          return `application/vnd.github.${preview}-preview${format}`;\n        }).join(\",\");\n      }\n    }\n  }\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    url = addQueryParameters(url, remainingParameters);\n  } else {\n    if (\"data\" in remainingParameters) {\n      body = remainingParameters.data;\n    } else {\n      if (Object.keys(remainingParameters).length) {\n        body = remainingParameters;\n      }\n    }\n  }\n  if (!headers[\"content-type\"] && typeof body !== \"undefined\") {\n    headers[\"content-type\"] = \"application/json; charset=utf-8\";\n  }\n  if ([\"PATCH\", \"PUT\"].includes(method) && typeof body === \"undefined\") {\n    body = \"\";\n  }\n  return Object.assign(\n    { method, url, headers },\n    typeof body !== \"undefined\" ? { body } : null,\n    options.request ? { request: options.request } : null\n  );\n}\n\n// pkg/dist-src/endpoint-with-defaults.js\nfunction endpointWithDefaults(defaults, route, options) {\n  return parse(merge(defaults, route, options));\n}\n\n// pkg/dist-src/with-defaults.js\nfunction withDefaults(oldDefaults, newDefaults) {\n  const DEFAULTS2 = merge(oldDefaults, newDefaults);\n  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);\n  return Object.assign(endpoint2, {\n    DEFAULTS: DEFAULTS2,\n    defaults: withDefaults.bind(null, DEFAULTS2),\n    merge: merge.bind(null, DEFAULTS2),\n    parse\n  });\n}\n\n// pkg/dist-src/index.js\nvar endpoint = withDefaults(null, DEFAULTS);\nexport {\n  endpoint\n};\n","'use strict'\n\nconst NullObject = function NullObject () { }\nNullObject.prototype = Object.create(null)\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nconst paramRE = /; *([!#$%&'*+.^\\w`|~-]+)=(\"(?:[\\v\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\v\\u0020-\\u00ff])*\"|[!#$%&'*+.^\\w`|~-]+) */gu\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nconst quotedPairRE = /\\\\([\\v\\u0020-\\u00ff])/gu\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nconst mediaTypeRE = /^[!#$%&'*+.^\\w|~-]+\\/[!#$%&'*+.^\\w|~-]+$/u\n\n// default ContentType to prevent repeated object creation\nconst defaultContentType = { type: '', parameters: new NullObject() }\nObject.freeze(defaultContentType.parameters)\nObject.freeze(defaultContentType)\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} header\n * @return {Object}\n * @public\n */\n\nfunction parse (header) {\n  if (typeof header !== 'string') {\n    throw new TypeError('argument header is required and must be a string')\n  }\n\n  let index = header.indexOf(';')\n  const type = index !== -1\n    ? header.slice(0, index).trim()\n    : header.trim()\n\n  if (mediaTypeRE.test(type) === false) {\n    throw new TypeError('invalid media type')\n  }\n\n  const result = {\n    type: type.toLowerCase(),\n    parameters: new NullObject()\n  }\n\n  // parse parameters\n  if (index === -1) {\n    return result\n  }\n\n  let key\n  let match\n  let value\n\n  paramRE.lastIndex = index\n\n  while ((match = paramRE.exec(header))) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format')\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value\n        .slice(1, value.length - 1)\n\n      quotedPairRE.test(value) && (value = value.replace(quotedPairRE, '$1'))\n    }\n\n    result.parameters[key] = value\n  }\n\n  if (index !== header.length) {\n    throw new TypeError('invalid parameter format')\n  }\n\n  return result\n}\n\nfunction safeParse (header) {\n  if (typeof header !== 'string') {\n    return defaultContentType\n  }\n\n  let index = header.indexOf(';')\n  const type = index !== -1\n    ? header.slice(0, index).trim()\n    : header.trim()\n\n  if (mediaTypeRE.test(type) === false) {\n    return defaultContentType\n  }\n\n  const result = {\n    type: type.toLowerCase(),\n    parameters: new NullObject()\n  }\n\n  // parse parameters\n  if (index === -1) {\n    return result\n  }\n\n  let key\n  let match\n  let value\n\n  paramRE.lastIndex = index\n\n  while ((match = paramRE.exec(header))) {\n    if (match.index !== index) {\n      return defaultContentType\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value\n        .slice(1, value.length - 1)\n\n      quotedPairRE.test(value) && (value = value.replace(quotedPairRE, '$1'))\n    }\n\n    result.parameters[key] = value\n  }\n\n  if (index !== header.length) {\n    return defaultContentType\n  }\n\n  return result\n}\n\nmodule.exports.default = { parse, safeParse }\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.defaultContentType = defaultContentType\n","class RequestError extends Error {\n  name;\n  /**\n   * http status code\n   */\n  status;\n  /**\n   * Request options that lead to the error.\n   */\n  request;\n  /**\n   * Response object if a response was received\n   */\n  response;\n  constructor(message, statusCode, options) {\n    super(message);\n    this.name = \"HttpError\";\n    this.status = Number.parseInt(statusCode);\n    if (Number.isNaN(this.status)) {\n      this.status = 0;\n    }\n    if (\"response\" in options) {\n      this.response = options.response;\n    }\n    const requestCopy = Object.assign({}, options.request);\n    if (options.request.headers.authorization) {\n      requestCopy.headers = Object.assign({}, options.request.headers, {\n        authorization: options.request.headers.authorization.replace(\n          /(?<! ) .*$/,\n          \" [REDACTED]\"\n        )\n      });\n    }\n    requestCopy.url = requestCopy.url.replace(/\\bclient_secret=\\w+/g, \"client_secret=[REDACTED]\").replace(/\\baccess_token=\\w+/g, \"access_token=[REDACTED]\");\n    this.request = requestCopy;\n  }\n}\nexport {\n  RequestError\n};\n","// pkg/dist-src/index.js\nimport { endpoint } from \"@octokit/endpoint\";\n\n// pkg/dist-src/defaults.js\nimport { getUserAgent } from \"universal-user-agent\";\n\n// pkg/dist-src/version.js\nvar VERSION = \"0.0.0-development\";\n\n// pkg/dist-src/defaults.js\nvar defaults_default = {\n  headers: {\n    \"user-agent\": `octokit-request.js/${VERSION} ${getUserAgent()}`\n  }\n};\n\n// pkg/dist-src/fetch-wrapper.js\nimport { safeParse } from \"fast-content-type-parse\";\n\n// pkg/dist-src/is-plain-object.js\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) return false;\n  if (Object.prototype.toString.call(value) !== \"[object Object]\") return false;\n  const proto = Object.getPrototypeOf(value);\n  if (proto === null) return true;\n  const Ctor = Object.prototype.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor === \"function\" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);\n}\n\n// pkg/dist-src/fetch-wrapper.js\nimport { RequestError } from \"@octokit/request-error\";\nasync function fetchWrapper(requestOptions) {\n  const fetch = requestOptions.request?.fetch || globalThis.fetch;\n  if (!fetch) {\n    throw new Error(\n      \"fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing\"\n    );\n  }\n  const log = requestOptions.request?.log || console;\n  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;\n  const body = isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;\n  const requestHeaders = Object.fromEntries(\n    Object.entries(requestOptions.headers).map(([name, value]) => [\n      name,\n      String(value)\n    ])\n  );\n  let fetchResponse;\n  try {\n    fetchResponse = await fetch(requestOptions.url, {\n      method: requestOptions.method,\n      body,\n      redirect: requestOptions.request?.redirect,\n      headers: requestHeaders,\n      signal: requestOptions.request?.signal,\n      // duplex must be set if request.body is ReadableStream or Async Iterables.\n      // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.\n      ...requestOptions.body && { duplex: \"half\" }\n    });\n  } catch (error) {\n    let message = \"Unknown Error\";\n    if (error instanceof Error) {\n      if (error.name === \"AbortError\") {\n        error.status = 500;\n        throw error;\n      }\n      message = error.message;\n      if (error.name === \"TypeError\" && \"cause\" in error) {\n        if (error.cause instanceof Error) {\n          message = error.cause.message;\n        } else if (typeof error.cause === \"string\") {\n          message = error.cause;\n        }\n      }\n    }\n    const requestError = new RequestError(message, 500, {\n      request: requestOptions\n    });\n    requestError.cause = error;\n    throw requestError;\n  }\n  const status = fetchResponse.status;\n  const url = fetchResponse.url;\n  const responseHeaders = {};\n  for (const [key, value] of fetchResponse.headers) {\n    responseHeaders[key] = value;\n  }\n  const octokitResponse = {\n    url,\n    status,\n    headers: responseHeaders,\n    data: \"\"\n  };\n  if (\"deprecation\" in responseHeaders) {\n    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel=\"deprecation\"/);\n    const deprecationLink = matches && matches.pop();\n    log.warn(\n      `[@octokit/request] \"${requestOptions.method} ${requestOptions.url}\" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : \"\"}`\n    );\n  }\n  if (status === 204 || status === 205) {\n    return octokitResponse;\n  }\n  if (requestOptions.method === \"HEAD\") {\n    if (status < 400) {\n      return octokitResponse;\n    }\n    throw new RequestError(fetchResponse.statusText, status, {\n      response: octokitResponse,\n      request: requestOptions\n    });\n  }\n  if (status === 304) {\n    octokitResponse.data = await getResponseData(fetchResponse);\n    throw new RequestError(\"Not modified\", status, {\n      response: octokitResponse,\n      request: requestOptions\n    });\n  }\n  if (status >= 400) {\n    octokitResponse.data = await getResponseData(fetchResponse);\n    throw new RequestError(toErrorMessage(octokitResponse.data), status, {\n      response: octokitResponse,\n      request: requestOptions\n    });\n  }\n  octokitResponse.data = parseSuccessResponseBody ? await getResponseData(fetchResponse) : fetchResponse.body;\n  return octokitResponse;\n}\nasync function getResponseData(response) {\n  const contentType = response.headers.get(\"content-type\");\n  if (!contentType) {\n    return response.text().catch(() => \"\");\n  }\n  const mimetype = safeParse(contentType);\n  if (isJSONResponse(mimetype)) {\n    let text = \"\";\n    try {\n      text = await response.text();\n      return JSON.parse(text);\n    } catch (err) {\n      return text;\n    }\n  } else if (mimetype.type.startsWith(\"text/\") || mimetype.parameters.charset?.toLowerCase() === \"utf-8\") {\n    return response.text().catch(() => \"\");\n  } else {\n    return response.arrayBuffer().catch(() => new ArrayBuffer(0));\n  }\n}\nfunction isJSONResponse(mimetype) {\n  return mimetype.type === \"application/json\" || mimetype.type === \"application/scim+json\";\n}\nfunction toErrorMessage(data) {\n  if (typeof data === \"string\") {\n    return data;\n  }\n  if (data instanceof ArrayBuffer) {\n    return \"Unknown error\";\n  }\n  if (\"message\" in data) {\n    const suffix = \"documentation_url\" in data ? ` - ${data.documentation_url}` : \"\";\n    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v) => JSON.stringify(v)).join(\", \")}${suffix}` : `${data.message}${suffix}`;\n  }\n  return `Unknown error: ${JSON.stringify(data)}`;\n}\n\n// pkg/dist-src/with-defaults.js\nfunction withDefaults(oldEndpoint, newDefaults) {\n  const endpoint2 = oldEndpoint.defaults(newDefaults);\n  const newApi = function(route, parameters) {\n    const endpointOptions = endpoint2.merge(route, parameters);\n    if (!endpointOptions.request || !endpointOptions.request.hook) {\n      return fetchWrapper(endpoint2.parse(endpointOptions));\n    }\n    const request2 = (route2, parameters2) => {\n      return fetchWrapper(\n        endpoint2.parse(endpoint2.merge(route2, parameters2))\n      );\n    };\n    Object.assign(request2, {\n      endpoint: endpoint2,\n      defaults: withDefaults.bind(null, endpoint2)\n    });\n    return endpointOptions.request.hook(request2, endpointOptions);\n  };\n  return Object.assign(newApi, {\n    endpoint: endpoint2,\n    defaults: withDefaults.bind(null, endpoint2)\n  });\n}\n\n// pkg/dist-src/index.js\nvar request = withDefaults(endpoint, defaults_default);\nexport {\n  request\n};\n","// pkg/dist-src/index.js\nimport { request } from \"@octokit/request\";\nimport { getUserAgent } from \"universal-user-agent\";\n\n// pkg/dist-src/version.js\nvar VERSION = \"0.0.0-development\";\n\n// pkg/dist-src/with-defaults.js\nimport { request as Request2 } from \"@octokit/request\";\n\n// pkg/dist-src/graphql.js\nimport { request as Request } from \"@octokit/request\";\n\n// pkg/dist-src/error.js\nfunction _buildMessageForResponseErrors(data) {\n  return `Request failed due to following response errors:\n` + data.errors.map((e) => ` - ${e.message}`).join(\"\\n\");\n}\nvar GraphqlResponseError = class extends Error {\n  constructor(request2, headers, response) {\n    super(_buildMessageForResponseErrors(response));\n    this.request = request2;\n    this.headers = headers;\n    this.response = response;\n    this.errors = response.errors;\n    this.data = response.data;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n  name = \"GraphqlResponseError\";\n  errors;\n  data;\n};\n\n// pkg/dist-src/graphql.js\nvar NON_VARIABLE_OPTIONS = [\n  \"method\",\n  \"baseUrl\",\n  \"url\",\n  \"headers\",\n  \"request\",\n  \"query\",\n  \"mediaType\",\n  \"operationName\"\n];\nvar FORBIDDEN_VARIABLE_OPTIONS = [\"query\", \"method\", \"url\"];\nvar GHES_V3_SUFFIX_REGEX = /\\/api\\/v3\\/?$/;\nfunction graphql(request2, query, options) {\n  if (options) {\n    if (typeof query === \"string\" && \"query\" in options) {\n      return Promise.reject(\n        new Error(`[@octokit/graphql] \"query\" cannot be used as variable name`)\n      );\n    }\n    for (const key in options) {\n      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;\n      return Promise.reject(\n        new Error(\n          `[@octokit/graphql] \"${key}\" cannot be used as variable name`\n        )\n      );\n    }\n  }\n  const parsedOptions = typeof query === \"string\" ? Object.assign({ query }, options) : query;\n  const requestOptions = Object.keys(\n    parsedOptions\n  ).reduce((result, key) => {\n    if (NON_VARIABLE_OPTIONS.includes(key)) {\n      result[key] = parsedOptions[key];\n      return result;\n    }\n    if (!result.variables) {\n      result.variables = {};\n    }\n    result.variables[key] = parsedOptions[key];\n    return result;\n  }, {});\n  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;\n  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {\n    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, \"/api/graphql\");\n  }\n  return request2(requestOptions).then((response) => {\n    if (response.data.errors) {\n      const headers = {};\n      for (const key of Object.keys(response.headers)) {\n        headers[key] = response.headers[key];\n      }\n      throw new GraphqlResponseError(\n        requestOptions,\n        headers,\n        response.data\n      );\n    }\n    return response.data.data;\n  });\n}\n\n// pkg/dist-src/with-defaults.js\nfunction withDefaults(request2, newDefaults) {\n  const newRequest = request2.defaults(newDefaults);\n  const newApi = (query, options) => {\n    return graphql(newRequest, query, options);\n  };\n  return Object.assign(newApi, {\n    defaults: withDefaults.bind(null, newRequest),\n    endpoint: newRequest.endpoint\n  });\n}\n\n// pkg/dist-src/index.js\nvar graphql2 = withDefaults(request, {\n  headers: {\n    \"user-agent\": `octokit-graphql.js/${VERSION} ${getUserAgent()}`\n  },\n  method: \"POST\",\n  url: \"/graphql\"\n});\nfunction withCustomRequest(customRequest) {\n  return withDefaults(customRequest, {\n    method: \"POST\",\n    url: \"/graphql\"\n  });\n}\nexport {\n  GraphqlResponseError,\n  graphql2 as graphql,\n  withCustomRequest\n};\n","// @ts-check\n\nexport function register(state, name, method, options) {\n  if (typeof method !== \"function\") {\n    throw new Error(\"method for before hook must be a function\");\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (Array.isArray(name)) {\n    return name.reverse().reduce((callback, name) => {\n      return register.bind(null, state, name, callback, options);\n    }, method)();\n  }\n\n  return Promise.resolve().then(() => {\n    if (!state.registry[name]) {\n      return method(options);\n    }\n\n    return state.registry[name].reduce((method, registered) => {\n      return registered.hook.bind(null, method, options);\n    }, method)();\n  });\n}\n","// @ts-check\n\nexport function addHook(state, kind, name, hook) {\n  const orig = hook;\n  if (!state.registry[name]) {\n    state.registry[name] = [];\n  }\n\n  if (kind === \"before\") {\n    hook = (method, options) => {\n      return Promise.resolve()\n        .then(orig.bind(null, options))\n        .then(method.bind(null, options));\n    };\n  }\n\n  if (kind === \"after\") {\n    hook = (method, options) => {\n      let result;\n      return Promise.resolve()\n        .then(method.bind(null, options))\n        .then((result_) => {\n          result = result_;\n          return orig(result, options);\n        })\n        .then(() => {\n          return result;\n        });\n    };\n  }\n\n  if (kind === \"error\") {\n    hook = (method, options) => {\n      return Promise.resolve()\n        .then(method.bind(null, options))\n        .catch((error) => {\n          return orig(error, options);\n        });\n    };\n  }\n\n  state.registry[name].push({\n    hook: hook,\n    orig: orig,\n  });\n}\n","// @ts-check\n\nexport function removeHook(state, name, method) {\n  if (!state.registry[name]) {\n    return;\n  }\n\n  const index = state.registry[name]\n    .map((registered) => {\n      return registered.orig;\n    })\n    .indexOf(method);\n\n  if (index === -1) {\n    return;\n  }\n\n  state.registry[name].splice(index, 1);\n}\n","// @ts-check\n\nimport { register } from \"./lib/register.js\";\nimport { addHook } from \"./lib/add.js\";\nimport { removeHook } from \"./lib/remove.js\";\n\n// bind with array of arguments: https://stackoverflow.com/a/21792913\nconst bind = Function.bind;\nconst bindable = bind.bind(bind);\n\nfunction bindApi(hook, state, name) {\n  const removeHookRef = bindable(removeHook, null).apply(\n    null,\n    name ? [state, name] : [state]\n  );\n  hook.api = { remove: removeHookRef };\n  hook.remove = removeHookRef;\n  [\"before\", \"error\", \"after\", \"wrap\"].forEach((kind) => {\n    const args = name ? [state, kind, name] : [state, kind];\n    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);\n  });\n}\n\nfunction Singular() {\n  const singularHookName = Symbol(\"Singular\");\n  const singularHookState = {\n    registry: {},\n  };\n  const singularHook = register.bind(null, singularHookState, singularHookName);\n  bindApi(singularHook, singularHookState, singularHookName);\n  return singularHook;\n}\n\nfunction Collection() {\n  const state = {\n    registry: {},\n  };\n\n  const hook = register.bind(null, state);\n  bindApi(hook, state);\n\n  return hook;\n}\n\nexport default { Singular, Collection };\n","// pkg/dist-src/is-jwt.js\nvar b64url = \"(?:[a-zA-Z0-9_-]+)\";\nvar sep = \"\\\\.\";\nvar jwtRE = new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`);\nvar isJWT = jwtRE.test.bind(jwtRE);\n\n// pkg/dist-src/auth.js\nasync function auth(token) {\n  const isApp = isJWT(token);\n  const isInstallation = token.startsWith(\"v1.\") || token.startsWith(\"ghs_\");\n  const isUserToServer = token.startsWith(\"ghu_\");\n  const tokenType = isApp ? \"app\" : isInstallation ? \"installation\" : isUserToServer ? \"user-to-server\" : \"oauth\";\n  return {\n    type: \"token\",\n    token,\n    tokenType\n  };\n}\n\n// pkg/dist-src/with-authorization-prefix.js\nfunction withAuthorizationPrefix(token) {\n  if (token.split(/\\./).length === 3) {\n    return `bearer ${token}`;\n  }\n  return `token ${token}`;\n}\n\n// pkg/dist-src/hook.js\nasync function hook(token, request, route, parameters) {\n  const endpoint = request.endpoint.merge(\n    route,\n    parameters\n  );\n  endpoint.headers.authorization = withAuthorizationPrefix(token);\n  return request(endpoint);\n}\n\n// pkg/dist-src/index.js\nvar createTokenAuth = function createTokenAuth2(token) {\n  if (!token) {\n    throw new Error(\"[@octokit/auth-token] No token passed to createTokenAuth\");\n  }\n  if (typeof token !== \"string\") {\n    throw new Error(\n      \"[@octokit/auth-token] Token passed to createTokenAuth is not a string\"\n    );\n  }\n  token = token.replace(/^(token|bearer) +/i, \"\");\n  return Object.assign(auth.bind(null, token), {\n    hook: hook.bind(null, token)\n  });\n};\nexport {\n  createTokenAuth\n};\n","const VERSION = \"6.1.5\";\nexport {\n  VERSION\n};\n","import { getUserAgent } from \"universal-user-agent\";\nimport Hook from \"before-after-hook\";\nimport { request } from \"@octokit/request\";\nimport { withCustomRequest } from \"@octokit/graphql\";\nimport { createTokenAuth } from \"@octokit/auth-token\";\nimport { VERSION } from \"./version.js\";\nconst noop = () => {\n};\nconst consoleWarn = console.warn.bind(console);\nconst consoleError = console.error.bind(console);\nconst userAgentTrail = `octokit-core.js/${VERSION} ${getUserAgent()}`;\nclass Octokit {\n  static VERSION = VERSION;\n  static defaults(defaults) {\n    const OctokitWithDefaults = class extends this {\n      constructor(...args) {\n        const options = args[0] || {};\n        if (typeof defaults === \"function\") {\n          super(defaults(options));\n          return;\n        }\n        super(\n          Object.assign(\n            {},\n            defaults,\n            options,\n            options.userAgent && defaults.userAgent ? {\n              userAgent: `${options.userAgent} ${defaults.userAgent}`\n            } : null\n          )\n        );\n      }\n    };\n    return OctokitWithDefaults;\n  }\n  static plugins = [];\n  /**\n   * Attach a plugin (or many) to your Octokit instance.\n   *\n   * @example\n   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)\n   */\n  static plugin(...newPlugins) {\n    const currentPlugins = this.plugins;\n    const NewOctokit = class extends this {\n      static plugins = currentPlugins.concat(\n        newPlugins.filter((plugin) => !currentPlugins.includes(plugin))\n      );\n    };\n    return NewOctokit;\n  }\n  constructor(options = {}) {\n    const hook = new Hook.Collection();\n    const requestDefaults = {\n      baseUrl: request.endpoint.DEFAULTS.baseUrl,\n      headers: {},\n      request: Object.assign({}, options.request, {\n        // @ts-ignore internal usage only, no need to type\n        hook: hook.bind(null, \"request\")\n      }),\n      mediaType: {\n        previews: [],\n        format: \"\"\n      }\n    };\n    requestDefaults.headers[\"user-agent\"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;\n    if (options.baseUrl) {\n      requestDefaults.baseUrl = options.baseUrl;\n    }\n    if (options.previews) {\n      requestDefaults.mediaType.previews = options.previews;\n    }\n    if (options.timeZone) {\n      requestDefaults.headers[\"time-zone\"] = options.timeZone;\n    }\n    this.request = request.defaults(requestDefaults);\n    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);\n    this.log = Object.assign(\n      {\n        debug: noop,\n        info: noop,\n        warn: consoleWarn,\n        error: consoleError\n      },\n      options.log\n    );\n    this.hook = hook;\n    if (!options.authStrategy) {\n      if (!options.auth) {\n        this.auth = async () => ({\n          type: \"unauthenticated\"\n        });\n      } else {\n        const auth = createTokenAuth(options.auth);\n        hook.wrap(\"request\", auth.hook);\n        this.auth = auth;\n      }\n    } else {\n      const { authStrategy, ...otherOptions } = options;\n      const auth = authStrategy(\n        Object.assign(\n          {\n            request: this.request,\n            log: this.log,\n            // we pass the current octokit instance as well as its constructor options\n            // to allow for authentication strategies that return a new octokit instance\n            // that shares the same internal state as the current one. The original\n            // requirement for this was the \"event-octokit\" authentication strategy\n            // of https://github.com/probot/octokit-auth-probot.\n            octokit: this,\n            octokitOptions: otherOptions\n          },\n          options.auth\n        )\n      );\n      hook.wrap(\"request\", auth.hook);\n      this.auth = auth;\n    }\n    const classConstructor = this.constructor;\n    for (let i = 0; i < classConstructor.plugins.length; ++i) {\n      Object.assign(this, classConstructor.plugins[i](this, options));\n    }\n  }\n  // assigned during constructor\n  request;\n  graphql;\n  log;\n  hook;\n  // TODO: type `octokit.auth` based on passed options.authStrategy\n  auth;\n}\nexport {\n  Octokit\n};\n","const VERSION = \"5.3.1\";\nexport {\n  VERSION\n};\n","import { VERSION } from \"./version.js\";\nfunction requestLog(octokit) {\n  octokit.hook.wrap(\"request\", (request, options) => {\n    octokit.log.debug(\"request\", options);\n    const start = Date.now();\n    const requestOptions = octokit.request.endpoint.parse(options);\n    const path = requestOptions.url.replace(options.baseUrl, \"\");\n    return request(options).then((response) => {\n      const requestId = response.headers[\"x-github-request-id\"];\n      octokit.log.info(\n        `${requestOptions.method} ${path} - ${response.status} with id ${requestId} in ${Date.now() - start}ms`\n      );\n      return response;\n    }).catch((error) => {\n      const requestId = error.response?.headers[\"x-github-request-id\"] || \"UNKNOWN\";\n      octokit.log.error(\n        `${requestOptions.method} ${path} - ${error.status} with id ${requestId} in ${Date.now() - start}ms`\n      );\n      throw error;\n    });\n  });\n}\nrequestLog.VERSION = VERSION;\nexport {\n  requestLog\n};\n","// pkg/dist-src/version.js\nvar VERSION = \"0.0.0-development\";\n\n// pkg/dist-src/normalize-paginated-list-response.js\nfunction normalizePaginatedListResponse(response) {\n  if (!response.data) {\n    return {\n      ...response,\n      data: []\n    };\n  }\n  const responseNeedsNormalization = \"total_count\" in response.data && !(\"url\" in response.data);\n  if (!responseNeedsNormalization) return response;\n  const incompleteResults = response.data.incomplete_results;\n  const repositorySelection = response.data.repository_selection;\n  const totalCount = response.data.total_count;\n  delete response.data.incomplete_results;\n  delete response.data.repository_selection;\n  delete response.data.total_count;\n  const namespaceKey = Object.keys(response.data)[0];\n  const data = response.data[namespaceKey];\n  response.data = data;\n  if (typeof incompleteResults !== \"undefined\") {\n    response.data.incomplete_results = incompleteResults;\n  }\n  if (typeof repositorySelection !== \"undefined\") {\n    response.data.repository_selection = repositorySelection;\n  }\n  response.data.total_count = totalCount;\n  return response;\n}\n\n// pkg/dist-src/iterator.js\nfunction iterator(octokit, route, parameters) {\n  const options = typeof route === \"function\" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);\n  const requestMethod = typeof route === \"function\" ? route : octokit.request;\n  const method = options.method;\n  const headers = options.headers;\n  let url = options.url;\n  return {\n    [Symbol.asyncIterator]: () => ({\n      async next() {\n        if (!url) return { done: true };\n        try {\n          const response = await requestMethod({ method, url, headers });\n          const normalizedResponse = normalizePaginatedListResponse(response);\n          url = ((normalizedResponse.headers.link || \"\").match(\n            /<([^<>]+)>;\\s*rel=\"next\"/\n          ) || [])[1];\n          return { value: normalizedResponse };\n        } catch (error) {\n          if (error.status !== 409) throw error;\n          url = \"\";\n          return {\n            value: {\n              status: 200,\n              headers: {},\n              data: []\n            }\n          };\n        }\n      }\n    })\n  };\n}\n\n// pkg/dist-src/paginate.js\nfunction paginate(octokit, route, parameters, mapFn) {\n  if (typeof parameters === \"function\") {\n    mapFn = parameters;\n    parameters = void 0;\n  }\n  return gather(\n    octokit,\n    [],\n    iterator(octokit, route, parameters)[Symbol.asyncIterator](),\n    mapFn\n  );\n}\nfunction gather(octokit, results, iterator2, mapFn) {\n  return iterator2.next().then((result) => {\n    if (result.done) {\n      return results;\n    }\n    let earlyExit = false;\n    function done() {\n      earlyExit = true;\n    }\n    results = results.concat(\n      mapFn ? mapFn(result.value, done) : result.value.data\n    );\n    if (earlyExit) {\n      return results;\n    }\n    return gather(octokit, results, iterator2, mapFn);\n  });\n}\n\n// pkg/dist-src/compose-paginate.js\nvar composePaginateRest = Object.assign(paginate, {\n  iterator\n});\n\n// pkg/dist-src/generated/paginating-endpoints.js\nvar paginatingEndpoints = [\n  \"GET /advisories\",\n  \"GET /app/hook/deliveries\",\n  \"GET /app/installation-requests\",\n  \"GET /app/installations\",\n  \"GET /assignments/{assignment_id}/accepted_assignments\",\n  \"GET /classrooms\",\n  \"GET /classrooms/{classroom_id}/assignments\",\n  \"GET /enterprises/{enterprise}/code-security/configurations\",\n  \"GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories\",\n  \"GET /enterprises/{enterprise}/dependabot/alerts\",\n  \"GET /enterprises/{enterprise}/secret-scanning/alerts\",\n  \"GET /events\",\n  \"GET /gists\",\n  \"GET /gists/public\",\n  \"GET /gists/starred\",\n  \"GET /gists/{gist_id}/comments\",\n  \"GET /gists/{gist_id}/commits\",\n  \"GET /gists/{gist_id}/forks\",\n  \"GET /installation/repositories\",\n  \"GET /issues\",\n  \"GET /licenses\",\n  \"GET /marketplace_listing/plans\",\n  \"GET /marketplace_listing/plans/{plan_id}/accounts\",\n  \"GET /marketplace_listing/stubbed/plans\",\n  \"GET /marketplace_listing/stubbed/plans/{plan_id}/accounts\",\n  \"GET /networks/{owner}/{repo}/events\",\n  \"GET /notifications\",\n  \"GET /organizations\",\n  \"GET /orgs/{org}/actions/cache/usage-by-repository\",\n  \"GET /orgs/{org}/actions/hosted-runners\",\n  \"GET /orgs/{org}/actions/permissions/repositories\",\n  \"GET /orgs/{org}/actions/runner-groups\",\n  \"GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners\",\n  \"GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories\",\n  \"GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners\",\n  \"GET /orgs/{org}/actions/runners\",\n  \"GET /orgs/{org}/actions/secrets\",\n  \"GET /orgs/{org}/actions/secrets/{secret_name}/repositories\",\n  \"GET /orgs/{org}/actions/variables\",\n  \"GET /orgs/{org}/actions/variables/{name}/repositories\",\n  \"GET /orgs/{org}/attestations/{subject_digest}\",\n  \"GET /orgs/{org}/blocks\",\n  \"GET /orgs/{org}/code-scanning/alerts\",\n  \"GET /orgs/{org}/code-security/configurations\",\n  \"GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories\",\n  \"GET /orgs/{org}/codespaces\",\n  \"GET /orgs/{org}/codespaces/secrets\",\n  \"GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories\",\n  \"GET /orgs/{org}/copilot/billing/seats\",\n  \"GET /orgs/{org}/copilot/metrics\",\n  \"GET /orgs/{org}/copilot/usage\",\n  \"GET /orgs/{org}/dependabot/alerts\",\n  \"GET /orgs/{org}/dependabot/secrets\",\n  \"GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories\",\n  \"GET /orgs/{org}/events\",\n  \"GET /orgs/{org}/failed_invitations\",\n  \"GET /orgs/{org}/hooks\",\n  \"GET /orgs/{org}/hooks/{hook_id}/deliveries\",\n  \"GET /orgs/{org}/insights/api/route-stats/{actor_type}/{actor_id}\",\n  \"GET /orgs/{org}/insights/api/subject-stats\",\n  \"GET /orgs/{org}/insights/api/user-stats/{user_id}\",\n  \"GET /orgs/{org}/installations\",\n  \"GET /orgs/{org}/invitations\",\n  \"GET /orgs/{org}/invitations/{invitation_id}/teams\",\n  \"GET /orgs/{org}/issues\",\n  \"GET /orgs/{org}/members\",\n  \"GET /orgs/{org}/members/{username}/codespaces\",\n  \"GET /orgs/{org}/migrations\",\n  \"GET /orgs/{org}/migrations/{migration_id}/repositories\",\n  \"GET /orgs/{org}/organization-roles/{role_id}/teams\",\n  \"GET /orgs/{org}/organization-roles/{role_id}/users\",\n  \"GET /orgs/{org}/outside_collaborators\",\n  \"GET /orgs/{org}/packages\",\n  \"GET /orgs/{org}/packages/{package_type}/{package_name}/versions\",\n  \"GET /orgs/{org}/personal-access-token-requests\",\n  \"GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories\",\n  \"GET /orgs/{org}/personal-access-tokens\",\n  \"GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories\",\n  \"GET /orgs/{org}/private-registries\",\n  \"GET /orgs/{org}/projects\",\n  \"GET /orgs/{org}/properties/values\",\n  \"GET /orgs/{org}/public_members\",\n  \"GET /orgs/{org}/repos\",\n  \"GET /orgs/{org}/rulesets\",\n  \"GET /orgs/{org}/rulesets/rule-suites\",\n  \"GET /orgs/{org}/rulesets/{ruleset_id}/history\",\n  \"GET /orgs/{org}/secret-scanning/alerts\",\n  \"GET /orgs/{org}/security-advisories\",\n  \"GET /orgs/{org}/settings/network-configurations\",\n  \"GET /orgs/{org}/team/{team_slug}/copilot/metrics\",\n  \"GET /orgs/{org}/team/{team_slug}/copilot/usage\",\n  \"GET /orgs/{org}/teams\",\n  \"GET /orgs/{org}/teams/{team_slug}/discussions\",\n  \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\",\n  \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions\",\n  \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions\",\n  \"GET /orgs/{org}/teams/{team_slug}/invitations\",\n  \"GET /orgs/{org}/teams/{team_slug}/members\",\n  \"GET /orgs/{org}/teams/{team_slug}/projects\",\n  \"GET /orgs/{org}/teams/{team_slug}/repos\",\n  \"GET /orgs/{org}/teams/{team_slug}/teams\",\n  \"GET /projects/columns/{column_id}/cards\",\n  \"GET /projects/{project_id}/collaborators\",\n  \"GET /projects/{project_id}/columns\",\n  \"GET /repos/{owner}/{repo}/actions/artifacts\",\n  \"GET /repos/{owner}/{repo}/actions/caches\",\n  \"GET /repos/{owner}/{repo}/actions/organization-secrets\",\n  \"GET /repos/{owner}/{repo}/actions/organization-variables\",\n  \"GET /repos/{owner}/{repo}/actions/runners\",\n  \"GET /repos/{owner}/{repo}/actions/runs\",\n  \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts\",\n  \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs\",\n  \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs\",\n  \"GET /repos/{owner}/{repo}/actions/secrets\",\n  \"GET /repos/{owner}/{repo}/actions/variables\",\n  \"GET /repos/{owner}/{repo}/actions/workflows\",\n  \"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs\",\n  \"GET /repos/{owner}/{repo}/activity\",\n  \"GET /repos/{owner}/{repo}/assignees\",\n  \"GET /repos/{owner}/{repo}/attestations/{subject_digest}\",\n  \"GET /repos/{owner}/{repo}/branches\",\n  \"GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations\",\n  \"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs\",\n  \"GET /repos/{owner}/{repo}/code-scanning/alerts\",\n  \"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances\",\n  \"GET /repos/{owner}/{repo}/code-scanning/analyses\",\n  \"GET /repos/{owner}/{repo}/codespaces\",\n  \"GET /repos/{owner}/{repo}/codespaces/devcontainers\",\n  \"GET /repos/{owner}/{repo}/codespaces/secrets\",\n  \"GET /repos/{owner}/{repo}/collaborators\",\n  \"GET /repos/{owner}/{repo}/comments\",\n  \"GET /repos/{owner}/{repo}/comments/{comment_id}/reactions\",\n  \"GET /repos/{owner}/{repo}/commits\",\n  \"GET /repos/{owner}/{repo}/commits/{commit_sha}/comments\",\n  \"GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls\",\n  \"GET /repos/{owner}/{repo}/commits/{ref}/check-runs\",\n  \"GET /repos/{owner}/{repo}/commits/{ref}/check-suites\",\n  \"GET /repos/{owner}/{repo}/commits/{ref}/status\",\n  \"GET /repos/{owner}/{repo}/commits/{ref}/statuses\",\n  \"GET /repos/{owner}/{repo}/contributors\",\n  \"GET /repos/{owner}/{repo}/dependabot/alerts\",\n  \"GET /repos/{owner}/{repo}/dependabot/secrets\",\n  \"GET /repos/{owner}/{repo}/deployments\",\n  \"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses\",\n  \"GET /repos/{owner}/{repo}/environments\",\n  \"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies\",\n  \"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps\",\n  \"GET /repos/{owner}/{repo}/environments/{environment_name}/secrets\",\n  \"GET /repos/{owner}/{repo}/environments/{environment_name}/variables\",\n  \"GET /repos/{owner}/{repo}/events\",\n  \"GET /repos/{owner}/{repo}/forks\",\n  \"GET /repos/{owner}/{repo}/hooks\",\n  \"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries\",\n  \"GET /repos/{owner}/{repo}/invitations\",\n  \"GET /repos/{owner}/{repo}/issues\",\n  \"GET /repos/{owner}/{repo}/issues/comments\",\n  \"GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions\",\n  \"GET /repos/{owner}/{repo}/issues/events\",\n  \"GET /repos/{owner}/{repo}/issues/{issue_number}/comments\",\n  \"GET /repos/{owner}/{repo}/issues/{issue_number}/events\",\n  \"GET /repos/{owner}/{repo}/issues/{issue_number}/labels\",\n  \"GET /repos/{owner}/{repo}/issues/{issue_number}/reactions\",\n  \"GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues\",\n  \"GET /repos/{owner}/{repo}/issues/{issue_number}/timeline\",\n  \"GET /repos/{owner}/{repo}/keys\",\n  \"GET /repos/{owner}/{repo}/labels\",\n  \"GET /repos/{owner}/{repo}/milestones\",\n  \"GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels\",\n  \"GET /repos/{owner}/{repo}/notifications\",\n  \"GET /repos/{owner}/{repo}/pages/builds\",\n  \"GET /repos/{owner}/{repo}/projects\",\n  \"GET /repos/{owner}/{repo}/pulls\",\n  \"GET /repos/{owner}/{repo}/pulls/comments\",\n  \"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions\",\n  \"GET /repos/{owner}/{repo}/pulls/{pull_number}/comments\",\n  \"GET /repos/{owner}/{repo}/pulls/{pull_number}/commits\",\n  \"GET /repos/{owner}/{repo}/pulls/{pull_number}/files\",\n  \"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews\",\n  \"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments\",\n  \"GET /repos/{owner}/{repo}/releases\",\n  \"GET /repos/{owner}/{repo}/releases/{release_id}/assets\",\n  \"GET /repos/{owner}/{repo}/releases/{release_id}/reactions\",\n  \"GET /repos/{owner}/{repo}/rules/branches/{branch}\",\n  \"GET /repos/{owner}/{repo}/rulesets\",\n  \"GET /repos/{owner}/{repo}/rulesets/rule-suites\",\n  \"GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history\",\n  \"GET /repos/{owner}/{repo}/secret-scanning/alerts\",\n  \"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations\",\n  \"GET /repos/{owner}/{repo}/security-advisories\",\n  \"GET /repos/{owner}/{repo}/stargazers\",\n  \"GET /repos/{owner}/{repo}/subscribers\",\n  \"GET /repos/{owner}/{repo}/tags\",\n  \"GET /repos/{owner}/{repo}/teams\",\n  \"GET /repos/{owner}/{repo}/topics\",\n  \"GET /repositories\",\n  \"GET /search/code\",\n  \"GET /search/commits\",\n  \"GET /search/issues\",\n  \"GET /search/labels\",\n  \"GET /search/repositories\",\n  \"GET /search/topics\",\n  \"GET /search/users\",\n  \"GET /teams/{team_id}/discussions\",\n  \"GET /teams/{team_id}/discussions/{discussion_number}/comments\",\n  \"GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions\",\n  \"GET /teams/{team_id}/discussions/{discussion_number}/reactions\",\n  \"GET /teams/{team_id}/invitations\",\n  \"GET /teams/{team_id}/members\",\n  \"GET /teams/{team_id}/projects\",\n  \"GET /teams/{team_id}/repos\",\n  \"GET /teams/{team_id}/teams\",\n  \"GET /user/blocks\",\n  \"GET /user/codespaces\",\n  \"GET /user/codespaces/secrets\",\n  \"GET /user/emails\",\n  \"GET /user/followers\",\n  \"GET /user/following\",\n  \"GET /user/gpg_keys\",\n  \"GET /user/installations\",\n  \"GET /user/installations/{installation_id}/repositories\",\n  \"GET /user/issues\",\n  \"GET /user/keys\",\n  \"GET /user/marketplace_purchases\",\n  \"GET /user/marketplace_purchases/stubbed\",\n  \"GET /user/memberships/orgs\",\n  \"GET /user/migrations\",\n  \"GET /user/migrations/{migration_id}/repositories\",\n  \"GET /user/orgs\",\n  \"GET /user/packages\",\n  \"GET /user/packages/{package_type}/{package_name}/versions\",\n  \"GET /user/public_emails\",\n  \"GET /user/repos\",\n  \"GET /user/repository_invitations\",\n  \"GET /user/social_accounts\",\n  \"GET /user/ssh_signing_keys\",\n  \"GET /user/starred\",\n  \"GET /user/subscriptions\",\n  \"GET /user/teams\",\n  \"GET /users\",\n  \"GET /users/{username}/attestations/{subject_digest}\",\n  \"GET /users/{username}/events\",\n  \"GET /users/{username}/events/orgs/{org}\",\n  \"GET /users/{username}/events/public\",\n  \"GET /users/{username}/followers\",\n  \"GET /users/{username}/following\",\n  \"GET /users/{username}/gists\",\n  \"GET /users/{username}/gpg_keys\",\n  \"GET /users/{username}/keys\",\n  \"GET /users/{username}/orgs\",\n  \"GET /users/{username}/packages\",\n  \"GET /users/{username}/projects\",\n  \"GET /users/{username}/received_events\",\n  \"GET /users/{username}/received_events/public\",\n  \"GET /users/{username}/repos\",\n  \"GET /users/{username}/social_accounts\",\n  \"GET /users/{username}/ssh_signing_keys\",\n  \"GET /users/{username}/starred\",\n  \"GET /users/{username}/subscriptions\"\n];\n\n// pkg/dist-src/paginating-endpoints.js\nfunction isPaginatingEndpoint(arg) {\n  if (typeof arg === \"string\") {\n    return paginatingEndpoints.includes(arg);\n  } else {\n    return false;\n  }\n}\n\n// pkg/dist-src/index.js\nfunction paginateRest(octokit) {\n  return {\n    paginate: Object.assign(paginate.bind(null, octokit), {\n      iterator: iterator.bind(null, octokit)\n    })\n  };\n}\npaginateRest.VERSION = VERSION;\nexport {\n  composePaginateRest,\n  isPaginatingEndpoint,\n  paginateRest,\n  paginatingEndpoints\n};\n","const VERSION = \"13.5.0\";\nexport {\n  VERSION\n};\n//# sourceMappingURL=version.js.map\n","const Endpoints = {\n  actions: {\n    addCustomLabelsToSelfHostedRunnerForOrg: [\n      \"POST /orgs/{org}/actions/runners/{runner_id}/labels\"\n    ],\n    addCustomLabelsToSelfHostedRunnerForRepo: [\n      \"POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels\"\n    ],\n    addRepoAccessToSelfHostedRunnerGroupInOrg: [\n      \"PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}\"\n    ],\n    addSelectedRepoToOrgSecret: [\n      \"PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}\"\n    ],\n    addSelectedRepoToOrgVariable: [\n      \"PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}\"\n    ],\n    approveWorkflowRun: [\n      \"POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve\"\n    ],\n    cancelWorkflowRun: [\n      \"POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel\"\n    ],\n    createEnvironmentVariable: [\n      \"POST /repos/{owner}/{repo}/environments/{environment_name}/variables\"\n    ],\n    createHostedRunnerForOrg: [\"POST /orgs/{org}/actions/hosted-runners\"],\n    createOrUpdateEnvironmentSecret: [\n      \"PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}\"\n    ],\n    createOrUpdateOrgSecret: [\"PUT /orgs/{org}/actions/secrets/{secret_name}\"],\n    createOrUpdateRepoSecret: [\n      \"PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}\"\n    ],\n    createOrgVariable: [\"POST /orgs/{org}/actions/variables\"],\n    createRegistrationTokenForOrg: [\n      \"POST /orgs/{org}/actions/runners/registration-token\"\n    ],\n    createRegistrationTokenForRepo: [\n      \"POST /repos/{owner}/{repo}/actions/runners/registration-token\"\n    ],\n    createRemoveTokenForOrg: [\"POST /orgs/{org}/actions/runners/remove-token\"],\n    createRemoveTokenForRepo: [\n      \"POST /repos/{owner}/{repo}/actions/runners/remove-token\"\n    ],\n    createRepoVariable: [\"POST /repos/{owner}/{repo}/actions/variables\"],\n    createWorkflowDispatch: [\n      \"POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches\"\n    ],\n    deleteActionsCacheById: [\n      \"DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}\"\n    ],\n    deleteActionsCacheByKey: [\n      \"DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}\"\n    ],\n    deleteArtifact: [\n      \"DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}\"\n    ],\n    deleteEnvironmentSecret: [\n      \"DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}\"\n    ],\n    deleteEnvironmentVariable: [\n      \"DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}\"\n    ],\n    deleteHostedRunnerForOrg: [\n      \"DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id}\"\n    ],\n    deleteOrgSecret: [\"DELETE /orgs/{org}/actions/secrets/{secret_name}\"],\n    deleteOrgVariable: [\"DELETE /orgs/{org}/actions/variables/{name}\"],\n    deleteRepoSecret: [\n      \"DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}\"\n    ],\n    deleteRepoVariable: [\n      \"DELETE /repos/{owner}/{repo}/actions/variables/{name}\"\n    ],\n    deleteSelfHostedRunnerFromOrg: [\n      \"DELETE /orgs/{org}/actions/runners/{runner_id}\"\n    ],\n    deleteSelfHostedRunnerFromRepo: [\n      \"DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}\"\n    ],\n    deleteWorkflowRun: [\"DELETE /repos/{owner}/{repo}/actions/runs/{run_id}\"],\n    deleteWorkflowRunLogs: [\n      \"DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs\"\n    ],\n    disableSelectedRepositoryGithubActionsOrganization: [\n      \"DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}\"\n    ],\n    disableWorkflow: [\n      \"PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable\"\n    ],\n    downloadArtifact: [\n      \"GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}\"\n    ],\n    downloadJobLogsForWorkflowRun: [\n      \"GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs\"\n    ],\n    downloadWorkflowRunAttemptLogs: [\n      \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs\"\n    ],\n    downloadWorkflowRunLogs: [\n      \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs\"\n    ],\n    enableSelectedRepositoryGithubActionsOrganization: [\n      \"PUT /orgs/{org}/actions/permissions/repositories/{repository_id}\"\n    ],\n    enableWorkflow: [\n      \"PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable\"\n    ],\n    forceCancelWorkflowRun: [\n      \"POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel\"\n    ],\n    generateRunnerJitconfigForOrg: [\n      \"POST /orgs/{org}/actions/runners/generate-jitconfig\"\n    ],\n    generateRunnerJitconfigForRepo: [\n      \"POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig\"\n    ],\n    getActionsCacheList: [\"GET /repos/{owner}/{repo}/actions/caches\"],\n    getActionsCacheUsage: [\"GET /repos/{owner}/{repo}/actions/cache/usage\"],\n    getActionsCacheUsageByRepoForOrg: [\n      \"GET /orgs/{org}/actions/cache/usage-by-repository\"\n    ],\n    getActionsCacheUsageForOrg: [\"GET /orgs/{org}/actions/cache/usage\"],\n    getAllowedActionsOrganization: [\n      \"GET /orgs/{org}/actions/permissions/selected-actions\"\n    ],\n    getAllowedActionsRepository: [\n      \"GET /repos/{owner}/{repo}/actions/permissions/selected-actions\"\n    ],\n    getArtifact: [\"GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}\"],\n    getCustomOidcSubClaimForRepo: [\n      \"GET /repos/{owner}/{repo}/actions/oidc/customization/sub\"\n    ],\n    getEnvironmentPublicKey: [\n      \"GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key\"\n    ],\n    getEnvironmentSecret: [\n      \"GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}\"\n    ],\n    getEnvironmentVariable: [\n      \"GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}\"\n    ],\n    getGithubActionsDefaultWorkflowPermissionsOrganization: [\n      \"GET /orgs/{org}/actions/permissions/workflow\"\n    ],\n    getGithubActionsDefaultWorkflowPermissionsRepository: [\n      \"GET /repos/{owner}/{repo}/actions/permissions/workflow\"\n    ],\n    getGithubActionsPermissionsOrganization: [\n      \"GET /orgs/{org}/actions/permissions\"\n    ],\n    getGithubActionsPermissionsRepository: [\n      \"GET /repos/{owner}/{repo}/actions/permissions\"\n    ],\n    getHostedRunnerForOrg: [\n      \"GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id}\"\n    ],\n    getHostedRunnersGithubOwnedImagesForOrg: [\n      \"GET /orgs/{org}/actions/hosted-runners/images/github-owned\"\n    ],\n    getHostedRunnersLimitsForOrg: [\n      \"GET /orgs/{org}/actions/hosted-runners/limits\"\n    ],\n    getHostedRunnersMachineSpecsForOrg: [\n      \"GET /orgs/{org}/actions/hosted-runners/machine-sizes\"\n    ],\n    getHostedRunnersPartnerImagesForOrg: [\n      \"GET /orgs/{org}/actions/hosted-runners/images/partner\"\n    ],\n    getHostedRunnersPlatformsForOrg: [\n      \"GET /orgs/{org}/actions/hosted-runners/platforms\"\n    ],\n    getJobForWorkflowRun: [\"GET /repos/{owner}/{repo}/actions/jobs/{job_id}\"],\n    getOrgPublicKey: [\"GET /orgs/{org}/actions/secrets/public-key\"],\n    getOrgSecret: [\"GET /orgs/{org}/actions/secrets/{secret_name}\"],\n    getOrgVariable: [\"GET /orgs/{org}/actions/variables/{name}\"],\n    getPendingDeploymentsForRun: [\n      \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments\"\n    ],\n    getRepoPermissions: [\n      \"GET /repos/{owner}/{repo}/actions/permissions\",\n      {},\n      { renamed: [\"actions\", \"getGithubActionsPermissionsRepository\"] }\n    ],\n    getRepoPublicKey: [\"GET /repos/{owner}/{repo}/actions/secrets/public-key\"],\n    getRepoSecret: [\"GET /repos/{owner}/{repo}/actions/secrets/{secret_name}\"],\n    getRepoVariable: [\"GET /repos/{owner}/{repo}/actions/variables/{name}\"],\n    getReviewsForRun: [\n      \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals\"\n    ],\n    getSelfHostedRunnerForOrg: [\"GET /orgs/{org}/actions/runners/{runner_id}\"],\n    getSelfHostedRunnerForRepo: [\n      \"GET /repos/{owner}/{repo}/actions/runners/{runner_id}\"\n    ],\n    getWorkflow: [\"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}\"],\n    getWorkflowAccessToRepository: [\n      \"GET /repos/{owner}/{repo}/actions/permissions/access\"\n    ],\n    getWorkflowRun: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}\"],\n    getWorkflowRunAttempt: [\n      \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}\"\n    ],\n    getWorkflowRunUsage: [\n      \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing\"\n    ],\n    getWorkflowUsage: [\n      \"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing\"\n    ],\n    listArtifactsForRepo: [\"GET /repos/{owner}/{repo}/actions/artifacts\"],\n    listEnvironmentSecrets: [\n      \"GET /repos/{owner}/{repo}/environments/{environment_name}/secrets\"\n    ],\n    listEnvironmentVariables: [\n      \"GET /repos/{owner}/{repo}/environments/{environment_name}/variables\"\n    ],\n    listGithubHostedRunnersInGroupForOrg: [\n      \"GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners\"\n    ],\n    listHostedRunnersForOrg: [\"GET /orgs/{org}/actions/hosted-runners\"],\n    listJobsForWorkflowRun: [\n      \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs\"\n    ],\n    listJobsForWorkflowRunAttempt: [\n      \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs\"\n    ],\n    listLabelsForSelfHostedRunnerForOrg: [\n      \"GET /orgs/{org}/actions/runners/{runner_id}/labels\"\n    ],\n    listLabelsForSelfHostedRunnerForRepo: [\n      \"GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels\"\n    ],\n    listOrgSecrets: [\"GET /orgs/{org}/actions/secrets\"],\n    listOrgVariables: [\"GET /orgs/{org}/actions/variables\"],\n    listRepoOrganizationSecrets: [\n      \"GET /repos/{owner}/{repo}/actions/organization-secrets\"\n    ],\n    listRepoOrganizationVariables: [\n      \"GET /repos/{owner}/{repo}/actions/organization-variables\"\n    ],\n    listRepoSecrets: [\"GET /repos/{owner}/{repo}/actions/secrets\"],\n    listRepoVariables: [\"GET /repos/{owner}/{repo}/actions/variables\"],\n    listRepoWorkflows: [\"GET /repos/{owner}/{repo}/actions/workflows\"],\n    listRunnerApplicationsForOrg: [\"GET /orgs/{org}/actions/runners/downloads\"],\n    listRunnerApplicationsForRepo: [\n      \"GET /repos/{owner}/{repo}/actions/runners/downloads\"\n    ],\n    listSelectedReposForOrgSecret: [\n      \"GET /orgs/{org}/actions/secrets/{secret_name}/repositories\"\n    ],\n    listSelectedReposForOrgVariable: [\n      \"GET /orgs/{org}/actions/variables/{name}/repositories\"\n    ],\n    listSelectedRepositoriesEnabledGithubActionsOrganization: [\n      \"GET /orgs/{org}/actions/permissions/repositories\"\n    ],\n    listSelfHostedRunnersForOrg: [\"GET /orgs/{org}/actions/runners\"],\n    listSelfHostedRunnersForRepo: [\"GET /repos/{owner}/{repo}/actions/runners\"],\n    listWorkflowRunArtifacts: [\n      \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts\"\n    ],\n    listWorkflowRuns: [\n      \"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs\"\n    ],\n    listWorkflowRunsForRepo: [\"GET /repos/{owner}/{repo}/actions/runs\"],\n    reRunJobForWorkflowRun: [\n      \"POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun\"\n    ],\n    reRunWorkflow: [\"POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun\"],\n    reRunWorkflowFailedJobs: [\n      \"POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs\"\n    ],\n    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [\n      \"DELETE /orgs/{org}/actions/runners/{runner_id}/labels\"\n    ],\n    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [\n      \"DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels\"\n    ],\n    removeCustomLabelFromSelfHostedRunnerForOrg: [\n      \"DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}\"\n    ],\n    removeCustomLabelFromSelfHostedRunnerForRepo: [\n      \"DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}\"\n    ],\n    removeSelectedRepoFromOrgSecret: [\n      \"DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}\"\n    ],\n    removeSelectedRepoFromOrgVariable: [\n      \"DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}\"\n    ],\n    reviewCustomGatesForRun: [\n      \"POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule\"\n    ],\n    reviewPendingDeploymentsForRun: [\n      \"POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments\"\n    ],\n    setAllowedActionsOrganization: [\n      \"PUT /orgs/{org}/actions/permissions/selected-actions\"\n    ],\n    setAllowedActionsRepository: [\n      \"PUT /repos/{owner}/{repo}/actions/permissions/selected-actions\"\n    ],\n    setCustomLabelsForSelfHostedRunnerForOrg: [\n      \"PUT /orgs/{org}/actions/runners/{runner_id}/labels\"\n    ],\n    setCustomLabelsForSelfHostedRunnerForRepo: [\n      \"PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels\"\n    ],\n    setCustomOidcSubClaimForRepo: [\n      \"PUT /repos/{owner}/{repo}/actions/oidc/customization/sub\"\n    ],\n    setGithubActionsDefaultWorkflowPermissionsOrganization: [\n      \"PUT /orgs/{org}/actions/permissions/workflow\"\n    ],\n    setGithubActionsDefaultWorkflowPermissionsRepository: [\n      \"PUT /repos/{owner}/{repo}/actions/permissions/workflow\"\n    ],\n    setGithubActionsPermissionsOrganization: [\n      \"PUT /orgs/{org}/actions/permissions\"\n    ],\n    setGithubActionsPermissionsRepository: [\n      \"PUT /repos/{owner}/{repo}/actions/permissions\"\n    ],\n    setSelectedReposForOrgSecret: [\n      \"PUT /orgs/{org}/actions/secrets/{secret_name}/repositories\"\n    ],\n    setSelectedReposForOrgVariable: [\n      \"PUT /orgs/{org}/actions/variables/{name}/repositories\"\n    ],\n    setSelectedRepositoriesEnabledGithubActionsOrganization: [\n      \"PUT /orgs/{org}/actions/permissions/repositories\"\n    ],\n    setWorkflowAccessToRepository: [\n      \"PUT /repos/{owner}/{repo}/actions/permissions/access\"\n    ],\n    updateEnvironmentVariable: [\n      \"PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}\"\n    ],\n    updateHostedRunnerForOrg: [\n      \"PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id}\"\n    ],\n    updateOrgVariable: [\"PATCH /orgs/{org}/actions/variables/{name}\"],\n    updateRepoVariable: [\n      \"PATCH /repos/{owner}/{repo}/actions/variables/{name}\"\n    ]\n  },\n  activity: {\n    checkRepoIsStarredByAuthenticatedUser: [\"GET /user/starred/{owner}/{repo}\"],\n    deleteRepoSubscription: [\"DELETE /repos/{owner}/{repo}/subscription\"],\n    deleteThreadSubscription: [\n      \"DELETE /notifications/threads/{thread_id}/subscription\"\n    ],\n    getFeeds: [\"GET /feeds\"],\n    getRepoSubscription: [\"GET /repos/{owner}/{repo}/subscription\"],\n    getThread: [\"GET /notifications/threads/{thread_id}\"],\n    getThreadSubscriptionForAuthenticatedUser: [\n      \"GET /notifications/threads/{thread_id}/subscription\"\n    ],\n    listEventsForAuthenticatedUser: [\"GET /users/{username}/events\"],\n    listNotificationsForAuthenticatedUser: [\"GET /notifications\"],\n    listOrgEventsForAuthenticatedUser: [\n      \"GET /users/{username}/events/orgs/{org}\"\n    ],\n    listPublicEvents: [\"GET /events\"],\n    listPublicEventsForRepoNetwork: [\"GET /networks/{owner}/{repo}/events\"],\n    listPublicEventsForUser: [\"GET /users/{username}/events/public\"],\n    listPublicOrgEvents: [\"GET /orgs/{org}/events\"],\n    listReceivedEventsForUser: [\"GET /users/{username}/received_events\"],\n    listReceivedPublicEventsForUser: [\n      \"GET /users/{username}/received_events/public\"\n    ],\n    listRepoEvents: [\"GET /repos/{owner}/{repo}/events\"],\n    listRepoNotificationsForAuthenticatedUser: [\n      \"GET /repos/{owner}/{repo}/notifications\"\n    ],\n    listReposStarredByAuthenticatedUser: [\"GET /user/starred\"],\n    listReposStarredByUser: [\"GET /users/{username}/starred\"],\n    listReposWatchedByUser: [\"GET /users/{username}/subscriptions\"],\n    listStargazersForRepo: [\"GET /repos/{owner}/{repo}/stargazers\"],\n    listWatchedReposForAuthenticatedUser: [\"GET /user/subscriptions\"],\n    listWatchersForRepo: [\"GET /repos/{owner}/{repo}/subscribers\"],\n    markNotificationsAsRead: [\"PUT /notifications\"],\n    markRepoNotificationsAsRead: [\"PUT /repos/{owner}/{repo}/notifications\"],\n    markThreadAsDone: [\"DELETE /notifications/threads/{thread_id}\"],\n    markThreadAsRead: [\"PATCH /notifications/threads/{thread_id}\"],\n    setRepoSubscription: [\"PUT /repos/{owner}/{repo}/subscription\"],\n    setThreadSubscription: [\n      \"PUT /notifications/threads/{thread_id}/subscription\"\n    ],\n    starRepoForAuthenticatedUser: [\"PUT /user/starred/{owner}/{repo}\"],\n    unstarRepoForAuthenticatedUser: [\"DELETE /user/starred/{owner}/{repo}\"]\n  },\n  apps: {\n    addRepoToInstallation: [\n      \"PUT /user/installations/{installation_id}/repositories/{repository_id}\",\n      {},\n      { renamed: [\"apps\", \"addRepoToInstallationForAuthenticatedUser\"] }\n    ],\n    addRepoToInstallationForAuthenticatedUser: [\n      \"PUT /user/installations/{installation_id}/repositories/{repository_id}\"\n    ],\n    checkToken: [\"POST /applications/{client_id}/token\"],\n    createFromManifest: [\"POST /app-manifests/{code}/conversions\"],\n    createInstallationAccessToken: [\n      \"POST /app/installations/{installation_id}/access_tokens\"\n    ],\n    deleteAuthorization: [\"DELETE /applications/{client_id}/grant\"],\n    deleteInstallation: [\"DELETE /app/installations/{installation_id}\"],\n    deleteToken: [\"DELETE /applications/{client_id}/token\"],\n    getAuthenticated: [\"GET /app\"],\n    getBySlug: [\"GET /apps/{app_slug}\"],\n    getInstallation: [\"GET /app/installations/{installation_id}\"],\n    getOrgInstallation: [\"GET /orgs/{org}/installation\"],\n    getRepoInstallation: [\"GET /repos/{owner}/{repo}/installation\"],\n    getSubscriptionPlanForAccount: [\n      \"GET /marketplace_listing/accounts/{account_id}\"\n    ],\n    getSubscriptionPlanForAccountStubbed: [\n      \"GET /marketplace_listing/stubbed/accounts/{account_id}\"\n    ],\n    getUserInstallation: [\"GET /users/{username}/installation\"],\n    getWebhookConfigForApp: [\"GET /app/hook/config\"],\n    getWebhookDelivery: [\"GET /app/hook/deliveries/{delivery_id}\"],\n    listAccountsForPlan: [\"GET /marketplace_listing/plans/{plan_id}/accounts\"],\n    listAccountsForPlanStubbed: [\n      \"GET /marketplace_listing/stubbed/plans/{plan_id}/accounts\"\n    ],\n    listInstallationReposForAuthenticatedUser: [\n      \"GET /user/installations/{installation_id}/repositories\"\n    ],\n    listInstallationRequestsForAuthenticatedApp: [\n      \"GET /app/installation-requests\"\n    ],\n    listInstallations: [\"GET /app/installations\"],\n    listInstallationsForAuthenticatedUser: [\"GET /user/installations\"],\n    listPlans: [\"GET /marketplace_listing/plans\"],\n    listPlansStubbed: [\"GET /marketplace_listing/stubbed/plans\"],\n    listReposAccessibleToInstallation: [\"GET /installation/repositories\"],\n    listSubscriptionsForAuthenticatedUser: [\"GET /user/marketplace_purchases\"],\n    listSubscriptionsForAuthenticatedUserStubbed: [\n      \"GET /user/marketplace_purchases/stubbed\"\n    ],\n    listWebhookDeliveries: [\"GET /app/hook/deliveries\"],\n    redeliverWebhookDelivery: [\n      \"POST /app/hook/deliveries/{delivery_id}/attempts\"\n    ],\n    removeRepoFromInstallation: [\n      \"DELETE /user/installations/{installation_id}/repositories/{repository_id}\",\n      {},\n      { renamed: [\"apps\", \"removeRepoFromInstallationForAuthenticatedUser\"] }\n    ],\n    removeRepoFromInstallationForAuthenticatedUser: [\n      \"DELETE /user/installations/{installation_id}/repositories/{repository_id}\"\n    ],\n    resetToken: [\"PATCH /applications/{client_id}/token\"],\n    revokeInstallationAccessToken: [\"DELETE /installation/token\"],\n    scopeToken: [\"POST /applications/{client_id}/token/scoped\"],\n    suspendInstallation: [\"PUT /app/installations/{installation_id}/suspended\"],\n    unsuspendInstallation: [\n      \"DELETE /app/installations/{installation_id}/suspended\"\n    ],\n    updateWebhookConfigForApp: [\"PATCH /app/hook/config\"]\n  },\n  billing: {\n    getGithubActionsBillingOrg: [\"GET /orgs/{org}/settings/billing/actions\"],\n    getGithubActionsBillingUser: [\n      \"GET /users/{username}/settings/billing/actions\"\n    ],\n    getGithubBillingUsageReportOrg: [\n      \"GET /organizations/{org}/settings/billing/usage\"\n    ],\n    getGithubPackagesBillingOrg: [\"GET /orgs/{org}/settings/billing/packages\"],\n    getGithubPackagesBillingUser: [\n      \"GET /users/{username}/settings/billing/packages\"\n    ],\n    getSharedStorageBillingOrg: [\n      \"GET /orgs/{org}/settings/billing/shared-storage\"\n    ],\n    getSharedStorageBillingUser: [\n      \"GET /users/{username}/settings/billing/shared-storage\"\n    ]\n  },\n  checks: {\n    create: [\"POST /repos/{owner}/{repo}/check-runs\"],\n    createSuite: [\"POST /repos/{owner}/{repo}/check-suites\"],\n    get: [\"GET /repos/{owner}/{repo}/check-runs/{check_run_id}\"],\n    getSuite: [\"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}\"],\n    listAnnotations: [\n      \"GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations\"\n    ],\n    listForRef: [\"GET /repos/{owner}/{repo}/commits/{ref}/check-runs\"],\n    listForSuite: [\n      \"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs\"\n    ],\n    listSuitesForRef: [\"GET /repos/{owner}/{repo}/commits/{ref}/check-suites\"],\n    rerequestRun: [\n      \"POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest\"\n    ],\n    rerequestSuite: [\n      \"POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest\"\n    ],\n    setSuitesPreferences: [\n      \"PATCH /repos/{owner}/{repo}/check-suites/preferences\"\n    ],\n    update: [\"PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}\"]\n  },\n  codeScanning: {\n    commitAutofix: [\n      \"POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits\"\n    ],\n    createAutofix: [\n      \"POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix\"\n    ],\n    createVariantAnalysis: [\n      \"POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses\"\n    ],\n    deleteAnalysis: [\n      \"DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}\"\n    ],\n    deleteCodeqlDatabase: [\n      \"DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}\"\n    ],\n    getAlert: [\n      \"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}\",\n      {},\n      { renamedParameters: { alert_id: \"alert_number\" } }\n    ],\n    getAnalysis: [\n      \"GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}\"\n    ],\n    getAutofix: [\n      \"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix\"\n    ],\n    getCodeqlDatabase: [\n      \"GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}\"\n    ],\n    getDefaultSetup: [\"GET /repos/{owner}/{repo}/code-scanning/default-setup\"],\n    getSarif: [\"GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}\"],\n    getVariantAnalysis: [\n      \"GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}\"\n    ],\n    getVariantAnalysisRepoTask: [\n      \"GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}\"\n    ],\n    listAlertInstances: [\n      \"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances\"\n    ],\n    listAlertsForOrg: [\"GET /orgs/{org}/code-scanning/alerts\"],\n    listAlertsForRepo: [\"GET /repos/{owner}/{repo}/code-scanning/alerts\"],\n    listAlertsInstances: [\n      \"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances\",\n      {},\n      { renamed: [\"codeScanning\", \"listAlertInstances\"] }\n    ],\n    listCodeqlDatabases: [\n      \"GET /repos/{owner}/{repo}/code-scanning/codeql/databases\"\n    ],\n    listRecentAnalyses: [\"GET /repos/{owner}/{repo}/code-scanning/analyses\"],\n    updateAlert: [\n      \"PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}\"\n    ],\n    updateDefaultSetup: [\n      \"PATCH /repos/{owner}/{repo}/code-scanning/default-setup\"\n    ],\n    uploadSarif: [\"POST /repos/{owner}/{repo}/code-scanning/sarifs\"]\n  },\n  codeSecurity: {\n    attachConfiguration: [\n      \"POST /orgs/{org}/code-security/configurations/{configuration_id}/attach\"\n    ],\n    attachEnterpriseConfiguration: [\n      \"POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach\"\n    ],\n    createConfiguration: [\"POST /orgs/{org}/code-security/configurations\"],\n    createConfigurationForEnterprise: [\n      \"POST /enterprises/{enterprise}/code-security/configurations\"\n    ],\n    deleteConfiguration: [\n      \"DELETE /orgs/{org}/code-security/configurations/{configuration_id}\"\n    ],\n    deleteConfigurationForEnterprise: [\n      \"DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}\"\n    ],\n    detachConfiguration: [\n      \"DELETE /orgs/{org}/code-security/configurations/detach\"\n    ],\n    getConfiguration: [\n      \"GET /orgs/{org}/code-security/configurations/{configuration_id}\"\n    ],\n    getConfigurationForRepository: [\n      \"GET /repos/{owner}/{repo}/code-security-configuration\"\n    ],\n    getConfigurationsForEnterprise: [\n      \"GET /enterprises/{enterprise}/code-security/configurations\"\n    ],\n    getConfigurationsForOrg: [\"GET /orgs/{org}/code-security/configurations\"],\n    getDefaultConfigurations: [\n      \"GET /orgs/{org}/code-security/configurations/defaults\"\n    ],\n    getDefaultConfigurationsForEnterprise: [\n      \"GET /enterprises/{enterprise}/code-security/configurations/defaults\"\n    ],\n    getRepositoriesForConfiguration: [\n      \"GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories\"\n    ],\n    getRepositoriesForEnterpriseConfiguration: [\n      \"GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories\"\n    ],\n    getSingleConfigurationForEnterprise: [\n      \"GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}\"\n    ],\n    setConfigurationAsDefault: [\n      \"PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults\"\n    ],\n    setConfigurationAsDefaultForEnterprise: [\n      \"PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults\"\n    ],\n    updateConfiguration: [\n      \"PATCH /orgs/{org}/code-security/configurations/{configuration_id}\"\n    ],\n    updateEnterpriseConfiguration: [\n      \"PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}\"\n    ]\n  },\n  codesOfConduct: {\n    getAllCodesOfConduct: [\"GET /codes_of_conduct\"],\n    getConductCode: [\"GET /codes_of_conduct/{key}\"]\n  },\n  codespaces: {\n    addRepositoryForSecretForAuthenticatedUser: [\n      \"PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}\"\n    ],\n    addSelectedRepoToOrgSecret: [\n      \"PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}\"\n    ],\n    checkPermissionsForDevcontainer: [\n      \"GET /repos/{owner}/{repo}/codespaces/permissions_check\"\n    ],\n    codespaceMachinesForAuthenticatedUser: [\n      \"GET /user/codespaces/{codespace_name}/machines\"\n    ],\n    createForAuthenticatedUser: [\"POST /user/codespaces\"],\n    createOrUpdateOrgSecret: [\n      \"PUT /orgs/{org}/codespaces/secrets/{secret_name}\"\n    ],\n    createOrUpdateRepoSecret: [\n      \"PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}\"\n    ],\n    createOrUpdateSecretForAuthenticatedUser: [\n      \"PUT /user/codespaces/secrets/{secret_name}\"\n    ],\n    createWithPrForAuthenticatedUser: [\n      \"POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces\"\n    ],\n    createWithRepoForAuthenticatedUser: [\n      \"POST /repos/{owner}/{repo}/codespaces\"\n    ],\n    deleteForAuthenticatedUser: [\"DELETE /user/codespaces/{codespace_name}\"],\n    deleteFromOrganization: [\n      \"DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}\"\n    ],\n    deleteOrgSecret: [\"DELETE /orgs/{org}/codespaces/secrets/{secret_name}\"],\n    deleteRepoSecret: [\n      \"DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}\"\n    ],\n    deleteSecretForAuthenticatedUser: [\n      \"DELETE /user/codespaces/secrets/{secret_name}\"\n    ],\n    exportForAuthenticatedUser: [\n      \"POST /user/codespaces/{codespace_name}/exports\"\n    ],\n    getCodespacesForUserInOrg: [\n      \"GET /orgs/{org}/members/{username}/codespaces\"\n    ],\n    getExportDetailsForAuthenticatedUser: [\n      \"GET /user/codespaces/{codespace_name}/exports/{export_id}\"\n    ],\n    getForAuthenticatedUser: [\"GET /user/codespaces/{codespace_name}\"],\n    getOrgPublicKey: [\"GET /orgs/{org}/codespaces/secrets/public-key\"],\n    getOrgSecret: [\"GET /orgs/{org}/codespaces/secrets/{secret_name}\"],\n    getPublicKeyForAuthenticatedUser: [\n      \"GET /user/codespaces/secrets/public-key\"\n    ],\n    getRepoPublicKey: [\n      \"GET /repos/{owner}/{repo}/codespaces/secrets/public-key\"\n    ],\n    getRepoSecret: [\n      \"GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}\"\n    ],\n    getSecretForAuthenticatedUser: [\n      \"GET /user/codespaces/secrets/{secret_name}\"\n    ],\n    listDevcontainersInRepositoryForAuthenticatedUser: [\n      \"GET /repos/{owner}/{repo}/codespaces/devcontainers\"\n    ],\n    listForAuthenticatedUser: [\"GET /user/codespaces\"],\n    listInOrganization: [\n      \"GET /orgs/{org}/codespaces\",\n      {},\n      { renamedParameters: { org_id: \"org\" } }\n    ],\n    listInRepositoryForAuthenticatedUser: [\n      \"GET /repos/{owner}/{repo}/codespaces\"\n    ],\n    listOrgSecrets: [\"GET /orgs/{org}/codespaces/secrets\"],\n    listRepoSecrets: [\"GET /repos/{owner}/{repo}/codespaces/secrets\"],\n    listRepositoriesForSecretForAuthenticatedUser: [\n      \"GET /user/codespaces/secrets/{secret_name}/repositories\"\n    ],\n    listSecretsForAuthenticatedUser: [\"GET /user/codespaces/secrets\"],\n    listSelectedReposForOrgSecret: [\n      \"GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories\"\n    ],\n    preFlightWithRepoForAuthenticatedUser: [\n      \"GET /repos/{owner}/{repo}/codespaces/new\"\n    ],\n    publishForAuthenticatedUser: [\n      \"POST /user/codespaces/{codespace_name}/publish\"\n    ],\n    removeRepositoryForSecretForAuthenticatedUser: [\n      \"DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}\"\n    ],\n    removeSelectedRepoFromOrgSecret: [\n      \"DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}\"\n    ],\n    repoMachinesForAuthenticatedUser: [\n      \"GET /repos/{owner}/{repo}/codespaces/machines\"\n    ],\n    setRepositoriesForSecretForAuthenticatedUser: [\n      \"PUT /user/codespaces/secrets/{secret_name}/repositories\"\n    ],\n    setSelectedReposForOrgSecret: [\n      \"PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories\"\n    ],\n    startForAuthenticatedUser: [\"POST /user/codespaces/{codespace_name}/start\"],\n    stopForAuthenticatedUser: [\"POST /user/codespaces/{codespace_name}/stop\"],\n    stopInOrganization: [\n      \"POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop\"\n    ],\n    updateForAuthenticatedUser: [\"PATCH /user/codespaces/{codespace_name}\"]\n  },\n  copilot: {\n    addCopilotSeatsForTeams: [\n      \"POST /orgs/{org}/copilot/billing/selected_teams\"\n    ],\n    addCopilotSeatsForUsers: [\n      \"POST /orgs/{org}/copilot/billing/selected_users\"\n    ],\n    cancelCopilotSeatAssignmentForTeams: [\n      \"DELETE /orgs/{org}/copilot/billing/selected_teams\"\n    ],\n    cancelCopilotSeatAssignmentForUsers: [\n      \"DELETE /orgs/{org}/copilot/billing/selected_users\"\n    ],\n    copilotMetricsForOrganization: [\"GET /orgs/{org}/copilot/metrics\"],\n    copilotMetricsForTeam: [\"GET /orgs/{org}/team/{team_slug}/copilot/metrics\"],\n    getCopilotOrganizationDetails: [\"GET /orgs/{org}/copilot/billing\"],\n    getCopilotSeatDetailsForUser: [\n      \"GET /orgs/{org}/members/{username}/copilot\"\n    ],\n    listCopilotSeats: [\"GET /orgs/{org}/copilot/billing/seats\"],\n    usageMetricsForOrg: [\"GET /orgs/{org}/copilot/usage\"],\n    usageMetricsForTeam: [\"GET /orgs/{org}/team/{team_slug}/copilot/usage\"]\n  },\n  dependabot: {\n    addSelectedRepoToOrgSecret: [\n      \"PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}\"\n    ],\n    createOrUpdateOrgSecret: [\n      \"PUT /orgs/{org}/dependabot/secrets/{secret_name}\"\n    ],\n    createOrUpdateRepoSecret: [\n      \"PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}\"\n    ],\n    deleteOrgSecret: [\"DELETE /orgs/{org}/dependabot/secrets/{secret_name}\"],\n    deleteRepoSecret: [\n      \"DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}\"\n    ],\n    getAlert: [\"GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}\"],\n    getOrgPublicKey: [\"GET /orgs/{org}/dependabot/secrets/public-key\"],\n    getOrgSecret: [\"GET /orgs/{org}/dependabot/secrets/{secret_name}\"],\n    getRepoPublicKey: [\n      \"GET /repos/{owner}/{repo}/dependabot/secrets/public-key\"\n    ],\n    getRepoSecret: [\n      \"GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}\"\n    ],\n    listAlertsForEnterprise: [\n      \"GET /enterprises/{enterprise}/dependabot/alerts\"\n    ],\n    listAlertsForOrg: [\"GET /orgs/{org}/dependabot/alerts\"],\n    listAlertsForRepo: [\"GET /repos/{owner}/{repo}/dependabot/alerts\"],\n    listOrgSecrets: [\"GET /orgs/{org}/dependabot/secrets\"],\n    listRepoSecrets: [\"GET /repos/{owner}/{repo}/dependabot/secrets\"],\n    listSelectedReposForOrgSecret: [\n      \"GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories\"\n    ],\n    removeSelectedRepoFromOrgSecret: [\n      \"DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}\"\n    ],\n    setSelectedReposForOrgSecret: [\n      \"PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories\"\n    ],\n    updateAlert: [\n      \"PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}\"\n    ]\n  },\n  dependencyGraph: {\n    createRepositorySnapshot: [\n      \"POST /repos/{owner}/{repo}/dependency-graph/snapshots\"\n    ],\n    diffRange: [\n      \"GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}\"\n    ],\n    exportSbom: [\"GET /repos/{owner}/{repo}/dependency-graph/sbom\"]\n  },\n  emojis: { get: [\"GET /emojis\"] },\n  gists: {\n    checkIsStarred: [\"GET /gists/{gist_id}/star\"],\n    create: [\"POST /gists\"],\n    createComment: [\"POST /gists/{gist_id}/comments\"],\n    delete: [\"DELETE /gists/{gist_id}\"],\n    deleteComment: [\"DELETE /gists/{gist_id}/comments/{comment_id}\"],\n    fork: [\"POST /gists/{gist_id}/forks\"],\n    get: [\"GET /gists/{gist_id}\"],\n    getComment: [\"GET /gists/{gist_id}/comments/{comment_id}\"],\n    getRevision: [\"GET /gists/{gist_id}/{sha}\"],\n    list: [\"GET /gists\"],\n    listComments: [\"GET /gists/{gist_id}/comments\"],\n    listCommits: [\"GET /gists/{gist_id}/commits\"],\n    listForUser: [\"GET /users/{username}/gists\"],\n    listForks: [\"GET /gists/{gist_id}/forks\"],\n    listPublic: [\"GET /gists/public\"],\n    listStarred: [\"GET /gists/starred\"],\n    star: [\"PUT /gists/{gist_id}/star\"],\n    unstar: [\"DELETE /gists/{gist_id}/star\"],\n    update: [\"PATCH /gists/{gist_id}\"],\n    updateComment: [\"PATCH /gists/{gist_id}/comments/{comment_id}\"]\n  },\n  git: {\n    createBlob: [\"POST /repos/{owner}/{repo}/git/blobs\"],\n    createCommit: [\"POST /repos/{owner}/{repo}/git/commits\"],\n    createRef: [\"POST /repos/{owner}/{repo}/git/refs\"],\n    createTag: [\"POST /repos/{owner}/{repo}/git/tags\"],\n    createTree: [\"POST /repos/{owner}/{repo}/git/trees\"],\n    deleteRef: [\"DELETE /repos/{owner}/{repo}/git/refs/{ref}\"],\n    getBlob: [\"GET /repos/{owner}/{repo}/git/blobs/{file_sha}\"],\n    getCommit: [\"GET /repos/{owner}/{repo}/git/commits/{commit_sha}\"],\n    getRef: [\"GET /repos/{owner}/{repo}/git/ref/{ref}\"],\n    getTag: [\"GET /repos/{owner}/{repo}/git/tags/{tag_sha}\"],\n    getTree: [\"GET /repos/{owner}/{repo}/git/trees/{tree_sha}\"],\n    listMatchingRefs: [\"GET /repos/{owner}/{repo}/git/matching-refs/{ref}\"],\n    updateRef: [\"PATCH /repos/{owner}/{repo}/git/refs/{ref}\"]\n  },\n  gitignore: {\n    getAllTemplates: [\"GET /gitignore/templates\"],\n    getTemplate: [\"GET /gitignore/templates/{name}\"]\n  },\n  hostedCompute: {\n    createNetworkConfigurationForOrg: [\n      \"POST /orgs/{org}/settings/network-configurations\"\n    ],\n    deleteNetworkConfigurationFromOrg: [\n      \"DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id}\"\n    ],\n    getNetworkConfigurationForOrg: [\n      \"GET /orgs/{org}/settings/network-configurations/{network_configuration_id}\"\n    ],\n    getNetworkSettingsForOrg: [\n      \"GET /orgs/{org}/settings/network-settings/{network_settings_id}\"\n    ],\n    listNetworkConfigurationsForOrg: [\n      \"GET /orgs/{org}/settings/network-configurations\"\n    ],\n    updateNetworkConfigurationForOrg: [\n      \"PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id}\"\n    ]\n  },\n  interactions: {\n    getRestrictionsForAuthenticatedUser: [\"GET /user/interaction-limits\"],\n    getRestrictionsForOrg: [\"GET /orgs/{org}/interaction-limits\"],\n    getRestrictionsForRepo: [\"GET /repos/{owner}/{repo}/interaction-limits\"],\n    getRestrictionsForYourPublicRepos: [\n      \"GET /user/interaction-limits\",\n      {},\n      { renamed: [\"interactions\", \"getRestrictionsForAuthenticatedUser\"] }\n    ],\n    removeRestrictionsForAuthenticatedUser: [\"DELETE /user/interaction-limits\"],\n    removeRestrictionsForOrg: [\"DELETE /orgs/{org}/interaction-limits\"],\n    removeRestrictionsForRepo: [\n      \"DELETE /repos/{owner}/{repo}/interaction-limits\"\n    ],\n    removeRestrictionsForYourPublicRepos: [\n      \"DELETE /user/interaction-limits\",\n      {},\n      { renamed: [\"interactions\", \"removeRestrictionsForAuthenticatedUser\"] }\n    ],\n    setRestrictionsForAuthenticatedUser: [\"PUT /user/interaction-limits\"],\n    setRestrictionsForOrg: [\"PUT /orgs/{org}/interaction-limits\"],\n    setRestrictionsForRepo: [\"PUT /repos/{owner}/{repo}/interaction-limits\"],\n    setRestrictionsForYourPublicRepos: [\n      \"PUT /user/interaction-limits\",\n      {},\n      { renamed: [\"interactions\", \"setRestrictionsForAuthenticatedUser\"] }\n    ]\n  },\n  issues: {\n    addAssignees: [\n      \"POST /repos/{owner}/{repo}/issues/{issue_number}/assignees\"\n    ],\n    addLabels: [\"POST /repos/{owner}/{repo}/issues/{issue_number}/labels\"],\n    addSubIssue: [\n      \"POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues\"\n    ],\n    checkUserCanBeAssigned: [\"GET /repos/{owner}/{repo}/assignees/{assignee}\"],\n    checkUserCanBeAssignedToIssue: [\n      \"GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}\"\n    ],\n    create: [\"POST /repos/{owner}/{repo}/issues\"],\n    createComment: [\n      \"POST /repos/{owner}/{repo}/issues/{issue_number}/comments\"\n    ],\n    createLabel: [\"POST /repos/{owner}/{repo}/labels\"],\n    createMilestone: [\"POST /repos/{owner}/{repo}/milestones\"],\n    deleteComment: [\n      \"DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}\"\n    ],\n    deleteLabel: [\"DELETE /repos/{owner}/{repo}/labels/{name}\"],\n    deleteMilestone: [\n      \"DELETE /repos/{owner}/{repo}/milestones/{milestone_number}\"\n    ],\n    get: [\"GET /repos/{owner}/{repo}/issues/{issue_number}\"],\n    getComment: [\"GET /repos/{owner}/{repo}/issues/comments/{comment_id}\"],\n    getEvent: [\"GET /repos/{owner}/{repo}/issues/events/{event_id}\"],\n    getLabel: [\"GET /repos/{owner}/{repo}/labels/{name}\"],\n    getMilestone: [\"GET /repos/{owner}/{repo}/milestones/{milestone_number}\"],\n    list: [\"GET /issues\"],\n    listAssignees: [\"GET /repos/{owner}/{repo}/assignees\"],\n    listComments: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/comments\"],\n    listCommentsForRepo: [\"GET /repos/{owner}/{repo}/issues/comments\"],\n    listEvents: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/events\"],\n    listEventsForRepo: [\"GET /repos/{owner}/{repo}/issues/events\"],\n    listEventsForTimeline: [\n      \"GET /repos/{owner}/{repo}/issues/{issue_number}/timeline\"\n    ],\n    listForAuthenticatedUser: [\"GET /user/issues\"],\n    listForOrg: [\"GET /orgs/{org}/issues\"],\n    listForRepo: [\"GET /repos/{owner}/{repo}/issues\"],\n    listLabelsForMilestone: [\n      \"GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels\"\n    ],\n    listLabelsForRepo: [\"GET /repos/{owner}/{repo}/labels\"],\n    listLabelsOnIssue: [\n      \"GET /repos/{owner}/{repo}/issues/{issue_number}/labels\"\n    ],\n    listMilestones: [\"GET /repos/{owner}/{repo}/milestones\"],\n    listSubIssues: [\n      \"GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues\"\n    ],\n    lock: [\"PUT /repos/{owner}/{repo}/issues/{issue_number}/lock\"],\n    removeAllLabels: [\n      \"DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels\"\n    ],\n    removeAssignees: [\n      \"DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees\"\n    ],\n    removeLabel: [\n      \"DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}\"\n    ],\n    removeSubIssue: [\n      \"DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue\"\n    ],\n    reprioritizeSubIssue: [\n      \"PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority\"\n    ],\n    setLabels: [\"PUT /repos/{owner}/{repo}/issues/{issue_number}/labels\"],\n    unlock: [\"DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock\"],\n    update: [\"PATCH /repos/{owner}/{repo}/issues/{issue_number}\"],\n    updateComment: [\"PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}\"],\n    updateLabel: [\"PATCH /repos/{owner}/{repo}/labels/{name}\"],\n    updateMilestone: [\n      \"PATCH /repos/{owner}/{repo}/milestones/{milestone_number}\"\n    ]\n  },\n  licenses: {\n    get: [\"GET /licenses/{license}\"],\n    getAllCommonlyUsed: [\"GET /licenses\"],\n    getForRepo: [\"GET /repos/{owner}/{repo}/license\"]\n  },\n  markdown: {\n    render: [\"POST /markdown\"],\n    renderRaw: [\n      \"POST /markdown/raw\",\n      { headers: { \"content-type\": \"text/plain; charset=utf-8\" } }\n    ]\n  },\n  meta: {\n    get: [\"GET /meta\"],\n    getAllVersions: [\"GET /versions\"],\n    getOctocat: [\"GET /octocat\"],\n    getZen: [\"GET /zen\"],\n    root: [\"GET /\"]\n  },\n  migrations: {\n    deleteArchiveForAuthenticatedUser: [\n      \"DELETE /user/migrations/{migration_id}/archive\"\n    ],\n    deleteArchiveForOrg: [\n      \"DELETE /orgs/{org}/migrations/{migration_id}/archive\"\n    ],\n    downloadArchiveForOrg: [\n      \"GET /orgs/{org}/migrations/{migration_id}/archive\"\n    ],\n    getArchiveForAuthenticatedUser: [\n      \"GET /user/migrations/{migration_id}/archive\"\n    ],\n    getStatusForAuthenticatedUser: [\"GET /user/migrations/{migration_id}\"],\n    getStatusForOrg: [\"GET /orgs/{org}/migrations/{migration_id}\"],\n    listForAuthenticatedUser: [\"GET /user/migrations\"],\n    listForOrg: [\"GET /orgs/{org}/migrations\"],\n    listReposForAuthenticatedUser: [\n      \"GET /user/migrations/{migration_id}/repositories\"\n    ],\n    listReposForOrg: [\"GET /orgs/{org}/migrations/{migration_id}/repositories\"],\n    listReposForUser: [\n      \"GET /user/migrations/{migration_id}/repositories\",\n      {},\n      { renamed: [\"migrations\", \"listReposForAuthenticatedUser\"] }\n    ],\n    startForAuthenticatedUser: [\"POST /user/migrations\"],\n    startForOrg: [\"POST /orgs/{org}/migrations\"],\n    unlockRepoForAuthenticatedUser: [\n      \"DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock\"\n    ],\n    unlockRepoForOrg: [\n      \"DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock\"\n    ]\n  },\n  oidc: {\n    getOidcCustomSubTemplateForOrg: [\n      \"GET /orgs/{org}/actions/oidc/customization/sub\"\n    ],\n    updateOidcCustomSubTemplateForOrg: [\n      \"PUT /orgs/{org}/actions/oidc/customization/sub\"\n    ]\n  },\n  orgs: {\n    addSecurityManagerTeam: [\n      \"PUT /orgs/{org}/security-managers/teams/{team_slug}\",\n      {},\n      {\n        deprecated: \"octokit.rest.orgs.addSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#add-a-security-manager-team\"\n      }\n    ],\n    assignTeamToOrgRole: [\n      \"PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}\"\n    ],\n    assignUserToOrgRole: [\n      \"PUT /orgs/{org}/organization-roles/users/{username}/{role_id}\"\n    ],\n    blockUser: [\"PUT /orgs/{org}/blocks/{username}\"],\n    cancelInvitation: [\"DELETE /orgs/{org}/invitations/{invitation_id}\"],\n    checkBlockedUser: [\"GET /orgs/{org}/blocks/{username}\"],\n    checkMembershipForUser: [\"GET /orgs/{org}/members/{username}\"],\n    checkPublicMembershipForUser: [\"GET /orgs/{org}/public_members/{username}\"],\n    convertMemberToOutsideCollaborator: [\n      \"PUT /orgs/{org}/outside_collaborators/{username}\"\n    ],\n    createInvitation: [\"POST /orgs/{org}/invitations\"],\n    createIssueType: [\"POST /orgs/{org}/issue-types\"],\n    createOrUpdateCustomProperties: [\"PATCH /orgs/{org}/properties/schema\"],\n    createOrUpdateCustomPropertiesValuesForRepos: [\n      \"PATCH /orgs/{org}/properties/values\"\n    ],\n    createOrUpdateCustomProperty: [\n      \"PUT /orgs/{org}/properties/schema/{custom_property_name}\"\n    ],\n    createWebhook: [\"POST /orgs/{org}/hooks\"],\n    delete: [\"DELETE /orgs/{org}\"],\n    deleteIssueType: [\"DELETE /orgs/{org}/issue-types/{issue_type_id}\"],\n    deleteWebhook: [\"DELETE /orgs/{org}/hooks/{hook_id}\"],\n    enableOrDisableSecurityProductOnAllOrgRepos: [\n      \"POST /orgs/{org}/{security_product}/{enablement}\",\n      {},\n      {\n        deprecated: \"octokit.rest.orgs.enableOrDisableSecurityProductOnAllOrgRepos() is deprecated, see https://docs.github.com/rest/orgs/orgs#enable-or-disable-a-security-feature-for-an-organization\"\n      }\n    ],\n    get: [\"GET /orgs/{org}\"],\n    getAllCustomProperties: [\"GET /orgs/{org}/properties/schema\"],\n    getCustomProperty: [\n      \"GET /orgs/{org}/properties/schema/{custom_property_name}\"\n    ],\n    getMembershipForAuthenticatedUser: [\"GET /user/memberships/orgs/{org}\"],\n    getMembershipForUser: [\"GET /orgs/{org}/memberships/{username}\"],\n    getOrgRole: [\"GET /orgs/{org}/organization-roles/{role_id}\"],\n    getOrgRulesetHistory: [\"GET /orgs/{org}/rulesets/{ruleset_id}/history\"],\n    getOrgRulesetVersion: [\n      \"GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id}\"\n    ],\n    getWebhook: [\"GET /orgs/{org}/hooks/{hook_id}\"],\n    getWebhookConfigForOrg: [\"GET /orgs/{org}/hooks/{hook_id}/config\"],\n    getWebhookDelivery: [\n      \"GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}\"\n    ],\n    list: [\"GET /organizations\"],\n    listAppInstallations: [\"GET /orgs/{org}/installations\"],\n    listAttestations: [\"GET /orgs/{org}/attestations/{subject_digest}\"],\n    listBlockedUsers: [\"GET /orgs/{org}/blocks\"],\n    listCustomPropertiesValuesForRepos: [\"GET /orgs/{org}/properties/values\"],\n    listFailedInvitations: [\"GET /orgs/{org}/failed_invitations\"],\n    listForAuthenticatedUser: [\"GET /user/orgs\"],\n    listForUser: [\"GET /users/{username}/orgs\"],\n    listInvitationTeams: [\"GET /orgs/{org}/invitations/{invitation_id}/teams\"],\n    listIssueTypes: [\"GET /orgs/{org}/issue-types\"],\n    listMembers: [\"GET /orgs/{org}/members\"],\n    listMembershipsForAuthenticatedUser: [\"GET /user/memberships/orgs\"],\n    listOrgRoleTeams: [\"GET /orgs/{org}/organization-roles/{role_id}/teams\"],\n    listOrgRoleUsers: [\"GET /orgs/{org}/organization-roles/{role_id}/users\"],\n    listOrgRoles: [\"GET /orgs/{org}/organization-roles\"],\n    listOrganizationFineGrainedPermissions: [\n      \"GET /orgs/{org}/organization-fine-grained-permissions\"\n    ],\n    listOutsideCollaborators: [\"GET /orgs/{org}/outside_collaborators\"],\n    listPatGrantRepositories: [\n      \"GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories\"\n    ],\n    listPatGrantRequestRepositories: [\n      \"GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories\"\n    ],\n    listPatGrantRequests: [\"GET /orgs/{org}/personal-access-token-requests\"],\n    listPatGrants: [\"GET /orgs/{org}/personal-access-tokens\"],\n    listPendingInvitations: [\"GET /orgs/{org}/invitations\"],\n    listPublicMembers: [\"GET /orgs/{org}/public_members\"],\n    listSecurityManagerTeams: [\n      \"GET /orgs/{org}/security-managers\",\n      {},\n      {\n        deprecated: \"octokit.rest.orgs.listSecurityManagerTeams() is deprecated, see https://docs.github.com/rest/orgs/security-managers#list-security-manager-teams\"\n      }\n    ],\n    listWebhookDeliveries: [\"GET /orgs/{org}/hooks/{hook_id}/deliveries\"],\n    listWebhooks: [\"GET /orgs/{org}/hooks\"],\n    pingWebhook: [\"POST /orgs/{org}/hooks/{hook_id}/pings\"],\n    redeliverWebhookDelivery: [\n      \"POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts\"\n    ],\n    removeCustomProperty: [\n      \"DELETE /orgs/{org}/properties/schema/{custom_property_name}\"\n    ],\n    removeMember: [\"DELETE /orgs/{org}/members/{username}\"],\n    removeMembershipForUser: [\"DELETE /orgs/{org}/memberships/{username}\"],\n    removeOutsideCollaborator: [\n      \"DELETE /orgs/{org}/outside_collaborators/{username}\"\n    ],\n    removePublicMembershipForAuthenticatedUser: [\n      \"DELETE /orgs/{org}/public_members/{username}\"\n    ],\n    removeSecurityManagerTeam: [\n      \"DELETE /orgs/{org}/security-managers/teams/{team_slug}\",\n      {},\n      {\n        deprecated: \"octokit.rest.orgs.removeSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#remove-a-security-manager-team\"\n      }\n    ],\n    reviewPatGrantRequest: [\n      \"POST /orgs/{org}/personal-access-token-requests/{pat_request_id}\"\n    ],\n    reviewPatGrantRequestsInBulk: [\n      \"POST /orgs/{org}/personal-access-token-requests\"\n    ],\n    revokeAllOrgRolesTeam: [\n      \"DELETE /orgs/{org}/organization-roles/teams/{team_slug}\"\n    ],\n    revokeAllOrgRolesUser: [\n      \"DELETE /orgs/{org}/organization-roles/users/{username}\"\n    ],\n    revokeOrgRoleTeam: [\n      \"DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}\"\n    ],\n    revokeOrgRoleUser: [\n      \"DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}\"\n    ],\n    setMembershipForUser: [\"PUT /orgs/{org}/memberships/{username}\"],\n    setPublicMembershipForAuthenticatedUser: [\n      \"PUT /orgs/{org}/public_members/{username}\"\n    ],\n    unblockUser: [\"DELETE /orgs/{org}/blocks/{username}\"],\n    update: [\"PATCH /orgs/{org}\"],\n    updateIssueType: [\"PUT /orgs/{org}/issue-types/{issue_type_id}\"],\n    updateMembershipForAuthenticatedUser: [\n      \"PATCH /user/memberships/orgs/{org}\"\n    ],\n    updatePatAccess: [\"POST /orgs/{org}/personal-access-tokens/{pat_id}\"],\n    updatePatAccesses: [\"POST /orgs/{org}/personal-access-tokens\"],\n    updateWebhook: [\"PATCH /orgs/{org}/hooks/{hook_id}\"],\n    updateWebhookConfigForOrg: [\"PATCH /orgs/{org}/hooks/{hook_id}/config\"]\n  },\n  packages: {\n    deletePackageForAuthenticatedUser: [\n      \"DELETE /user/packages/{package_type}/{package_name}\"\n    ],\n    deletePackageForOrg: [\n      \"DELETE /orgs/{org}/packages/{package_type}/{package_name}\"\n    ],\n    deletePackageForUser: [\n      \"DELETE /users/{username}/packages/{package_type}/{package_name}\"\n    ],\n    deletePackageVersionForAuthenticatedUser: [\n      \"DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}\"\n    ],\n    deletePackageVersionForOrg: [\n      \"DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}\"\n    ],\n    deletePackageVersionForUser: [\n      \"DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}\"\n    ],\n    getAllPackageVersionsForAPackageOwnedByAnOrg: [\n      \"GET /orgs/{org}/packages/{package_type}/{package_name}/versions\",\n      {},\n      { renamed: [\"packages\", \"getAllPackageVersionsForPackageOwnedByOrg\"] }\n    ],\n    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [\n      \"GET /user/packages/{package_type}/{package_name}/versions\",\n      {},\n      {\n        renamed: [\n          \"packages\",\n          \"getAllPackageVersionsForPackageOwnedByAuthenticatedUser\"\n        ]\n      }\n    ],\n    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [\n      \"GET /user/packages/{package_type}/{package_name}/versions\"\n    ],\n    getAllPackageVersionsForPackageOwnedByOrg: [\n      \"GET /orgs/{org}/packages/{package_type}/{package_name}/versions\"\n    ],\n    getAllPackageVersionsForPackageOwnedByUser: [\n      \"GET /users/{username}/packages/{package_type}/{package_name}/versions\"\n    ],\n    getPackageForAuthenticatedUser: [\n      \"GET /user/packages/{package_type}/{package_name}\"\n    ],\n    getPackageForOrganization: [\n      \"GET /orgs/{org}/packages/{package_type}/{package_name}\"\n    ],\n    getPackageForUser: [\n      \"GET /users/{username}/packages/{package_type}/{package_name}\"\n    ],\n    getPackageVersionForAuthenticatedUser: [\n      \"GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}\"\n    ],\n    getPackageVersionForOrganization: [\n      \"GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}\"\n    ],\n    getPackageVersionForUser: [\n      \"GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}\"\n    ],\n    listDockerMigrationConflictingPackagesForAuthenticatedUser: [\n      \"GET /user/docker/conflicts\"\n    ],\n    listDockerMigrationConflictingPackagesForOrganization: [\n      \"GET /orgs/{org}/docker/conflicts\"\n    ],\n    listDockerMigrationConflictingPackagesForUser: [\n      \"GET /users/{username}/docker/conflicts\"\n    ],\n    listPackagesForAuthenticatedUser: [\"GET /user/packages\"],\n    listPackagesForOrganization: [\"GET /orgs/{org}/packages\"],\n    listPackagesForUser: [\"GET /users/{username}/packages\"],\n    restorePackageForAuthenticatedUser: [\n      \"POST /user/packages/{package_type}/{package_name}/restore{?token}\"\n    ],\n    restorePackageForOrg: [\n      \"POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}\"\n    ],\n    restorePackageForUser: [\n      \"POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}\"\n    ],\n    restorePackageVersionForAuthenticatedUser: [\n      \"POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore\"\n    ],\n    restorePackageVersionForOrg: [\n      \"POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore\"\n    ],\n    restorePackageVersionForUser: [\n      \"POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore\"\n    ]\n  },\n  privateRegistries: {\n    createOrgPrivateRegistry: [\"POST /orgs/{org}/private-registries\"],\n    deleteOrgPrivateRegistry: [\n      \"DELETE /orgs/{org}/private-registries/{secret_name}\"\n    ],\n    getOrgPrivateRegistry: [\"GET /orgs/{org}/private-registries/{secret_name}\"],\n    getOrgPublicKey: [\"GET /orgs/{org}/private-registries/public-key\"],\n    listOrgPrivateRegistries: [\"GET /orgs/{org}/private-registries\"],\n    updateOrgPrivateRegistry: [\n      \"PATCH /orgs/{org}/private-registries/{secret_name}\"\n    ]\n  },\n  projects: {\n    addCollaborator: [\n      \"PUT /projects/{project_id}/collaborators/{username}\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.addCollaborator() is deprecated, see https://docs.github.com/rest/projects/collaborators#add-project-collaborator\"\n      }\n    ],\n    createCard: [\n      \"POST /projects/columns/{column_id}/cards\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.createCard() is deprecated, see https://docs.github.com/rest/projects/cards#create-a-project-card\"\n      }\n    ],\n    createColumn: [\n      \"POST /projects/{project_id}/columns\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.createColumn() is deprecated, see https://docs.github.com/rest/projects/columns#create-a-project-column\"\n      }\n    ],\n    createForAuthenticatedUser: [\n      \"POST /user/projects\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.createForAuthenticatedUser() is deprecated, see https://docs.github.com/rest/projects/projects#create-a-user-project\"\n      }\n    ],\n    createForOrg: [\n      \"POST /orgs/{org}/projects\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.createForOrg() is deprecated, see https://docs.github.com/rest/projects/projects#create-an-organization-project\"\n      }\n    ],\n    createForRepo: [\n      \"POST /repos/{owner}/{repo}/projects\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.createForRepo() is deprecated, see https://docs.github.com/rest/projects/projects#create-a-repository-project\"\n      }\n    ],\n    delete: [\n      \"DELETE /projects/{project_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.delete() is deprecated, see https://docs.github.com/rest/projects/projects#delete-a-project\"\n      }\n    ],\n    deleteCard: [\n      \"DELETE /projects/columns/cards/{card_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.deleteCard() is deprecated, see https://docs.github.com/rest/projects/cards#delete-a-project-card\"\n      }\n    ],\n    deleteColumn: [\n      \"DELETE /projects/columns/{column_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.deleteColumn() is deprecated, see https://docs.github.com/rest/projects/columns#delete-a-project-column\"\n      }\n    ],\n    get: [\n      \"GET /projects/{project_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.get() is deprecated, see https://docs.github.com/rest/projects/projects#get-a-project\"\n      }\n    ],\n    getCard: [\n      \"GET /projects/columns/cards/{card_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.getCard() is deprecated, see https://docs.github.com/rest/projects/cards#get-a-project-card\"\n      }\n    ],\n    getColumn: [\n      \"GET /projects/columns/{column_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.getColumn() is deprecated, see https://docs.github.com/rest/projects/columns#get-a-project-column\"\n      }\n    ],\n    getPermissionForUser: [\n      \"GET /projects/{project_id}/collaborators/{username}/permission\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.getPermissionForUser() is deprecated, see https://docs.github.com/rest/projects/collaborators#get-project-permission-for-a-user\"\n      }\n    ],\n    listCards: [\n      \"GET /projects/columns/{column_id}/cards\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.listCards() is deprecated, see https://docs.github.com/rest/projects/cards#list-project-cards\"\n      }\n    ],\n    listCollaborators: [\n      \"GET /projects/{project_id}/collaborators\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.listCollaborators() is deprecated, see https://docs.github.com/rest/projects/collaborators#list-project-collaborators\"\n      }\n    ],\n    listColumns: [\n      \"GET /projects/{project_id}/columns\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.listColumns() is deprecated, see https://docs.github.com/rest/projects/columns#list-project-columns\"\n      }\n    ],\n    listForOrg: [\n      \"GET /orgs/{org}/projects\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.listForOrg() is deprecated, see https://docs.github.com/rest/projects/projects#list-organization-projects\"\n      }\n    ],\n    listForRepo: [\n      \"GET /repos/{owner}/{repo}/projects\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.listForRepo() is deprecated, see https://docs.github.com/rest/projects/projects#list-repository-projects\"\n      }\n    ],\n    listForUser: [\n      \"GET /users/{username}/projects\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.listForUser() is deprecated, see https://docs.github.com/rest/projects/projects#list-user-projects\"\n      }\n    ],\n    moveCard: [\n      \"POST /projects/columns/cards/{card_id}/moves\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.moveCard() is deprecated, see https://docs.github.com/rest/projects/cards#move-a-project-card\"\n      }\n    ],\n    moveColumn: [\n      \"POST /projects/columns/{column_id}/moves\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.moveColumn() is deprecated, see https://docs.github.com/rest/projects/columns#move-a-project-column\"\n      }\n    ],\n    removeCollaborator: [\n      \"DELETE /projects/{project_id}/collaborators/{username}\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.removeCollaborator() is deprecated, see https://docs.github.com/rest/projects/collaborators#remove-user-as-a-collaborator\"\n      }\n    ],\n    update: [\n      \"PATCH /projects/{project_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.update() is deprecated, see https://docs.github.com/rest/projects/projects#update-a-project\"\n      }\n    ],\n    updateCard: [\n      \"PATCH /projects/columns/cards/{card_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.updateCard() is deprecated, see https://docs.github.com/rest/projects/cards#update-an-existing-project-card\"\n      }\n    ],\n    updateColumn: [\n      \"PATCH /projects/columns/{column_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.projects.updateColumn() is deprecated, see https://docs.github.com/rest/projects/columns#update-an-existing-project-column\"\n      }\n    ]\n  },\n  pulls: {\n    checkIfMerged: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/merge\"],\n    create: [\"POST /repos/{owner}/{repo}/pulls\"],\n    createReplyForReviewComment: [\n      \"POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies\"\n    ],\n    createReview: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews\"],\n    createReviewComment: [\n      \"POST /repos/{owner}/{repo}/pulls/{pull_number}/comments\"\n    ],\n    deletePendingReview: [\n      \"DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}\"\n    ],\n    deleteReviewComment: [\n      \"DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}\"\n    ],\n    dismissReview: [\n      \"PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals\"\n    ],\n    get: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}\"],\n    getReview: [\n      \"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}\"\n    ],\n    getReviewComment: [\"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}\"],\n    list: [\"GET /repos/{owner}/{repo}/pulls\"],\n    listCommentsForReview: [\n      \"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments\"\n    ],\n    listCommits: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/commits\"],\n    listFiles: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/files\"],\n    listRequestedReviewers: [\n      \"GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\"\n    ],\n    listReviewComments: [\n      \"GET /repos/{owner}/{repo}/pulls/{pull_number}/comments\"\n    ],\n    listReviewCommentsForRepo: [\"GET /repos/{owner}/{repo}/pulls/comments\"],\n    listReviews: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews\"],\n    merge: [\"PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge\"],\n    removeRequestedReviewers: [\n      \"DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\"\n    ],\n    requestReviewers: [\n      \"POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\"\n    ],\n    submitReview: [\n      \"POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events\"\n    ],\n    update: [\"PATCH /repos/{owner}/{repo}/pulls/{pull_number}\"],\n    updateBranch: [\n      \"PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch\"\n    ],\n    updateReview: [\n      \"PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}\"\n    ],\n    updateReviewComment: [\n      \"PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}\"\n    ]\n  },\n  rateLimit: { get: [\"GET /rate_limit\"] },\n  reactions: {\n    createForCommitComment: [\n      \"POST /repos/{owner}/{repo}/comments/{comment_id}/reactions\"\n    ],\n    createForIssue: [\n      \"POST /repos/{owner}/{repo}/issues/{issue_number}/reactions\"\n    ],\n    createForIssueComment: [\n      \"POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions\"\n    ],\n    createForPullRequestReviewComment: [\n      \"POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions\"\n    ],\n    createForRelease: [\n      \"POST /repos/{owner}/{repo}/releases/{release_id}/reactions\"\n    ],\n    createForTeamDiscussionCommentInOrg: [\n      \"POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions\"\n    ],\n    createForTeamDiscussionInOrg: [\n      \"POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions\"\n    ],\n    deleteForCommitComment: [\n      \"DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}\"\n    ],\n    deleteForIssue: [\n      \"DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}\"\n    ],\n    deleteForIssueComment: [\n      \"DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}\"\n    ],\n    deleteForPullRequestComment: [\n      \"DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}\"\n    ],\n    deleteForRelease: [\n      \"DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}\"\n    ],\n    deleteForTeamDiscussion: [\n      \"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}\"\n    ],\n    deleteForTeamDiscussionComment: [\n      \"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}\"\n    ],\n    listForCommitComment: [\n      \"GET /repos/{owner}/{repo}/comments/{comment_id}/reactions\"\n    ],\n    listForIssue: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/reactions\"],\n    listForIssueComment: [\n      \"GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions\"\n    ],\n    listForPullRequestReviewComment: [\n      \"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions\"\n    ],\n    listForRelease: [\n      \"GET /repos/{owner}/{repo}/releases/{release_id}/reactions\"\n    ],\n    listForTeamDiscussionCommentInOrg: [\n      \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions\"\n    ],\n    listForTeamDiscussionInOrg: [\n      \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions\"\n    ]\n  },\n  repos: {\n    acceptInvitation: [\n      \"PATCH /user/repository_invitations/{invitation_id}\",\n      {},\n      { renamed: [\"repos\", \"acceptInvitationForAuthenticatedUser\"] }\n    ],\n    acceptInvitationForAuthenticatedUser: [\n      \"PATCH /user/repository_invitations/{invitation_id}\"\n    ],\n    addAppAccessRestrictions: [\n      \"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps\",\n      {},\n      { mapToData: \"apps\" }\n    ],\n    addCollaborator: [\"PUT /repos/{owner}/{repo}/collaborators/{username}\"],\n    addStatusCheckContexts: [\n      \"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts\",\n      {},\n      { mapToData: \"contexts\" }\n    ],\n    addTeamAccessRestrictions: [\n      \"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams\",\n      {},\n      { mapToData: \"teams\" }\n    ],\n    addUserAccessRestrictions: [\n      \"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users\",\n      {},\n      { mapToData: \"users\" }\n    ],\n    cancelPagesDeployment: [\n      \"POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel\"\n    ],\n    checkAutomatedSecurityFixes: [\n      \"GET /repos/{owner}/{repo}/automated-security-fixes\"\n    ],\n    checkCollaborator: [\"GET /repos/{owner}/{repo}/collaborators/{username}\"],\n    checkPrivateVulnerabilityReporting: [\n      \"GET /repos/{owner}/{repo}/private-vulnerability-reporting\"\n    ],\n    checkVulnerabilityAlerts: [\n      \"GET /repos/{owner}/{repo}/vulnerability-alerts\"\n    ],\n    codeownersErrors: [\"GET /repos/{owner}/{repo}/codeowners/errors\"],\n    compareCommits: [\"GET /repos/{owner}/{repo}/compare/{base}...{head}\"],\n    compareCommitsWithBasehead: [\n      \"GET /repos/{owner}/{repo}/compare/{basehead}\"\n    ],\n    createAttestation: [\"POST /repos/{owner}/{repo}/attestations\"],\n    createAutolink: [\"POST /repos/{owner}/{repo}/autolinks\"],\n    createCommitComment: [\n      \"POST /repos/{owner}/{repo}/commits/{commit_sha}/comments\"\n    ],\n    createCommitSignatureProtection: [\n      \"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures\"\n    ],\n    createCommitStatus: [\"POST /repos/{owner}/{repo}/statuses/{sha}\"],\n    createDeployKey: [\"POST /repos/{owner}/{repo}/keys\"],\n    createDeployment: [\"POST /repos/{owner}/{repo}/deployments\"],\n    createDeploymentBranchPolicy: [\n      \"POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies\"\n    ],\n    createDeploymentProtectionRule: [\n      \"POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules\"\n    ],\n    createDeploymentStatus: [\n      \"POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses\"\n    ],\n    createDispatchEvent: [\"POST /repos/{owner}/{repo}/dispatches\"],\n    createForAuthenticatedUser: [\"POST /user/repos\"],\n    createFork: [\"POST /repos/{owner}/{repo}/forks\"],\n    createInOrg: [\"POST /orgs/{org}/repos\"],\n    createOrUpdateCustomPropertiesValues: [\n      \"PATCH /repos/{owner}/{repo}/properties/values\"\n    ],\n    createOrUpdateEnvironment: [\n      \"PUT /repos/{owner}/{repo}/environments/{environment_name}\"\n    ],\n    createOrUpdateFileContents: [\"PUT /repos/{owner}/{repo}/contents/{path}\"],\n    createOrgRuleset: [\"POST /orgs/{org}/rulesets\"],\n    createPagesDeployment: [\"POST /repos/{owner}/{repo}/pages/deployments\"],\n    createPagesSite: [\"POST /repos/{owner}/{repo}/pages\"],\n    createRelease: [\"POST /repos/{owner}/{repo}/releases\"],\n    createRepoRuleset: [\"POST /repos/{owner}/{repo}/rulesets\"],\n    createUsingTemplate: [\n      \"POST /repos/{template_owner}/{template_repo}/generate\"\n    ],\n    createWebhook: [\"POST /repos/{owner}/{repo}/hooks\"],\n    declineInvitation: [\n      \"DELETE /user/repository_invitations/{invitation_id}\",\n      {},\n      { renamed: [\"repos\", \"declineInvitationForAuthenticatedUser\"] }\n    ],\n    declineInvitationForAuthenticatedUser: [\n      \"DELETE /user/repository_invitations/{invitation_id}\"\n    ],\n    delete: [\"DELETE /repos/{owner}/{repo}\"],\n    deleteAccessRestrictions: [\n      \"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions\"\n    ],\n    deleteAdminBranchProtection: [\n      \"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins\"\n    ],\n    deleteAnEnvironment: [\n      \"DELETE /repos/{owner}/{repo}/environments/{environment_name}\"\n    ],\n    deleteAutolink: [\"DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}\"],\n    deleteBranchProtection: [\n      \"DELETE /repos/{owner}/{repo}/branches/{branch}/protection\"\n    ],\n    deleteCommitComment: [\"DELETE /repos/{owner}/{repo}/comments/{comment_id}\"],\n    deleteCommitSignatureProtection: [\n      \"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures\"\n    ],\n    deleteDeployKey: [\"DELETE /repos/{owner}/{repo}/keys/{key_id}\"],\n    deleteDeployment: [\n      \"DELETE /repos/{owner}/{repo}/deployments/{deployment_id}\"\n    ],\n    deleteDeploymentBranchPolicy: [\n      \"DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}\"\n    ],\n    deleteFile: [\"DELETE /repos/{owner}/{repo}/contents/{path}\"],\n    deleteInvitation: [\n      \"DELETE /repos/{owner}/{repo}/invitations/{invitation_id}\"\n    ],\n    deleteOrgRuleset: [\"DELETE /orgs/{org}/rulesets/{ruleset_id}\"],\n    deletePagesSite: [\"DELETE /repos/{owner}/{repo}/pages\"],\n    deletePullRequestReviewProtection: [\n      \"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews\"\n    ],\n    deleteRelease: [\"DELETE /repos/{owner}/{repo}/releases/{release_id}\"],\n    deleteReleaseAsset: [\n      \"DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}\"\n    ],\n    deleteRepoRuleset: [\"DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}\"],\n    deleteWebhook: [\"DELETE /repos/{owner}/{repo}/hooks/{hook_id}\"],\n    disableAutomatedSecurityFixes: [\n      \"DELETE /repos/{owner}/{repo}/automated-security-fixes\"\n    ],\n    disableDeploymentProtectionRule: [\n      \"DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}\"\n    ],\n    disablePrivateVulnerabilityReporting: [\n      \"DELETE /repos/{owner}/{repo}/private-vulnerability-reporting\"\n    ],\n    disableVulnerabilityAlerts: [\n      \"DELETE /repos/{owner}/{repo}/vulnerability-alerts\"\n    ],\n    downloadArchive: [\n      \"GET /repos/{owner}/{repo}/zipball/{ref}\",\n      {},\n      { renamed: [\"repos\", \"downloadZipballArchive\"] }\n    ],\n    downloadTarballArchive: [\"GET /repos/{owner}/{repo}/tarball/{ref}\"],\n    downloadZipballArchive: [\"GET /repos/{owner}/{repo}/zipball/{ref}\"],\n    enableAutomatedSecurityFixes: [\n      \"PUT /repos/{owner}/{repo}/automated-security-fixes\"\n    ],\n    enablePrivateVulnerabilityReporting: [\n      \"PUT /repos/{owner}/{repo}/private-vulnerability-reporting\"\n    ],\n    enableVulnerabilityAlerts: [\n      \"PUT /repos/{owner}/{repo}/vulnerability-alerts\"\n    ],\n    generateReleaseNotes: [\n      \"POST /repos/{owner}/{repo}/releases/generate-notes\"\n    ],\n    get: [\"GET /repos/{owner}/{repo}\"],\n    getAccessRestrictions: [\n      \"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions\"\n    ],\n    getAdminBranchProtection: [\n      \"GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins\"\n    ],\n    getAllDeploymentProtectionRules: [\n      \"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules\"\n    ],\n    getAllEnvironments: [\"GET /repos/{owner}/{repo}/environments\"],\n    getAllStatusCheckContexts: [\n      \"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts\"\n    ],\n    getAllTopics: [\"GET /repos/{owner}/{repo}/topics\"],\n    getAppsWithAccessToProtectedBranch: [\n      \"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps\"\n    ],\n    getAutolink: [\"GET /repos/{owner}/{repo}/autolinks/{autolink_id}\"],\n    getBranch: [\"GET /repos/{owner}/{repo}/branches/{branch}\"],\n    getBranchProtection: [\n      \"GET /repos/{owner}/{repo}/branches/{branch}/protection\"\n    ],\n    getBranchRules: [\"GET /repos/{owner}/{repo}/rules/branches/{branch}\"],\n    getClones: [\"GET /repos/{owner}/{repo}/traffic/clones\"],\n    getCodeFrequencyStats: [\"GET /repos/{owner}/{repo}/stats/code_frequency\"],\n    getCollaboratorPermissionLevel: [\n      \"GET /repos/{owner}/{repo}/collaborators/{username}/permission\"\n    ],\n    getCombinedStatusForRef: [\"GET /repos/{owner}/{repo}/commits/{ref}/status\"],\n    getCommit: [\"GET /repos/{owner}/{repo}/commits/{ref}\"],\n    getCommitActivityStats: [\"GET /repos/{owner}/{repo}/stats/commit_activity\"],\n    getCommitComment: [\"GET /repos/{owner}/{repo}/comments/{comment_id}\"],\n    getCommitSignatureProtection: [\n      \"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures\"\n    ],\n    getCommunityProfileMetrics: [\"GET /repos/{owner}/{repo}/community/profile\"],\n    getContent: [\"GET /repos/{owner}/{repo}/contents/{path}\"],\n    getContributorsStats: [\"GET /repos/{owner}/{repo}/stats/contributors\"],\n    getCustomDeploymentProtectionRule: [\n      \"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}\"\n    ],\n    getCustomPropertiesValues: [\"GET /repos/{owner}/{repo}/properties/values\"],\n    getDeployKey: [\"GET /repos/{owner}/{repo}/keys/{key_id}\"],\n    getDeployment: [\"GET /repos/{owner}/{repo}/deployments/{deployment_id}\"],\n    getDeploymentBranchPolicy: [\n      \"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}\"\n    ],\n    getDeploymentStatus: [\n      \"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}\"\n    ],\n    getEnvironment: [\n      \"GET /repos/{owner}/{repo}/environments/{environment_name}\"\n    ],\n    getLatestPagesBuild: [\"GET /repos/{owner}/{repo}/pages/builds/latest\"],\n    getLatestRelease: [\"GET /repos/{owner}/{repo}/releases/latest\"],\n    getOrgRuleSuite: [\"GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}\"],\n    getOrgRuleSuites: [\"GET /orgs/{org}/rulesets/rule-suites\"],\n    getOrgRuleset: [\"GET /orgs/{org}/rulesets/{ruleset_id}\"],\n    getOrgRulesets: [\"GET /orgs/{org}/rulesets\"],\n    getPages: [\"GET /repos/{owner}/{repo}/pages\"],\n    getPagesBuild: [\"GET /repos/{owner}/{repo}/pages/builds/{build_id}\"],\n    getPagesDeployment: [\n      \"GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}\"\n    ],\n    getPagesHealthCheck: [\"GET /repos/{owner}/{repo}/pages/health\"],\n    getParticipationStats: [\"GET /repos/{owner}/{repo}/stats/participation\"],\n    getPullRequestReviewProtection: [\n      \"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews\"\n    ],\n    getPunchCardStats: [\"GET /repos/{owner}/{repo}/stats/punch_card\"],\n    getReadme: [\"GET /repos/{owner}/{repo}/readme\"],\n    getReadmeInDirectory: [\"GET /repos/{owner}/{repo}/readme/{dir}\"],\n    getRelease: [\"GET /repos/{owner}/{repo}/releases/{release_id}\"],\n    getReleaseAsset: [\"GET /repos/{owner}/{repo}/releases/assets/{asset_id}\"],\n    getReleaseByTag: [\"GET /repos/{owner}/{repo}/releases/tags/{tag}\"],\n    getRepoRuleSuite: [\n      \"GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}\"\n    ],\n    getRepoRuleSuites: [\"GET /repos/{owner}/{repo}/rulesets/rule-suites\"],\n    getRepoRuleset: [\"GET /repos/{owner}/{repo}/rulesets/{ruleset_id}\"],\n    getRepoRulesetHistory: [\n      \"GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history\"\n    ],\n    getRepoRulesetVersion: [\n      \"GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}\"\n    ],\n    getRepoRulesets: [\"GET /repos/{owner}/{repo}/rulesets\"],\n    getStatusChecksProtection: [\n      \"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks\"\n    ],\n    getTeamsWithAccessToProtectedBranch: [\n      \"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams\"\n    ],\n    getTopPaths: [\"GET /repos/{owner}/{repo}/traffic/popular/paths\"],\n    getTopReferrers: [\"GET /repos/{owner}/{repo}/traffic/popular/referrers\"],\n    getUsersWithAccessToProtectedBranch: [\n      \"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users\"\n    ],\n    getViews: [\"GET /repos/{owner}/{repo}/traffic/views\"],\n    getWebhook: [\"GET /repos/{owner}/{repo}/hooks/{hook_id}\"],\n    getWebhookConfigForRepo: [\n      \"GET /repos/{owner}/{repo}/hooks/{hook_id}/config\"\n    ],\n    getWebhookDelivery: [\n      \"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}\"\n    ],\n    listActivities: [\"GET /repos/{owner}/{repo}/activity\"],\n    listAttestations: [\n      \"GET /repos/{owner}/{repo}/attestations/{subject_digest}\"\n    ],\n    listAutolinks: [\"GET /repos/{owner}/{repo}/autolinks\"],\n    listBranches: [\"GET /repos/{owner}/{repo}/branches\"],\n    listBranchesForHeadCommit: [\n      \"GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head\"\n    ],\n    listCollaborators: [\"GET /repos/{owner}/{repo}/collaborators\"],\n    listCommentsForCommit: [\n      \"GET /repos/{owner}/{repo}/commits/{commit_sha}/comments\"\n    ],\n    listCommitCommentsForRepo: [\"GET /repos/{owner}/{repo}/comments\"],\n    listCommitStatusesForRef: [\n      \"GET /repos/{owner}/{repo}/commits/{ref}/statuses\"\n    ],\n    listCommits: [\"GET /repos/{owner}/{repo}/commits\"],\n    listContributors: [\"GET /repos/{owner}/{repo}/contributors\"],\n    listCustomDeploymentRuleIntegrations: [\n      \"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps\"\n    ],\n    listDeployKeys: [\"GET /repos/{owner}/{repo}/keys\"],\n    listDeploymentBranchPolicies: [\n      \"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies\"\n    ],\n    listDeploymentStatuses: [\n      \"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses\"\n    ],\n    listDeployments: [\"GET /repos/{owner}/{repo}/deployments\"],\n    listForAuthenticatedUser: [\"GET /user/repos\"],\n    listForOrg: [\"GET /orgs/{org}/repos\"],\n    listForUser: [\"GET /users/{username}/repos\"],\n    listForks: [\"GET /repos/{owner}/{repo}/forks\"],\n    listInvitations: [\"GET /repos/{owner}/{repo}/invitations\"],\n    listInvitationsForAuthenticatedUser: [\"GET /user/repository_invitations\"],\n    listLanguages: [\"GET /repos/{owner}/{repo}/languages\"],\n    listPagesBuilds: [\"GET /repos/{owner}/{repo}/pages/builds\"],\n    listPublic: [\"GET /repositories\"],\n    listPullRequestsAssociatedWithCommit: [\n      \"GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls\"\n    ],\n    listReleaseAssets: [\n      \"GET /repos/{owner}/{repo}/releases/{release_id}/assets\"\n    ],\n    listReleases: [\"GET /repos/{owner}/{repo}/releases\"],\n    listTags: [\"GET /repos/{owner}/{repo}/tags\"],\n    listTeams: [\"GET /repos/{owner}/{repo}/teams\"],\n    listWebhookDeliveries: [\n      \"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries\"\n    ],\n    listWebhooks: [\"GET /repos/{owner}/{repo}/hooks\"],\n    merge: [\"POST /repos/{owner}/{repo}/merges\"],\n    mergeUpstream: [\"POST /repos/{owner}/{repo}/merge-upstream\"],\n    pingWebhook: [\"POST /repos/{owner}/{repo}/hooks/{hook_id}/pings\"],\n    redeliverWebhookDelivery: [\n      \"POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts\"\n    ],\n    removeAppAccessRestrictions: [\n      \"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps\",\n      {},\n      { mapToData: \"apps\" }\n    ],\n    removeCollaborator: [\n      \"DELETE /repos/{owner}/{repo}/collaborators/{username}\"\n    ],\n    removeStatusCheckContexts: [\n      \"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts\",\n      {},\n      { mapToData: \"contexts\" }\n    ],\n    removeStatusCheckProtection: [\n      \"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks\"\n    ],\n    removeTeamAccessRestrictions: [\n      \"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams\",\n      {},\n      { mapToData: \"teams\" }\n    ],\n    removeUserAccessRestrictions: [\n      \"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users\",\n      {},\n      { mapToData: \"users\" }\n    ],\n    renameBranch: [\"POST /repos/{owner}/{repo}/branches/{branch}/rename\"],\n    replaceAllTopics: [\"PUT /repos/{owner}/{repo}/topics\"],\n    requestPagesBuild: [\"POST /repos/{owner}/{repo}/pages/builds\"],\n    setAdminBranchProtection: [\n      \"POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins\"\n    ],\n    setAppAccessRestrictions: [\n      \"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps\",\n      {},\n      { mapToData: \"apps\" }\n    ],\n    setStatusCheckContexts: [\n      \"PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts\",\n      {},\n      { mapToData: \"contexts\" }\n    ],\n    setTeamAccessRestrictions: [\n      \"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams\",\n      {},\n      { mapToData: \"teams\" }\n    ],\n    setUserAccessRestrictions: [\n      \"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users\",\n      {},\n      { mapToData: \"users\" }\n    ],\n    testPushWebhook: [\"POST /repos/{owner}/{repo}/hooks/{hook_id}/tests\"],\n    transfer: [\"POST /repos/{owner}/{repo}/transfer\"],\n    update: [\"PATCH /repos/{owner}/{repo}\"],\n    updateBranchProtection: [\n      \"PUT /repos/{owner}/{repo}/branches/{branch}/protection\"\n    ],\n    updateCommitComment: [\"PATCH /repos/{owner}/{repo}/comments/{comment_id}\"],\n    updateDeploymentBranchPolicy: [\n      \"PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}\"\n    ],\n    updateInformationAboutPagesSite: [\"PUT /repos/{owner}/{repo}/pages\"],\n    updateInvitation: [\n      \"PATCH /repos/{owner}/{repo}/invitations/{invitation_id}\"\n    ],\n    updateOrgRuleset: [\"PUT /orgs/{org}/rulesets/{ruleset_id}\"],\n    updatePullRequestReviewProtection: [\n      \"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews\"\n    ],\n    updateRelease: [\"PATCH /repos/{owner}/{repo}/releases/{release_id}\"],\n    updateReleaseAsset: [\n      \"PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}\"\n    ],\n    updateRepoRuleset: [\"PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}\"],\n    updateStatusCheckPotection: [\n      \"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks\",\n      {},\n      { renamed: [\"repos\", \"updateStatusCheckProtection\"] }\n    ],\n    updateStatusCheckProtection: [\n      \"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks\"\n    ],\n    updateWebhook: [\"PATCH /repos/{owner}/{repo}/hooks/{hook_id}\"],\n    updateWebhookConfigForRepo: [\n      \"PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config\"\n    ],\n    uploadReleaseAsset: [\n      \"POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}\",\n      { baseUrl: \"https://uploads.github.com\" }\n    ]\n  },\n  search: {\n    code: [\"GET /search/code\"],\n    commits: [\"GET /search/commits\"],\n    issuesAndPullRequests: [\n      \"GET /search/issues\",\n      {},\n      {\n        deprecated: \"octokit.rest.search.issuesAndPullRequests() is deprecated, see https://docs.github.com/rest/search/search#search-issues-and-pull-requests\"\n      }\n    ],\n    labels: [\"GET /search/labels\"],\n    repos: [\"GET /search/repositories\"],\n    topics: [\"GET /search/topics\"],\n    users: [\"GET /search/users\"]\n  },\n  secretScanning: {\n    createPushProtectionBypass: [\n      \"POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses\"\n    ],\n    getAlert: [\n      \"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}\"\n    ],\n    getScanHistory: [\"GET /repos/{owner}/{repo}/secret-scanning/scan-history\"],\n    listAlertsForEnterprise: [\n      \"GET /enterprises/{enterprise}/secret-scanning/alerts\"\n    ],\n    listAlertsForOrg: [\"GET /orgs/{org}/secret-scanning/alerts\"],\n    listAlertsForRepo: [\"GET /repos/{owner}/{repo}/secret-scanning/alerts\"],\n    listLocationsForAlert: [\n      \"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations\"\n    ],\n    updateAlert: [\n      \"PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}\"\n    ]\n  },\n  securityAdvisories: {\n    createFork: [\n      \"POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks\"\n    ],\n    createPrivateVulnerabilityReport: [\n      \"POST /repos/{owner}/{repo}/security-advisories/reports\"\n    ],\n    createRepositoryAdvisory: [\n      \"POST /repos/{owner}/{repo}/security-advisories\"\n    ],\n    createRepositoryAdvisoryCveRequest: [\n      \"POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve\"\n    ],\n    getGlobalAdvisory: [\"GET /advisories/{ghsa_id}\"],\n    getRepositoryAdvisory: [\n      \"GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}\"\n    ],\n    listGlobalAdvisories: [\"GET /advisories\"],\n    listOrgRepositoryAdvisories: [\"GET /orgs/{org}/security-advisories\"],\n    listRepositoryAdvisories: [\"GET /repos/{owner}/{repo}/security-advisories\"],\n    updateRepositoryAdvisory: [\n      \"PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}\"\n    ]\n  },\n  teams: {\n    addOrUpdateMembershipForUserInOrg: [\n      \"PUT /orgs/{org}/teams/{team_slug}/memberships/{username}\"\n    ],\n    addOrUpdateProjectPermissionsInOrg: [\n      \"PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.teams.addOrUpdateProjectPermissionsInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#add-or-update-team-project-permissions\"\n      }\n    ],\n    addOrUpdateProjectPermissionsLegacy: [\n      \"PUT /teams/{team_id}/projects/{project_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.teams.addOrUpdateProjectPermissionsLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#add-or-update-team-project-permissions-legacy\"\n      }\n    ],\n    addOrUpdateRepoPermissionsInOrg: [\n      \"PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}\"\n    ],\n    checkPermissionsForProjectInOrg: [\n      \"GET /orgs/{org}/teams/{team_slug}/projects/{project_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.teams.checkPermissionsForProjectInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-project\"\n      }\n    ],\n    checkPermissionsForProjectLegacy: [\n      \"GET /teams/{team_id}/projects/{project_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.teams.checkPermissionsForProjectLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-project-legacy\"\n      }\n    ],\n    checkPermissionsForRepoInOrg: [\n      \"GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}\"\n    ],\n    create: [\"POST /orgs/{org}/teams\"],\n    createDiscussionCommentInOrg: [\n      \"POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\"\n    ],\n    createDiscussionInOrg: [\"POST /orgs/{org}/teams/{team_slug}/discussions\"],\n    deleteDiscussionCommentInOrg: [\n      \"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}\"\n    ],\n    deleteDiscussionInOrg: [\n      \"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}\"\n    ],\n    deleteInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}\"],\n    getByName: [\"GET /orgs/{org}/teams/{team_slug}\"],\n    getDiscussionCommentInOrg: [\n      \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}\"\n    ],\n    getDiscussionInOrg: [\n      \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}\"\n    ],\n    getMembershipForUserInOrg: [\n      \"GET /orgs/{org}/teams/{team_slug}/memberships/{username}\"\n    ],\n    list: [\"GET /orgs/{org}/teams\"],\n    listChildInOrg: [\"GET /orgs/{org}/teams/{team_slug}/teams\"],\n    listDiscussionCommentsInOrg: [\n      \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\"\n    ],\n    listDiscussionsInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions\"],\n    listForAuthenticatedUser: [\"GET /user/teams\"],\n    listMembersInOrg: [\"GET /orgs/{org}/teams/{team_slug}/members\"],\n    listPendingInvitationsInOrg: [\n      \"GET /orgs/{org}/teams/{team_slug}/invitations\"\n    ],\n    listProjectsInOrg: [\n      \"GET /orgs/{org}/teams/{team_slug}/projects\",\n      {},\n      {\n        deprecated: \"octokit.rest.teams.listProjectsInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#list-team-projects\"\n      }\n    ],\n    listProjectsLegacy: [\n      \"GET /teams/{team_id}/projects\",\n      {},\n      {\n        deprecated: \"octokit.rest.teams.listProjectsLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#list-team-projects-legacy\"\n      }\n    ],\n    listReposInOrg: [\"GET /orgs/{org}/teams/{team_slug}/repos\"],\n    removeMembershipForUserInOrg: [\n      \"DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}\"\n    ],\n    removeProjectInOrg: [\n      \"DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.teams.removeProjectInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#remove-a-project-from-a-team\"\n      }\n    ],\n    removeProjectLegacy: [\n      \"DELETE /teams/{team_id}/projects/{project_id}\",\n      {},\n      {\n        deprecated: \"octokit.rest.teams.removeProjectLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#remove-a-project-from-a-team-legacy\"\n      }\n    ],\n    removeRepoInOrg: [\n      \"DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}\"\n    ],\n    updateDiscussionCommentInOrg: [\n      \"PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}\"\n    ],\n    updateDiscussionInOrg: [\n      \"PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}\"\n    ],\n    updateInOrg: [\"PATCH /orgs/{org}/teams/{team_slug}\"]\n  },\n  users: {\n    addEmailForAuthenticated: [\n      \"POST /user/emails\",\n      {},\n      { renamed: [\"users\", \"addEmailForAuthenticatedUser\"] }\n    ],\n    addEmailForAuthenticatedUser: [\"POST /user/emails\"],\n    addSocialAccountForAuthenticatedUser: [\"POST /user/social_accounts\"],\n    block: [\"PUT /user/blocks/{username}\"],\n    checkBlocked: [\"GET /user/blocks/{username}\"],\n    checkFollowingForUser: [\"GET /users/{username}/following/{target_user}\"],\n    checkPersonIsFollowedByAuthenticated: [\"GET /user/following/{username}\"],\n    createGpgKeyForAuthenticated: [\n      \"POST /user/gpg_keys\",\n      {},\n      { renamed: [\"users\", \"createGpgKeyForAuthenticatedUser\"] }\n    ],\n    createGpgKeyForAuthenticatedUser: [\"POST /user/gpg_keys\"],\n    createPublicSshKeyForAuthenticated: [\n      \"POST /user/keys\",\n      {},\n      { renamed: [\"users\", \"createPublicSshKeyForAuthenticatedUser\"] }\n    ],\n    createPublicSshKeyForAuthenticatedUser: [\"POST /user/keys\"],\n    createSshSigningKeyForAuthenticatedUser: [\"POST /user/ssh_signing_keys\"],\n    deleteEmailForAuthenticated: [\n      \"DELETE /user/emails\",\n      {},\n      { renamed: [\"users\", \"deleteEmailForAuthenticatedUser\"] }\n    ],\n    deleteEmailForAuthenticatedUser: [\"DELETE /user/emails\"],\n    deleteGpgKeyForAuthenticated: [\n      \"DELETE /user/gpg_keys/{gpg_key_id}\",\n      {},\n      { renamed: [\"users\", \"deleteGpgKeyForAuthenticatedUser\"] }\n    ],\n    deleteGpgKeyForAuthenticatedUser: [\"DELETE /user/gpg_keys/{gpg_key_id}\"],\n    deletePublicSshKeyForAuthenticated: [\n      \"DELETE /user/keys/{key_id}\",\n      {},\n      { renamed: [\"users\", \"deletePublicSshKeyForAuthenticatedUser\"] }\n    ],\n    deletePublicSshKeyForAuthenticatedUser: [\"DELETE /user/keys/{key_id}\"],\n    deleteSocialAccountForAuthenticatedUser: [\"DELETE /user/social_accounts\"],\n    deleteSshSigningKeyForAuthenticatedUser: [\n      \"DELETE /user/ssh_signing_keys/{ssh_signing_key_id}\"\n    ],\n    follow: [\"PUT /user/following/{username}\"],\n    getAuthenticated: [\"GET /user\"],\n    getById: [\"GET /user/{account_id}\"],\n    getByUsername: [\"GET /users/{username}\"],\n    getContextForUser: [\"GET /users/{username}/hovercard\"],\n    getGpgKeyForAuthenticated: [\n      \"GET /user/gpg_keys/{gpg_key_id}\",\n      {},\n      { renamed: [\"users\", \"getGpgKeyForAuthenticatedUser\"] }\n    ],\n    getGpgKeyForAuthenticatedUser: [\"GET /user/gpg_keys/{gpg_key_id}\"],\n    getPublicSshKeyForAuthenticated: [\n      \"GET /user/keys/{key_id}\",\n      {},\n      { renamed: [\"users\", \"getPublicSshKeyForAuthenticatedUser\"] }\n    ],\n    getPublicSshKeyForAuthenticatedUser: [\"GET /user/keys/{key_id}\"],\n    getSshSigningKeyForAuthenticatedUser: [\n      \"GET /user/ssh_signing_keys/{ssh_signing_key_id}\"\n    ],\n    list: [\"GET /users\"],\n    listAttestations: [\"GET /users/{username}/attestations/{subject_digest}\"],\n    listBlockedByAuthenticated: [\n      \"GET /user/blocks\",\n      {},\n      { renamed: [\"users\", \"listBlockedByAuthenticatedUser\"] }\n    ],\n    listBlockedByAuthenticatedUser: [\"GET /user/blocks\"],\n    listEmailsForAuthenticated: [\n      \"GET /user/emails\",\n      {},\n      { renamed: [\"users\", \"listEmailsForAuthenticatedUser\"] }\n    ],\n    listEmailsForAuthenticatedUser: [\"GET /user/emails\"],\n    listFollowedByAuthenticated: [\n      \"GET /user/following\",\n      {},\n      { renamed: [\"users\", \"listFollowedByAuthenticatedUser\"] }\n    ],\n    listFollowedByAuthenticatedUser: [\"GET /user/following\"],\n    listFollowersForAuthenticatedUser: [\"GET /user/followers\"],\n    listFollowersForUser: [\"GET /users/{username}/followers\"],\n    listFollowingForUser: [\"GET /users/{username}/following\"],\n    listGpgKeysForAuthenticated: [\n      \"GET /user/gpg_keys\",\n      {},\n      { renamed: [\"users\", \"listGpgKeysForAuthenticatedUser\"] }\n    ],\n    listGpgKeysForAuthenticatedUser: [\"GET /user/gpg_keys\"],\n    listGpgKeysForUser: [\"GET /users/{username}/gpg_keys\"],\n    listPublicEmailsForAuthenticated: [\n      \"GET /user/public_emails\",\n      {},\n      { renamed: [\"users\", \"listPublicEmailsForAuthenticatedUser\"] }\n    ],\n    listPublicEmailsForAuthenticatedUser: [\"GET /user/public_emails\"],\n    listPublicKeysForUser: [\"GET /users/{username}/keys\"],\n    listPublicSshKeysForAuthenticated: [\n      \"GET /user/keys\",\n      {},\n      { renamed: [\"users\", \"listPublicSshKeysForAuthenticatedUser\"] }\n    ],\n    listPublicSshKeysForAuthenticatedUser: [\"GET /user/keys\"],\n    listSocialAccountsForAuthenticatedUser: [\"GET /user/social_accounts\"],\n    listSocialAccountsForUser: [\"GET /users/{username}/social_accounts\"],\n    listSshSigningKeysForAuthenticatedUser: [\"GET /user/ssh_signing_keys\"],\n    listSshSigningKeysForUser: [\"GET /users/{username}/ssh_signing_keys\"],\n    setPrimaryEmailVisibilityForAuthenticated: [\n      \"PATCH /user/email/visibility\",\n      {},\n      { renamed: [\"users\", \"setPrimaryEmailVisibilityForAuthenticatedUser\"] }\n    ],\n    setPrimaryEmailVisibilityForAuthenticatedUser: [\n      \"PATCH /user/email/visibility\"\n    ],\n    unblock: [\"DELETE /user/blocks/{username}\"],\n    unfollow: [\"DELETE /user/following/{username}\"],\n    updateAuthenticated: [\"PATCH /user\"]\n  }\n};\nvar endpoints_default = Endpoints;\nexport {\n  endpoints_default as default\n};\n//# sourceMappingURL=endpoints.js.map\n","import ENDPOINTS from \"./generated/endpoints.js\";\nconst endpointMethodsMap = /* @__PURE__ */ new Map();\nfor (const [scope, endpoints] of Object.entries(ENDPOINTS)) {\n  for (const [methodName, endpoint] of Object.entries(endpoints)) {\n    const [route, defaults, decorations] = endpoint;\n    const [method, url] = route.split(/ /);\n    const endpointDefaults = Object.assign(\n      {\n        method,\n        url\n      },\n      defaults\n    );\n    if (!endpointMethodsMap.has(scope)) {\n      endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());\n    }\n    endpointMethodsMap.get(scope).set(methodName, {\n      scope,\n      methodName,\n      endpointDefaults,\n      decorations\n    });\n  }\n}\nconst handler = {\n  has({ scope }, methodName) {\n    return endpointMethodsMap.get(scope).has(methodName);\n  },\n  getOwnPropertyDescriptor(target, methodName) {\n    return {\n      value: this.get(target, methodName),\n      // ensures method is in the cache\n      configurable: true,\n      writable: true,\n      enumerable: true\n    };\n  },\n  defineProperty(target, methodName, descriptor) {\n    Object.defineProperty(target.cache, methodName, descriptor);\n    return true;\n  },\n  deleteProperty(target, methodName) {\n    delete target.cache[methodName];\n    return true;\n  },\n  ownKeys({ scope }) {\n    return [...endpointMethodsMap.get(scope).keys()];\n  },\n  set(target, methodName, value) {\n    return target.cache[methodName] = value;\n  },\n  get({ octokit, scope, cache }, methodName) {\n    if (cache[methodName]) {\n      return cache[methodName];\n    }\n    const method = endpointMethodsMap.get(scope).get(methodName);\n    if (!method) {\n      return void 0;\n    }\n    const { endpointDefaults, decorations } = method;\n    if (decorations) {\n      cache[methodName] = decorate(\n        octokit,\n        scope,\n        methodName,\n        endpointDefaults,\n        decorations\n      );\n    } else {\n      cache[methodName] = octokit.request.defaults(endpointDefaults);\n    }\n    return cache[methodName];\n  }\n};\nfunction endpointsToMethods(octokit) {\n  const newMethods = {};\n  for (const scope of endpointMethodsMap.keys()) {\n    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);\n  }\n  return newMethods;\n}\nfunction decorate(octokit, scope, methodName, defaults, decorations) {\n  const requestWithDefaults = octokit.request.defaults(defaults);\n  function withDecorations(...args) {\n    let options = requestWithDefaults.endpoint.merge(...args);\n    if (decorations.mapToData) {\n      options = Object.assign({}, options, {\n        data: options[decorations.mapToData],\n        [decorations.mapToData]: void 0\n      });\n      return requestWithDefaults(options);\n    }\n    if (decorations.renamed) {\n      const [newScope, newMethodName] = decorations.renamed;\n      octokit.log.warn(\n        `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`\n      );\n    }\n    if (decorations.deprecated) {\n      octokit.log.warn(decorations.deprecated);\n    }\n    if (decorations.renamedParameters) {\n      const options2 = requestWithDefaults.endpoint.merge(...args);\n      for (const [name, alias] of Object.entries(\n        decorations.renamedParameters\n      )) {\n        if (name in options2) {\n          octokit.log.warn(\n            `\"${name}\" parameter is deprecated for \"octokit.${scope}.${methodName}()\". Use \"${alias}\" instead`\n          );\n          if (!(alias in options2)) {\n            options2[alias] = options2[name];\n          }\n          delete options2[name];\n        }\n      }\n      return requestWithDefaults(options2);\n    }\n    return requestWithDefaults(...args);\n  }\n  return Object.assign(withDecorations, requestWithDefaults);\n}\nexport {\n  endpointsToMethods\n};\n//# sourceMappingURL=endpoints-to-methods.js.map\n","import { VERSION } from \"./version.js\";\nimport { endpointsToMethods } from \"./endpoints-to-methods.js\";\nfunction restEndpointMethods(octokit) {\n  const api = endpointsToMethods(octokit);\n  return {\n    rest: api\n  };\n}\nrestEndpointMethods.VERSION = VERSION;\nfunction legacyRestEndpointMethods(octokit) {\n  const api = endpointsToMethods(octokit);\n  return {\n    ...api,\n    rest: api\n  };\n}\nlegacyRestEndpointMethods.VERSION = VERSION;\nexport {\n  legacyRestEndpointMethods,\n  restEndpointMethods\n};\n//# sourceMappingURL=index.js.map\n","const VERSION = \"21.1.1\";\nexport {\n  VERSION\n};\n","import { Octokit as Core } from \"@octokit/core\";\nimport { requestLog } from \"@octokit/plugin-request-log\";\nimport {\n  paginateRest\n} from \"@octokit/plugin-paginate-rest\";\nimport { legacyRestEndpointMethods } from \"@octokit/plugin-rest-endpoint-methods\";\nimport { VERSION } from \"./version.js\";\nconst Octokit = Core.plugin(requestLog, legacyRestEndpointMethods, paginateRest).defaults(\n  {\n    userAgent: `octokit-rest.js/${VERSION}`\n  }\n);\nexport {\n  Octokit\n};\n","'use strict'\n\nmodule.exports = function indentString(string, count = 1, options) {\n  const { includeEmptyLines = false, indent = ' ' } = {\n    __proto__: null,\n    ...options\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      `Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``\n    )\n  }\n  if (typeof count !== 'number') {\n    throw new TypeError(\n      `Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count}\\``\n    )\n  }\n  if (count < 0) {\n    throw new RangeError(\n      `Expected \\`count\\` to be at least 0, got \\`${count}\\``\n    )\n  }\n  if (typeof indent !== 'string') {\n    throw new TypeError(\n      `Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof indent}\\``\n    )\n  }\n  if (count === 0) {\n    return string\n  }\n  const regex = includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm\n  return string.replace(regex, indent.repeat(count))\n}\n","\"use strict\";\n/**\n * @module LRUCache\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LRUCache = void 0;\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nclass LRUCache {\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (memoMethod !== undefined &&\n            typeof memoMethod !== 'function') {\n            throw new TypeError('memoMethod must be a function if defined');\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], 'expire');\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    [Symbol.toStringTag] = 'LRUCache';\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], 'expire');\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRLUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, 'set');\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.#delete(k, 'fetch');\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, 'fetch');\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined)\n            throw new Error('fetch() returned undefined');\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error('no memoMethod provided to constructor');\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined)\n            return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context,\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, 'expire');\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        return this.#delete(k, 'delete');\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, reason]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        return this.#clear('delete');\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, reason]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\nexports.LRUCache = LRUCache;\n//# sourceMappingURL=index.js.map","/* eslint-disable max-len */\n\n'use strict'\n\nconst maybeJoin = (...args) => args.every(arg => arg) ? args.join('') : ''\nconst maybeEncode = (arg) => arg ? encodeURIComponent(arg) : ''\nconst formatHashFragment = (f) => f.toLowerCase()\n  .replace(/^\\W+/g, '') // strip leading non-characters\n  .replace(/(?<!\\W)\\W+$/, '') // strip trailing non-characters\n  .replace(/\\//g, '') // strip all slashes\n  .replace(/\\W+/g, '-') // replace remaining non-characters with '-'\n\nconst defaults = {\n  sshtemplate: ({ domain, user, project, committish }) =>\n    `git@${domain}:${user}/${project}.git${maybeJoin('#', committish)}`,\n  sshurltemplate: ({ domain, user, project, committish }) =>\n    `git+ssh://git@${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  edittemplate: ({ domain, user, project, committish, editpath, path }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', editpath, '/', maybeEncode(committish || 'HEAD'), '/', path)}`,\n  browsetemplate: ({ domain, user, project, committish, treepath }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}`,\n  browsetreetemplate: ({ domain, user, project, committish, treepath, path, fragment, hashformat }) =>\n    `https://${domain}/${user}/${project}/${treepath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,\n  browseblobtemplate: ({ domain, user, project, committish, blobpath, path, fragment, hashformat }) =>\n    `https://${domain}/${user}/${project}/${blobpath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,\n  docstemplate: ({ domain, user, project, treepath, committish }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}#readme`,\n  httpstemplate: ({ auth, domain, user, project, committish }) =>\n    `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  filetemplate: ({ domain, user, project, committish, path }) =>\n    `https://${domain}/${user}/${project}/raw/${maybeEncode(committish || 'HEAD')}/${path}`,\n  shortcuttemplate: ({ type, user, project, committish }) =>\n    `${type}:${user}/${project}${maybeJoin('#', committish)}`,\n  pathtemplate: ({ user, project, committish }) =>\n    `${user}/${project}${maybeJoin('#', committish)}`,\n  bugstemplate: ({ domain, user, project }) =>\n    `https://${domain}/${user}/${project}/issues`,\n  hashformat: formatHashFragment,\n}\n\nconst hosts = {}\nhosts.github = {\n  // First two are insecure and generally shouldn't be used any more, but\n  // they are still supported.\n  protocols: ['git:', 'http:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],\n  domain: 'github.com',\n  treepath: 'tree',\n  blobpath: 'blob',\n  editpath: 'edit',\n  filetemplate: ({ auth, user, project, committish, path }) =>\n    `https://${maybeJoin(auth, '@')}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || 'HEAD')}/${path}`,\n  gittemplate: ({ auth, domain, user, project, committish }) =>\n    `git://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  tarballtemplate: ({ domain, user, project, committish }) =>\n    `https://codeload.${domain}/${user}/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,\n  extract: (url) => {\n    let [, user, project, type, committish] = url.pathname.split('/', 5)\n    if (type && type !== 'tree') {\n      return\n    }\n\n    if (!type) {\n      committish = url.hash.slice(1)\n    }\n\n    if (project && project.endsWith('.git')) {\n      project = project.slice(0, -4)\n    }\n\n    if (!user || !project) {\n      return\n    }\n\n    return { user, project, committish }\n  },\n}\n\nhosts.bitbucket = {\n  protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],\n  domain: 'bitbucket.org',\n  treepath: 'src',\n  blobpath: 'src',\n  editpath: '?mode=edit',\n  edittemplate: ({ domain, user, project, committish, treepath, path, editpath }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish || 'HEAD'), '/', path, editpath)}`,\n  tarballtemplate: ({ domain, user, project, committish }) =>\n    `https://${domain}/${user}/${project}/get/${maybeEncode(committish || 'HEAD')}.tar.gz`,\n  extract: (url) => {\n    let [, user, project, aux] = url.pathname.split('/', 4)\n    if (['get'].includes(aux)) {\n      return\n    }\n\n    if (project && project.endsWith('.git')) {\n      project = project.slice(0, -4)\n    }\n\n    if (!user || !project) {\n      return\n    }\n\n    return { user, project, committish: url.hash.slice(1) }\n  },\n}\n\nhosts.gitlab = {\n  protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],\n  domain: 'gitlab.com',\n  treepath: 'tree',\n  blobpath: 'tree',\n  editpath: '-/edit',\n  httpstemplate: ({ auth, domain, user, project, committish }) =>\n    `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  tarballtemplate: ({ domain, user, project, committish }) =>\n    `https://${domain}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || 'HEAD')}`,\n  extract: (url) => {\n    const path = url.pathname.slice(1)\n    if (path.includes('/-/') || path.includes('/archive.tar.gz')) {\n      return\n    }\n\n    const segments = path.split('/')\n    let project = segments.pop()\n    if (project.endsWith('.git')) {\n      project = project.slice(0, -4)\n    }\n\n    const user = segments.join('/')\n    if (!user || !project) {\n      return\n    }\n\n    return { user, project, committish: url.hash.slice(1) }\n  },\n}\n\nhosts.gist = {\n  protocols: ['git:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],\n  domain: 'gist.github.com',\n  editpath: 'edit',\n  sshtemplate: ({ domain, project, committish }) =>\n    `git@${domain}:${project}.git${maybeJoin('#', committish)}`,\n  sshurltemplate: ({ domain, project, committish }) =>\n    `git+ssh://git@${domain}/${project}.git${maybeJoin('#', committish)}`,\n  edittemplate: ({ domain, user, project, committish, editpath }) =>\n    `https://${domain}/${user}/${project}${maybeJoin('/', maybeEncode(committish))}/${editpath}`,\n  browsetemplate: ({ domain, project, committish }) =>\n    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,\n  browsetreetemplate: ({ domain, project, committish, path, hashformat }) =>\n    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,\n  browseblobtemplate: ({ domain, project, committish, path, hashformat }) =>\n    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,\n  docstemplate: ({ domain, project, committish }) =>\n    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,\n  httpstemplate: ({ domain, project, committish }) =>\n    `git+https://${domain}/${project}.git${maybeJoin('#', committish)}`,\n  filetemplate: ({ user, project, committish, path }) =>\n    `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin('/', maybeEncode(committish))}/${path}`,\n  shortcuttemplate: ({ type, project, committish }) =>\n    `${type}:${project}${maybeJoin('#', committish)}`,\n  pathtemplate: ({ project, committish }) =>\n    `${project}${maybeJoin('#', committish)}`,\n  bugstemplate: ({ domain, project }) =>\n    `https://${domain}/${project}`,\n  gittemplate: ({ domain, project, committish }) =>\n    `git://${domain}/${project}.git${maybeJoin('#', committish)}`,\n  tarballtemplate: ({ project, committish }) =>\n    `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,\n  extract: (url) => {\n    let [, user, project, aux] = url.pathname.split('/', 4)\n    if (aux === 'raw') {\n      return\n    }\n\n    if (!project) {\n      if (!user) {\n        return\n      }\n\n      project = user\n      user = null\n    }\n\n    if (project.endsWith('.git')) {\n      project = project.slice(0, -4)\n    }\n\n    return { user, project, committish: url.hash.slice(1) }\n  },\n  hashformat: function (fragment) {\n    return fragment && 'file-' + formatHashFragment(fragment)\n  },\n}\n\nhosts.sourcehut = {\n  protocols: ['git+ssh:', 'https:'],\n  domain: 'git.sr.ht',\n  treepath: 'tree',\n  blobpath: 'tree',\n  filetemplate: ({ domain, user, project, committish, path }) =>\n    `https://${domain}/${user}/${project}/blob/${maybeEncode(committish) || 'HEAD'}/${path}`,\n  httpstemplate: ({ domain, user, project, committish }) =>\n    `https://${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,\n  tarballtemplate: ({ domain, user, project, committish }) =>\n    `https://${domain}/${user}/${project}/archive/${maybeEncode(committish) || 'HEAD'}.tar.gz`,\n  bugstemplate: () => null,\n  extract: (url) => {\n    let [, user, project, aux] = url.pathname.split('/', 4)\n\n    // tarball url\n    if (['archive'].includes(aux)) {\n      return\n    }\n\n    if (project && project.endsWith('.git')) {\n      project = project.slice(0, -4)\n    }\n\n    if (!user || !project) {\n      return\n    }\n\n    return { user, project, committish: url.hash.slice(1) }\n  },\n}\n\nfor (const [name, host] of Object.entries(hosts)) {\n  hosts[name] = Object.assign({}, defaults, host)\n}\n\nmodule.exports = hosts\n","const url = require('url')\n\nconst lastIndexOfBefore = (str, char, beforeChar) => {\n  const startPosition = str.indexOf(beforeChar)\n  return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity)\n}\n\nconst safeUrl = (u) => {\n  try {\n    return new url.URL(u)\n  } catch {\n    // this fn should never throw\n  }\n}\n\n// accepts input like git:github.com:user/repo and inserts the // after the first :\nconst correctProtocol = (arg, protocols) => {\n  const firstColon = arg.indexOf(':')\n  const proto = arg.slice(0, firstColon + 1)\n  if (Object.prototype.hasOwnProperty.call(protocols, proto)) {\n    return arg\n  }\n\n  const firstAt = arg.indexOf('@')\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`\n    } else {\n      return arg\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//')\n  if (doubleSlash === firstColon + 1) {\n    return arg\n  }\n\n  return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`\n}\n\n// attempt to correct an scp style url so that it will parse with `new URL()`\nconst correctUrl = (giturl) => {\n  // ignore @ that come after the first hash since the denotes the start\n  // of a committish which can contain @ characters\n  const firstAt = lastIndexOfBefore(giturl, '@', '#')\n  // ignore colons that come after the hash since that could include colons such as:\n  // git@github.com:user/package-2#semver:^1.0.0\n  const lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#')\n\n  if (lastColonBeforeHash > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    giturl = giturl.slice(0, lastColonBeforeHash) + '/' + giturl.slice(lastColonBeforeHash + 1)\n  }\n\n  if (lastIndexOfBefore(giturl, ':', '#') === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    giturl = `git+ssh://${giturl}`\n  }\n\n  return giturl\n}\n\nmodule.exports = (giturl, protocols) => {\n  const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl\n  return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol))\n}\n","'use strict'\n\nconst parseUrl = require('./parse-url')\n\n// look for github shorthand inputs, such as npm/cli\nconst isGitHubShorthand = (arg) => {\n  // it cannot contain whitespace before the first #\n  // it cannot start with a / because that's probably an absolute file path\n  // but it must include a slash since repos are username/repository\n  // it cannot start with a . because that's probably a relative file path\n  // it cannot start with an @ because that's a scoped package if it passes the other tests\n  // it cannot contain a : before a # because that tells us that there's a protocol\n  // a second / may not exist before a #\n  const firstHash = arg.indexOf('#')\n  const firstSlash = arg.indexOf('/')\n  const secondSlash = arg.indexOf('/', firstSlash + 1)\n  const firstColon = arg.indexOf(':')\n  const firstSpace = /\\s/.exec(arg)\n  const firstAt = arg.indexOf('@')\n\n  const spaceOnlyAfterHash = !firstSpace || (firstHash > -1 && firstSpace.index > firstHash)\n  const atOnlyAfterHash = firstAt === -1 || (firstHash > -1 && firstAt > firstHash)\n  const colonOnlyAfterHash = firstColon === -1 || (firstHash > -1 && firstColon > firstHash)\n  const secondSlashOnlyAfterHash = secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash)\n  const hasSlash = firstSlash > 0\n  // if a # is found, what we really want to know is that the character\n  // immediately before # is not a /\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/')\n  const doesNotStartWithDot = !arg.startsWith('.')\n\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash &&\n    doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash &&\n    secondSlashOnlyAfterHash\n}\n\nmodule.exports = (giturl, opts, { gitHosts, protocols }) => {\n  if (!giturl) {\n    return\n  }\n\n  const correctedUrl = isGitHubShorthand(giturl) ? `github:${giturl}` : giturl\n  const parsed = parseUrl(correctedUrl, protocols)\n  if (!parsed) {\n    return\n  }\n\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol]\n  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.')\n    ? parsed.hostname.slice(4)\n    : parsed.hostname]\n  const gitHostName = gitHostShortcut || gitHostDomain\n  if (!gitHostName) {\n    return\n  }\n\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain]\n  let auth = null\n  if (protocols[parsed.protocol]?.auth && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`\n  }\n\n  let committish = null\n  let user = null\n  let project = null\n  let defaultRepresentation = null\n\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname\n      const firstAt = pathname.indexOf('@')\n      // we ignore auth for shortcuts, so just trim it out\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1)\n      }\n\n      const lastSlash = pathname.lastIndexOf('/')\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash))\n        // we want nulls only, never empty strings\n        if (!user) {\n          user = null\n        }\n        project = decodeURIComponent(pathname.slice(lastSlash + 1))\n      } else {\n        project = decodeURIComponent(pathname)\n      }\n\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4)\n      }\n\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1))\n      }\n\n      defaultRepresentation = 'shortcut'\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return\n      }\n\n      const segments = gitHostInfo.extract(parsed)\n      if (!segments) {\n        return\n      }\n\n      user = segments.user && decodeURIComponent(segments.user)\n      project = decodeURIComponent(segments.project)\n      committish = decodeURIComponent(segments.committish)\n      defaultRepresentation = protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1)\n    }\n  } catch (err) {\n    /* istanbul ignore else */\n    if (err instanceof URIError) {\n      return\n    } else {\n      throw err\n    }\n  }\n\n  return [gitHostName, user, auth, project, committish, defaultRepresentation, opts]\n}\n","'use strict'\n\nconst { LRUCache } = require('lru-cache')\nconst hosts = require('./hosts.js')\nconst fromUrl = require('./from-url.js')\nconst parseUrl = require('./parse-url.js')\n\nconst cache = new LRUCache({ max: 1000 })\n\nfunction unknownHostedUrl (url) {\n  try {\n    const {\n      protocol,\n      hostname,\n      pathname,\n    } = new URL(url)\n\n    if (!hostname) {\n      return null\n    }\n\n    const proto = /(?:git\\+)http:$/.test(protocol) ? 'http:' : 'https:'\n    const path = pathname.replace(/\\.git$/, '')\n    return `${proto}//${hostname}${path}`\n  } catch {\n    return null\n  }\n}\n\nclass GitHost {\n  constructor (type, user, auth, project, committish, defaultRepresentation, opts = {}) {\n    Object.assign(this, GitHost.#gitHosts[type], {\n      type,\n      user,\n      auth,\n      project,\n      committish,\n      default: defaultRepresentation,\n      opts,\n    })\n  }\n\n  static #gitHosts = { byShortcut: {}, byDomain: {} }\n  static #protocols = {\n    'git+ssh:': { name: 'sshurl' },\n    'ssh:': { name: 'sshurl' },\n    'git+https:': { name: 'https', auth: true },\n    'git:': { auth: true },\n    'http:': { auth: true },\n    'https:': { auth: true },\n    'git+http:': { auth: true },\n  }\n\n  static addHost (name, host) {\n    GitHost.#gitHosts[name] = host\n    GitHost.#gitHosts.byDomain[host.domain] = name\n    GitHost.#gitHosts.byShortcut[`${name}:`] = name\n    GitHost.#protocols[`${name}:`] = { name }\n  }\n\n  static fromUrl (giturl, opts) {\n    if (typeof giturl !== 'string') {\n      return\n    }\n\n    const key = giturl + JSON.stringify(opts || {})\n\n    if (!cache.has(key)) {\n      const hostArgs = fromUrl(giturl, opts, {\n        gitHosts: GitHost.#gitHosts,\n        protocols: GitHost.#protocols,\n      })\n      cache.set(key, hostArgs ? new GitHost(...hostArgs) : undefined)\n    }\n\n    return cache.get(key)\n  }\n\n  static fromManifest (manifest, opts = {}) {\n    if (!manifest || typeof manifest !== 'object') {\n      return\n    }\n\n    const r = manifest.repository\n    // TODO: look into also checking the `bugs`/`homepage` URLs\n\n    const rurl = r && (\n      typeof r === 'string'\n        ? r\n        : typeof r === 'object' && typeof r.url === 'string'\n          ? r.url\n          : null\n    )\n\n    if (!rurl) {\n      throw new Error('no repository')\n    }\n\n    const info = (rurl && GitHost.fromUrl(rurl.replace(/^git\\+/, ''), opts)) || null\n    if (info) {\n      return info\n    }\n    const unk = unknownHostedUrl(rurl)\n    return GitHost.fromUrl(unk, opts) || unk\n  }\n\n  static parseUrl (url) {\n    return parseUrl(url)\n  }\n\n  #fill (template, opts) {\n    if (typeof template !== 'function') {\n      return null\n    }\n\n    const options = { ...this, ...this.opts, ...opts }\n\n    // the path should always be set so we don't end up with 'undefined' in urls\n    if (!options.path) {\n      options.path = ''\n    }\n\n    // template functions will insert the leading slash themselves\n    if (options.path.startsWith('/')) {\n      options.path = options.path.slice(1)\n    }\n\n    if (options.noCommittish) {\n      options.committish = null\n    }\n\n    const result = template(options)\n    return options.noGitPlus && result.startsWith('git+') ? result.slice(4) : result\n  }\n\n  hash () {\n    return this.committish ? `#${this.committish}` : ''\n  }\n\n  ssh (opts) {\n    return this.#fill(this.sshtemplate, opts)\n  }\n\n  sshurl (opts) {\n    return this.#fill(this.sshurltemplate, opts)\n  }\n\n  browse (path, ...args) {\n    // not a string, treat path as opts\n    if (typeof path !== 'string') {\n      return this.#fill(this.browsetemplate, path)\n    }\n\n    if (typeof args[0] !== 'string') {\n      return this.#fill(this.browsetreetemplate, { ...args[0], path })\n    }\n\n    return this.#fill(this.browsetreetemplate, { ...args[1], fragment: args[0], path })\n  }\n\n  // If the path is known to be a file, then browseFile should be used. For some hosts\n  // the url is the same as browse, but for others like GitHub a file can use both `/tree/`\n  // and `/blob/` in the path. When using a default committish of `HEAD` then the `/tree/`\n  // path will redirect to a specific commit. Using the `/blob/` path avoids this and\n  // does not redirect to a different commit.\n  browseFile (path, ...args) {\n    if (typeof args[0] !== 'string') {\n      return this.#fill(this.browseblobtemplate, { ...args[0], path })\n    }\n\n    return this.#fill(this.browseblobtemplate, { ...args[1], fragment: args[0], path })\n  }\n\n  docs (opts) {\n    return this.#fill(this.docstemplate, opts)\n  }\n\n  bugs (opts) {\n    return this.#fill(this.bugstemplate, opts)\n  }\n\n  https (opts) {\n    return this.#fill(this.httpstemplate, opts)\n  }\n\n  git (opts) {\n    return this.#fill(this.gittemplate, opts)\n  }\n\n  shortcut (opts) {\n    return this.#fill(this.shortcuttemplate, opts)\n  }\n\n  path (opts) {\n    return this.#fill(this.pathtemplate, opts)\n  }\n\n  tarball (opts) {\n    return this.#fill(this.tarballtemplate, { ...opts, noCommittish: false })\n  }\n\n  file (path, opts) {\n    return this.#fill(this.filetemplate, { ...opts, path })\n  }\n\n  edit (path, opts) {\n    return this.#fill(this.edittemplate, { ...opts, path })\n  }\n\n  getDefaultRepresentation () {\n    return this.default\n  }\n\n  toString (opts) {\n    if (this.default && typeof this[this.default] === 'function') {\n      return this[this.default](opts)\n    }\n\n    return this.sshurl(opts)\n  }\n}\n\nfor (const [name, host] of Object.entries(hosts)) {\n  GitHost.addHost(name, host)\n}\n\nmodule.exports = GitHost\n","'use strict'\nconst { builtinModules: builtins } = require('module')\n\nvar scopedPackagePattern = new RegExp('^(?:@([^/]+?)[/])?([^/]+?)$')\nvar blacklist = [\n  'node_modules',\n  'favicon.ico',\n]\n\nfunction validate (name) {\n  var warnings = []\n  var errors = []\n\n  if (name === null) {\n    errors.push('name cannot be null')\n    return done(warnings, errors)\n  }\n\n  if (name === undefined) {\n    errors.push('name cannot be undefined')\n    return done(warnings, errors)\n  }\n\n  if (typeof name !== 'string') {\n    errors.push('name must be a string')\n    return done(warnings, errors)\n  }\n\n  if (!name.length) {\n    errors.push('name length must be greater than zero')\n  }\n\n  if (name.match(/^\\./)) {\n    errors.push('name cannot start with a period')\n  }\n\n  if (name.match(/^_/)) {\n    errors.push('name cannot start with an underscore')\n  }\n\n  if (name.trim() !== name) {\n    errors.push('name cannot contain leading or trailing spaces')\n  }\n\n  // No funny business\n  blacklist.forEach(function (blacklistedName) {\n    if (name.toLowerCase() === blacklistedName) {\n      errors.push(blacklistedName + ' is a blacklisted name')\n    }\n  })\n\n  // Generate warnings for stuff that used to be allowed\n\n  // core module names like http, events, util, etc\n  if (builtins.includes(name.toLowerCase())) {\n    warnings.push(name + ' is a core module name')\n  }\n\n  if (name.length > 214) {\n    warnings.push('name can no longer contain more than 214 characters')\n  }\n\n  // mIxeD CaSe nAMEs\n  if (name.toLowerCase() !== name) {\n    warnings.push('name can no longer contain capital letters')\n  }\n\n  if (/[~'!()*]/.test(name.split('/').slice(-1)[0])) {\n    warnings.push('name can no longer contain special characters (\"~\\'!()*\")')\n  }\n\n  if (encodeURIComponent(name) !== name) {\n    // Maybe it's a scoped package name, like @user/package\n    var nameMatch = name.match(scopedPackagePattern)\n    if (nameMatch) {\n      var user = nameMatch[1]\n      var pkg = nameMatch[2]\n      if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) {\n        return done(warnings, errors)\n      }\n    }\n\n    errors.push('name can only contain URL-friendly characters')\n  }\n\n  return done(warnings, errors)\n}\n\nvar done = function (warnings, errors) {\n  var result = {\n    validForNewPackages: errors.length === 0 && warnings.length === 0,\n    validForOldPackages: errors.length === 0,\n    warnings: warnings,\n    errors: errors,\n  }\n  if (!result.warnings.length) {\n    delete result.warnings\n  }\n  if (!result.errors.length) {\n    delete result.errors\n  }\n  return result\n}\n\nmodule.exports = validate\n","const META = Symbol('proc-log.meta')\nmodule.exports = {\n  META: META,\n  output: {\n    LEVELS: [\n      'standard',\n      'error',\n      'buffer',\n      'flush',\n    ],\n    KEYS: {\n      standard: 'standard',\n      error: 'error',\n      buffer: 'buffer',\n      flush: 'flush',\n    },\n    standard: function (...args) {\n      return process.emit('output', 'standard', ...args)\n    },\n    error: function (...args) {\n      return process.emit('output', 'error', ...args)\n    },\n    buffer: function (...args) {\n      return process.emit('output', 'buffer', ...args)\n    },\n    flush: function (...args) {\n      return process.emit('output', 'flush', ...args)\n    },\n  },\n  log: {\n    LEVELS: [\n      'notice',\n      'error',\n      'warn',\n      'info',\n      'verbose',\n      'http',\n      'silly',\n      'timing',\n      'pause',\n      'resume',\n    ],\n    KEYS: {\n      notice: 'notice',\n      error: 'error',\n      warn: 'warn',\n      info: 'info',\n      verbose: 'verbose',\n      http: 'http',\n      silly: 'silly',\n      timing: 'timing',\n      pause: 'pause',\n      resume: 'resume',\n    },\n    error: function (...args) {\n      return process.emit('log', 'error', ...args)\n    },\n    notice: function (...args) {\n      return process.emit('log', 'notice', ...args)\n    },\n    warn: function (...args) {\n      return process.emit('log', 'warn', ...args)\n    },\n    info: function (...args) {\n      return process.emit('log', 'info', ...args)\n    },\n    verbose: function (...args) {\n      return process.emit('log', 'verbose', ...args)\n    },\n    http: function (...args) {\n      return process.emit('log', 'http', ...args)\n    },\n    silly: function (...args) {\n      return process.emit('log', 'silly', ...args)\n    },\n    timing: function (...args) {\n      return process.emit('log', 'timing', ...args)\n    },\n    pause: function () {\n      return process.emit('log', 'pause')\n    },\n    resume: function () {\n      return process.emit('log', 'resume')\n    },\n  },\n  time: {\n    LEVELS: [\n      'start',\n      'end',\n    ],\n    KEYS: {\n      start: 'start',\n      end: 'end',\n    },\n    start: function (name, fn) {\n      process.emit('time', 'start', name)\n      function end () {\n        return process.emit('time', 'end', name)\n      }\n      if (typeof fn === 'function') {\n        const res = fn()\n        if (res && res.finally) {\n          return res.finally(end)\n        }\n        end()\n        return res\n      }\n      return end\n    },\n    end: function (name) {\n      return process.emit('time', 'end', name)\n    },\n  },\n  input: {\n    LEVELS: [\n      'start',\n      'end',\n      'read',\n    ],\n    KEYS: {\n      start: 'start',\n      end: 'end',\n      read: 'read',\n    },\n    start: function (fn) {\n      process.emit('input', 'start')\n      function end () {\n        return process.emit('input', 'end')\n      }\n      if (typeof fn === 'function') {\n        const res = fn()\n        if (res && res.finally) {\n          return res.finally(end)\n        }\n        end()\n        return res\n      }\n      return end\n    },\n    end: function () {\n      return process.emit('input', 'end')\n    },\n    read: function (...args) {\n      let resolve, reject\n      const promise = new Promise((_resolve, _reject) => {\n        resolve = _resolve\n        reject = _reject\n      })\n      process.emit('input', 'read', resolve, reject, ...args)\n      return promise\n    },\n  },\n}\n","'use strict'\n\nconst isWindows = process.platform === 'win32'\n\nconst { URL } = require('node:url')\n// We need to use path/win32 so that we get consistent results in tests, but this also means we need to manually convert backslashes to forward slashes when generating file: urls with paths.\nconst path = isWindows ? require('node:path/win32') : require('node:path')\nconst { homedir } = require('node:os')\nconst HostedGit = require('hosted-git-info')\nconst semver = require('semver')\nconst validatePackageName = require('validate-npm-package-name')\nconst { log } = require('proc-log')\n\nconst hasSlashes = isWindows ? /\\\\|[/]/ : /[/]/\nconst isURL = /^(?:git[+])?[a-z]+:/i\nconst isGit = /^[^@]+@[^:.]+\\.[^:]+:.+$/i\nconst isFileType = /[.](?:tgz|tar.gz|tar)$/i\nconst isPortNumber = /:[0-9]+(\\/|$)/i\nconst isWindowsFile = /^(?:[.]|~[/]|[/\\\\]|[a-zA-Z]:)/\nconst isPosixFile = /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/\nconst defaultRegistry = 'https://registry.npmjs.org'\n\nfunction npa (arg, where) {\n  let name\n  let spec\n  if (typeof arg === 'object') {\n    if (arg instanceof Result && (!where || where === arg.where)) {\n      return arg\n    } else if (arg.name && arg.rawSpec) {\n      return npa.resolve(arg.name, arg.rawSpec, where || arg.where)\n    } else {\n      return npa(arg.raw, where || arg.where)\n    }\n  }\n  const nameEndsAt = arg.indexOf('@', 1) // Skip possible leading @\n  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg\n  if (isURL.test(arg)) {\n    spec = arg\n  } else if (isGit.test(arg)) {\n    spec = `git+ssh://${arg}`\n  // eslint-disable-next-line max-len\n  } else if (!namePart.startsWith('@') && (hasSlashes.test(namePart) || isFileType.test(namePart))) {\n    spec = arg\n  } else if (nameEndsAt > 0) {\n    name = namePart\n    spec = arg.slice(nameEndsAt + 1) || '*'\n  } else {\n    const valid = validatePackageName(arg)\n    if (valid.validForOldPackages) {\n      name = arg\n      spec = '*'\n    } else {\n      spec = arg\n    }\n  }\n  return resolve(name, spec, where, arg)\n}\n\nfunction isFileSpec (spec) {\n  if (!spec) {\n    return false\n  }\n  if (spec.toLowerCase().startsWith('file:')) {\n    return true\n  }\n  if (isWindows) {\n    return isWindowsFile.test(spec)\n  }\n  // We never hit this in windows tests, obviously\n  /* istanbul ignore next */\n  return isPosixFile.test(spec)\n}\n\nfunction isAliasSpec (spec) {\n  if (!spec) {\n    return false\n  }\n  return spec.toLowerCase().startsWith('npm:')\n}\n\nfunction resolve (name, spec, where, arg) {\n  const res = new Result({\n    raw: arg,\n    name: name,\n    rawSpec: spec,\n    fromArgument: arg != null,\n  })\n\n  if (name) {\n    res.name = name\n  }\n\n  if (!where) {\n    where = process.cwd()\n  }\n\n  if (isFileSpec(spec)) {\n    return fromFile(res, where)\n  } else if (isAliasSpec(spec)) {\n    return fromAlias(res, where)\n  }\n\n  const hosted = HostedGit.fromUrl(spec, {\n    noGitPlus: true,\n    noCommittish: true,\n  })\n  if (hosted) {\n    return fromHostedGit(res, hosted)\n  } else if (spec && isURL.test(spec)) {\n    return fromURL(res)\n  } else if (spec && (hasSlashes.test(spec) || isFileType.test(spec))) {\n    return fromFile(res, where)\n  } else {\n    return fromRegistry(res)\n  }\n}\n\nfunction toPurl (arg, reg = defaultRegistry) {\n  const res = npa(arg)\n\n  if (res.type !== 'version') {\n    throw invalidPurlType(res.type, res.raw)\n  }\n\n  // URI-encode leading @ of scoped packages\n  let purl = 'pkg:npm/' + res.name.replace(/^@/, '%40') + '@' + res.rawSpec\n  if (reg !== defaultRegistry) {\n    purl += '?repository_url=' + reg\n  }\n\n  return purl\n}\n\nfunction invalidPackageName (name, valid, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid package name \"${name}\" of package \"${raw}\": ${valid.errors.join('; ')}.`)\n  err.code = 'EINVALIDPACKAGENAME'\n  return err\n}\n\nfunction invalidTagName (name, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid tag name \"${name}\" of package \"${raw}\": Tags may not have any characters that encodeURIComponent encodes.`)\n  err.code = 'EINVALIDTAGNAME'\n  return err\n}\n\nfunction invalidPurlType (type, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid type \"${type}\" of package \"${raw}\": Purl can only be generated for \"version\" types.`)\n  err.code = 'EINVALIDPURLTYPE'\n  return err\n}\n\nclass Result {\n  constructor (opts) {\n    this.type = opts.type\n    this.registry = opts.registry\n    this.where = opts.where\n    if (opts.raw == null) {\n      this.raw = opts.name ? `${opts.name}@${opts.rawSpec}` : opts.rawSpec\n    } else {\n      this.raw = opts.raw\n    }\n    this.name = undefined\n    this.escapedName = undefined\n    this.scope = undefined\n    this.rawSpec = opts.rawSpec || ''\n    this.saveSpec = opts.saveSpec\n    this.fetchSpec = opts.fetchSpec\n    if (opts.name) {\n      this.setName(opts.name)\n    }\n    this.gitRange = opts.gitRange\n    this.gitCommittish = opts.gitCommittish\n    this.gitSubdir = opts.gitSubdir\n    this.hosted = opts.hosted\n  }\n\n  // TODO move this to a getter/setter in a semver major\n  setName (name) {\n    const valid = validatePackageName(name)\n    if (!valid.validForOldPackages) {\n      throw invalidPackageName(name, valid, this.raw)\n    }\n\n    this.name = name\n    this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined\n    // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar\n    this.escapedName = name.replace('/', '%2f')\n    return this\n  }\n\n  toString () {\n    const full = []\n    if (this.name != null && this.name !== '') {\n      full.push(this.name)\n    }\n    const spec = this.saveSpec || this.fetchSpec || this.rawSpec\n    if (spec != null && spec !== '') {\n      full.push(spec)\n    }\n    return full.length ? full.join('@') : this.raw\n  }\n\n  toJSON () {\n    const result = Object.assign({}, this)\n    delete result.hosted\n    return result\n  }\n}\n\n// sets res.gitCommittish, res.gitRange, and res.gitSubdir\nfunction setGitAttrs (res, committish) {\n  if (!committish) {\n    res.gitCommittish = null\n    return\n  }\n\n  // for each :: separated item:\n  for (const part of committish.split('::')) {\n    // if the item has no : the n it is a commit-ish\n    if (!part.includes(':')) {\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a committish')\n      }\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a second committish')\n      }\n      res.gitCommittish = part\n      continue\n    }\n    // split on name:value\n    const [name, value] = part.split(':')\n    // if name is semver do semver lookup of ref or tag\n    if (name === 'semver') {\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a semver range')\n      }\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a second semver range')\n      }\n      res.gitRange = decodeURIComponent(value)\n      continue\n    }\n    if (name === 'path') {\n      if (res.gitSubdir) {\n        throw new Error('cannot override existing path with a second path')\n      }\n      res.gitSubdir = `/${value}`\n      continue\n    }\n    log.warn('npm-package-arg', `ignoring unknown key \"${name}\"`)\n  }\n}\n\n// Taken from: EncodePathChars and lookup_table in src/node_url.cc\n// url.pathToFileURL only returns absolute references.  We can't use it to encode paths.\n// encodeURI mangles windows paths. We can't use it to encode paths.\n// Under the hood, url.pathToFileURL does a limited set of encoding, with an extra windows step, and then calls path.resolve.\n// The encoding node does without path.resolve is not available outside of the source, so we are recreating it here.\nconst encodedPathChars = new Map([\n  ['\\0', '%00'],\n  ['\\t', '%09'],\n  ['\\n', '%0A'],\n  ['\\r', '%0D'],\n  [' ', '%20'],\n  ['\"', '%22'],\n  ['#', '%23'],\n  ['%', '%25'],\n  ['?', '%3F'],\n  ['[', '%5B'],\n  ['\\\\', isWindows ? '/' : '%5C'],\n  [']', '%5D'],\n  ['^', '%5E'],\n  ['|', '%7C'],\n  ['~', '%7E'],\n])\n\nfunction pathToFileURL (str) {\n  let result = ''\n  for (let i = 0; i < str.length; i++) {\n    result = `${result}${encodedPathChars.get(str[i]) ?? str[i]}`\n  }\n  if (result.startsWith('file:')) {\n    return result\n  }\n  return `file:${result}`\n}\n\nfunction fromFile (res, where) {\n  res.type = isFileType.test(res.rawSpec) ? 'file' : 'directory'\n  res.where = where\n\n  let rawSpec = pathToFileURL(res.rawSpec)\n\n  if (rawSpec.startsWith('file:/')) {\n    // XXX backwards compatibility lack of compliance with RFC 8089\n\n    // turn file://path into file:/path\n    if (/^file:\\/\\/[^/]/.test(rawSpec)) {\n      rawSpec = `file:/${rawSpec.slice(5)}`\n    }\n\n    // turn file:/../path into file:../path\n    // for 1 or 3 leading slashes (2 is already ruled out from handling file:// explicitly above)\n    if (/^\\/{1,3}\\.\\.?(\\/|$)/.test(rawSpec.slice(5))) {\n      rawSpec = rawSpec.replace(/^file:\\/{1,3}/, 'file:')\n    }\n  }\n\n  let resolvedUrl\n  let specUrl\n  try {\n    // always put the '/' on \"where\", or else file:foo from /path/to/bar goes to /path/to/foo, when we want it to be /path/to/bar/foo\n    resolvedUrl = new URL(rawSpec, `${pathToFileURL(path.resolve(where))}/`)\n    specUrl = new URL(rawSpec)\n  } catch (originalError) {\n    const er = new Error('Invalid file: URL, must comply with RFC 8089')\n    throw Object.assign(er, {\n      raw: res.rawSpec,\n      spec: res,\n      where,\n      originalError,\n    })\n  }\n\n  // turn /C:/blah into just C:/blah on windows\n  let specPath = decodeURIComponent(specUrl.pathname)\n  let resolvedPath = decodeURIComponent(resolvedUrl.pathname)\n  if (isWindows) {\n    specPath = specPath.replace(/^\\/+([a-z]:\\/)/i, '$1')\n    resolvedPath = resolvedPath.replace(/^\\/+([a-z]:\\/)/i, '$1')\n  }\n\n  // replace ~ with homedir, but keep the ~ in the saveSpec\n  // otherwise, make it relative to where param\n  if (/^\\/~(\\/|$)/.test(specPath)) {\n    res.saveSpec = `file:${specPath.substr(1)}`\n    resolvedPath = path.resolve(homedir(), specPath.substr(3))\n  } else if (!path.isAbsolute(rawSpec.slice(5))) {\n    res.saveSpec = `file:${path.relative(where, resolvedPath)}`\n  } else {\n    res.saveSpec = `file:${path.resolve(resolvedPath)}`\n  }\n\n  res.fetchSpec = path.resolve(where, resolvedPath)\n  // re-normalize the slashes in saveSpec due to node:path/win32 behavior in windows\n  res.saveSpec = res.saveSpec.split('\\\\').join('/')\n  // Ignoring because this only happens in windows\n  /* istanbul ignore next */\n  if (res.saveSpec.startsWith('file://')) {\n    // normalization of \\\\win32\\root paths can cause a double / which we don't want\n    res.saveSpec = `file:/${res.saveSpec.slice(7)}`\n  }\n  return res\n}\n\nfunction fromHostedGit (res, hosted) {\n  res.type = 'git'\n  res.hosted = hosted\n  res.saveSpec = hosted.toString({ noGitPlus: false, noCommittish: false })\n  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString()\n  setGitAttrs(res, hosted.committish)\n  return res\n}\n\nfunction unsupportedURLType (protocol, spec) {\n  const err = new Error(`Unsupported URL Type \"${protocol}\": ${spec}`)\n  err.code = 'EUNSUPPORTEDPROTOCOL'\n  return err\n}\n\nfunction fromURL (res) {\n  let rawSpec = res.rawSpec\n  res.saveSpec = rawSpec\n  if (rawSpec.startsWith('git+ssh:')) {\n    // git ssh specifiers are overloaded to also use scp-style git\n    // specifiers, so we have to parse those out and treat them special.\n    // They are NOT true URIs, so we can't hand them to URL.\n\n    // This regex looks for things that look like:\n    // git+ssh://git@my.custom.git.com:username/project.git#deadbeef\n    // ...and various combinations. The username in the beginning is *required*.\n    const matched = rawSpec.match(/^git\\+ssh:\\/\\/([^:#]+:[^#]+(?:\\.git)?)(?:#(.*))?$/i)\n    // Filter out all-number \"usernames\" which are really port numbers\n    // They can either be :1234 :1234/ or :1234/path but not :12abc\n    if (matched && !matched[1].match(isPortNumber)) {\n      res.type = 'git'\n      setGitAttrs(res, matched[2])\n      res.fetchSpec = matched[1]\n      return res\n    }\n  } else if (rawSpec.startsWith('git+file://')) {\n    // URL can't handle windows paths\n    rawSpec = rawSpec.replace(/\\\\/g, '/')\n  }\n  const parsedUrl = new URL(rawSpec)\n  // check the protocol, and then see if it's git or not\n  switch (parsedUrl.protocol) {\n    case 'git:':\n    case 'git+http:':\n    case 'git+https:':\n    case 'git+rsync:':\n    case 'git+ftp:':\n    case 'git+file:':\n    case 'git+ssh:':\n      res.type = 'git'\n      setGitAttrs(res, parsedUrl.hash.slice(1))\n      if (parsedUrl.protocol === 'git+file:' && /^git\\+file:\\/\\/[a-z]:/i.test(rawSpec)) {\n        // URL can't handle drive letters on windows file paths, the host can't contain a :\n        res.fetchSpec = `git+file://${parsedUrl.host.toLowerCase()}:${parsedUrl.pathname}`\n      } else {\n        parsedUrl.hash = ''\n        res.fetchSpec = parsedUrl.toString()\n      }\n      if (res.fetchSpec.startsWith('git+')) {\n        res.fetchSpec = res.fetchSpec.slice(4)\n      }\n      break\n    case 'http:':\n    case 'https:':\n      res.type = 'remote'\n      res.fetchSpec = res.saveSpec\n      break\n\n    default:\n      throw unsupportedURLType(parsedUrl.protocol, rawSpec)\n  }\n\n  return res\n}\n\nfunction fromAlias (res, where) {\n  const subSpec = npa(res.rawSpec.substr(4), where)\n  if (subSpec.type === 'alias') {\n    throw new Error('nested aliases not supported')\n  }\n\n  if (!subSpec.registry) {\n    throw new Error('aliases only work for registry deps')\n  }\n\n  if (!subSpec.name) {\n    throw new Error('aliases must have a name')\n  }\n\n  res.subSpec = subSpec\n  res.registry = true\n  res.type = 'alias'\n  res.saveSpec = null\n  res.fetchSpec = null\n  return res\n}\n\nfunction fromRegistry (res) {\n  res.registry = true\n  const spec = res.rawSpec.trim()\n  // no save spec for registry components as we save based on the fetched\n  // version, not on the argument so this can't compute that.\n  res.saveSpec = null\n  res.fetchSpec = spec\n  const version = semver.valid(spec, true)\n  const range = semver.validRange(spec, true)\n  if (version) {\n    res.type = 'version'\n  } else if (range) {\n    res.type = 'range'\n  } else {\n    if (encodeURIComponent(spec) !== spec) {\n      throw invalidTagName(spec, res.raw)\n    }\n    res.type = 'tag'\n  }\n  return res\n}\n\nmodule.exports = npa\nmodule.exports.resolve = resolve\nmodule.exports.toPurl = toPurl\nmodule.exports.Result = Result\n","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\n// This check is needed until node.js 12 is required\nif (typeof process.chdir === 'function') {\n  var chdir = process.chdir\n  process.chdir = function (d) {\n    cwd = null\n    chdir.call(process, d)\n  }\n  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (fs.chmod && !fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (fs.chown && !fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = typeof fs.rename !== 'function' ? fs.rename\n    : (function (fs$rename) {\n      function rename (from, to, cb) {\n        var start = Date.now()\n        var backoff = 0;\n        fs$rename(from, to, function CB (er) {\n          if (er\n              && (er.code === \"EACCES\" || er.code === \"EPERM\" || er.code === \"EBUSY\")\n              && Date.now() - start < 60000) {\n            setTimeout(function() {\n              fs.stat(to, function (stater, st) {\n                if (stater && stater.code === \"ENOENT\")\n                  fs$rename(from, to, CB);\n                else\n                  cb(er)\n              })\n            }, backoff)\n            if (backoff < 100)\n              backoff += 10;\n            return;\n          }\n          if (cb) cb(er)\n        })\n      }\n      if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename)\n      return rename\n    })(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = typeof fs.read !== 'function' ? fs.read\n  : (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)\n    return read\n  })(fs.read)\n\n  fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync\n  : (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\") && fs.futimes) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else if (fs.futimes) {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats) {\n        if (stats.uid < 0) stats.uid += 0x100000000\n        if (stats.gid < 0) stats.gid += 0x100000000\n      }\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = clone\n\nvar getPrototypeOf = Object.getPrototypeOf || function (obj) {\n  return obj.__proto__\n}\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  var copy = obj instanceof Object\n    ? { __proto__: getPrototypeOf(obj) }\n    : Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar util = require('util')\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nfunction publishQueue(context, queue) {\n  Object.defineProperty(context, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!fs[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = global[gracefulQueue] || []\n  publishQueue(fs, queue)\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          resetQueue()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      resetQueue()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(fs[gracefulQueue])\n      require('assert').equal(fs[gracefulQueue].length, 0)\n    })\n  }\n}\n\nif (!global[gracefulQueue]) {\n  publishQueue(global, fs[gracefulQueue]);\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb, startTime) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb, startTime) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb, startTime) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$copyFile = fs.copyFile\n  if (fs$copyFile)\n    fs.copyFile = copyFile\n  function copyFile (src, dest, flags, cb) {\n    if (typeof flags === 'function') {\n      cb = flags\n      flags = 0\n    }\n    return go$copyFile(src, dest, flags, cb)\n\n    function go$copyFile (src, dest, flags, cb, startTime) {\n      return fs$copyFile(src, dest, flags, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  var noReaddirOptionVersions = /^v[0-5]\\./\n  function readdir (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    var go$readdir = noReaddirOptionVersions.test(process.version)\n      ? function go$readdir (path, options, cb, startTime) {\n        return fs$readdir(path, fs$readdirCallback(\n          path, options, cb, startTime\n        ))\n      }\n      : function go$readdir (path, options, cb, startTime) {\n        return fs$readdir(path, options, fs$readdirCallback(\n          path, options, cb, startTime\n        ))\n      }\n\n    return go$readdir(path, options, cb)\n\n    function fs$readdirCallback (path, options, cb, startTime) {\n      return function (err, files) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([\n            go$readdir,\n            [path, options, cb],\n            err,\n            startTime || Date.now(),\n            Date.now()\n          ])\n        else {\n          if (files && files.sort)\n            files.sort()\n\n          if (typeof cb === 'function')\n            cb.call(this, err, files)\n        }\n      }\n    }\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb, startTime) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  fs[gracefulQueue].push(elem)\n  retry()\n}\n\n// keep track of the timeout between retry() calls\nvar retryTimer\n\n// reset the startTime and lastTime to now\n// this resets the start of the 60 second overall timeout as well as the\n// delay between attempts so that we'll retry these jobs sooner\nfunction resetQueue () {\n  var now = Date.now()\n  for (var i = 0; i < fs[gracefulQueue].length; ++i) {\n    // entries that are only a length of 2 are from an older version, don't\n    // bother modifying those since they'll be retried anyway.\n    if (fs[gracefulQueue][i].length > 2) {\n      fs[gracefulQueue][i][3] = now // startTime\n      fs[gracefulQueue][i][4] = now // lastTime\n    }\n  }\n  // call retry to make sure we're actively processing the queue\n  retry()\n}\n\nfunction retry () {\n  // clear the timer and remove it to help prevent unintended concurrency\n  clearTimeout(retryTimer)\n  retryTimer = undefined\n\n  if (fs[gracefulQueue].length === 0)\n    return\n\n  var elem = fs[gracefulQueue].shift()\n  var fn = elem[0]\n  var args = elem[1]\n  // these items may be unset if they were added by an older graceful-fs\n  var err = elem[2]\n  var startTime = elem[3]\n  var lastTime = elem[4]\n\n  // if we don't have a startTime we have no way of knowing if we've waited\n  // long enough, so go ahead and retry this item now\n  if (startTime === undefined) {\n    debug('RETRY', fn.name, args)\n    fn.apply(null, args)\n  } else if (Date.now() - startTime >= 60000) {\n    // it's been more than 60 seconds total, bail now\n    debug('TIMEOUT', fn.name, args)\n    var cb = args.pop()\n    if (typeof cb === 'function')\n      cb.call(null, err)\n  } else {\n    // the amount of time between the last attempt and right now\n    var sinceAttempt = Date.now() - lastTime\n    // the amount of time between when we first tried, and when we last tried\n    // rounded up to at least 1\n    var sinceStart = Math.max(lastTime - startTime, 1)\n    // backoff. wait longer than the total time we've been retrying, but only\n    // up to a maximum of 100ms\n    var desiredDelay = Math.min(sinceStart * 1.2, 100)\n    // it's been long enough since the last retry, do it again\n    if (sinceAttempt >= desiredDelay) {\n      debug('RETRY', fn.name, args)\n      fn.apply(null, args.concat([startTime]))\n    } else {\n      // if we can't do this job yet, push it to the end of the queue\n      // and let the next iteration check again\n      fs[gracefulQueue].push(elem)\n    }\n  }\n\n  // schedule our next run if one isn't already scheduled\n  if (retryTimer === undefined) {\n    retryTimer = setTimeout(retry, 0)\n  }\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"util\");\nconst graceful_fs_1 = __importDefault(require(\"graceful-fs\"));\nexports.default = {\n    copyFile: (0, util_1.promisify)(graceful_fs_1.default.copyFile),\n    copyFileSync: graceful_fs_1.default.copyFileSync,\n    createReadStream: graceful_fs_1.default.createReadStream,\n    link: (0, util_1.promisify)(graceful_fs_1.default.link),\n    linkSync: graceful_fs_1.default.linkSync,\n    readFile: (0, util_1.promisify)(graceful_fs_1.default.readFile),\n    readFileSync: graceful_fs_1.default.readFileSync,\n    readdirSync: graceful_fs_1.default.readdirSync,\n    stat: (0, util_1.promisify)(graceful_fs_1.default.stat),\n    statSync: graceful_fs_1.default.statSync,\n    unlinkSync: graceful_fs_1.default.unlinkSync,\n    writeFile: (0, util_1.promisify)(graceful_fs_1.default.writeFile),\n    writeFileSync: graceful_fs_1.default.writeFileSync,\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;\nconst proc = typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n    };\nconst node_events_1 = require(\"node:events\");\nconst node_stream_1 = __importDefault(require(\"node:stream\"));\nconst node_string_decoder_1 = require(\"node:string_decoder\");\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nconst isStream = (s) => !!s &&\n    typeof s === 'object' &&\n    (s instanceof Minipass ||\n        s instanceof node_stream_1.default ||\n        (0, exports.isReadable)(s) ||\n        (0, exports.isWritable)(s));\nexports.isStream = isStream;\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nconst isReadable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.pipe === 'function' &&\n    // node core Writable streams have a pipe() method, but it throws\n    s.pipe !== node_stream_1.default.Writable.prototype.pipe;\nexports.isReadable = isReadable;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nconst isWritable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.write === 'function' &&\n    typeof s.end === 'function';\nexports.isWritable = isWritable;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst DATALISTENERS = Symbol('dataListeners');\nconst DISCARDED = Symbol('discarded');\nconst defer = (fn) => Promise.resolve().then(fn);\nconst nodefer = (fn) => fn();\nconst isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBufferLike = (b) => b instanceof ArrayBuffer ||\n    (!!b &&\n        typeof b === 'object' &&\n        b.constructor &&\n        b.constructor.name === 'ArrayBuffer' &&\n        b.byteLength >= 0);\nconst isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe {\n    src;\n    dest;\n    opts;\n    ondrain;\n    constructor(src, dest, opts) {\n        this.src = src;\n        this.dest = dest;\n        this.opts = opts;\n        this.ondrain = () => src[RESUME]();\n        this.dest.on('drain', this.ondrain);\n    }\n    unpipe() {\n        this.dest.removeListener('drain', this.ondrain);\n    }\n    // only here for the prototype\n    /* c8 ignore start */\n    proxyErrors(_er) { }\n    /* c8 ignore stop */\n    end() {\n        this.unpipe();\n        if (this.opts.end)\n            this.dest.end();\n    }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors extends Pipe {\n    unpipe() {\n        this.src.removeListener('error', this.proxyErrors);\n        super.unpipe();\n    }\n    constructor(src, dest, opts) {\n        super(src, dest, opts);\n        this.proxyErrors = er => dest.emit('error', er);\n        src.on('error', this.proxyErrors);\n    }\n}\nconst isObjectModeOptions = (o) => !!o.objectMode;\nconst isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nclass Minipass extends node_events_1.EventEmitter {\n    [FLOWING] = false;\n    [PAUSED] = false;\n    [PIPES] = [];\n    [BUFFER] = [];\n    [OBJECTMODE];\n    [ENCODING];\n    [ASYNC];\n    [DECODER];\n    [EOF] = false;\n    [EMITTED_END] = false;\n    [EMITTING_END] = false;\n    [CLOSED] = false;\n    [EMITTED_ERROR] = null;\n    [BUFFERLENGTH] = 0;\n    [DESTROYED] = false;\n    [SIGNAL];\n    [ABORTED] = false;\n    [DATALISTENERS] = 0;\n    [DISCARDED] = false;\n    /**\n     * true if the stream can be written\n     */\n    writable = true;\n    /**\n     * true if the stream can be read\n     */\n    readable = true;\n    /**\n     * If `RType` is Buffer, then options do not need to be provided.\n     * Otherwise, an options object must be provided to specify either\n     * {@link Minipass.SharedOptions.objectMode} or\n     * {@link Minipass.SharedOptions.encoding}, as appropriate.\n     */\n    constructor(...args) {\n        const options = (args[0] ||\n            {});\n        super();\n        if (options.objectMode && typeof options.encoding === 'string') {\n            throw new TypeError('Encoding and objectMode may not be used together');\n        }\n        if (isObjectModeOptions(options)) {\n            this[OBJECTMODE] = true;\n            this[ENCODING] = null;\n        }\n        else if (isEncodingOptions(options)) {\n            this[ENCODING] = options.encoding;\n            this[OBJECTMODE] = false;\n        }\n        else {\n            this[OBJECTMODE] = false;\n            this[ENCODING] = null;\n        }\n        this[ASYNC] = !!options.async;\n        this[DECODER] = this[ENCODING]\n            ? new node_string_decoder_1.StringDecoder(this[ENCODING])\n            : null;\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposeBuffer === true) {\n            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });\n        }\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposePipes === true) {\n            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });\n        }\n        const { signal } = options;\n        if (signal) {\n            this[SIGNAL] = signal;\n            if (signal.aborted) {\n                this[ABORT]();\n            }\n            else {\n                signal.addEventListener('abort', () => this[ABORT]());\n            }\n        }\n    }\n    /**\n     * The amount of data stored in the buffer waiting to be read.\n     *\n     * For Buffer strings, this will be the total byte length.\n     * For string encoding streams, this will be the string character length,\n     * according to JavaScript's `string.length` logic.\n     * For objectMode streams, this is a count of the items waiting to be\n     * emitted.\n     */\n    get bufferLength() {\n        return this[BUFFERLENGTH];\n    }\n    /**\n     * The `BufferEncoding` currently in use, or `null`\n     */\n    get encoding() {\n        return this[ENCODING];\n    }\n    /**\n     * @deprecated - This is a read only property\n     */\n    set encoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * @deprecated - Encoding may only be set at instantiation time\n     */\n    setEncoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * True if this is an objectMode stream\n     */\n    get objectMode() {\n        return this[OBJECTMODE];\n    }\n    /**\n     * @deprecated - This is a read-only property\n     */\n    set objectMode(_om) {\n        throw new Error('objectMode must be set at instantiation time');\n    }\n    /**\n     * true if this is an async stream\n     */\n    get ['async']() {\n        return this[ASYNC];\n    }\n    /**\n     * Set to true to make this stream async.\n     *\n     * Once set, it cannot be unset, as this would potentially cause incorrect\n     * behavior.  Ie, a sync stream can be made async, but an async stream\n     * cannot be safely made sync.\n     */\n    set ['async'](a) {\n        this[ASYNC] = this[ASYNC] || !!a;\n    }\n    // drop everything and get out of the flow completely\n    [ABORT]() {\n        this[ABORTED] = true;\n        this.emit('abort', this[SIGNAL]?.reason);\n        this.destroy(this[SIGNAL]?.reason);\n    }\n    /**\n     * True if the stream has been aborted.\n     */\n    get aborted() {\n        return this[ABORTED];\n    }\n    /**\n     * No-op setter. Stream aborted status is set via the AbortSignal provided\n     * in the constructor options.\n     */\n    set aborted(_) { }\n    write(chunk, encoding, cb) {\n        if (this[ABORTED])\n            return false;\n        if (this[EOF])\n            throw new Error('write after end');\n        if (this[DESTROYED]) {\n            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));\n            return true;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (!encoding)\n            encoding = 'utf8';\n        const fn = this[ASYNC] ? defer : nodefer;\n        // convert array buffers and typed array views into buffers\n        // at some point in the future, we may want to do the opposite!\n        // leave strings and buffers as-is\n        // anything is only allowed if in object mode, so throw\n        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n            if (isArrayBufferView(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n            }\n            else if (isArrayBufferLike(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk);\n            }\n            else if (typeof chunk !== 'string') {\n                throw new Error('Non-contiguous data written to non-objectMode stream');\n            }\n        }\n        // handle object mode up front, since it's simpler\n        // this yields better performance, fewer checks later.\n        if (this[OBJECTMODE]) {\n            // maybe impossible?\n            /* c8 ignore start */\n            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n                this[FLUSH](true);\n            /* c8 ignore stop */\n            if (this[FLOWING])\n                this.emit('data', chunk);\n            else\n                this[BUFFERPUSH](chunk);\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // at this point the chunk is a buffer or string\n        // don't buffer it up or send it to the decoder\n        if (!chunk.length) {\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // fast-path writing strings of same encoding to a stream with\n        // an empty buffer, skipping the buffer/decoder dance\n        if (typeof chunk === 'string' &&\n            // unless it is a string already ready for us to use\n            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = this[DECODER].write(chunk);\n        }\n        // Note: flushing CAN potentially switch us into not-flowing mode\n        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n            this[FLUSH](true);\n        if (this[FLOWING])\n            this.emit('data', chunk);\n        else\n            this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0)\n            this.emit('readable');\n        if (cb)\n            fn(cb);\n        return this[FLOWING];\n    }\n    /**\n     * Low-level explicit read method.\n     *\n     * In objectMode, the argument is ignored, and one item is returned if\n     * available.\n     *\n     * `n` is the number of bytes (or in the case of encoding streams,\n     * characters) to consume. If `n` is not provided, then the entire buffer\n     * is returned, or `null` is returned if no data is available.\n     *\n     * If `n` is greater that the amount of data in the internal buffer,\n     * then `null` is returned.\n     */\n    read(n) {\n        if (this[DESTROYED])\n            return null;\n        this[DISCARDED] = false;\n        if (this[BUFFERLENGTH] === 0 ||\n            n === 0 ||\n            (n && n > this[BUFFERLENGTH])) {\n            this[MAYBE_EMIT_END]();\n            return null;\n        }\n        if (this[OBJECTMODE])\n            n = null;\n        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n            // not object mode, so if we have an encoding, then RType is string\n            // otherwise, must be Buffer\n            this[BUFFER] = [\n                (this[ENCODING]\n                    ? this[BUFFER].join('')\n                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),\n            ];\n        }\n        const ret = this[READ](n || null, this[BUFFER][0]);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [READ](n, chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERSHIFT]();\n        else {\n            const c = chunk;\n            if (n === c.length || n === null)\n                this[BUFFERSHIFT]();\n            else if (typeof c === 'string') {\n                this[BUFFER][0] = c.slice(n);\n                chunk = c.slice(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n            else {\n                this[BUFFER][0] = c.subarray(n);\n                chunk = c.subarray(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n        }\n        this.emit('data', chunk);\n        if (!this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n        return chunk;\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (chunk !== undefined)\n            this.write(chunk, encoding);\n        if (cb)\n            this.once('end', cb);\n        this[EOF] = true;\n        this.writable = false;\n        // if we haven't written anything, then go ahead and emit,\n        // even if we're not reading.\n        // we'll re-emit if a new 'end' listener is added anyway.\n        // This makes MP more suitable to write-only use cases.\n        if (this[FLOWING] || !this[PAUSED])\n            this[MAYBE_EMIT_END]();\n        return this;\n    }\n    // don't let the internal resume be overwritten\n    [RESUME]() {\n        if (this[DESTROYED])\n            return;\n        if (!this[DATALISTENERS] && !this[PIPES].length) {\n            this[DISCARDED] = true;\n        }\n        this[PAUSED] = false;\n        this[FLOWING] = true;\n        this.emit('resume');\n        if (this[BUFFER].length)\n            this[FLUSH]();\n        else if (this[EOF])\n            this[MAYBE_EMIT_END]();\n        else\n            this.emit('drain');\n    }\n    /**\n     * Resume the stream if it is currently in a paused state\n     *\n     * If called when there are no pipe destinations or `data` event listeners,\n     * this will place the stream in a \"discarded\" state, where all data will\n     * be thrown away. The discarded state is removed if a pipe destination or\n     * data handler is added, if pause() is called, or if any synchronous or\n     * asynchronous iteration is started.\n     */\n    resume() {\n        return this[RESUME]();\n    }\n    /**\n     * Pause the stream\n     */\n    pause() {\n        this[FLOWING] = false;\n        this[PAUSED] = true;\n        this[DISCARDED] = false;\n    }\n    /**\n     * true if the stream has been forcibly destroyed\n     */\n    get destroyed() {\n        return this[DESTROYED];\n    }\n    /**\n     * true if the stream is currently in a flowing state, meaning that\n     * any writes will be immediately emitted.\n     */\n    get flowing() {\n        return this[FLOWING];\n    }\n    /**\n     * true if the stream is currently in a paused state\n     */\n    get paused() {\n        return this[PAUSED];\n    }\n    [BUFFERPUSH](chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] += 1;\n        else\n            this[BUFFERLENGTH] += chunk.length;\n        this[BUFFER].push(chunk);\n    }\n    [BUFFERSHIFT]() {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] -= 1;\n        else\n            this[BUFFERLENGTH] -= this[BUFFER][0].length;\n        return this[BUFFER].shift();\n    }\n    [FLUSH](noDrain = false) {\n        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n            this[BUFFER].length);\n        if (!noDrain && !this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n    }\n    [FLUSHCHUNK](chunk) {\n        this.emit('data', chunk);\n        return this[FLOWING];\n    }\n    /**\n     * Pipe all data emitted by this stream into the destination provided.\n     *\n     * Triggers the flow of data.\n     */\n    pipe(dest, opts) {\n        if (this[DESTROYED])\n            return dest;\n        this[DISCARDED] = false;\n        const ended = this[EMITTED_END];\n        opts = opts || {};\n        if (dest === proc.stdout || dest === proc.stderr)\n            opts.end = false;\n        else\n            opts.end = opts.end !== false;\n        opts.proxyErrors = !!opts.proxyErrors;\n        // piping an ended stream ends immediately\n        if (ended) {\n            if (opts.end)\n                dest.end();\n        }\n        else {\n            // \"as\" here just ignores the WType, which pipes don't care about,\n            // since they're only consuming from us, and writing to the dest\n            this[PIPES].push(!opts.proxyErrors\n                ? new Pipe(this, dest, opts)\n                : new PipeProxyErrors(this, dest, opts));\n            if (this[ASYNC])\n                defer(() => this[RESUME]());\n            else\n                this[RESUME]();\n        }\n        return dest;\n    }\n    /**\n     * Fully unhook a piped destination stream.\n     *\n     * If the destination stream was the only consumer of this stream (ie,\n     * there are no other piped destinations or `'data'` event listeners)\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    unpipe(dest) {\n        const p = this[PIPES].find(p => p.dest === dest);\n        if (p) {\n            if (this[PIPES].length === 1) {\n                if (this[FLOWING] && this[DATALISTENERS] === 0) {\n                    this[FLOWING] = false;\n                }\n                this[PIPES] = [];\n            }\n            else\n                this[PIPES].splice(this[PIPES].indexOf(p), 1);\n            p.unpipe();\n        }\n    }\n    /**\n     * Alias for {@link Minipass#on}\n     */\n    addListener(ev, handler) {\n        return this.on(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.on`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * - Adding a 'data' event handler will trigger the flow of data\n     *\n     * - Adding a 'readable' event handler when there is data waiting to be read\n     *   will cause 'readable' to be emitted immediately.\n     *\n     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n     *   already passed will cause the event to be emitted immediately and all\n     *   handlers removed.\n     *\n     * - Adding an 'error' event handler after an error has been emitted will\n     *   cause the event to be re-emitted immediately with the error previously\n     *   raised.\n     */\n    on(ev, handler) {\n        const ret = super.on(ev, handler);\n        if (ev === 'data') {\n            this[DISCARDED] = false;\n            this[DATALISTENERS]++;\n            if (!this[PIPES].length && !this[FLOWING]) {\n                this[RESUME]();\n            }\n        }\n        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n            super.emit('readable');\n        }\n        else if (isEndish(ev) && this[EMITTED_END]) {\n            super.emit(ev);\n            this.removeAllListeners(ev);\n        }\n        else if (ev === 'error' && this[EMITTED_ERROR]) {\n            const h = handler;\n            if (this[ASYNC])\n                defer(() => h.call(this, this[EMITTED_ERROR]));\n            else\n                h.call(this, this[EMITTED_ERROR]);\n        }\n        return ret;\n    }\n    /**\n     * Alias for {@link Minipass#off}\n     */\n    removeListener(ev, handler) {\n        return this.off(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.off`\n     *\n     * If a 'data' event handler is removed, and it was the last consumer\n     * (ie, there are no pipe destinations or other 'data' event listeners),\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    off(ev, handler) {\n        const ret = super.off(ev, handler);\n        // if we previously had listeners, and now we don't, and we don't\n        // have any pipes, then stop the flow, unless it's been explicitly\n        // put in a discarded flowing state via stream.resume().\n        if (ev === 'data') {\n            this[DATALISTENERS] = this.listeners('data').length;\n            if (this[DATALISTENERS] === 0 &&\n                !this[DISCARDED] &&\n                !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Mostly identical to `EventEmitter.removeAllListeners`\n     *\n     * If all 'data' event handlers are removed, and they were the last consumer\n     * (ie, there are no pipe destinations), then the flow of data will stop\n     * until there is another consumer or {@link Minipass#resume} is explicitly\n     * called.\n     */\n    removeAllListeners(ev) {\n        const ret = super.removeAllListeners(ev);\n        if (ev === 'data' || ev === undefined) {\n            this[DATALISTENERS] = 0;\n            if (!this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * true if the 'end' event has been emitted\n     */\n    get emittedEnd() {\n        return this[EMITTED_END];\n    }\n    [MAYBE_EMIT_END]() {\n        if (!this[EMITTING_END] &&\n            !this[EMITTED_END] &&\n            !this[DESTROYED] &&\n            this[BUFFER].length === 0 &&\n            this[EOF]) {\n            this[EMITTING_END] = true;\n            this.emit('end');\n            this.emit('prefinish');\n            this.emit('finish');\n            if (this[CLOSED])\n                this.emit('close');\n            this[EMITTING_END] = false;\n        }\n    }\n    /**\n     * Mostly identical to `EventEmitter.emit`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * If the stream has been destroyed, and the event is something other\n     * than 'close' or 'error', then `false` is returned and no handlers\n     * are called.\n     *\n     * If the event is 'end', and has already been emitted, then the event\n     * is ignored. If the stream is in a paused or non-flowing state, then\n     * the event will be deferred until data flow resumes. If the stream is\n     * async, then handlers will be called on the next tick rather than\n     * immediately.\n     *\n     * If the event is 'close', and 'end' has not yet been emitted, then\n     * the event will be deferred until after 'end' is emitted.\n     *\n     * If the event is 'error', and an AbortSignal was provided for the stream,\n     * and there are no listeners, then the event is ignored, matching the\n     * behavior of node core streams in the presense of an AbortSignal.\n     *\n     * If the event is 'finish' or 'prefinish', then all listeners will be\n     * removed after emitting the event, to prevent double-firing.\n     */\n    emit(ev, ...args) {\n        const data = args[0];\n        // error and close are only events allowed after calling destroy()\n        if (ev !== 'error' &&\n            ev !== 'close' &&\n            ev !== DESTROYED &&\n            this[DESTROYED]) {\n            return false;\n        }\n        else if (ev === 'data') {\n            return !this[OBJECTMODE] && !data\n                ? false\n                : this[ASYNC]\n                    ? (defer(() => this[EMITDATA](data)), true)\n                    : this[EMITDATA](data);\n        }\n        else if (ev === 'end') {\n            return this[EMITEND]();\n        }\n        else if (ev === 'close') {\n            this[CLOSED] = true;\n            // don't emit close before 'end' and 'finish'\n            if (!this[EMITTED_END] && !this[DESTROYED])\n                return false;\n            const ret = super.emit('close');\n            this.removeAllListeners('close');\n            return ret;\n        }\n        else if (ev === 'error') {\n            this[EMITTED_ERROR] = data;\n            super.emit(ERROR, data);\n            const ret = !this[SIGNAL] || this.listeners('error').length\n                ? super.emit('error', data)\n                : false;\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'resume') {\n            const ret = super.emit('resume');\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'finish' || ev === 'prefinish') {\n            const ret = super.emit(ev);\n            this.removeAllListeners(ev);\n            return ret;\n        }\n        // Some other unknown event\n        const ret = super.emit(ev, ...args);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITDATA](data) {\n        for (const p of this[PIPES]) {\n            if (p.dest.write(data) === false)\n                this.pause();\n        }\n        const ret = this[DISCARDED] ? false : super.emit('data', data);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITEND]() {\n        if (this[EMITTED_END])\n            return false;\n        this[EMITTED_END] = true;\n        this.readable = false;\n        return this[ASYNC]\n            ? (defer(() => this[EMITEND2]()), true)\n            : this[EMITEND2]();\n    }\n    [EMITEND2]() {\n        if (this[DECODER]) {\n            const data = this[DECODER].end();\n            if (data) {\n                for (const p of this[PIPES]) {\n                    p.dest.write(data);\n                }\n                if (!this[DISCARDED])\n                    super.emit('data', data);\n            }\n        }\n        for (const p of this[PIPES]) {\n            p.end();\n        }\n        const ret = super.emit('end');\n        this.removeAllListeners('end');\n        return ret;\n    }\n    /**\n     * Return a Promise that resolves to an array of all emitted data once\n     * the stream ends.\n     */\n    async collect() {\n        const buf = Object.assign([], {\n            dataLength: 0,\n        });\n        if (!this[OBJECTMODE])\n            buf.dataLength = 0;\n        // set the promise first, in case an error is raised\n        // by triggering the flow here.\n        const p = this.promise();\n        this.on('data', c => {\n            buf.push(c);\n            if (!this[OBJECTMODE])\n                buf.dataLength += c.length;\n        });\n        await p;\n        return buf;\n    }\n    /**\n     * Return a Promise that resolves to the concatenation of all emitted data\n     * once the stream ends.\n     *\n     * Not allowed on objectMode streams.\n     */\n    async concat() {\n        if (this[OBJECTMODE]) {\n            throw new Error('cannot concat in objectMode');\n        }\n        const buf = await this.collect();\n        return (this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength));\n    }\n    /**\n     * Return a void Promise that resolves once the stream ends.\n     */\n    async promise() {\n        return new Promise((resolve, reject) => {\n            this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n            this.on('error', er => reject(er));\n            this.on('end', () => resolve());\n        });\n    }\n    /**\n     * Asynchronous `for await of` iteration.\n     *\n     * This will continue emitting all chunks until the stream terminates.\n     */\n    [Symbol.asyncIterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = async () => {\n            this.pause();\n            stopped = true;\n            return { value: undefined, done: true };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const res = this.read();\n            if (res !== null)\n                return Promise.resolve({ done: false, value: res });\n            if (this[EOF])\n                return stop();\n            let resolve;\n            let reject;\n            const onerr = (er) => {\n                this.off('data', ondata);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                reject(er);\n            };\n            const ondata = (value) => {\n                this.off('error', onerr);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                this.pause();\n                resolve({ value, done: !!this[EOF] });\n            };\n            const onend = () => {\n                this.off('error', onerr);\n                this.off('data', ondata);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                resolve({ done: true, value: undefined });\n            };\n            const ondestroy = () => onerr(new Error('stream destroyed'));\n            return new Promise((res, rej) => {\n                reject = rej;\n                resolve = res;\n                this.once(DESTROYED, ondestroy);\n                this.once('error', onerr);\n                this.once('end', onend);\n                this.once('data', ondata);\n            });\n        };\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Synchronous `for of` iteration.\n     *\n     * The iteration will terminate when the internal buffer runs out, even\n     * if the stream has not yet terminated.\n     */\n    [Symbol.iterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = () => {\n            this.pause();\n            this.off(ERROR, stop);\n            this.off(DESTROYED, stop);\n            this.off('end', stop);\n            stopped = true;\n            return { done: true, value: undefined };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const value = this.read();\n            return value === null ? stop() : { done: false, value };\n        };\n        this.once('end', stop);\n        this.once(ERROR, stop);\n        this.once(DESTROYED, stop);\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Destroy a stream, preventing it from being used for any further purpose.\n     *\n     * If the stream has a `close()` method, then it will be called on\n     * destruction.\n     *\n     * After destruction, any attempt to write data, read data, or emit most\n     * events will be ignored.\n     *\n     * If an error argument is provided, then it will be emitted in an\n     * 'error' event.\n     */\n    destroy(er) {\n        if (this[DESTROYED]) {\n            if (er)\n                this.emit('error', er);\n            else\n                this.emit(DESTROYED);\n            return this;\n        }\n        this[DESTROYED] = true;\n        this[DISCARDED] = true;\n        // throw away all buffered data, it's never coming out\n        this[BUFFER].length = 0;\n        this[BUFFERLENGTH] = 0;\n        const wc = this;\n        if (typeof wc.close === 'function' && !this[CLOSED])\n            wc.close();\n        if (er)\n            this.emit('error', er);\n        // if no error to emit, still reject pending promises\n        else\n            this.emit(DESTROYED);\n        return this;\n    }\n    /**\n     * Alias for {@link isStream}\n     *\n     * Former export location, maintained for backwards compatibility.\n     *\n     * @deprecated\n     */\n    static get isStream() {\n        return exports.isStream;\n    }\n}\nexports.Minipass = Minipass;\n//# sourceMappingURL=index.js.map","'use strict'\n\nconst crypto = require('crypto')\nconst { Minipass } = require('minipass')\n\nconst SPEC_ALGORITHMS = ['sha512', 'sha384', 'sha256']\nconst DEFAULT_ALGORITHMS = ['sha512']\n\n// TODO: this should really be a hardcoded list of algorithms we support,\n// rather than [a-z0-9].\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i\nconst SRI_REGEX = /^([a-z0-9]+)-([^?]+)([?\\S*]*)$/\nconst STRICT_SRI_REGEX = /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/\n\nconst getOptString = options => options?.length ? `?${options.join('?')}` : ''\n\nclass IntegrityStream extends Minipass {\n  #emittedIntegrity\n  #emittedSize\n  #emittedVerified\n\n  constructor (opts) {\n    super()\n    this.size = 0\n    this.opts = opts\n\n    // may be overridden later, but set now for class consistency\n    this.#getOptions()\n\n    // options used for calculating stream.  can't be changed.\n    if (opts?.algorithms) {\n      this.algorithms = [...opts.algorithms]\n    } else {\n      this.algorithms = [...DEFAULT_ALGORITHMS]\n    }\n    if (this.algorithm !== null && !this.algorithms.includes(this.algorithm)) {\n      this.algorithms.push(this.algorithm)\n    }\n\n    this.hashes = this.algorithms.map(crypto.createHash)\n  }\n\n  #getOptions () {\n    // For verification\n    this.sri = this.opts?.integrity ? parse(this.opts?.integrity, this.opts) : null\n    this.expectedSize = this.opts?.size\n\n    if (!this.sri) {\n      this.algorithm = null\n    } else if (this.sri.isHash) {\n      this.goodSri = true\n      this.algorithm = this.sri.algorithm\n    } else {\n      this.goodSri = !this.sri.isEmpty()\n      this.algorithm = this.sri.pickAlgorithm(this.opts)\n    }\n\n    this.digests = this.goodSri ? this.sri[this.algorithm] : null\n    this.optString = getOptString(this.opts?.options)\n  }\n\n  on (ev, handler) {\n    if (ev === 'size' && this.#emittedSize) {\n      return handler(this.#emittedSize)\n    }\n\n    if (ev === 'integrity' && this.#emittedIntegrity) {\n      return handler(this.#emittedIntegrity)\n    }\n\n    if (ev === 'verified' && this.#emittedVerified) {\n      return handler(this.#emittedVerified)\n    }\n\n    return super.on(ev, handler)\n  }\n\n  emit (ev, data) {\n    if (ev === 'end') {\n      this.#onEnd()\n    }\n    return super.emit(ev, data)\n  }\n\n  write (data) {\n    this.size += data.length\n    this.hashes.forEach(h => h.update(data))\n    return super.write(data)\n  }\n\n  #onEnd () {\n    if (!this.goodSri) {\n      this.#getOptions()\n    }\n    const newSri = parse(this.hashes.map((h, i) => {\n      return `${this.algorithms[i]}-${h.digest('base64')}${this.optString}`\n    }).join(' '), this.opts)\n    // Integrity verification mode\n    const match = this.goodSri && newSri.match(this.sri, this.opts)\n    if (typeof this.expectedSize === 'number' && this.size !== this.expectedSize) {\n      /* eslint-disable-next-line max-len */\n      const err = new Error(`stream size mismatch when checking ${this.sri}.\\n  Wanted: ${this.expectedSize}\\n  Found: ${this.size}`)\n      err.code = 'EBADSIZE'\n      err.found = this.size\n      err.expected = this.expectedSize\n      err.sri = this.sri\n      this.emit('error', err)\n    } else if (this.sri && !match) {\n      /* eslint-disable-next-line max-len */\n      const err = new Error(`${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`)\n      err.code = 'EINTEGRITY'\n      err.found = newSri\n      err.expected = this.digests\n      err.algorithm = this.algorithm\n      err.sri = this.sri\n      this.emit('error', err)\n    } else {\n      this.#emittedSize = this.size\n      this.emit('size', this.size)\n      this.#emittedIntegrity = newSri\n      this.emit('integrity', newSri)\n      if (match) {\n        this.#emittedVerified = match\n        this.emit('verified', match)\n      }\n    }\n  }\n}\n\nclass Hash {\n  get isHash () {\n    return true\n  }\n\n  constructor (hash, opts) {\n    const strict = opts?.strict\n    this.source = hash.trim()\n\n    // set default values so that we make V8 happy to\n    // always see a familiar object template.\n    this.digest = ''\n    this.algorithm = ''\n    this.options = []\n\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(\n      strict\n        ? STRICT_SRI_REGEX\n        : SRI_REGEX\n    )\n    if (!match) {\n      return\n    }\n    if (strict && !SPEC_ALGORITHMS.includes(match[1])) {\n      return\n    }\n    this.algorithm = match[1]\n    this.digest = match[2]\n\n    const rawOpts = match[3]\n    if (rawOpts) {\n      this.options = rawOpts.slice(1).split('?')\n    }\n  }\n\n  hexDigest () {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n\n  match (integrity, opts) {\n    const other = parse(integrity, opts)\n    if (!other) {\n      return false\n    }\n    if (other.isIntegrity) {\n      const algo = other.pickAlgorithm(opts, [this.algorithm])\n\n      if (!algo) {\n        return false\n      }\n\n      const foundHash = other[algo].find(hash => hash.digest === this.digest)\n\n      if (foundHash) {\n        return foundHash\n      }\n\n      return false\n    }\n    return other.digest === this.digest ? other : false\n  }\n\n  toString (opts) {\n    if (opts?.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n        // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.includes(this.algorithm) &&\n        // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) &&\n        // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        this.options.every(opt => opt.match(VCHAR_REGEX))\n      )) {\n        return ''\n      }\n    }\n    return `${this.algorithm}-${this.digest}${getOptString(this.options)}`\n  }\n}\n\nfunction integrityHashToString (toString, sep, opts, hashes) {\n  const toStringIsNotEmpty = toString !== ''\n\n  let shouldAddFirstSep = false\n  let complement = ''\n\n  const lastIndex = hashes.length - 1\n\n  for (let i = 0; i < lastIndex; i++) {\n    const hashString = Hash.prototype.toString.call(hashes[i], opts)\n\n    if (hashString) {\n      shouldAddFirstSep = true\n\n      complement += hashString\n      complement += sep\n    }\n  }\n\n  const finalHashString = Hash.prototype.toString.call(hashes[lastIndex], opts)\n\n  if (finalHashString) {\n    shouldAddFirstSep = true\n    complement += finalHashString\n  }\n\n  if (toStringIsNotEmpty && shouldAddFirstSep) {\n    return toString + sep + complement\n  }\n\n  return toString + complement\n}\n\nclass Integrity {\n  get isIntegrity () {\n    return true\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n\n  isEmpty () {\n    return Object.keys(this).length === 0\n  }\n\n  toString (opts) {\n    let sep = opts?.sep || ' '\n    let toString = ''\n\n    if (opts?.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ')\n\n      for (const hash of SPEC_ALGORITHMS) {\n        if (this[hash]) {\n          toString = integrityHashToString(toString, sep, opts, this[hash])\n        }\n      }\n    } else {\n      for (const hash of Object.keys(this)) {\n        toString = integrityHashToString(toString, sep, opts, this[hash])\n      }\n    }\n\n    return toString\n  }\n\n  concat (integrity, opts) {\n    const other = typeof integrity === 'string'\n      ? integrity\n      : stringify(integrity, opts)\n    return parse(`${this.toString(opts)} ${other}`, opts)\n  }\n\n  hexDigest () {\n    return parse(this, { single: true }).hexDigest()\n  }\n\n  // add additional hashes to an integrity value, but prevent\n  // *changing* an existing integrity hash.\n  merge (integrity, opts) {\n    const other = parse(integrity, opts)\n    for (const algo in other) {\n      if (this[algo]) {\n        if (!this[algo].find(hash =>\n          other[algo].find(otherhash =>\n            hash.digest === otherhash.digest))) {\n          throw new Error('hashes do not match, cannot update integrity')\n        }\n      } else {\n        this[algo] = other[algo]\n      }\n    }\n  }\n\n  match (integrity, opts) {\n    const other = parse(integrity, opts)\n    if (!other) {\n      return false\n    }\n    const algo = other.pickAlgorithm(opts, Object.keys(this))\n    return (\n      !!algo &&\n      this[algo] &&\n      other[algo] &&\n      this[algo].find(hash =>\n        other[algo].find(otherhash =>\n          hash.digest === otherhash.digest\n        )\n      )\n    ) || false\n  }\n\n  // Pick the highest priority algorithm present, optionally also limited to a\n  // set of hashes found in another integrity.  When limiting it may return\n  // nothing.\n  pickAlgorithm (opts, hashes) {\n    const pickAlgorithm = opts?.pickAlgorithm || getPrioritizedHash\n    const keys = Object.keys(this).filter(k => {\n      if (hashes?.length) {\n        return hashes.includes(k)\n      }\n      return true\n    })\n    if (keys.length) {\n      return keys.reduce((acc, algo) => pickAlgorithm(acc, algo) || acc)\n    }\n    // no intersection between this and hashes,\n    return null\n  }\n}\n\nmodule.exports.parse = parse\nfunction parse (sri, opts) {\n  if (!sri) {\n    return null\n  }\n  if (typeof sri === 'string') {\n    return _parse(sri, opts)\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity()\n    fullSri[sri.algorithm] = [sri]\n    return _parse(stringify(fullSri, opts), opts)\n  } else {\n    return _parse(stringify(sri, opts), opts)\n  }\n}\n\nfunction _parse (integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts?.single) {\n    return new Hash(integrity, opts)\n  }\n  const hashes = integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts)\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) {\n        acc[algo] = []\n      }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n  return hashes.isEmpty() ? null : hashes\n}\n\nmodule.exports.stringify = stringify\nfunction stringify (obj, opts) {\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts)\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts)\n  } else {\n    return Integrity.prototype.toString.call(obj, opts)\n  }\n}\n\nmodule.exports.fromHex = fromHex\nfunction fromHex (hexDigest, algorithm, opts) {\n  const optString = getOptString(opts?.options)\n  return parse(\n    `${algorithm}-${\n      Buffer.from(hexDigest, 'hex').toString('base64')\n    }${optString}`, opts\n  )\n}\n\nmodule.exports.fromData = fromData\nfunction fromData (data, opts) {\n  const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS]\n  const optString = getOptString(opts?.options)\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64')\n    const hash = new Hash(\n      `${algo}-${digest}${optString}`,\n      opts\n    )\n    /* istanbul ignore else - it would be VERY strange if the string we\n     * just calculated with an algo did not have an algo or digest.\n     */\n    if (hash.algorithm && hash.digest) {\n      const hashAlgo = hash.algorithm\n      if (!acc[hashAlgo]) {\n        acc[hashAlgo] = []\n      }\n      acc[hashAlgo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.fromStream = fromStream\nfunction fromStream (stream, opts) {\n  const istream = integrityStream(opts)\n  return new Promise((resolve, reject) => {\n    stream.pipe(istream)\n    stream.on('error', reject)\n    istream.on('error', reject)\n    let sri\n    istream.on('integrity', s => {\n      sri = s\n    })\n    istream.on('end', () => resolve(sri))\n    istream.resume()\n  })\n}\n\nmodule.exports.checkData = checkData\nfunction checkData (data, sri, opts) {\n  sri = parse(sri, opts)\n  if (!sri || !Object.keys(sri).length) {\n    if (opts?.error) {\n      throw Object.assign(\n        new Error('No valid integrity hashes to check against'), {\n          code: 'EINTEGRITY',\n        }\n      )\n    } else {\n      return false\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts)\n  const digest = crypto.createHash(algorithm).update(data).digest('base64')\n  const newSri = parse({ algorithm, digest })\n  const match = newSri.match(sri, opts)\n  opts = opts || {}\n  if (match || !(opts.error)) {\n    return match\n  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {\n    /* eslint-disable-next-line max-len */\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`)\n    err.code = 'EBADSIZE'\n    err.found = data.length\n    err.expected = opts.size\n    err.sri = sri\n    throw err\n  } else {\n    /* eslint-disable-next-line max-len */\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)\n    err.code = 'EINTEGRITY'\n    err.found = newSri\n    err.expected = sri\n    err.algorithm = algorithm\n    err.sri = sri\n    throw err\n  }\n}\n\nmodule.exports.checkStream = checkStream\nfunction checkStream (stream, sri, opts) {\n  opts = opts || Object.create(null)\n  opts.integrity = sri\n  sri = parse(sri, opts)\n  if (!sri || !Object.keys(sri).length) {\n    return Promise.reject(Object.assign(\n      new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY',\n      }\n    ))\n  }\n  const checker = integrityStream(opts)\n  return new Promise((resolve, reject) => {\n    stream.pipe(checker)\n    stream.on('error', reject)\n    checker.on('error', reject)\n    let verified\n    checker.on('verified', s => {\n      verified = s\n    })\n    checker.on('end', () => resolve(verified))\n    checker.resume()\n  })\n}\n\nmodule.exports.integrityStream = integrityStream\nfunction integrityStream (opts = Object.create(null)) {\n  return new IntegrityStream(opts)\n}\n\nmodule.exports.create = createIntegrity\nfunction createIntegrity (opts) {\n  const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS]\n  const optString = getOptString(opts?.options)\n\n  const hashes = algorithms.map(crypto.createHash)\n\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc))\n      return this\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64')\n        const hash = new Hash(\n          `${algo}-${digest}${optString}`,\n          opts\n        )\n        /* istanbul ignore else - it would be VERY strange if the hash we\n         * just calculated with an algo did not have an algo or digest.\n         */\n        if (hash.algorithm && hash.digest) {\n          const hashAlgo = hash.algorithm\n          if (!acc[hashAlgo]) {\n            acc[hashAlgo] = []\n          }\n          acc[hashAlgo].push(hash)\n        }\n        return acc\n      }, new Integrity())\n\n      return integrity\n    },\n  }\n}\n\nconst NODE_HASHES = crypto.getHashes()\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = [\n  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n  // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3',\n  'sha3-256', 'sha3-384', 'sha3-512',\n  'sha3_256', 'sha3_384', 'sha3_512',\n].filter(algo => NODE_HASHES.includes(algo))\n\nfunction getPrioritizedHash (algo1, algo2) {\n  /* eslint-disable-next-line max-len */\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())\n    ? algo1\n    : algo2\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createShortHash = createShortHash;\nexports.createHexHash = createHexHash;\nexports.createHash = createHash;\nexports.createHashFromFile = createHashFromFile;\nexports.createHexHashFromFile = createHexHashFromFile;\nexports.getTarballIntegrity = getTarballIntegrity;\nconst crypto = __importStar(require(\"@pnpm/crypto.polyfill\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst graceful_fs_1 = __importDefault(require(\"@pnpm/graceful-fs\"));\nconst ssri_1 = __importDefault(require(\"ssri\"));\nfunction createShortHash(input) {\n    return createHexHash(input).substring(0, 32);\n}\nfunction createHexHash(input) {\n    return crypto.hash('sha256', input, 'hex');\n}\nfunction createHash(input) {\n    return `sha256-${crypto.hash('sha256', input, 'base64')}`;\n}\nasync function createHashFromFile(file) {\n    return createHash(await readNormalizedFile(file));\n}\nasync function createHexHashFromFile(file) {\n    return createHexHash(await readNormalizedFile(file));\n}\nasync function readNormalizedFile(file) {\n    const content = await fs_1.default.promises.readFile(file, 'utf8');\n    return content.split('\\r\\n').join('\\n');\n}\nasync function getTarballIntegrity(filename) {\n    return (await ssri_1.default.fromStream(graceful_fs_1.default.createReadStream(filename))).toString();\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isAbsolute = isAbsolute;\nexports.indexOfPeersSuffix = indexOfPeersSuffix;\nexports.parseDepPath = parseDepPath;\nexports.removeSuffix = removeSuffix;\nexports.getPkgIdWithPatchHash = getPkgIdWithPatchHash;\nexports.tryGetPackageId = tryGetPackageId;\nexports.getRegistryByPackageName = getRegistryByPackageName;\nexports.refToRelative = refToRelative;\nexports.parse = parse;\nexports.depPathToFilename = depPathToFilename;\nexports.createPeersDirSuffix = createPeersDirSuffix;\nconst crypto_hash_1 = require(\"@pnpm/crypto.hash\");\nconst semver_1 = __importDefault(require(\"semver\"));\nfunction isAbsolute(dependencyPath) {\n    return dependencyPath[0] !== '/';\n}\nfunction indexOfPeersSuffix(depPath) {\n    if (!depPath.endsWith(')'))\n        return { peersIndex: -1, patchHashIndex: -1 };\n    let open = 1;\n    for (let i = depPath.length - 2; i >= 0; i--) {\n        if (depPath[i] === '(') {\n            open--;\n        }\n        else if (depPath[i] === ')') {\n            open++;\n        }\n        else if (!open) {\n            if (depPath.substring(i + 1).startsWith('(patch_hash=')) {\n                return {\n                    patchHashIndex: i + 1,\n                    peersIndex: depPath.indexOf('(', i + 2),\n                };\n            }\n            return {\n                patchHashIndex: -1,\n                peersIndex: i + 1,\n            };\n        }\n    }\n    return { peersIndex: -1, patchHashIndex: -1 };\n}\nfunction parseDepPath(relDepPath) {\n    const { peersIndex } = indexOfPeersSuffix(relDepPath);\n    if (peersIndex !== -1) {\n        return {\n            id: relDepPath.substring(0, peersIndex),\n            peersSuffix: relDepPath.substring(peersIndex),\n        };\n    }\n    return {\n        id: relDepPath,\n        peersSuffix: '',\n    };\n}\nfunction removeSuffix(relDepPath) {\n    const { peersIndex, patchHashIndex } = indexOfPeersSuffix(relDepPath);\n    if (patchHashIndex !== -1) {\n        return relDepPath.substring(0, patchHashIndex);\n    }\n    if (peersIndex !== -1) {\n        return relDepPath.substring(0, peersIndex);\n    }\n    return relDepPath;\n}\nfunction getPkgIdWithPatchHash(depPath) {\n    let pkgId = depPath;\n    const { peersIndex: sepIndex } = indexOfPeersSuffix(pkgId);\n    if (sepIndex !== -1) {\n        pkgId = pkgId.substring(0, sepIndex);\n    }\n    if (pkgId.includes(':')) {\n        pkgId = pkgId.substring(pkgId.indexOf('@', 1) + 1);\n    }\n    return pkgId;\n}\nfunction tryGetPackageId(relDepPath) {\n    let pkgId = relDepPath;\n    const { peersIndex, patchHashIndex } = indexOfPeersSuffix(pkgId);\n    const sepIndex = patchHashIndex === -1 ? peersIndex : patchHashIndex;\n    if (sepIndex !== -1) {\n        pkgId = pkgId.substring(0, sepIndex);\n    }\n    if (pkgId.includes(':')) {\n        pkgId = pkgId.substring(pkgId.indexOf('@', 1) + 1);\n    }\n    return pkgId;\n}\nfunction getRegistryByPackageName(registries, packageName) {\n    if (packageName[0] !== '@')\n        return registries.default;\n    const scope = packageName.substring(0, packageName.indexOf('/'));\n    return registries[scope] || registries.default;\n}\nfunction refToRelative(reference, pkgName) {\n    if (reference.startsWith('link:')) {\n        return null;\n    }\n    if (reference.startsWith('@'))\n        return reference;\n    const atIndex = reference.indexOf('@');\n    if (atIndex === -1)\n        return `${pkgName}@${reference}`;\n    const colonIndex = reference.indexOf(':');\n    const bracketIndex = reference.indexOf('(');\n    if ((colonIndex === -1 || atIndex < colonIndex) && (bracketIndex === -1 || atIndex < bracketIndex))\n        return reference;\n    return `${pkgName}@${reference}`;\n}\nfunction parse(dependencyPath) {\n    // eslint-disable-next-line: strict-type-predicates\n    if (typeof dependencyPath !== 'string') {\n        throw new TypeError(`Expected \\`dependencyPath\\` to be of type \\`string\\`, got \\`${\n        // eslint-disable-next-line: strict-type-predicates\n        dependencyPath === null ? 'null' : typeof dependencyPath}\\``);\n    }\n    const sepIndex = dependencyPath.indexOf('@', 1);\n    if (sepIndex === -1) {\n        return {};\n    }\n    const name = dependencyPath.substring(0, sepIndex);\n    let version = dependencyPath.substring(sepIndex + 1);\n    if (version) {\n        let peersSuffix;\n        let patchHash;\n        const { peersIndex, patchHashIndex } = indexOfPeersSuffix(version);\n        if (peersIndex !== -1 || patchHashIndex !== -1) {\n            if (peersIndex === -1) {\n                patchHash = version.substring(patchHashIndex);\n                version = version.substring(0, patchHashIndex);\n            }\n            else if (patchHashIndex === -1) {\n                peersSuffix = version.substring(peersIndex);\n                version = version.substring(0, peersIndex);\n            }\n            else {\n                patchHash = version.substring(patchHashIndex, peersIndex);\n                peersSuffix = version.substring(peersIndex);\n                version = version.substring(0, patchHashIndex);\n            }\n        }\n        if (semver_1.default.valid(version)) {\n            return {\n                name,\n                peersSuffix,\n                version,\n                patchHash,\n            };\n        }\n        return {\n            name,\n            nonSemverVersion: version,\n            peersSuffix,\n            patchHash,\n        };\n    }\n    return {};\n}\nfunction depPathToFilename(depPath, maxLengthWithoutHash) {\n    let filename = depPathToFilenameUnescaped(depPath).replace(/[\\\\/:*?\"<>|#]/g, '+');\n    if (filename.includes('(')) {\n        filename = filename\n            .replace(/\\)$/, '')\n            .replace(/\\)\\(|\\(|\\)/g, '_');\n    }\n    if (filename.length > maxLengthWithoutHash || filename !== filename.toLowerCase() && !filename.startsWith('file+')) {\n        return `${filename.substring(0, maxLengthWithoutHash - 33)}_${(0, crypto_hash_1.createShortHash)(filename)}`;\n    }\n    return filename;\n}\nfunction depPathToFilenameUnescaped(depPath) {\n    if (depPath.indexOf('file:') !== 0) {\n        if (depPath[0] === '/') {\n            depPath = depPath.substring(1);\n        }\n        const index = depPath.indexOf('@', 1);\n        if (index === -1)\n            return depPath;\n        return `${depPath.substring(0, index)}@${depPath.slice(index + 1)}`;\n    }\n    return depPath.replace(':', '+');\n}\nfunction createPeersDirSuffix(peerIds, maxLength = 1000) {\n    let dirName = peerIds.map((peerId) => {\n        if (typeof peerId !== 'string') {\n            return `${peerId.name}@${peerId.version}`;\n        }\n        if (peerId.startsWith('/')) {\n            return peerId.substring(1);\n        }\n        return peerId;\n    }).sort().join(')(');\n    if (dirName.length > maxLength) {\n        dirName = (0, crypto_hash_1.createShortHash)(dirName);\n    }\n    return `(${dirName})`;\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DepType = void 0;\nexports.detectDepTypes = detectDepTypes;\nconst dp = __importStar(require(\"@pnpm/dependency-path\"));\nvar DepType;\n(function (DepType) {\n    DepType[DepType[\"DevOnly\"] = 0] = \"DevOnly\";\n    DepType[DepType[\"DevAndProd\"] = 1] = \"DevAndProd\";\n    DepType[DepType[\"ProdOnly\"] = 2] = \"ProdOnly\";\n})(DepType || (exports.DepType = DepType = {}));\nfunction detectDepTypes(lockfile) {\n    const dev = {};\n    const devDepPaths = Object.values(lockfile.importers)\n        .map((deps) => resolvedDepsToDepPaths(deps.devDependencies ?? {})).flat();\n    const optionalDepPaths = Object.values(lockfile.importers)\n        .map((deps) => resolvedDepsToDepPaths(deps.optionalDependencies ?? {})).flat();\n    const prodDepPaths = Object.values(lockfile.importers)\n        .map((deps) => resolvedDepsToDepPaths(deps.dependencies ?? {})).flat();\n    const ctx = {\n        packages: lockfile.packages ?? {},\n        walked: new Set(),\n        notProdOnly: new Set(),\n        dev,\n    };\n    detectDepTypesInSubGraph(ctx, devDepPaths, {\n        dev: true,\n    });\n    detectDepTypesInSubGraph(ctx, optionalDepPaths, {\n        dev: false,\n    });\n    detectDepTypesInSubGraph(ctx, prodDepPaths, {\n        dev: false,\n    });\n    return dev;\n}\nfunction detectDepTypesInSubGraph(ctx, depPaths, opts) {\n    for (const depPath of depPaths) {\n        const key = `${depPath}:${opts.dev.toString()}`;\n        if (ctx.walked.has(key))\n            continue;\n        ctx.walked.add(key);\n        if (!ctx.packages[depPath]) {\n            continue;\n        }\n        if (opts.dev) {\n            ctx.notProdOnly.add(depPath);\n            ctx.dev[depPath] = DepType.DevOnly;\n        }\n        else if (ctx.dev[depPath] === DepType.DevOnly) { // keeping if dev is explicitly false\n            ctx.dev[depPath] = DepType.DevAndProd;\n        }\n        else if (ctx.dev[depPath] === undefined && !ctx.notProdOnly.has(depPath)) {\n            ctx.dev[depPath] = DepType.ProdOnly;\n        }\n        const depLockfile = ctx.packages[depPath];\n        const newDependencies = resolvedDepsToDepPaths(depLockfile.dependencies ?? {});\n        detectDepTypesInSubGraph(ctx, newDependencies, opts);\n        const newOptionalDependencies = resolvedDepsToDepPaths(depLockfile.optionalDependencies ?? {});\n        detectDepTypesInSubGraph(ctx, newOptionalDependencies, { dev: opts.dev });\n    }\n}\nfunction resolvedDepsToDepPaths(deps) {\n    return Object.entries(deps)\n        .map(([alias, ref]) => dp.refToRelative(ref, alias))\n        .filter((depPath) => depPath !== null);\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.USEFUL_NON_ROOT_PNPM_FIELDS = exports.FULL_FILTERED_META_DIR = exports.FULL_META_DIR = exports.ABBREVIATED_META_DIR = exports.WORKSPACE_MANIFEST_FILENAME = exports.STORE_VERSION = exports.LAYOUT_VERSION = exports.ENGINE_NAME = exports.MANIFEST_BASE_NAMES = exports.LOCKFILE_VERSION = exports.LOCKFILE_MAJOR_VERSION = exports.WANTED_LOCKFILE = void 0;\nexports.WANTED_LOCKFILE = 'pnpm-lock.yaml';\nexports.LOCKFILE_MAJOR_VERSION = '9';\nexports.LOCKFILE_VERSION = `${exports.LOCKFILE_MAJOR_VERSION}.0`;\nexports.MANIFEST_BASE_NAMES = ['package.json', 'package.json5', 'package.yaml'];\nexports.ENGINE_NAME = `${process.platform};${process.arch};node${process.version.split('.')[0].substring(1)}`;\nexports.LAYOUT_VERSION = 5;\nexports.STORE_VERSION = 'v10';\nexports.WORKSPACE_MANIFEST_FILENAME = 'pnpm-workspace.yaml';\n// This file contains meta information\n// about all the packages published by the same name, not just the manifest\n// of one package/version\nexports.ABBREVIATED_META_DIR = 'metadata-v1.3';\nexports.FULL_META_DIR = 'metadata-full-v1.3'; // This is currently not used at all\nexports.FULL_FILTERED_META_DIR = 'metadata-v1.3';\nexports.USEFUL_NON_ROOT_PNPM_FIELDS = ['executionEnv'];\n//# sourceMappingURL=index.js.map","const fs = require('fs')\n\nmodule.exports = async (p) => {\n  try {\n    await fs.promises.rm(p, { recursive: true, force: true, maxRetries: 3 })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n}\n\nmodule.exports.sync = (p) => {\n  try {\n    fs.rmSync(p, { recursive: true, force: true, maxRetries: 3 })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n}\n","'use strict';\n\n\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nmodule.exports.isNothing      = isNothing;\nmodule.exports.isObject       = isObject;\nmodule.exports.toArray        = toArray;\nmodule.exports.repeat         = repeat;\nmodule.exports.isNegativeZero = isNegativeZero;\nmodule.exports.extend         = extend;\n","// YAML error class. http://stackoverflow.com/questions/8458984\n//\n'use strict';\n\n\nfunction formatError(exception, compact) {\n  var where = '', message = exception.reason || '(unknown reason)';\n\n  if (!exception.mark) return message;\n\n  if (exception.mark.name) {\n    where += 'in \"' + exception.mark.name + '\" ';\n  }\n\n  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n  if (!compact && exception.mark.snippet) {\n    where += '\\n\\n' + exception.mark.snippet;\n  }\n\n  return message + ' ' + where;\n}\n\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false);\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  return this.name + ': ' + formatError(this, compact);\n};\n\n\nmodule.exports = YAMLException;\n","'use strict';\n\n\nvar common = require('./common');\n\n\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n  var head = '';\n  var tail = '';\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n  if (position - lineStart > maxHalfLength) {\n    head = ' ... ';\n    lineStart = position - maxHalfLength + head.length;\n  }\n\n  if (lineEnd - position > maxHalfLength) {\n    tail = ' ...';\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n\n  return {\n    str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, '→') + tail,\n    pos: position - lineStart + head.length // relative position\n  };\n}\n\n\nfunction padStart(string, max) {\n  return common.repeat(' ', max - string.length) + string;\n}\n\n\nfunction makeSnippet(mark, options) {\n  options = Object.create(options || null);\n\n  if (!mark.buffer) return null;\n\n  if (!options.maxLength) options.maxLength = 79;\n  if (typeof options.indent      !== 'number') options.indent      = 1;\n  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [ 0 ];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n\n  while ((match = re.exec(mark.buffer))) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n\n  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n  var result = '', i, line;\n  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n  for (i = 1; i <= options.linesBefore; i++) {\n    if (foundLineNo - i < 0) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo - i],\n      lineEnds[foundLineNo - i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n      maxLineLength\n    );\n    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n' + result;\n  }\n\n  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n    ' | ' + line.str + '\\n';\n  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n  for (i = 1; i <= options.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo + i],\n      lineEnds[foundLineNo + i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n      maxLineLength\n    );\n    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n  }\n\n  return result.replace(/\\n$/, '');\n}\n\n\nmodule.exports = makeSnippet;\n","'use strict';\n\nvar YAMLException = require('./exception');\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'multi',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'representName',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.tag           = tag;\n  this.kind          = options['kind']          || null;\n  this.resolve       = options['resolve']       || function () { return true; };\n  this.construct     = options['construct']     || function (data) { return data; };\n  this.instanceOf    = options['instanceOf']    || null;\n  this.predicate     = options['predicate']     || null;\n  this.represent     = options['represent']     || null;\n  this.representName = options['representName'] || null;\n  this.defaultStyle  = options['defaultStyle']  || null;\n  this.multi         = options['multi']         || false;\n  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nmodule.exports = Type;\n","'use strict';\n\n/*eslint-disable max-len*/\n\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        exclude.push(previousIndex);\n      }\n    });\n\n    result.push(currentType);\n  });\n\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  return this.extend(definition);\n}\n\n\nSchema.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof Type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new YAMLException('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type.multi) {\n      throw new YAMLException('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit', []);\n  result.compiledExplicit = compileList(result, 'explicit', []);\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nmodule.exports = Schema;\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n","// Standard YAML's Failsafe schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  explicit: [\n    require('../type/str'),\n    require('../type/seq'),\n    require('../type/map')\n  ]\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; },\n    empty:     function () { return '';     }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'o') {\n      // base 8\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isOctCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n  }\n\n  // base 10 (except 0)\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  return true;\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch;\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n","// Standard YAML's JSON schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2803231\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, this schema is not such strict as defined in the YAML specification.\n// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n'use strict';\n\n\nmodule.exports = require('./failsafe').extend({\n  implicit: [\n    require('../type/null'),\n    require('../type/bool'),\n    require('../type/int'),\n    require('../type/float')\n  ]\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n","'use strict';\n\n/*eslint-disable no-bitwise*/\n\n\nvar Type = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n","// JS-YAML's default schema for `safeLoad` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on standard YAML's Core schema and includes most of\n// extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n'use strict';\n\n\nmodule.exports = require('./core').extend({\n  implicit: [\n    require('../type/timestamp'),\n    require('../type/merge')\n  ],\n  explicit: [\n    require('../type/binary'),\n    require('../type/omap'),\n    require('../type/pairs'),\n    require('../type/set')\n  ]\n});\n","'use strict';\n\n/*eslint-disable max-len,no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar makeSnippet         = require('./snippet');\nvar DEFAULT_SCHEMA      = require('./schema/default');\n\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || DEFAULT_SCHEMA;\n  this.onWarning = options['onWarning'] || null;\n  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n  // if such documents have no explicit %YAML directive\n  this.legacy    = options['legacy']    || false;\n\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  // position of first leading tab in the current line,\n  // used to make sure there are no tabs in the indentation\n  this.firstTabInLine = -1;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  var mark = {\n    name:     state.filename,\n    buffer:   state.input.slice(0, -1), // omit trailing \\0\n    position: state.position,\n    line:     state.line,\n    column:   state.position - state.lineStart\n  };\n\n  mark.snippet = makeSnippet(mark);\n\n  return new YAMLException(message, mark);\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, 'tag prefix is malformed: ' + prefix);\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n  startLine, startLineStart, startPos) {\n\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty.call(overridableKeys, keyNode) &&\n        _hasOwnProperty.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    // used for this specific key only because Object.defineProperty is slow\n    if (keyNode === '__proto__') {\n      Object.defineProperty(_result, keyNode, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: valueNode\n      });\n    } else {\n      _result[keyNode] = valueNode;\n    }\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    } else if (ch === 0x2C/* , */) {\n      // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n      throwError(state, \"expected the node content, but found ','\");\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line; // Save the current line.\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = Object.create(null),\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        // Neither implicit nor explicit notation.\n        // Reading is done. Go to the epilogue.\n        break;\n      }\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, 'tag name is malformed: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n\n  } else if (state.tag === '?') {\n    // Implicit resolving is not allowed for non-scalar types, and '?'\n    // non-specific tag is only automatically assigned to plain scalars.\n    //\n    // We only need to check kind conformity in case user explicitly assigns '?'\n    // tag, for example like this: \"!<?> [0]\"\n    //\n    if (state.result !== null && state.kind !== 'scalar') {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type = state.implicitTypes[typeIndex];\n\n      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        state.result = type.construct(state.result);\n        state.tag = type.tag;\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n        break;\n      }\n    }\n  } else if (state.tag !== '!') {\n    if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n    } else {\n      // looking for multi type\n      type = null;\n      typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n\n    if (!type) {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n\n    if (state.result !== null && type.kind !== state.kind) {\n      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n    }\n\n    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n    } else {\n      state.result = type.construct(state.result, state.tag);\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = Object.create(null);\n  state.anchorMap = Object.create(null);\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new YAMLException('expected a single document in the stream, but found more');\n}\n\n\nmodule.exports.loadAll = loadAll;\nmodule.exports.load    = load;\n","'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_SCHEMA      = require('./schema/default');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nvar SINGLE_LINE_KEYS = {\n  cpu: true,\n  engines: true,\n  os: true,\n  resolution: true,\n  libc: true\n};\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.blankLines    = options['blankLines'] || false;\n  this.schema        = options['schema'] || DEFAULT_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level, doubleLine) {\n  return '\\n' + (doubleLine ? '\\n' : '') + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out\n//                             c = flow-in   ⇒ ns-plain-safe-in\n//                             c = block-key ⇒ ns-plain-safe-out\n//                             c = flow-key  ⇒ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )\n//                            | ( /* An ns-char preceding */ “#” )\n//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock, singleLO) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey || singleLO\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object, singleLineOnly) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false, singleLineOnly)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false, singleLineOnly)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact, doubleLine) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level, doubleLine);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair, null, null, objectKey)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq, objectKey, singleLineOnly) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      singleLineOnly = SINGLE_LINE_KEYS[objectKey];\n      if (block && (Object.keys(state.dump).length !== 0) && !singleLineOnly) {\n        var doubleLine = state.blankLines ?\n          (objectKey === 'packages' || objectKey === 'importers' || objectKey === 'snapshots' || level === 0) : false;\n        writeBlockMapping(state, level, state.dump, compact, doubleLine);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump, singleLineOnly);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      singleLineOnly = SINGLE_LINE_KEYS[objectKey];\n      if (block && (state.dump.length !== 0) && !singleLineOnly) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump, singleLineOnly);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock, singleLineOnly);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”\n      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”\n      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”\n      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nmodule.exports.dump = dump;\n","'use strict';\n\n\nvar loader = require('./lib/loader');\nvar dumper = require('./lib/dumper');\n\n\nfunction renamed(from, to) {\n  return function () {\n    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n      'Use yaml.' + to + ' instead, which is now safe by default.');\n  };\n}\n\n\nmodule.exports.Type                = require('./lib/type');\nmodule.exports.Schema              = require('./lib/schema');\nmodule.exports.FAILSAFE_SCHEMA     = require('./lib/schema/failsafe');\nmodule.exports.JSON_SCHEMA         = require('./lib/schema/json');\nmodule.exports.CORE_SCHEMA         = require('./lib/schema/core');\nmodule.exports.DEFAULT_SCHEMA      = require('./lib/schema/default');\nmodule.exports.load                = loader.load;\nmodule.exports.loadAll             = loader.loadAll;\nmodule.exports.dump                = dumper.dump;\nmodule.exports.YAMLException       = require('./lib/exception');\n\n// Removed functions from JS-YAML 3.0.x\nmodule.exports.safeLoad            = renamed('safeLoad', 'load');\nmodule.exports.safeLoadAll         = renamed('safeLoadAll', 'loadAll');\nmodule.exports.safeDump            = renamed('safeDump', 'dump');\n","function _isPlaceholder(a) {\n  return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n}\n\nmodule.exports = _isPlaceholder;","var _isPlaceholder =\n/*#__PURE__*/\nrequire(\"./_isPlaceholder.js\");\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}\n\nmodule.exports = _curry1;","function _has(prop, obj) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = _has;","var _has =\n/*#__PURE__*/\nrequire(\"./_has.js\");\n\nvar toString = Object.prototype.toString;\n\nvar _isArguments =\n/*#__PURE__*/\nfunction () {\n  return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {\n    return toString.call(x) === '[object Arguments]';\n  } : function _isArguments(x) {\n    return _has('callee', x);\n  };\n}();\n\nmodule.exports = _isArguments;","function _isObject(x) {\n  return Object.prototype.toString.call(x) === '[object Object]';\n}\n\nmodule.exports = _isObject;","function _isString(x) {\n  return Object.prototype.toString.call(x) === '[object String]';\n}\n\nmodule.exports = _isString;","/**\n * Tests whether or not an object is a typed array.\n *\n * @private\n * @param {*} val The object to test.\n * @return {Boolean} `true` if `val` is a typed array, `false` otherwise.\n * @example\n *\n *      _isTypedArray(new Uint8Array([])); //=> true\n *      _isTypedArray(new Float32Array([])); //=> true\n *      _isTypedArray([]); //=> false\n *      _isTypedArray(null); //=> false\n *      _isTypedArray({}); //=> false\n */\nfunction _isTypedArray(val) {\n  var type = Object.prototype.toString.call(val);\n  return type === '[object Uint8ClampedArray]' || type === '[object Int8Array]' || type === '[object Uint8Array]' || type === '[object Int16Array]' || type === '[object Uint16Array]' || type === '[object Int32Array]' || type === '[object Uint32Array]' || type === '[object Float32Array]' || type === '[object Float64Array]' || type === '[object BigInt64Array]' || type === '[object BigUint64Array]';\n}\n\nmodule.exports = _isTypedArray;","var _curry1 =\n/*#__PURE__*/\nrequire(\"./internal/_curry1.js\");\n\nvar _isArguments =\n/*#__PURE__*/\nrequire(\"./internal/_isArguments.js\");\n\nvar _isArray =\n/*#__PURE__*/\nrequire(\"./internal/_isArray.js\");\n\nvar _isObject =\n/*#__PURE__*/\nrequire(\"./internal/_isObject.js\");\n\nvar _isString =\n/*#__PURE__*/\nrequire(\"./internal/_isString.js\");\n\nvar _isTypedArray =\n/*#__PURE__*/\nrequire(\"./internal/_isTypedArray.js\");\n/**\n * Returns the empty value of its argument's type. Ramda defines the empty\n * value of Array (`[]`), Object (`{}`), String (`''`),\n * TypedArray (`Uint8Array []`, `Float32Array []`, etc), and Arguments. Other\n * types are supported if they define `<Type>.empty`,\n * `<Type>.prototype.empty` or implement the\n * [FantasyLand Monoid spec](https://github.com/fantasyland/fantasy-land#monoid).\n *\n * Dispatches to the `empty` method of the first argument, if present.\n *\n * @func\n * @memberOf R\n * @since v0.3.0\n * @category Function\n * @sig a -> a\n * @param {*} x\n * @return {*}\n * @example\n *\n *      R.empty(Just(42));               //=> Nothing()\n *      R.empty([1, 2, 3]);              //=> []\n *      R.empty('unicorns');             //=> ''\n *      R.empty({x: 1, y: 2});           //=> {}\n *      R.empty(Uint8Array.from('123')); //=> Uint8Array []\n */\n\n\nvar empty =\n/*#__PURE__*/\n_curry1(function empty(x) {\n  return x != null && typeof x['fantasy-land/empty'] === 'function' ? x['fantasy-land/empty']() : x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function' ? x.constructor['fantasy-land/empty']() : x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {\n    return arguments;\n  }() : _isTypedArray(x) ? x.constructor.from('') : void 0 // else\n  ;\n});\n\nmodule.exports = empty;","var _curry1 =\n/*#__PURE__*/\nrequire(\"./_curry1.js\");\n\nvar _isPlaceholder =\n/*#__PURE__*/\nrequire(\"./_isPlaceholder.js\");\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n          return fn(a, _b);\n        });\n\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b);\n        }) : fn(a, b);\n    }\n  };\n}\n\nmodule.exports = _curry2;","function _arrayFromIterator(iter) {\n  var list = [];\n  var next;\n\n  while (!(next = iter.next()).done) {\n    list.push(next.value);\n  }\n\n  return list;\n}\n\nmodule.exports = _arrayFromIterator;","function _includesWith(pred, x, list) {\n  var idx = 0;\n  var len = list.length;\n\n  while (idx < len) {\n    if (pred(x, list[idx])) {\n      return true;\n    }\n\n    idx += 1;\n  }\n\n  return false;\n}\n\nmodule.exports = _includesWith;","function _functionName(f) {\n  // String(x => x) evaluates to \"x => x\", so the pattern may not match.\n  var match = String(f).match(/^function (\\w*)/);\n  return match == null ? '' : match[1];\n}\n\nmodule.exports = _functionName;","// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\nfunction _objectIs(a, b) {\n  // SameValue algorithm\n  if (a === b) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    return a !== 0 || 1 / a === 1 / b;\n  } else {\n    // Step 6.a: NaN == NaN\n    return a !== a && b !== b;\n  }\n}\n\nmodule.exports = typeof Object.is === 'function' ? Object.is : _objectIs;","var _curry1 =\n/*#__PURE__*/\nrequire(\"./internal/_curry1.js\");\n\nvar _has =\n/*#__PURE__*/\nrequire(\"./internal/_has.js\");\n\nvar _isArguments =\n/*#__PURE__*/\nrequire(\"./internal/_isArguments.js\"); // cover IE < 9 keys issues\n\n\nvar hasEnumBug = !\n/*#__PURE__*/\n{\n  toString: null\n}.propertyIsEnumerable('toString');\nvar nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug\n\nvar hasArgsEnumBug =\n/*#__PURE__*/\nfunction () {\n  'use strict';\n\n  return arguments.propertyIsEnumerable('length');\n}();\n\nvar contains = function contains(list, item) {\n  var idx = 0;\n\n  while (idx < list.length) {\n    if (list[idx] === item) {\n      return true;\n    }\n\n    idx += 1;\n  }\n\n  return false;\n};\n/**\n * Returns a list containing the names of all the enumerable own properties of\n * the supplied object.\n * Note that the order of the output array is not guaranteed to be consistent\n * across different JS platforms.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @sig {k: v} -> [k]\n * @param {Object} obj The object to extract properties from\n * @return {Array} An array of the object's own properties.\n * @see R.keysIn, R.values, R.toPairs\n * @example\n *\n *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']\n */\n\n\nvar keys = typeof Object.keys === 'function' && !hasArgsEnumBug ?\n/*#__PURE__*/\n_curry1(function keys(obj) {\n  return Object(obj) !== obj ? [] : Object.keys(obj);\n}) :\n/*#__PURE__*/\n_curry1(function keys(obj) {\n  if (Object(obj) !== obj) {\n    return [];\n  }\n\n  var prop, nIdx;\n  var ks = [];\n\n  var checkArgsLength = hasArgsEnumBug && _isArguments(obj);\n\n  for (prop in obj) {\n    if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {\n      ks[ks.length] = prop;\n    }\n  }\n\n  if (hasEnumBug) {\n    nIdx = nonEnumerableProps.length - 1;\n\n    while (nIdx >= 0) {\n      prop = nonEnumerableProps[nIdx];\n\n      if (_has(prop, obj) && !contains(ks, prop)) {\n        ks[ks.length] = prop;\n      }\n\n      nIdx -= 1;\n    }\n  }\n\n  return ks;\n});\nmodule.exports = keys;","var _curry1 =\n/*#__PURE__*/\nrequire(\"./internal/_curry1.js\");\n/**\n * Gives a single-word string description of the (native) type of a value,\n * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not\n * attempt to distinguish user Object types any further, reporting them all as\n * 'Object'.\n *\n * @func\n * @memberOf R\n * @since v0.8.0\n * @category Type\n * @sig (* -> {*}) -> String\n * @param {*} val The value to test\n * @return {String}\n * @example\n *\n *      R.type({}); //=> \"Object\"\n *      R.type(1); //=> \"Number\"\n *      R.type(false); //=> \"Boolean\"\n *      R.type('s'); //=> \"String\"\n *      R.type(null); //=> \"Null\"\n *      R.type([]); //=> \"Array\"\n *      R.type(/[A-z]/); //=> \"RegExp\"\n *      R.type(() => {}); //=> \"Function\"\n *      R.type(undefined); //=> \"Undefined\"\n */\n\n\nvar type =\n/*#__PURE__*/\n_curry1(function type(val) {\n  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);\n});\n\nmodule.exports = type;","var _arrayFromIterator =\n/*#__PURE__*/\nrequire(\"./_arrayFromIterator.js\");\n\nvar _includesWith =\n/*#__PURE__*/\nrequire(\"./_includesWith.js\");\n\nvar _functionName =\n/*#__PURE__*/\nrequire(\"./_functionName.js\");\n\nvar _has =\n/*#__PURE__*/\nrequire(\"./_has.js\");\n\nvar _objectIs =\n/*#__PURE__*/\nrequire(\"./_objectIs.js\");\n\nvar keys =\n/*#__PURE__*/\nrequire(\"../keys.js\");\n\nvar type =\n/*#__PURE__*/\nrequire(\"../type.js\");\n/**\n * private _uniqContentEquals function.\n * That function is checking equality of 2 iterator contents with 2 assumptions\n * - iterators lengths are the same\n * - iterators values are unique\n *\n * false-positive result will be returned for comparison of, e.g.\n * - [1,2,3] and [1,2,3,4]\n * - [1,1,1] and [1,2,3]\n * */\n\n\nfunction _uniqContentEquals(aIterator, bIterator, stackA, stackB) {\n  var a = _arrayFromIterator(aIterator);\n\n  var b = _arrayFromIterator(bIterator);\n\n  function eq(_a, _b) {\n    return _equals(_a, _b, stackA.slice(), stackB.slice());\n  } // if *a* array contains any element that is not included in *b*\n\n\n  return !_includesWith(function (b, aItem) {\n    return !_includesWith(eq, aItem, b);\n  }, b, a);\n}\n\nfunction _equals(a, b, stackA, stackB) {\n  if (_objectIs(a, b)) {\n    return true;\n  }\n\n  var typeA = type(a);\n\n  if (typeA !== type(b)) {\n    return false;\n  }\n\n  if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {\n    return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);\n  }\n\n  if (typeof a.equals === 'function' || typeof b.equals === 'function') {\n    return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);\n  }\n\n  switch (typeA) {\n    case 'Arguments':\n    case 'Array':\n    case 'Object':\n      if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {\n        return a === b;\n      }\n\n      break;\n\n    case 'Boolean':\n    case 'Number':\n    case 'String':\n      if (!(typeof a === typeof b && _objectIs(a.valueOf(), b.valueOf()))) {\n        return false;\n      }\n\n      break;\n\n    case 'Date':\n      if (!_objectIs(a.valueOf(), b.valueOf())) {\n        return false;\n      }\n\n      break;\n\n    case 'Error':\n      return a.name === b.name && a.message === b.message;\n\n    case 'RegExp':\n      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {\n        return false;\n      }\n\n      break;\n  }\n\n  var idx = stackA.length - 1;\n\n  while (idx >= 0) {\n    if (stackA[idx] === a) {\n      return stackB[idx] === b;\n    }\n\n    idx -= 1;\n  }\n\n  switch (typeA) {\n    case 'Map':\n      if (a.size !== b.size) {\n        return false;\n      }\n\n      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));\n\n    case 'Set':\n      if (a.size !== b.size) {\n        return false;\n      }\n\n      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));\n\n    case 'Arguments':\n    case 'Array':\n    case 'Object':\n    case 'Boolean':\n    case 'Number':\n    case 'String':\n    case 'Date':\n    case 'Error':\n    case 'RegExp':\n    case 'Int8Array':\n    case 'Uint8Array':\n    case 'Uint8ClampedArray':\n    case 'Int16Array':\n    case 'Uint16Array':\n    case 'Int32Array':\n    case 'Uint32Array':\n    case 'Float32Array':\n    case 'Float64Array':\n    case 'ArrayBuffer':\n      break;\n\n    default:\n      // Values of other types are only equal if identical.\n      return false;\n  }\n\n  var keysA = keys(a);\n\n  if (keysA.length !== keys(b).length) {\n    return false;\n  }\n\n  var extendedStackA = stackA.concat([a]);\n  var extendedStackB = stackB.concat([b]);\n  idx = keysA.length - 1;\n\n  while (idx >= 0) {\n    var key = keysA[idx];\n\n    if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {\n      return false;\n    }\n\n    idx -= 1;\n  }\n\n  return true;\n}\n\nmodule.exports = _equals;","var _curry2 =\n/*#__PURE__*/\nrequire(\"./internal/_curry2.js\");\n\nvar _equals =\n/*#__PURE__*/\nrequire(\"./internal/_equals.js\");\n/**\n * Returns `true` if its arguments are equivalent, `false` otherwise. Handles\n * cyclical data structures.\n *\n * Dispatches symmetrically to the `equals` methods of both arguments, if\n * present.\n *\n * @func\n * @memberOf R\n * @since v0.15.0\n * @category Relation\n * @sig a -> b -> Boolean\n * @param {*} a\n * @param {*} b\n * @return {Boolean}\n * @example\n *\n *      R.equals(1, 1); //=> true\n *      R.equals(1, '1'); //=> false\n *      R.equals([1, 2, 3], [1, 2, 3]); //=> true\n *\n *      const a = {}; a.v = a;\n *      const b = {}; b.v = b;\n *      R.equals(a, b); //=> true\n */\n\n\nvar equals =\n/*#__PURE__*/\n_curry2(function equals(a, b) {\n  return _equals(a, b, [], []);\n});\n\nmodule.exports = equals;","var _curry1 =\n/*#__PURE__*/\nrequire(\"./internal/_curry1.js\");\n\nvar empty =\n/*#__PURE__*/\nrequire(\"./empty.js\");\n\nvar equals =\n/*#__PURE__*/\nrequire(\"./equals.js\");\n/**\n * Returns `true` if the given value is its type's empty value; `false`\n * otherwise.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Logic\n * @sig a -> Boolean\n * @param {*} x\n * @return {Boolean}\n * @see R.empty\n * @example\n *\n *      R.isEmpty([1, 2, 3]);           //=> false\n *      R.isEmpty([]);                  //=> true\n *      R.isEmpty('');                  //=> true\n *      R.isEmpty(null);                //=> false\n *      R.isEmpty({});                  //=> true\n *      R.isEmpty({length: 0});         //=> false\n *      R.isEmpty(Uint8Array.from('')); //=> true\n */\n\n\nvar isEmpty =\n/*#__PURE__*/\n_curry1(function isEmpty(x) {\n  return x != null && equals(x, empty(x));\n});\n\nmodule.exports = isEmpty;","/**\n * @preserve\n * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)\n *\n * @author <a href=\"mailto:jensyt@gmail.com\">Jens Taylor</a>\n * @see http://github.com/homebrewing/brauhaus-diff\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n */\n(function(){\n    var cache;\n\n    // Call this function without `new` to use the cached object (good for\n    // single-threaded environments), or with `new` to create a new object.\n    //\n    // @param {string} key A UTF-16 or ASCII string\n    // @param {number} seed An optional positive integer\n    // @return {object} A MurmurHash3 object for incremental hashing\n    function MurmurHash3(key, seed) {\n        var m = this instanceof MurmurHash3 ? this : cache;\n        m.reset(seed)\n        if (typeof key === 'string' && key.length > 0) {\n            m.hash(key);\n        }\n\n        if (m !== this) {\n            return m;\n        }\n    };\n\n    // Incrementally add a string to this hash\n    //\n    // @param {string} key A UTF-16 or ASCII string\n    // @return {object} this\n    MurmurHash3.prototype.hash = function(key) {\n        var h1, k1, i, top, len;\n\n        len = key.length;\n        this.len += len;\n\n        k1 = this.k1;\n        i = 0;\n        switch (this.rem) {\n            case 0: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) : 0;\n            case 1: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 8 : 0;\n            case 2: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 16 : 0;\n            case 3:\n                k1 ^= len > i ? (key.charCodeAt(i) & 0xff) << 24 : 0;\n                k1 ^= len > i ? (key.charCodeAt(i++) & 0xff00) >> 8 : 0;\n        }\n\n        this.rem = (len + this.rem) & 3; // & 3 is same as % 4\n        len -= this.rem;\n        if (len > 0) {\n            h1 = this.h1;\n            while (1) {\n                k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;\n                k1 = (k1 << 15) | (k1 >>> 17);\n                k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;\n\n                h1 ^= k1;\n                h1 = (h1 << 13) | (h1 >>> 19);\n                h1 = (h1 * 5 + 0xe6546b64) & 0xffffffff;\n\n                if (i >= len) {\n                    break;\n                }\n\n                k1 = ((key.charCodeAt(i++) & 0xffff)) ^\n                     ((key.charCodeAt(i++) & 0xffff) << 8) ^\n                     ((key.charCodeAt(i++) & 0xffff) << 16);\n                top = key.charCodeAt(i++);\n                k1 ^= ((top & 0xff) << 24) ^\n                      ((top & 0xff00) >> 8);\n            }\n\n            k1 = 0;\n            switch (this.rem) {\n                case 3: k1 ^= (key.charCodeAt(i + 2) & 0xffff) << 16;\n                case 2: k1 ^= (key.charCodeAt(i + 1) & 0xffff) << 8;\n                case 1: k1 ^= (key.charCodeAt(i) & 0xffff);\n            }\n\n            this.h1 = h1;\n        }\n\n        this.k1 = k1;\n        return this;\n    };\n\n    // Get the result of this hash\n    //\n    // @return {number} The 32-bit hash\n    MurmurHash3.prototype.result = function() {\n        var k1, h1;\n        \n        k1 = this.k1;\n        h1 = this.h1;\n\n        if (k1 > 0) {\n            k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;\n            k1 = (k1 << 15) | (k1 >>> 17);\n            k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;\n            h1 ^= k1;\n        }\n\n        h1 ^= this.len;\n\n        h1 ^= h1 >>> 16;\n        h1 = (h1 * 0xca6b + (h1 & 0xffff) * 0x85eb0000) & 0xffffffff;\n        h1 ^= h1 >>> 13;\n        h1 = (h1 * 0xae35 + (h1 & 0xffff) * 0xc2b20000) & 0xffffffff;\n        h1 ^= h1 >>> 16;\n\n        return h1 >>> 0;\n    };\n\n    // Reset the hash object for reuse\n    //\n    // @param {number} seed An optional positive integer\n    MurmurHash3.prototype.reset = function(seed) {\n        this.h1 = typeof seed === 'number' ? seed : 0;\n        this.rem = this.k1 = this.len = 0;\n        return this;\n    };\n\n    // A cached object to use. This can be safely used if you're in a single-\n    // threaded environment, otherwise you need to create new hashes to use.\n    cache = new MurmurHash3();\n\n    if (typeof(module) != 'undefined') {\n        module.exports = MurmurHash3;\n    } else {\n        this.MurmurHash3 = MurmurHash3;\n    }\n}());\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.signals = void 0;\n/**\n * This is not the set of all possible signals.\n *\n * It IS, however, the set of all signals that trigger\n * an exit on either Linux or BSD systems.  Linux is a\n * superset of the signal names supported on BSD, and\n * the unknown signals just fail to register, so we can\n * catch that easily enough.\n *\n * Windows signals are a different set, since there are\n * signals that terminate Windows processes, but don't\n * terminate (or don't even exist) on Posix systems.\n *\n * Don't bother with SIGKILL.  It's uncatchable, which\n * means that we can't fire any callbacks anyway.\n *\n * If a user does happen to register a handler on a non-\n * fatal signal like SIGWINCH or something, and then\n * exit, it'll end up firing `process.emit('exit')`, so\n * the handler will be fired anyway.\n *\n * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n * artificially, inherently leave the process in a\n * state from which it is not safe to try and enter JS\n * listeners.\n */\nexports.signals = [];\nexports.signals.push('SIGHUP', 'SIGINT', 'SIGTERM');\nif (process.platform !== 'win32') {\n    exports.signals.push('SIGALRM', 'SIGABRT', 'SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n    );\n}\nif (process.platform === 'linux') {\n    exports.signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT');\n}\n//# sourceMappingURL=signals.js.map","\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unload = exports.load = exports.onExit = exports.signals = void 0;\n// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nconst signals_js_1 = require(\"./signals.js\");\nObject.defineProperty(exports, \"signals\", { enumerable: true, get: function () { return signals_js_1.signals; } });\nconst processOk = (process) => !!process &&\n    typeof process === 'object' &&\n    typeof process.removeListener === 'function' &&\n    typeof process.emit === 'function' &&\n    typeof process.reallyExit === 'function' &&\n    typeof process.listeners === 'function' &&\n    typeof process.kill === 'function' &&\n    typeof process.pid === 'number' &&\n    typeof process.on === 'function';\nconst kExitEmitter = Symbol.for('signal-exit emitter');\nconst global = globalThis;\nconst ObjectDefineProperty = Object.defineProperty.bind(Object);\n// teeny special purpose ee\nclass Emitter {\n    emitted = {\n        afterExit: false,\n        exit: false,\n    };\n    listeners = {\n        afterExit: [],\n        exit: [],\n    };\n    count = 0;\n    id = Math.random();\n    constructor() {\n        if (global[kExitEmitter]) {\n            return global[kExitEmitter];\n        }\n        ObjectDefineProperty(global, kExitEmitter, {\n            value: this,\n            writable: false,\n            enumerable: false,\n            configurable: false,\n        });\n    }\n    on(ev, fn) {\n        this.listeners[ev].push(fn);\n    }\n    removeListener(ev, fn) {\n        const list = this.listeners[ev];\n        const i = list.indexOf(fn);\n        /* c8 ignore start */\n        if (i === -1) {\n            return;\n        }\n        /* c8 ignore stop */\n        if (i === 0 && list.length === 1) {\n            list.length = 0;\n        }\n        else {\n            list.splice(i, 1);\n        }\n    }\n    emit(ev, code, signal) {\n        if (this.emitted[ev]) {\n            return false;\n        }\n        this.emitted[ev] = true;\n        let ret = false;\n        for (const fn of this.listeners[ev]) {\n            ret = fn(code, signal) === true || ret;\n        }\n        if (ev === 'exit') {\n            ret = this.emit('afterExit', code, signal) || ret;\n        }\n        return ret;\n    }\n}\nclass SignalExitBase {\n}\nconst signalExitWrap = (handler) => {\n    return {\n        onExit(cb, opts) {\n            return handler.onExit(cb, opts);\n        },\n        load() {\n            return handler.load();\n        },\n        unload() {\n            return handler.unload();\n        },\n    };\n};\nclass SignalExitFallback extends SignalExitBase {\n    onExit() {\n        return () => { };\n    }\n    load() { }\n    unload() { }\n}\nclass SignalExit extends SignalExitBase {\n    // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n    // so use a supported signal instead\n    /* c8 ignore start */\n    #hupSig = process.platform === 'win32' ? 'SIGINT' : 'SIGHUP';\n    /* c8 ignore stop */\n    #emitter = new Emitter();\n    #process;\n    #originalProcessEmit;\n    #originalProcessReallyExit;\n    #sigListeners = {};\n    #loaded = false;\n    constructor(process) {\n        super();\n        this.#process = process;\n        // { <signal>: <listener fn>, ... }\n        this.#sigListeners = {};\n        for (const sig of signals_js_1.signals) {\n            this.#sigListeners[sig] = () => {\n                // If there are no other listeners, an exit is coming!\n                // Simplest way: remove us and then re-send the signal.\n                // We know that this will kill the process, so we can\n                // safely emit now.\n                const listeners = this.#process.listeners(sig);\n                let { count } = this.#emitter;\n                // This is a workaround for the fact that signal-exit v3 and signal\n                // exit v4 are not aware of each other, and each will attempt to let\n                // the other handle it, so neither of them do. To correct this, we\n                // detect if we're the only handler *except* for previous versions\n                // of signal-exit, and increment by the count of listeners it has\n                // created.\n                /* c8 ignore start */\n                const p = process;\n                if (typeof p.__signal_exit_emitter__ === 'object' &&\n                    typeof p.__signal_exit_emitter__.count === 'number') {\n                    count += p.__signal_exit_emitter__.count;\n                }\n                /* c8 ignore stop */\n                if (listeners.length === count) {\n                    this.unload();\n                    const ret = this.#emitter.emit('exit', null, sig);\n                    /* c8 ignore start */\n                    const s = sig === 'SIGHUP' ? this.#hupSig : sig;\n                    if (!ret)\n                        process.kill(process.pid, s);\n                    /* c8 ignore stop */\n                }\n            };\n        }\n        this.#originalProcessReallyExit = process.reallyExit;\n        this.#originalProcessEmit = process.emit;\n    }\n    onExit(cb, opts) {\n        /* c8 ignore start */\n        if (!processOk(this.#process)) {\n            return () => { };\n        }\n        /* c8 ignore stop */\n        if (this.#loaded === false) {\n            this.load();\n        }\n        const ev = opts?.alwaysLast ? 'afterExit' : 'exit';\n        this.#emitter.on(ev, cb);\n        return () => {\n            this.#emitter.removeListener(ev, cb);\n            if (this.#emitter.listeners['exit'].length === 0 &&\n                this.#emitter.listeners['afterExit'].length === 0) {\n                this.unload();\n            }\n        };\n    }\n    load() {\n        if (this.#loaded) {\n            return;\n        }\n        this.#loaded = true;\n        // This is the number of onSignalExit's that are in play.\n        // It's important so that we can count the correct number of\n        // listeners on signals, and don't wait for the other one to\n        // handle it instead of us.\n        this.#emitter.count += 1;\n        for (const sig of signals_js_1.signals) {\n            try {\n                const fn = this.#sigListeners[sig];\n                if (fn)\n                    this.#process.on(sig, fn);\n            }\n            catch (_) { }\n        }\n        this.#process.emit = (ev, ...a) => {\n            return this.#processEmit(ev, ...a);\n        };\n        this.#process.reallyExit = (code) => {\n            return this.#processReallyExit(code);\n        };\n    }\n    unload() {\n        if (!this.#loaded) {\n            return;\n        }\n        this.#loaded = false;\n        signals_js_1.signals.forEach(sig => {\n            const listener = this.#sigListeners[sig];\n            /* c8 ignore start */\n            if (!listener) {\n                throw new Error('Listener not defined for signal: ' + sig);\n            }\n            /* c8 ignore stop */\n            try {\n                this.#process.removeListener(sig, listener);\n                /* c8 ignore start */\n            }\n            catch (_) { }\n            /* c8 ignore stop */\n        });\n        this.#process.emit = this.#originalProcessEmit;\n        this.#process.reallyExit = this.#originalProcessReallyExit;\n        this.#emitter.count -= 1;\n    }\n    #processReallyExit(code) {\n        /* c8 ignore start */\n        if (!processOk(this.#process)) {\n            return 0;\n        }\n        this.#process.exitCode = code || 0;\n        /* c8 ignore stop */\n        this.#emitter.emit('exit', this.#process.exitCode, null);\n        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);\n    }\n    #processEmit(ev, ...args) {\n        const og = this.#originalProcessEmit;\n        if (ev === 'exit' && processOk(this.#process)) {\n            if (typeof args[0] === 'number') {\n                this.#process.exitCode = args[0];\n                /* c8 ignore start */\n            }\n            /* c8 ignore start */\n            const ret = og.call(this.#process, ev, ...args);\n            /* c8 ignore start */\n            this.#emitter.emit('exit', this.#process.exitCode, null);\n            /* c8 ignore stop */\n            return ret;\n        }\n        else {\n            return og.call(this.#process, ev, ...args);\n        }\n    }\n}\nconst process = globalThis.process;\n// wrap so that we call the method on the actual handler, without\n// exporting it directly.\n_a = signalExitWrap(processOk(process) ? new SignalExit(process) : new SignalExitFallback()), \n/**\n * Called when the process is exiting, whether via signal, explicit\n * exit, or running out of stuff to do.\n *\n * If the global process object is not suitable for instrumentation,\n * then this will be a no-op.\n *\n * Returns a function that may be used to unload signal-exit.\n */\nexports.onExit = _a.onExit, \n/**\n * Load the listeners.  Likely you never need to call this, unless\n * doing a rather deep integration with signal-exit functionality.\n * Mostly exposed for the benefit of testing.\n *\n * @internal\n */\nexports.load = _a.load, \n/**\n * Unload the listeners.  Likely you never need to call this, unless\n * doing a rather deep integration with signal-exit functionality.\n * Mostly exposed for the benefit of testing.\n *\n * @internal\n */\nexports.unload = _a.unload;\n//# sourceMappingURL=index.js.map","'use strict'\nmodule.exports = writeFile\nmodule.exports.sync = writeFileSync\nmodule.exports._getTmpname = getTmpname // for testing\nmodule.exports._cleanupOnExit = cleanupOnExit\n\nconst fs = require('fs')\nconst MurmurHash3 = require('imurmurhash')\nconst { onExit } = require('signal-exit')\nconst path = require('path')\nconst { promisify } = require('util')\nconst activeFiles = {}\n\n// if we run inside of a worker_thread, `process.pid` is not unique\n/* istanbul ignore next */\nconst threadId = (function getId () {\n  try {\n    const workerThreads = require('worker_threads')\n\n    /// if we are in main thread, this is set to `0`\n    return workerThreads.threadId\n  } catch (e) {\n    // worker_threads are not available, fallback to 0\n    return 0\n  }\n})()\n\nlet invocations = 0\nfunction getTmpname (filename) {\n  return filename + '.' +\n    MurmurHash3(__filename)\n      .hash(String(process.pid))\n      .hash(String(threadId))\n      .hash(String(++invocations))\n      .result()\n}\n\nfunction cleanupOnExit (tmpfile) {\n  return () => {\n    try {\n      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile)\n    } catch {\n      // ignore errors\n    }\n  }\n}\n\nfunction serializeActiveFile (absoluteName) {\n  return new Promise(resolve => {\n    // make a queue if it doesn't already exist\n    if (!activeFiles[absoluteName]) {\n      activeFiles[absoluteName] = []\n    }\n\n    activeFiles[absoluteName].push(resolve) // add this job to the queue\n    if (activeFiles[absoluteName].length === 1) {\n      resolve()\n    } // kick off the first one\n  })\n}\n\n// https://github.com/isaacs/node-graceful-fs/blob/master/polyfills.js#L315-L342\nfunction isChownErrOk (err) {\n  if (err.code === 'ENOSYS') {\n    return true\n  }\n\n  const nonroot = !process.getuid || process.getuid() !== 0\n  if (nonroot) {\n    if (err.code === 'EINVAL' || err.code === 'EPERM') {\n      return true\n    }\n  }\n\n  return false\n}\n\nasync function writeFileAsync (filename, data, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  let fd\n  let tmpfile\n  /* istanbul ignore next -- The closure only gets called when onExit triggers */\n  const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile))\n  const absoluteName = path.resolve(filename)\n\n  try {\n    await serializeActiveFile(absoluteName)\n    const truename = await promisify(fs.realpath)(filename).catch(() => filename)\n    tmpfile = getTmpname(truename)\n\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      const stats = await promisify(fs.stat)(truename).catch(() => {})\n      if (stats) {\n        if (options.mode == null) {\n          options.mode = stats.mode\n        }\n\n        if (options.chown == null && process.getuid) {\n          options.chown = { uid: stats.uid, gid: stats.gid }\n        }\n      }\n    }\n\n    fd = await promisify(fs.open)(tmpfile, 'w', options.mode)\n    if (options.tmpfileCreated) {\n      await options.tmpfileCreated(tmpfile)\n    }\n    if (ArrayBuffer.isView(data)) {\n      await promisify(fs.write)(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      await promisify(fs.write)(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n\n    if (options.fsync !== false) {\n      await promisify(fs.fsync)(fd)\n    }\n\n    await promisify(fs.close)(fd)\n    fd = null\n\n    if (options.chown) {\n      await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid).catch(err => {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      })\n    }\n\n    if (options.mode) {\n      await promisify(fs.chmod)(tmpfile, options.mode).catch(err => {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      })\n    }\n\n    await promisify(fs.rename)(tmpfile, truename)\n  } finally {\n    if (fd) {\n      await promisify(fs.close)(fd).catch(\n        /* istanbul ignore next */\n        () => {}\n      )\n    }\n    removeOnExitHandler()\n    await promisify(fs.unlink)(tmpfile).catch(() => {})\n    activeFiles[absoluteName].shift() // remove the element added by serializeSameFile\n    if (activeFiles[absoluteName].length > 0) {\n      activeFiles[absoluteName][0]() // start next job if one is pending\n    } else {\n      delete activeFiles[absoluteName]\n    }\n  }\n}\n\nasync function writeFile (filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options\n    options = {}\n  }\n\n  const promise = writeFileAsync(filename, data, options)\n  if (callback) {\n    try {\n      const result = await promise\n      return callback(result)\n    } catch (err) {\n      return callback(err)\n    }\n  }\n\n  return promise\n}\n\nfunction writeFileSync (filename, data, options) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  } else if (!options) {\n    options = {}\n  }\n  try {\n    filename = fs.realpathSync(filename)\n  } catch (ex) {\n    // it's ok, it'll happen on a not yet existing file\n  }\n  const tmpfile = getTmpname(filename)\n\n  if (!options.mode || !options.chown) {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    try {\n      const stats = fs.statSync(filename)\n      options = Object.assign({}, options)\n      if (!options.mode) {\n        options.mode = stats.mode\n      }\n      if (!options.chown && process.getuid) {\n        options.chown = { uid: stats.uid, gid: stats.gid }\n      }\n    } catch (ex) {\n      // ignore stat errors\n    }\n  }\n\n  let fd\n  const cleanup = cleanupOnExit(tmpfile)\n  const removeOnExitHandler = onExit(cleanup)\n\n  let threw = true\n  try {\n    fd = fs.openSync(tmpfile, 'w', options.mode || 0o666)\n    if (options.tmpfileCreated) {\n      options.tmpfileCreated(tmpfile)\n    }\n    if (ArrayBuffer.isView(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n    if (options.fsync !== false) {\n      fs.fsyncSync(fd)\n    }\n\n    fs.closeSync(fd)\n    fd = null\n\n    if (options.chown) {\n      try {\n        fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)\n      } catch (err) {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      }\n    }\n\n    if (options.mode) {\n      try {\n        fs.chmodSync(tmpfile, options.mode)\n      } catch (err) {\n        if (!isChownErrOk(err)) {\n          throw err\n        }\n      }\n    }\n\n    fs.renameSync(tmpfile, filename)\n    threw = false\n  } finally {\n    if (fd) {\n      try {\n        fs.closeSync(fd)\n      } catch (ex) {\n        // ignore close errors at this stage, error may have closed fd already.\n      }\n    }\n    removeOnExitHandler()\n    if (threw) {\n      cleanup()\n    }\n  }\n}\n","module.exports = stringify\nstringify.default = stringify\nstringify.stable = deterministicStringify\nstringify.stableStringify = deterministicStringify\n\nvar LIMIT_REPLACE_NODE = '[...]'\nvar CIRCULAR_REPLACE_NODE = '[Circular]'\n\nvar arr = []\nvar replacerStack = []\n\nfunction defaultOptions () {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  }\n}\n\n// Regular stringify\nfunction stringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  decirc(obj, '', 0, [], undefined, 0, options)\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer)\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction setReplace (replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace })\n      arr.push([parent, k, val, propertyDescriptor])\n    } else {\n      replacerStack.push([val, k, replace])\n    }\n  } else {\n    parent[k] = replace\n    arr.push([parent, k, val])\n  }\n}\n\nfunction decirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      var keys = Object.keys(val)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        decirc(val[key], key, i, stack, val, depth, options)\n      }\n    }\n    stack.pop()\n  }\n}\n\n// Stable-stringify\nfunction compareFunction (a, b) {\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nfunction deterministicStringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer)\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return\n      }\n    } catch (_) {\n      return\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {}\n      var keys = Object.keys(val).sort(compareFunction)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        deterministicDecirc(val[key], key, i, stack, val, depth, options)\n        tmp[key] = val[key]\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val])\n        parent[k] = tmp\n      } else {\n        return tmp\n      }\n    }\n    stack.pop()\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues (replacer) {\n  replacer =\n    typeof replacer !== 'undefined'\n      ? replacer\n      : function (k, v) {\n        return v\n      }\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i]\n        if (part[1] === key && part[0] === val) {\n          val = part[2]\n          replacerStack.splice(i, 1)\n          break\n        }\n      }\n    }\n    return replacer.call(this, key, val)\n  }\n}\n","'use strict';\n\n/*global window, global*/\n\nvar root = typeof window !== 'undefined' ?\n    window : typeof global !== 'undefined' ?\n    global : {};\n\nmodule.exports = Individual;\n\nfunction Individual(key, value) {\n    if (key in root) {\n        return root[key];\n    }\n\n    root[key] = value;\n\n    return value;\n}\n","// consider this a warning about getting obsessive about optimization\n\nconst utilformat = require('util').format\n\nfunction format (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {\n  if (a16 !== undefined) {\n    return utilformat(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16)\n  }\n  if (a15 !== undefined) {\n    return utilformat(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)\n  }\n  if (a14 !== undefined) {\n    return utilformat(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)\n  }\n  if (a13 !== undefined) {\n    return utilformat(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)\n  }\n  if (a12 !== undefined) {\n    return utilformat(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)\n  }\n  if (a11 !== undefined) {\n    return utilformat(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)\n  }\n  if (a10 !== undefined) {\n    return utilformat(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)\n  }\n  if (a9 !== undefined) {\n    return utilformat(a1, a2, a3, a4, a5, a6, a7, a8, a9)\n  }\n  if (a8 !== undefined) {\n    return utilformat(a1, a2, a3, a4, a5, a6, a7, a8)\n  }\n  if (a7 !== undefined) {\n    return utilformat(a1, a2, a3, a4, a5, a6, a7)\n  }\n  if (a6 !== undefined) {\n    return utilformat(a1, a2, a3, a4, a5, a6)\n  }\n  if (a5 !== undefined) {\n    return utilformat(a1, a2, a3, a4, a5)\n  }\n  if (a4 !== undefined) {\n    return utilformat(a1, a2, a3, a4)\n  }\n  if (a3 !== undefined) {\n    return utilformat(a1, a2, a3)\n  }\n  if (a2 !== undefined) {\n    return utilformat(a1, a2)\n  }\n  return a1\n}\n\nmodule.exports = format\n","'use strict'\n\nconst _stringify = require('fast-safe-stringify')\nconst individual = require('individual')('$$bole', { fastTime: false }) // singleton\nconst format = require('./format')\nconst levels = 'debug info warn error'.split(' ')\nconst os = require('os')\nconst pid = process.pid\nlet hasObjMode = false\nconst scache = []\n\n// Ref: https://github.com/rvagg/bole/issues/20\nlet hostname\ntry {\n  hostname = os.hostname()\n} catch (e) {\n  hostname = os.version().indexOf('Windows 7 ') === 0 ? 'windows7' : 'hostname-unknown'\n}\nconst hostnameSt = _stringify(hostname)\n\nfor (const level of levels) {\n  // prepare a common part of the stringified output\n  scache[level] = ',\"hostname\":' + hostnameSt + ',\"pid\":' + pid + ',\"level\":\"' + level\n  Number(scache[level]) // convert internal representation to plain string\n\n  if (!Array.isArray(individual[level])) {\n    individual[level] = []\n  }\n}\n\nfunction stackToString (e) {\n  let s = e.stack\n  let ce\n\n  if (typeof e.cause === 'function' && (ce = e.cause())) {\n    s += '\\nCaused by: ' + stackToString(ce)\n  }\n\n  return s\n}\n\nfunction errorToOut (err, out) {\n  out.err = {\n    name: err.name,\n    message: err.message,\n    code: err.code, // perhaps\n    stack: stackToString(err)\n  }\n}\n\nfunction requestToOut (req, out) {\n  out.req = {\n    method: req.method,\n    url: req.url,\n    headers: req.headers,\n    remoteAddress: req.connection.remoteAddress,\n    remotePort: req.connection.remotePort\n  }\n}\n\nfunction objectToOut (obj, out) {\n  for (const k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && obj[k] !== undefined) {\n      out[k] = obj[k]\n    }\n  }\n}\n\nfunction objectMode (stream) {\n  return stream._writableState && stream._writableState.objectMode === true\n}\n\nfunction stringify (level, name, message, obj) {\n  let s = '{\"time\":' +\n        (individual.fastTime ? Date.now() : ('\"' + new Date().toISOString() + '\"')) +\n        scache[level] +\n        '\",\"name\":' +\n        name +\n        (message !== undefined ? (',\"message\":' + _stringify(message)) : '')\n\n  for (const k in obj) {\n    s += ',' + _stringify(k) + ':' + _stringify(obj[k])\n  }\n\n  s += '}'\n\n  Number(s) // convert internal representation to plain string\n\n  return s\n}\n\nfunction extend (level, name, message, obj) {\n  const newObj = {\n    time: individual.fastTime ? Date.now() : new Date().toISOString(),\n    hostname,\n    pid,\n    level,\n    name\n  }\n\n  if (message !== undefined) {\n    obj.message = message\n  }\n\n  for (const k in obj) {\n    newObj[k] = obj[k]\n  }\n\n  return newObj\n}\n\nfunction levelLogger (level, name) {\n  const outputs = individual[level]\n  const nameSt = _stringify(name)\n\n  return function namedLevelLogger (inp, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {\n    if (outputs.length === 0) {\n      return\n    }\n\n    const out = {}\n    let objectOut\n    let i = 0\n    const l = outputs.length\n    let stringified\n    let message\n\n    if (typeof inp === 'string' || inp == null) {\n      if (!(message = format(inp, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16))) {\n        message = undefined\n      }\n    } else {\n      if (inp instanceof Error) {\n        if (typeof a2 === 'object') {\n          objectToOut(a2, out)\n          errorToOut(inp, out)\n          if (!(message = format(a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16))) {\n            message = undefined\n          }\n        } else {\n          errorToOut(inp, out)\n          if (!(message = format(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16))) {\n            message = undefined\n          }\n        }\n      } else {\n        if (!(message = format(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16))) {\n          message = undefined\n        }\n      }\n      if (typeof inp === 'boolean') { message = String(inp) } else if (typeof inp === 'object' && !(inp instanceof Error)) {\n        if (inp.method && inp.url && inp.headers && inp.socket) { requestToOut(inp, out) } else { objectToOut(inp, out) }\n      }\n    }\n\n    if (l === 1 && !hasObjMode) { // fast, standard case\n      outputs[0].write(Buffer.from(stringify(level, nameSt, message, out) + '\\n'))\n      return\n    }\n\n    for (; i < l; i++) {\n      if (objectMode(outputs[i])) {\n        if (objectOut === undefined) { // lazy object completion\n          objectOut = extend(level, name, message, out)\n        }\n        outputs[i].write(objectOut)\n      } else {\n        if (stringified === undefined) { // lazy stringify\n          stringified = Buffer.from(stringify(level, nameSt, message, out) + '\\n')\n        }\n        outputs[i].write(stringified)\n      }\n    }\n  }\n}\n\nfunction bole (name) {\n  function boleLogger (subname) {\n    return bole(name + ':' + subname)\n  }\n\n  function makeLogger (p, level) {\n    p[level] = levelLogger(level, name)\n    return p\n  }\n\n  return levels.reduce(makeLogger, boleLogger)\n}\n\nbole.output = function output (opt) {\n  let b = false\n\n  if (Array.isArray(opt)) {\n    opt.forEach(bole.output)\n    return bole\n  }\n\n  if (typeof opt.level !== 'string') {\n    throw new TypeError('Must provide a \"level\" option')\n  }\n\n  for (const level of levels) {\n    if (!b && level === opt.level) {\n      b = true\n    }\n\n    if (b) {\n      if (opt.stream && objectMode(opt.stream)) {\n        hasObjMode = true\n      }\n      individual[level].push(opt.stream)\n    }\n  }\n\n  return bole\n}\n\nbole.reset = function reset () {\n  for (const level of levels) {\n    individual[level].splice(0, individual[level].length)\n  }\n  individual.fastTime = false\n  return bole\n}\n\nbole.setFastTime = function setFastTime (b) {\n  if (!arguments.length) {\n    individual.fastTime = true\n  } else {\n    individual.fastTime = b\n  }\n\n  return bole\n}\n\nmodule.exports = bole\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.logger = void 0;\nexports.globalWarn = globalWarn;\nexports.globalInfo = globalInfo;\nconst bole_1 = __importDefault(require(\"bole\"));\nbole_1.default.setFastTime();\nexports.logger = (0, bole_1.default)('pnpm');\nconst globalLogger = (0, bole_1.default)('pnpm:global');\nfunction globalWarn(message) {\n    globalLogger.warn(message);\n}\nfunction globalInfo(message) {\n    globalLogger.info(message);\n}\n//# sourceMappingURL=logger.js.map","module.exports = require('stream');\n","'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = require('buffer'),\n  Buffer = _require.Buffer;\nvar _require2 = require('util'),\n  inspect = _require2.inspect;\nvar custom = inspect && inspect.custom || 'inspect';\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\nmodule.exports = /*#__PURE__*/function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n      while (p = p.next) ret += s + p.data;\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes or characters from the buffered data.\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    }\n\n    // Consumes a specified amount of characters from the buffered data.\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes from the buffered data.\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Make sure the linked list only shows the minimal necessary information.\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n  return BufferList;\n}();","'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","'use strict';\n\nconst codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error\n  }\n\n  function getMessage (arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message\n    } else {\n      return message(arg1, arg2, arg3)\n    }\n  }\n\n  class NodeError extends Base {\n    constructor (arg1, arg2, arg3) {\n      super(getMessage(arg1, arg2, arg3));\n    }\n  }\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n\n  codes[code] = NodeError;\n}\n\n// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    const len = expected.length;\n    expected = expected.map((i) => String(i));\n    if (len > 2) {\n      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +\n             expected[len - 1];\n    } else if (len === 2) {\n      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n    } else {\n      return `of ${thing} ${expected[0]}`;\n    }\n  } else {\n    return `of ${thing} ${String(expected)}`;\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\nfunction startsWith(str, search, pos) {\n\treturn str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nfunction endsWith(str, search, this_len) {\n\tif (this_len === undefined || this_len > str.length) {\n\t\tthis_len = str.length;\n\t}\n\treturn str.substring(this_len - search.length, this_len) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"'\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  let determiner;\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  let msg;\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n  } else {\n    const type = includes(name, '.') ? 'property' : 'argument';\n    msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n  }\n\n  msg += `. Received type ${typeof actual}`;\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented'\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\n\nmodule.exports.codes = codes;\n","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n    return Math.floor(hwm);\n  }\n\n  // Default value\n  return state.objectMode ? 16 : 16 * 1024;\n}\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","try {\n  var util = require('util');\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = require('./inherits_browser.js');\n}\n","\n/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nmodule.exports = require('util').deprecate;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nrequire('inherits')(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\nrequire('inherits')(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","'use strict'\n\n// Use non-'node:' prefixed require to avoid Webpack errors.\n// eslint-disable-next-line n/prefer-node-protocol\nconst { Buffer: UnsafeBuffer } = require('buffer')\n\nconst SafeBuffer = Object.defineProperties(function SafeBuffer(\n  arg,\n  encodingOrOffset,\n  length\n) {\n  return UnsafeBuffer.from(arg, encodingOrOffset, length)\n}, Object.getOwnPropertyDescriptors(UnsafeBuffer))\n\nmodule.exports = {\n  Buffer: SafeBuffer\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    callback.apply(this, args);\n  };\n}\nfunction noop() {}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n  var writableEnded = stream._writableState && stream._writableState.finished;\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n  var onclose = function onclose() {\n    var err;\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\nmodule.exports = eos;","'use strict';\n\nvar _Object$setPrototypeO;\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar finished = require('./end-of-stream');\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    var data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n  next: function next() {\n    var _this = this;\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    var lastPromise = this[kLastPromise];\n    var promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    var resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;","'use strict';\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar ERR_INVALID_ARG_TYPE = require('../../../errors').codes.ERR_INVALID_ARG_TYPE;\nfunction from(Readable, iterable, opts) {\n  var iterator;\n  if (iterable && typeof iterable.next === 'function') {\n    iterator = iterable;\n  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);\n  var readable = new Readable(_objectSpread({\n    objectMode: true\n  }, opts));\n  // Reading boolean to protect against _read\n  // being called before last iteration completion.\n  var reading = false;\n  readable._read = function () {\n    if (!reading) {\n      reading = true;\n      next();\n    }\n  };\n  function next() {\n    return _next2.apply(this, arguments);\n  }\n  function _next2() {\n    _next2 = _asyncToGenerator(function* () {\n      try {\n        var _yield$iterator$next = yield iterator.next(),\n          value = _yield$iterator$next.value,\n          done = _yield$iterator$next.done;\n        if (done) {\n          readable.push(null);\n        } else if (readable.push(yield value)) {\n          next();\n        } else {\n          reading = false;\n        }\n      } catch (err) {\n        readable.destroy(err);\n      }\n    });\n    return _next2.apply(this, arguments);\n  }\n  return readable;\n}\nmodule.exports = from;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/buffer_list');\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\nrequire('inherits')(Readable, Stream);\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  var p = this._readableState.buffer.head;\n  var content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nvar MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\nvar _require$codes = require('../errors').codes,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nvar Duplex = require('./_stream_duplex');\nrequire('inherits')(Transform, Duplex);\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\nfunction prefinish() {\n  var _this = this;\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\nvar Transform = require('./_stream_transform');\nrequire('inherits')(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar eos;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\nvar _require$codes = require('../../../errors').codes,\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true;\n\n    // request.destroy just do .end - .abort is what we want\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\nfunction call(fn) {\n  fn();\n}\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\nmodule.exports = pipeline;","var Stream = require('stream');\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream.Readable;\n  Object.assign(module.exports, Stream);\n  module.exports.Stream = Stream;\n} else {\n  exports = module.exports = require('./lib/_stream_readable.js');\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = require('./lib/_stream_writable.js');\n  exports.Duplex = require('./lib/_stream_duplex.js');\n  exports.Transform = require('./lib/_stream_transform.js');\n  exports.PassThrough = require('./lib/_stream_passthrough.js');\n  exports.finished = require('./lib/internal/streams/end-of-stream.js');\n  exports.pipeline = require('./lib/internal/streams/pipeline.js');\n}\n","const { Transform } = require('readable-stream')\n\nfunction inherits (fn, sup) {\n  fn.super_ = sup\n  fn.prototype = Object.create(sup.prototype, {\n    constructor: { value: fn, enumerable: false, writable: true, configurable: true }\n  })\n}\n\n// create a new export function, used by both the main export and\n// the .ctor export, contains common logic for dealing with arguments\nfunction through2 (construct) {\n  return (options, transform, flush) => {\n    if (typeof options === 'function') {\n      flush = transform\n      transform = options\n      options = {}\n    }\n\n    if (typeof transform !== 'function') {\n      // noop\n      transform = (chunk, enc, cb) => cb(null, chunk)\n    }\n\n    if (typeof flush !== 'function') {\n      flush = null\n    }\n\n    return construct(options, transform, flush)\n  }\n}\n\n// main export, just make me a transform stream!\nconst make = through2((options, transform, flush) => {\n  const t2 = new Transform(options)\n\n  t2._transform = transform\n\n  if (flush) {\n    t2._flush = flush\n  }\n\n  return t2\n})\n\n// make me a reusable prototype that I can `new`, or implicitly `new`\n// with a constructor call\nconst ctor = through2((options, transform, flush) => {\n  function Through2 (override) {\n    if (!(this instanceof Through2)) {\n      return new Through2(override)\n    }\n\n    this.options = Object.assign({}, options, override)\n\n    Transform.call(this, this.options)\n\n    this._transform = transform\n    if (flush) {\n      this._flush = flush\n    }\n  }\n\n  inherits(Through2, Transform)\n\n  return Through2\n})\n\nconst obj = through2(function (options, transform, flush) {\n  const t2 = new Transform(Object.assign({ objectMode: true, highWaterMark: 16 }, options))\n\n  t2._transform = transform\n\n  if (flush) {\n    t2._flush = flush\n  }\n\n  return t2\n})\n\nmodule.exports = make\nmodule.exports.ctor = ctor\nmodule.exports.obj = obj\n","module.exports = require('stream');\n","'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = require('buffer'),\n  Buffer = _require.Buffer;\nvar _require2 = require('util'),\n  inspect = _require2.inspect;\nvar custom = inspect && inspect.custom || 'inspect';\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\nmodule.exports = /*#__PURE__*/function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n      while (p = p.next) ret += s + p.data;\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes or characters from the buffered data.\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    }\n\n    // Consumes a specified amount of characters from the buffered data.\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes from the buffered data.\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Make sure the linked list only shows the minimal necessary information.\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n  return BufferList;\n}();","'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","'use strict';\n\nconst codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error\n  }\n\n  function getMessage (arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message\n    } else {\n      return message(arg1, arg2, arg3)\n    }\n  }\n\n  class NodeError extends Base {\n    constructor (arg1, arg2, arg3) {\n      super(getMessage(arg1, arg2, arg3));\n    }\n  }\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n\n  codes[code] = NodeError;\n}\n\n// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    const len = expected.length;\n    expected = expected.map((i) => String(i));\n    if (len > 2) {\n      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +\n             expected[len - 1];\n    } else if (len === 2) {\n      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n    } else {\n      return `of ${thing} ${expected[0]}`;\n    }\n  } else {\n    return `of ${thing} ${String(expected)}`;\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\nfunction startsWith(str, search, pos) {\n\treturn str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nfunction endsWith(str, search, this_len) {\n\tif (this_len === undefined || this_len > str.length) {\n\t\tthis_len = str.length;\n\t}\n\treturn str.substring(this_len - search.length, this_len) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"'\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  let determiner;\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  let msg;\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n  } else {\n    const type = includes(name, '.') ? 'property' : 'argument';\n    msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n  }\n\n  msg += `. Received type ${typeof actual}`;\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented'\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\n\nmodule.exports.codes = codes;\n","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n    return Math.floor(hwm);\n  }\n\n  // Default value\n  return state.objectMode ? 16 : 16 * 1024;\n}\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nrequire('inherits')(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\nrequire('inherits')(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    callback.apply(this, args);\n  };\n}\nfunction noop() {}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n  var writableEnded = stream._writableState && stream._writableState.finished;\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n  var onclose = function onclose() {\n    var err;\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\nmodule.exports = eos;","'use strict';\n\nvar _Object$setPrototypeO;\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar finished = require('./end-of-stream');\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    var data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n  next: function next() {\n    var _this = this;\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    var lastPromise = this[kLastPromise];\n    var promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    var resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;","'use strict';\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar ERR_INVALID_ARG_TYPE = require('../../../errors').codes.ERR_INVALID_ARG_TYPE;\nfunction from(Readable, iterable, opts) {\n  var iterator;\n  if (iterable && typeof iterable.next === 'function') {\n    iterator = iterable;\n  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);\n  var readable = new Readable(_objectSpread({\n    objectMode: true\n  }, opts));\n  // Reading boolean to protect against _read\n  // being called before last iteration completion.\n  var reading = false;\n  readable._read = function () {\n    if (!reading) {\n      reading = true;\n      next();\n    }\n  };\n  function next() {\n    return _next2.apply(this, arguments);\n  }\n  function _next2() {\n    _next2 = _asyncToGenerator(function* () {\n      try {\n        var _yield$iterator$next = yield iterator.next(),\n          value = _yield$iterator$next.value,\n          done = _yield$iterator$next.done;\n        if (done) {\n          readable.push(null);\n        } else if (readable.push(yield value)) {\n          next();\n        } else {\n          reading = false;\n        }\n      } catch (err) {\n        readable.destroy(err);\n      }\n    });\n    return _next2.apply(this, arguments);\n  }\n  return readable;\n}\nmodule.exports = from;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/buffer_list');\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\nrequire('inherits')(Readable, Stream);\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  var p = this._readableState.buffer.head;\n  var content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nvar MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\nvar _require$codes = require('../errors').codes,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nvar Duplex = require('./_stream_duplex');\nrequire('inherits')(Transform, Duplex);\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\nfunction prefinish() {\n  var _this = this;\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\nvar Transform = require('./_stream_transform');\nrequire('inherits')(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar eos;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\nvar _require$codes = require('../../../errors').codes,\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true;\n\n    // request.destroy just do .end - .abort is what we want\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\nfunction call(fn) {\n  fn();\n}\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\nmodule.exports = pipeline;","var Stream = require('stream');\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream.Readable;\n  Object.assign(module.exports, Stream);\n  module.exports.Stream = Stream;\n} else {\n  exports = module.exports = require('./lib/_stream_readable.js');\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = require('./lib/_stream_writable.js');\n  exports.Duplex = require('./lib/_stream_duplex.js');\n  exports.Transform = require('./lib/_stream_transform.js');\n  exports.PassThrough = require('./lib/_stream_passthrough.js');\n  exports.finished = require('./lib/internal/streams/end-of-stream.js');\n  exports.pipeline = require('./lib/internal/streams/pipeline.js');\n}\n","/*\nCopyright (c) 2014-2018, Matteo Collina <hello@matteocollina.com>\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR\nIN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\n'use strict'\n\nconst { Transform } = require('readable-stream')\nconst { StringDecoder } = require('string_decoder')\nconst kLast = Symbol('last')\nconst kDecoder = Symbol('decoder')\n\nfunction transform (chunk, enc, cb) {\n  var list\n  if (this.overflow) { // Line buffer is full. Skip to start of next line.\n    var buf = this[kDecoder].write(chunk)\n    list = buf.split(this.matcher)\n\n    if (list.length === 1) return cb() // Line ending not found. Discard entire chunk.\n\n    // Line ending found. Discard trailing fragment of previous line and reset overflow state.\n    list.shift()\n    this.overflow = false\n  } else {\n    this[kLast] += this[kDecoder].write(chunk)\n    list = this[kLast].split(this.matcher)\n  }\n\n  this[kLast] = list.pop()\n\n  for (var i = 0; i < list.length; i++) {\n    try {\n      push(this, this.mapper(list[i]))\n    } catch (error) {\n      return cb(error)\n    }\n  }\n\n  this.overflow = this[kLast].length > this.maxLength\n  if (this.overflow && !this.skipOverflow) return cb(new Error('maximum buffer reached'))\n\n  cb()\n}\n\nfunction flush (cb) {\n  // forward any gibberish left in there\n  this[kLast] += this[kDecoder].end()\n\n  if (this[kLast]) {\n    try {\n      push(this, this.mapper(this[kLast]))\n    } catch (error) {\n      return cb(error)\n    }\n  }\n\n  cb()\n}\n\nfunction push (self, val) {\n  if (val !== undefined) {\n    self.push(val)\n  }\n}\n\nfunction noop (incoming) {\n  return incoming\n}\n\nfunction split (matcher, mapper, options) {\n  // Set defaults for any arguments not supplied.\n  matcher = matcher || /\\r?\\n/\n  mapper = mapper || noop\n  options = options || {}\n\n  // Test arguments explicitly.\n  switch (arguments.length) {\n    case 1:\n      // If mapper is only argument.\n      if (typeof matcher === 'function') {\n        mapper = matcher\n        matcher = /\\r?\\n/\n      // If options is only argument.\n      } else if (typeof matcher === 'object' && !(matcher instanceof RegExp)) {\n        options = matcher\n        matcher = /\\r?\\n/\n      }\n      break\n\n    case 2:\n      // If mapper and options are arguments.\n      if (typeof matcher === 'function') {\n        options = mapper\n        mapper = matcher\n        matcher = /\\r?\\n/\n      // If matcher and options are arguments.\n      } else if (typeof mapper === 'object') {\n        options = mapper\n        mapper = noop\n      }\n  }\n\n  options = Object.assign({}, options)\n  options.transform = transform\n  options.flush = flush\n  options.readableObjectMode = true\n\n  const stream = new Transform(options)\n\n  stream[kLast] = ''\n  stream[kDecoder] = new StringDecoder('utf8')\n  stream.matcher = matcher\n  stream.mapper = mapper\n  stream.maxLength = options.maxLength\n  stream.skipOverflow = options.skipOverflow\n  stream.overflow = false\n\n  return stream\n}\n\nmodule.exports = split\n","exports = module.exports = stringify\nexports.getSerialize = serializer\n\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\n}\n\nfunction serializer(replacer, cycleReplacer) {\n  var stack = [], keys = []\n\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\n    if (stack[0] === value) return \"[Circular ~]\"\n    return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\"\n  }\n\n  return function(key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this)\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\n    }\n    else stack.push(value)\n\n    return replacer == null ? value : replacer.call(this, key, value)\n  }\n}\n","const through = require('through2')\nconst split = require('split2')\nconst { EOL } = require('os')\nconst stringify = require('json-stringify-safe')\n\nmodule.exports.stringify = (opts) =>\n  through.obj(opts, (obj, _, cb) => {\n    cb(null, stringify(obj) + EOL)\n  })\n\nmodule.exports.parse = (opts) => {\n  opts = opts || {}\n  opts.strict = opts.strict !== false\n\n  function parseRow (row) {\n    try {\n      if (row) return JSON.parse(row)\n    } catch (e) {\n      if (opts.strict) {\n        this.emit('error', new Error('Could not parse row ' + row.slice(0, 50) + '...'))\n      }\n    }\n  }\n\n  return split(parseRow, opts)\n}","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.streamParser = void 0;\nexports.createStreamParser = createStreamParser;\nconst bole_1 = __importDefault(require(\"bole\"));\nconst ndjson_1 = __importDefault(require(\"ndjson\"));\nexports.streamParser = createStreamParser();\nfunction createStreamParser() {\n    const sp = ndjson_1.default.parse();\n    bole_1.default.output([\n        {\n            level: 'debug', stream: sp,\n        },\n    ]);\n    return sp;\n}\n//# sourceMappingURL=streamParser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.writeToConsole = exports.streamParser = exports.createStreamParser = exports.globalWarn = exports.globalInfo = exports.logger = void 0;\nvar logger_1 = require(\"./logger\");\nObject.defineProperty(exports, \"logger\", { enumerable: true, get: function () { return logger_1.logger; } });\nObject.defineProperty(exports, \"globalInfo\", { enumerable: true, get: function () { return logger_1.globalInfo; } });\nObject.defineProperty(exports, \"globalWarn\", { enumerable: true, get: function () { return logger_1.globalWarn; } });\nvar streamParser_1 = require(\"./streamParser\");\nObject.defineProperty(exports, \"createStreamParser\", { enumerable: true, get: function () { return streamParser_1.createStreamParser; } });\nObject.defineProperty(exports, \"streamParser\", { enumerable: true, get: function () { return streamParser_1.streamParser; } });\nvar writeToConsole_1 = require(\"./writeToConsole\");\nObject.defineProperty(exports, \"writeToConsole\", { enumerable: true, get: function () { return writeToConsole_1.writeToConsole; } });\n//# sourceMappingURL=index.js.map","'use strict';\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n","'use strict';\nconst isPlainObject = require('is-plain-obj');\n\nmodule.exports = (object, options = {}) => {\n\tif (!isPlainObject(object) && !Array.isArray(object)) {\n\t\tthrow new TypeError('Expected a plain object or array');\n\t}\n\n\tconst {deep} = options;\n\tconst seenInput = [];\n\tconst seenOutput = [];\n\n\tconst deepSortArray = array => {\n\t\tconst seenIndex = seenInput.indexOf(array);\n\n\t\tif (seenIndex !== -1) {\n\t\t\treturn seenOutput[seenIndex];\n\t\t}\n\n\t\tconst result = [];\n\t\tseenInput.push(array);\n\t\tseenOutput.push(result);\n\n\t\tresult.push(...array.map(item => {\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\treturn deepSortArray(item);\n\t\t\t}\n\n\t\t\tif (isPlainObject(item)) {\n\t\t\t\treturn sortKeys(item);\n\t\t\t}\n\n\t\t\treturn item;\n\t\t}));\n\n\t\treturn result;\n\t};\n\n\tconst sortKeys = object => {\n\t\tconst seenIndex = seenInput.indexOf(object);\n\n\t\tif (seenIndex !== -1) {\n\t\t\treturn seenOutput[seenIndex];\n\t\t}\n\n\t\tconst result = {};\n\t\tconst keys = Object.keys(object).sort(options.compare);\n\n\t\tseenInput.push(object);\n\t\tseenOutput.push(result);\n\n\t\tfor (const key of keys) {\n\t\t\tconst value = object[key];\n\t\t\tlet newValue;\n\n\t\t\tif (deep && Array.isArray(value)) {\n\t\t\t\tnewValue = deepSortArray(value);\n\t\t\t} else {\n\t\t\t\tnewValue = deep && isPlainObject(value) ? sortKeys(value) : value;\n\t\t\t}\n\n\t\t\tObject.defineProperty(result, key, {\n\t\t\t\t...Object.getOwnPropertyDescriptor(object, key),\n\t\t\t\tvalue: newValue\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tif (Array.isArray(object)) {\n\t\treturn deep ? deepSortArray(object) : object.slice();\n\t}\n\n\treturn sortKeys(object);\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sortDirectKeys = sortDirectKeys;\nexports.sortDeepKeys = sortDeepKeys;\nexports.sortKeysByPriority = sortKeysByPriority;\nconst util_lex_comparator_1 = require(\"@pnpm/util.lex-comparator\");\nconst sort_keys_1 = __importDefault(require(\"sort-keys\"));\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction sortDirectKeys(obj) {\n    return (0, sort_keys_1.default)(obj, {\n        compare: util_lex_comparator_1.lexCompare,\n        deep: false,\n    });\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction sortDeepKeys(obj) {\n    return (0, sort_keys_1.default)(obj, {\n        compare: util_lex_comparator_1.lexCompare,\n        deep: true,\n    });\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction sortKeysByPriority(opts, obj) {\n    const compare = compareWithPriority.bind(null, opts.priority);\n    return (0, sort_keys_1.default)(obj, {\n        compare,\n        deep: opts.deep,\n    });\n}\nfunction compareWithPriority(priority, left, right) {\n    const leftPriority = priority[left];\n    const rightPriority = priority[right];\n    if (leftPriority != null && rightPriority != null)\n        return leftPriority - rightPriority;\n    if (leftPriority != null)\n        return -1;\n    if (rightPriority != null)\n        return 1;\n    return (0, util_lex_comparator_1.lexCompare)(left, right);\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sortLockfileKeys = sortLockfileKeys;\nconst object_key_sorting_1 = require(\"@pnpm/object.key-sorting\");\nconst ORDERED_KEYS = {\n    resolution: 1,\n    id: 2,\n    name: 3,\n    version: 4,\n    engines: 5,\n    cpu: 6,\n    os: 7,\n    libc: 8,\n    deprecated: 9,\n    hasBin: 10,\n    prepare: 11,\n    requiresBuild: 12,\n    bundleDependencies: 13,\n    peerDependencies: 14,\n    peerDependenciesMeta: 15,\n    dependencies: 16,\n    optionalDependencies: 17,\n    transitivePeerDependencies: 18,\n    dev: 19,\n    optional: 20,\n};\nconst ROOT_KEYS = [\n    'lockfileVersion',\n    'settings',\n    'catalogs',\n    'overrides',\n    'packageExtensionsChecksum',\n    'pnpmfileChecksum',\n    'patchedDependencies',\n    'importers',\n    'packages',\n];\nconst ROOT_KEYS_ORDER = Object.fromEntries(ROOT_KEYS.map((key, index) => [key, index]));\nfunction sortLockfileKeys(lockfile) {\n    if (lockfile.importers != null) {\n        lockfile.importers = (0, object_key_sorting_1.sortDirectKeys)(lockfile.importers);\n        for (const [importerId, importer] of Object.entries(lockfile.importers)) {\n            lockfile.importers[importerId] = (0, object_key_sorting_1.sortKeysByPriority)({\n                priority: ROOT_KEYS_ORDER,\n                deep: true,\n            }, importer);\n        }\n    }\n    if (lockfile.packages != null) {\n        lockfile.packages = (0, object_key_sorting_1.sortDirectKeys)(lockfile.packages);\n        for (const [pkgId, pkg] of Object.entries(lockfile.packages)) {\n            lockfile.packages[pkgId] = (0, object_key_sorting_1.sortKeysByPriority)({\n                priority: ORDERED_KEYS,\n                deep: true,\n            }, pkg);\n        }\n    }\n    if (lockfile.snapshots != null) {\n        lockfile.snapshots = (0, object_key_sorting_1.sortDirectKeys)(lockfile.snapshots);\n        for (const [pkgId, pkg] of Object.entries(lockfile.snapshots)) {\n            lockfile.snapshots[pkgId] = (0, object_key_sorting_1.sortKeysByPriority)({\n                priority: ORDERED_KEYS,\n                deep: true,\n            }, pkg);\n        }\n    }\n    if (lockfile.catalogs != null) {\n        lockfile.catalogs = (0, object_key_sorting_1.sortDirectKeys)(lockfile.catalogs);\n        for (const [catalogName, catalog] of Object.entries(lockfile.catalogs)) {\n            lockfile.catalogs[catalogName] = (0, object_key_sorting_1.sortDeepKeys)(catalog);\n        }\n    }\n    for (const key of ['time', 'patchedDependencies']) {\n        if (!lockfile[key])\n            continue;\n        lockfile[key] = (0, object_key_sorting_1.sortDirectKeys)(lockfile[key]); // eslint-disable-line @typescript-eslint/no-explicit-any\n    }\n    return (0, object_key_sorting_1.sortKeysByPriority)({ priority: ROOT_KEYS_ORDER }, lockfile);\n}\n//# sourceMappingURL=sortLockfileKeys.js.map","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n","var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n","const isWindows = process.platform === 'win32' ||\r\n    process.env.OSTYPE === 'cygwin' ||\r\n    process.env.OSTYPE === 'msys'\r\n\r\nconst path = require('path')\r\nconst COLON = isWindows ? ';' : ':'\r\nconst isexe = require('isexe')\r\n\r\nconst getNotFoundError = (cmd) =>\r\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\r\n\r\nconst getPathInfo = (cmd, opt) => {\r\n  const colon = opt.colon || COLON\r\n\r\n  // If it has a slash, then we don't bother searching the pathenv.\r\n  // just check the file itself, and that's it.\r\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\r\n    : (opt.path || process.env.PATH ||\r\n          /* istanbul ignore next: very unusual */ '').split(colon)\r\n  const pathExtExe = isWindows\r\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\r\n    : ''\r\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\r\n\r\n  if (isWindows) {\r\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\r\n      pathExt.unshift('')\r\n  }\r\n\r\n  return {\r\n    pathEnv,\r\n    pathExt,\r\n    pathExtExe,\r\n  }\r\n}\r\n\r\nconst which = (cmd, opt, cb) => {\r\n  if (typeof opt === 'function') {\r\n    cb = opt\r\n    opt = {}\r\n  }\r\n  if (!opt)\r\n    opt = {}\r\n\r\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\r\n  const found = []\r\n\r\n  const step = i => new Promise((resolve, reject) => {\r\n    if (i === pathEnv.length)\r\n      return opt.all && found.length ? resolve(found)\r\n        : reject(getNotFoundError(cmd))\r\n\r\n    const ppRaw = pathEnv[i]\r\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\r\n\r\n    const pCmd = path.join(pathPart, cmd)\r\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\r\n      : pCmd\r\n\r\n    resolve(subStep(p, i, 0))\r\n  })\r\n\r\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\r\n    if (ii === pathExt.length)\r\n      return resolve(step(i + 1))\r\n    const ext = pathExt[ii]\r\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\r\n      if (!er && is) {\r\n        if (opt.all)\r\n          found.push(p + ext)\r\n        else\r\n          return resolve(p + ext)\r\n      }\r\n      return resolve(subStep(p, i, ii + 1))\r\n    })\r\n  })\r\n\r\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\r\n}\r\n\r\nconst whichSync = (cmd, opt) => {\r\n  opt = opt || {}\r\n\r\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\r\n  const found = []\r\n\r\n  for (let i = 0; i < pathEnv.length; i ++) {\r\n    const ppRaw = pathEnv[i]\r\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\r\n\r\n    const pCmd = path.join(pathPart, cmd)\r\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\r\n      : pCmd\r\n\r\n    for (let j = 0; j < pathExt.length; j ++) {\r\n      const cur = p + pathExt[j]\r\n      try {\r\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\r\n        if (is) {\r\n          if (opt.all)\r\n            found.push(cur)\r\n          else\r\n            return cur\r\n        }\r\n      } catch (ex) {}\r\n    }\r\n  }\r\n\r\n  if (opt.all && found.length)\r\n    return found\r\n\r\n  if (opt.nothrow)\r\n    return null\r\n\r\n  throw getNotFoundError(cmd)\r\n}\r\n\r\nmodule.exports = which\r\nwhich.sync = whichSync\r\n","const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = require('path')\nconst COLON = isWindows ? ';' : ':'\nconst isexe = require('isexe')\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n","'use strict';\n\nconst pathKey = (options = {}) => {\n\tconst environment = options.env || process.env;\n\tconst platform = options.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n};\n\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n","'use strict';\n\nconst path = require('path');\nconst which = require('which');\nconst getPathKey = require('path-key');\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({ env })],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        if (shouldSwitchCwd) {\n            process.chdir(cwd);\n        }\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n","'use strict';\n\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    return arg;\n}\n\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n\n    // Algorithm below is based on https://qntm.org/cmd\n    // It's slightly altered to disable JS backtracking to avoid hanging on specially crafted input\n    // Please see https://github.com/moxystudio/node-cross-spawn/pull/160 for more information\n\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(?=(\\\\+?)?)\\1\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(?=(\\\\+?)?)\\1$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) {\n        arg = arg.replace(metaCharsRegExp, '^$1');\n    }\n\n    return arg;\n}\n\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n","'use strict';\nmodule.exports = /^#!(.*)/;\n","'use strict';\nconst shebangRegex = require('shebang-regex');\n\nmodule.exports = (string = '') => {\n\tconst match = string.match(shebangRegex);\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tconst [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n\tconst binary = path.split('/').pop();\n\n\tif (binary === 'env') {\n\t\treturn argument;\n\t}\n\n\treturn argument ? `${binary} ${argument}` : binary;\n};\n","'use strict';\n\nconst fs = require('fs');\nconst shebangCommand = require('shebang-command');\n\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n\n    let fd;\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* Empty */ }\n\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\n\nmodule.exports = readShebang;\n","'use strict';\n\nconst path = require('path');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n","'use strict';\n\nconst isWin = process.platform === 'win32';\n\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args,\n    });\n}\n\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) {\n        return;\n    }\n\n    const originalEmit = cp.emit;\n\n    cp.emit = function (name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed);\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\n\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawn');\n    }\n\n    return null;\n}\n\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawnSync');\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError,\n};\n","'use strict';\n\nconst cp = require('child_process');\nconst parse = require('./lib/parse');\nconst enoent = require('./lib/enoent');\n\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n\n    return result;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\n\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n","'use strict';\n\nmodule.exports = input => {\n\tconst LF = typeof input === 'string' ? '\\n' : '\\n'.charCodeAt();\n\tconst CR = typeof input === 'string' ? '\\r' : '\\r'.charCodeAt();\n\n\tif (input[input.length - 1] === LF) {\n\t\tinput = input.slice(0, input.length - 1);\n\t}\n\n\tif (input[input.length - 1] === CR) {\n\t\tinput = input.slice(0, input.length - 1);\n\t}\n\n\treturn input;\n};\n","'use strict';\nconst path = require('path');\nconst pathKey = require('path-key');\n\nconst npmRunPath = options => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\tpath: process.env[pathKey()],\n\t\texecPath: process.execPath,\n\t\t...options\n\t};\n\n\tlet previous;\n\tlet cwdPath = path.resolve(options.cwd);\n\tconst result = [];\n\n\twhile (previous !== cwdPath) {\n\t\tresult.push(path.join(cwdPath, 'node_modules/.bin'));\n\t\tprevious = cwdPath;\n\t\tcwdPath = path.resolve(cwdPath, '..');\n\t}\n\n\t// Ensure the running `node` binary is used\n\tconst execPathDir = path.resolve(options.cwd, options.execPath, '..');\n\tresult.push(execPathDir);\n\n\treturn result.concat(options.path).join(path.delimiter);\n};\n\nmodule.exports = npmRunPath;\n// TODO: Remove this for the next major release\nmodule.exports.default = npmRunPath;\n\nmodule.exports.env = options => {\n\toptions = {\n\t\tenv: process.env,\n\t\t...options\n\t};\n\n\tconst env = {...options.env};\n\tconst path = pathKey({env});\n\n\toptions.path = env[path];\n\tenv[path] = module.exports(options);\n\n\treturn env;\n};\n","'use strict';\n\nconst mimicFn = (to, from) => {\n\tfor (const prop of Reflect.ownKeys(from)) {\n\t\tObject.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));\n\t}\n\n\treturn to;\n};\n\nmodule.exports = mimicFn;\n// TODO: Remove this for the next major release\nmodule.exports.default = mimicFn;\n","'use strict';\nconst mimicFn = require('mimic-fn');\n\nconst calledFunctions = new WeakMap();\n\nconst onetime = (function_, options = {}) => {\n\tif (typeof function_ !== 'function') {\n\t\tthrow new TypeError('Expected a function');\n\t}\n\n\tlet returnValue;\n\tlet callCount = 0;\n\tconst functionName = function_.displayName || function_.name || '<anonymous>';\n\n\tconst onetime = function (...arguments_) {\n\t\tcalledFunctions.set(onetime, ++callCount);\n\n\t\tif (callCount === 1) {\n\t\t\treturnValue = function_.apply(this, arguments_);\n\t\t\tfunction_ = null;\n\t\t} else if (options.throw === true) {\n\t\t\tthrow new Error(`Function \\`${functionName}\\` can only be called once`);\n\t\t}\n\n\t\treturn returnValue;\n\t};\n\n\tmimicFn(onetime, function_);\n\tcalledFunctions.set(onetime, callCount);\n\n\treturn onetime;\n};\n\nmodule.exports = onetime;\n// TODO: Remove this for the next major release\nmodule.exports.default = onetime;\n\nmodule.exports.callCount = function_ => {\n\tif (!calledFunctions.has(function_)) {\n\t\tthrow new Error(`The given function \\`${function_.name}\\` is not wrapped by the \\`onetime\\` package`);\n\t}\n\n\treturn calledFunctions.get(function_);\n};\n","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.SIGNALS=void 0;\n\nconst SIGNALS=[\n{\nname:\"SIGHUP\",\nnumber:1,\naction:\"terminate\",\ndescription:\"Terminal closed\",\nstandard:\"posix\"},\n\n{\nname:\"SIGINT\",\nnumber:2,\naction:\"terminate\",\ndescription:\"User interruption with CTRL-C\",\nstandard:\"ansi\"},\n\n{\nname:\"SIGQUIT\",\nnumber:3,\naction:\"core\",\ndescription:\"User interruption with CTRL-\\\\\",\nstandard:\"posix\"},\n\n{\nname:\"SIGILL\",\nnumber:4,\naction:\"core\",\ndescription:\"Invalid machine instruction\",\nstandard:\"ansi\"},\n\n{\nname:\"SIGTRAP\",\nnumber:5,\naction:\"core\",\ndescription:\"Debugger breakpoint\",\nstandard:\"posix\"},\n\n{\nname:\"SIGABRT\",\nnumber:6,\naction:\"core\",\ndescription:\"Aborted\",\nstandard:\"ansi\"},\n\n{\nname:\"SIGIOT\",\nnumber:6,\naction:\"core\",\ndescription:\"Aborted\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGBUS\",\nnumber:7,\naction:\"core\",\ndescription:\n\"Bus error due to misaligned, non-existing address or paging error\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGEMT\",\nnumber:7,\naction:\"terminate\",\ndescription:\"Command should be emulated but is not implemented\",\nstandard:\"other\"},\n\n{\nname:\"SIGFPE\",\nnumber:8,\naction:\"core\",\ndescription:\"Floating point arithmetic error\",\nstandard:\"ansi\"},\n\n{\nname:\"SIGKILL\",\nnumber:9,\naction:\"terminate\",\ndescription:\"Forced termination\",\nstandard:\"posix\",\nforced:true},\n\n{\nname:\"SIGUSR1\",\nnumber:10,\naction:\"terminate\",\ndescription:\"Application-specific signal\",\nstandard:\"posix\"},\n\n{\nname:\"SIGSEGV\",\nnumber:11,\naction:\"core\",\ndescription:\"Segmentation fault\",\nstandard:\"ansi\"},\n\n{\nname:\"SIGUSR2\",\nnumber:12,\naction:\"terminate\",\ndescription:\"Application-specific signal\",\nstandard:\"posix\"},\n\n{\nname:\"SIGPIPE\",\nnumber:13,\naction:\"terminate\",\ndescription:\"Broken pipe or socket\",\nstandard:\"posix\"},\n\n{\nname:\"SIGALRM\",\nnumber:14,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"posix\"},\n\n{\nname:\"SIGTERM\",\nnumber:15,\naction:\"terminate\",\ndescription:\"Termination\",\nstandard:\"ansi\"},\n\n{\nname:\"SIGSTKFLT\",\nnumber:16,\naction:\"terminate\",\ndescription:\"Stack is empty or overflowed\",\nstandard:\"other\"},\n\n{\nname:\"SIGCHLD\",\nnumber:17,\naction:\"ignore\",\ndescription:\"Child process terminated, paused or unpaused\",\nstandard:\"posix\"},\n\n{\nname:\"SIGCLD\",\nnumber:17,\naction:\"ignore\",\ndescription:\"Child process terminated, paused or unpaused\",\nstandard:\"other\"},\n\n{\nname:\"SIGCONT\",\nnumber:18,\naction:\"unpause\",\ndescription:\"Unpaused\",\nstandard:\"posix\",\nforced:true},\n\n{\nname:\"SIGSTOP\",\nnumber:19,\naction:\"pause\",\ndescription:\"Paused\",\nstandard:\"posix\",\nforced:true},\n\n{\nname:\"SIGTSTP\",\nnumber:20,\naction:\"pause\",\ndescription:\"Paused using CTRL-Z or \\\"suspend\\\"\",\nstandard:\"posix\"},\n\n{\nname:\"SIGTTIN\",\nnumber:21,\naction:\"pause\",\ndescription:\"Background process cannot read terminal input\",\nstandard:\"posix\"},\n\n{\nname:\"SIGBREAK\",\nnumber:21,\naction:\"terminate\",\ndescription:\"User interruption with CTRL-BREAK\",\nstandard:\"other\"},\n\n{\nname:\"SIGTTOU\",\nnumber:22,\naction:\"pause\",\ndescription:\"Background process cannot write to terminal output\",\nstandard:\"posix\"},\n\n{\nname:\"SIGURG\",\nnumber:23,\naction:\"ignore\",\ndescription:\"Socket received out-of-band data\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGXCPU\",\nnumber:24,\naction:\"core\",\ndescription:\"Process timed out\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGXFSZ\",\nnumber:25,\naction:\"core\",\ndescription:\"File too big\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGVTALRM\",\nnumber:26,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGPROF\",\nnumber:27,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGWINCH\",\nnumber:28,\naction:\"ignore\",\ndescription:\"Terminal window size changed\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGIO\",\nnumber:29,\naction:\"terminate\",\ndescription:\"I/O is available\",\nstandard:\"other\"},\n\n{\nname:\"SIGPOLL\",\nnumber:29,\naction:\"terminate\",\ndescription:\"Watched event\",\nstandard:\"other\"},\n\n{\nname:\"SIGINFO\",\nnumber:29,\naction:\"ignore\",\ndescription:\"Request for process information\",\nstandard:\"other\"},\n\n{\nname:\"SIGPWR\",\nnumber:30,\naction:\"terminate\",\ndescription:\"Device running out of power\",\nstandard:\"systemv\"},\n\n{\nname:\"SIGSYS\",\nnumber:31,\naction:\"core\",\ndescription:\"Invalid system call\",\nstandard:\"other\"},\n\n{\nname:\"SIGUNUSED\",\nnumber:31,\naction:\"terminate\",\ndescription:\"Invalid system call\",\nstandard:\"other\"}];exports.SIGNALS=SIGNALS;\n//# sourceMappingURL=core.js.map","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.SIGRTMAX=exports.getRealtimeSignals=void 0;\nconst getRealtimeSignals=function(){\nconst length=SIGRTMAX-SIGRTMIN+1;\nreturn Array.from({length},getRealtimeSignal);\n};exports.getRealtimeSignals=getRealtimeSignals;\n\nconst getRealtimeSignal=function(value,index){\nreturn{\nname:`SIGRT${index+1}`,\nnumber:SIGRTMIN+index,\naction:\"terminate\",\ndescription:\"Application-specific signal (realtime)\",\nstandard:\"posix\"};\n\n};\n\nconst SIGRTMIN=34;\nconst SIGRTMAX=64;exports.SIGRTMAX=SIGRTMAX;\n//# sourceMappingURL=realtime.js.map","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.getSignals=void 0;var _os=require(\"os\");\n\nvar _core=require(\"./core.js\");\nvar _realtime=require(\"./realtime.js\");\n\n\n\nconst getSignals=function(){\nconst realtimeSignals=(0,_realtime.getRealtimeSignals)();\nconst signals=[..._core.SIGNALS,...realtimeSignals].map(normalizeSignal);\nreturn signals;\n};exports.getSignals=getSignals;\n\n\n\n\n\n\n\nconst normalizeSignal=function({\nname,\nnumber:defaultNumber,\ndescription,\naction,\nforced=false,\nstandard})\n{\nconst{\nsignals:{[name]:constantSignal}}=\n_os.constants;\nconst supported=constantSignal!==undefined;\nconst number=supported?constantSignal:defaultNumber;\nreturn{name,number,description,supported,action,forced,standard};\n};\n//# sourceMappingURL=signals.js.map","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.signalsByNumber=exports.signalsByName=void 0;var _os=require(\"os\");\n\nvar _signals=require(\"./signals.js\");\nvar _realtime=require(\"./realtime.js\");\n\n\n\nconst getSignalsByName=function(){\nconst signals=(0,_signals.getSignals)();\nreturn signals.reduce(getSignalByName,{});\n};\n\nconst getSignalByName=function(\nsignalByNameMemo,\n{name,number,description,supported,action,forced,standard})\n{\nreturn{\n...signalByNameMemo,\n[name]:{name,number,description,supported,action,forced,standard}};\n\n};\n\nconst signalsByName=getSignalsByName();exports.signalsByName=signalsByName;\n\n\n\n\nconst getSignalsByNumber=function(){\nconst signals=(0,_signals.getSignals)();\nconst length=_realtime.SIGRTMAX+1;\nconst signalsA=Array.from({length},(value,number)=>\ngetSignalByNumber(number,signals));\n\nreturn Object.assign({},...signalsA);\n};\n\nconst getSignalByNumber=function(number,signals){\nconst signal=findSignalByNumber(number,signals);\n\nif(signal===undefined){\nreturn{};\n}\n\nconst{name,description,supported,action,forced,standard}=signal;\nreturn{\n[number]:{\nname,\nnumber,\ndescription,\nsupported,\naction,\nforced,\nstandard}};\n\n\n};\n\n\n\nconst findSignalByNumber=function(number,signals){\nconst signal=signals.find(({name})=>_os.constants.signals[name]===number);\n\nif(signal!==undefined){\nreturn signal;\n}\n\nreturn signals.find(signalA=>signalA.number===number);\n};\n\nconst signalsByNumber=getSignalsByNumber();exports.signalsByNumber=signalsByNumber;\n//# sourceMappingURL=main.js.map","'use strict';\nconst {signalsByName} = require('human-signals');\n\nconst getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {\n\tif (timedOut) {\n\t\treturn `timed out after ${timeout} milliseconds`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn 'was canceled';\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `failed with ${errorCode}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'failed';\n};\n\nconst makeError = ({\n\tstdout,\n\tstderr,\n\tall,\n\terror,\n\tsignal,\n\texitCode,\n\tcommand,\n\tescapedCommand,\n\ttimedOut,\n\tisCanceled,\n\tkilled,\n\tparsed: {options: {timeout}}\n}) => {\n\t// `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n\t// We normalize them to `undefined`\n\texitCode = exitCode === null ? undefined : exitCode;\n\tsignal = signal === null ? undefined : signal;\n\tconst signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n\n\tconst errorCode = error && error.code;\n\n\tconst prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});\n\tconst execaMessage = `Command ${prefix}: ${command}`;\n\tconst isError = Object.prototype.toString.call(error) === '[object Error]';\n\tconst shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n\tconst message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n\n\tif (isError) {\n\t\terror.originalMessage = error.message;\n\t\terror.message = message;\n\t} else {\n\t\terror = new Error(message);\n\t}\n\n\terror.shortMessage = shortMessage;\n\terror.command = command;\n\terror.escapedCommand = escapedCommand;\n\terror.exitCode = exitCode;\n\terror.signal = signal;\n\terror.signalDescription = signalDescription;\n\terror.stdout = stdout;\n\terror.stderr = stderr;\n\n\tif (all !== undefined) {\n\t\terror.all = all;\n\t}\n\n\tif ('bufferedData' in error) {\n\t\tdelete error.bufferedData;\n\t}\n\n\terror.failed = true;\n\terror.timedOut = Boolean(timedOut);\n\terror.isCanceled = isCanceled;\n\terror.killed = killed && !timedOut;\n\n\treturn error;\n};\n\nmodule.exports = makeError;\n","'use strict';\nconst aliases = ['stdin', 'stdout', 'stderr'];\n\nconst hasAlias = options => aliases.some(alias => options[alias] !== undefined);\n\nconst normalizeStdio = options => {\n\tif (!options) {\n\t\treturn;\n\t}\n\n\tconst {stdio} = options;\n\n\tif (stdio === undefined) {\n\t\treturn aliases.map(alias => options[alias]);\n\t}\n\n\tif (hasAlias(options)) {\n\t\tthrow new Error(`It's not possible to provide \\`stdio\\` in combination with one of ${aliases.map(alias => `\\`${alias}\\``).join(', ')}`);\n\t}\n\n\tif (typeof stdio === 'string') {\n\t\treturn stdio;\n\t}\n\n\tif (!Array.isArray(stdio)) {\n\t\tthrow new TypeError(`Expected \\`stdio\\` to be of type \\`string\\` or \\`Array\\`, got \\`${typeof stdio}\\``);\n\t}\n\n\tconst length = Math.max(stdio.length, aliases.length);\n\treturn Array.from({length}, (value, index) => stdio[index]);\n};\n\nmodule.exports = normalizeStdio;\n\n// `ipc` is pushed unless it is already present\nmodule.exports.node = options => {\n\tconst stdio = normalizeStdio(options);\n\n\tif (stdio === 'ipc') {\n\t\treturn 'ipc';\n\t}\n\n\tif (stdio === undefined || typeof stdio === 'string') {\n\t\treturn [stdio, stdio, stdio, 'ipc'];\n\t}\n\n\tif (stdio.includes('ipc')) {\n\t\treturn stdio;\n\t}\n\n\treturn [...stdio, 'ipc'];\n};\n","// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\nmodule.exports = [\n  'SIGABRT',\n  'SIGALRM',\n  'SIGHUP',\n  'SIGINT',\n  'SIGTERM'\n]\n\nif (process.platform !== 'win32') {\n  module.exports.push(\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (process.platform === 'linux') {\n  module.exports.push(\n    'SIGIO',\n    'SIGPOLL',\n    'SIGPWR',\n    'SIGSTKFLT',\n    'SIGUNUSED'\n  )\n}\n","// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nvar process = global.process\n\nconst processOk = function (process) {\n  return process &&\n    typeof process === 'object' &&\n    typeof process.removeListener === 'function' &&\n    typeof process.emit === 'function' &&\n    typeof process.reallyExit === 'function' &&\n    typeof process.listeners === 'function' &&\n    typeof process.kill === 'function' &&\n    typeof process.pid === 'number' &&\n    typeof process.on === 'function'\n}\n\n// some kind of non-node environment, just no-op\n/* istanbul ignore if */\nif (!processOk(process)) {\n  module.exports = function () {\n    return function () {}\n  }\n} else {\n  var assert = require('assert')\n  var signals = require('./signals.js')\n  var isWin = /^win/i.test(process.platform)\n\n  var EE = require('events')\n  /* istanbul ignore if */\n  if (typeof EE !== 'function') {\n    EE = EE.EventEmitter\n  }\n\n  var emitter\n  if (process.__signal_exit_emitter__) {\n    emitter = process.__signal_exit_emitter__\n  } else {\n    emitter = process.__signal_exit_emitter__ = new EE()\n    emitter.count = 0\n    emitter.emitted = {}\n  }\n\n  // Because this emitter is a global, we have to check to see if a\n  // previous version of this library failed to enable infinite listeners.\n  // I know what you're about to say.  But literally everything about\n  // signal-exit is a compromise with evil.  Get used to it.\n  if (!emitter.infinite) {\n    emitter.setMaxListeners(Infinity)\n    emitter.infinite = true\n  }\n\n  module.exports = function (cb, opts) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return function () {}\n    }\n    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n    if (loaded === false) {\n      load()\n    }\n\n    var ev = 'exit'\n    if (opts && opts.alwaysLast) {\n      ev = 'afterexit'\n    }\n\n    var remove = function () {\n      emitter.removeListener(ev, cb)\n      if (emitter.listeners('exit').length === 0 &&\n          emitter.listeners('afterexit').length === 0) {\n        unload()\n      }\n    }\n    emitter.on(ev, cb)\n\n    return remove\n  }\n\n  var unload = function unload () {\n    if (!loaded || !processOk(global.process)) {\n      return\n    }\n    loaded = false\n\n    signals.forEach(function (sig) {\n      try {\n        process.removeListener(sig, sigListeners[sig])\n      } catch (er) {}\n    })\n    process.emit = originalProcessEmit\n    process.reallyExit = originalProcessReallyExit\n    emitter.count -= 1\n  }\n  module.exports.unload = unload\n\n  var emit = function emit (event, code, signal) {\n    /* istanbul ignore if */\n    if (emitter.emitted[event]) {\n      return\n    }\n    emitter.emitted[event] = true\n    emitter.emit(event, code, signal)\n  }\n\n  // { <signal>: <listener fn>, ... }\n  var sigListeners = {}\n  signals.forEach(function (sig) {\n    sigListeners[sig] = function listener () {\n      /* istanbul ignore if */\n      if (!processOk(global.process)) {\n        return\n      }\n      // If there are no other listeners, an exit is coming!\n      // Simplest way: remove us and then re-send the signal.\n      // We know that this will kill the process, so we can\n      // safely emit now.\n      var listeners = process.listeners(sig)\n      if (listeners.length === emitter.count) {\n        unload()\n        emit('exit', null, sig)\n        /* istanbul ignore next */\n        emit('afterexit', null, sig)\n        /* istanbul ignore next */\n        if (isWin && sig === 'SIGHUP') {\n          // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n          // so use a supported signal instead\n          sig = 'SIGINT'\n        }\n        /* istanbul ignore next */\n        process.kill(process.pid, sig)\n      }\n    }\n  })\n\n  module.exports.signals = function () {\n    return signals\n  }\n\n  var loaded = false\n\n  var load = function load () {\n    if (loaded || !processOk(global.process)) {\n      return\n    }\n    loaded = true\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    emitter.count += 1\n\n    signals = signals.filter(function (sig) {\n      try {\n        process.on(sig, sigListeners[sig])\n        return true\n      } catch (er) {\n        return false\n      }\n    })\n\n    process.emit = processEmit\n    process.reallyExit = processReallyExit\n  }\n  module.exports.load = load\n\n  var originalProcessReallyExit = process.reallyExit\n  var processReallyExit = function processReallyExit (code) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return\n    }\n    process.exitCode = code || /* istanbul ignore next */ 0\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    /* istanbul ignore next */\n    originalProcessReallyExit.call(process, process.exitCode)\n  }\n\n  var originalProcessEmit = process.emit\n  var processEmit = function processEmit (ev, arg) {\n    if (ev === 'exit' && processOk(global.process)) {\n      /* istanbul ignore else */\n      if (arg !== undefined) {\n        process.exitCode = arg\n      }\n      var ret = originalProcessEmit.apply(this, arguments)\n      /* istanbul ignore next */\n      emit('exit', process.exitCode, null)\n      /* istanbul ignore next */\n      emit('afterexit', process.exitCode, null)\n      /* istanbul ignore next */\n      return ret\n    } else {\n      return originalProcessEmit.apply(this, arguments)\n    }\n  }\n}\n","'use strict';\nconst os = require('os');\nconst onExit = require('signal-exit');\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\nconst spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {\n\tconst killResult = kill(signal);\n\tsetKillTimeout(kill, signal, options, killResult);\n\treturn killResult;\n};\n\nconst setKillTimeout = (kill, signal, options, killResult) => {\n\tif (!shouldForceKill(signal, options, killResult)) {\n\t\treturn;\n\t}\n\n\tconst timeout = getForceKillAfterTimeout(options);\n\tconst t = setTimeout(() => {\n\t\tkill('SIGKILL');\n\t}, timeout);\n\n\t// Guarded because there's no `.unref()` when `execa` is used in the renderer\n\t// process in Electron. This cannot be tested since we don't run tests in\n\t// Electron.\n\t// istanbul ignore else\n\tif (t.unref) {\n\t\tt.unref();\n\t}\n};\n\nconst shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {\n\treturn isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n};\n\nconst isSigterm = signal => {\n\treturn signal === os.constants.signals.SIGTERM ||\n\t\t(typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');\n};\n\nconst getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {\n\tif (forceKillAfterTimeout === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n\t}\n\n\treturn forceKillAfterTimeout;\n};\n\n// `childProcess.cancel()`\nconst spawnedCancel = (spawned, context) => {\n\tconst killResult = spawned.kill();\n\n\tif (killResult) {\n\t\tcontext.isCanceled = true;\n\t}\n};\n\nconst timeoutKill = (spawned, signal, reject) => {\n\tspawned.kill(signal);\n\treject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));\n};\n\n// `timeout` option handling\nconst setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {\n\tif (timeout === 0 || timeout === undefined) {\n\t\treturn spawnedPromise;\n\t}\n\n\tlet timeoutId;\n\tconst timeoutPromise = new Promise((resolve, reject) => {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimeoutKill(spawned, killSignal, reject);\n\t\t}, timeout);\n\t});\n\n\tconst safeSpawnedPromise = spawnedPromise.finally(() => {\n\t\tclearTimeout(timeoutId);\n\t});\n\n\treturn Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\n\nconst validateTimeout = ({timeout}) => {\n\tif (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n};\n\n// `cleanup` option handling\nconst setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {\n\tif (!cleanup || detached) {\n\t\treturn timedPromise;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tspawned.kill();\n\t});\n\n\treturn timedPromise.finally(() => {\n\t\tremoveExitHandler();\n\t});\n};\n\nmodule.exports = {\n\tspawnedKill,\n\tspawnedCancel,\n\tsetupTimeout,\n\tvalidateTimeout,\n\tsetExitHandler\n};\n","'use strict';\n\nconst isStream = stream =>\n\tstream !== null &&\n\ttypeof stream === 'object' &&\n\ttypeof stream.pipe === 'function';\n\nisStream.writable = stream =>\n\tisStream(stream) &&\n\tstream.writable !== false &&\n\ttypeof stream._write === 'function' &&\n\ttypeof stream._writableState === 'object';\n\nisStream.readable = stream =>\n\tisStream(stream) &&\n\tstream.readable !== false &&\n\ttypeof stream._read === 'function' &&\n\ttypeof stream._readableState === 'object';\n\nisStream.duplex = stream =>\n\tisStream.writable(stream) &&\n\tisStream.readable(stream);\n\nisStream.transform = stream =>\n\tisStream.duplex(stream) &&\n\ttypeof stream._transform === 'function';\n\nmodule.exports = isStream;\n","'use strict';\nconst {PassThrough: PassThroughStream} = require('stream');\n\nmodule.exports = options => {\n\toptions = {...options};\n\n\tconst {array} = options;\n\tlet {encoding} = options;\n\tconst isBuffer = encoding === 'buffer';\n\tlet objectMode = false;\n\n\tif (array) {\n\t\tobjectMode = !(encoding || isBuffer);\n\t} else {\n\t\tencoding = encoding || 'utf8';\n\t}\n\n\tif (isBuffer) {\n\t\tencoding = null;\n\t}\n\n\tconst stream = new PassThroughStream({objectMode});\n\n\tif (encoding) {\n\t\tstream.setEncoding(encoding);\n\t}\n\n\tlet length = 0;\n\tconst chunks = [];\n\n\tstream.on('data', chunk => {\n\t\tchunks.push(chunk);\n\n\t\tif (objectMode) {\n\t\t\tlength = chunks.length;\n\t\t} else {\n\t\t\tlength += chunk.length;\n\t\t}\n\t});\n\n\tstream.getBufferedValue = () => {\n\t\tif (array) {\n\t\t\treturn chunks;\n\t\t}\n\n\t\treturn isBuffer ? Buffer.concat(chunks, length) : chunks.join('');\n\t};\n\n\tstream.getBufferedLength = () => length;\n\n\treturn stream;\n};\n","'use strict';\nconst {constants: BufferConstants} = require('buffer');\nconst stream = require('stream');\nconst {promisify} = require('util');\nconst bufferStream = require('./buffer-stream');\n\nconst streamPipelinePromisified = promisify(stream.pipeline);\n\nclass MaxBufferError extends Error {\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t\tthis.name = 'MaxBufferError';\n\t}\n}\n\nasync function getStream(inputStream, options) {\n\tif (!inputStream) {\n\t\tthrow new Error('Expected a stream');\n\t}\n\n\toptions = {\n\t\tmaxBuffer: Infinity,\n\t\t...options\n\t};\n\n\tconst {maxBuffer} = options;\n\tconst stream = bufferStream(options);\n\n\tawait new Promise((resolve, reject) => {\n\t\tconst rejectPromise = error => {\n\t\t\t// Don't retrieve an oversized buffer.\n\t\t\tif (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n\t\t\t\terror.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\n\t\t\treject(error);\n\t\t};\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tawait streamPipelinePromisified(inputStream, stream);\n\t\t\t\tresolve();\n\t\t\t} catch (error) {\n\t\t\t\trejectPromise(error);\n\t\t\t}\n\t\t})();\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\trejectPromise(new MaxBufferError());\n\t\t\t}\n\t\t});\n\t});\n\n\treturn stream.getBufferedValue();\n}\n\nmodule.exports = getStream;\nmodule.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});\nmodule.exports.array = (stream, options) => getStream(stream, {...options, array: true});\nmodule.exports.MaxBufferError = MaxBufferError;\n","'use strict';\n\nconst { PassThrough } = require('stream');\n\nmodule.exports = function (/*streams...*/) {\n  var sources = []\n  var output  = new PassThrough({objectMode: true})\n\n  output.setMaxListeners(0)\n\n  output.add = add\n  output.isEmpty = isEmpty\n\n  output.on('unpipe', remove)\n\n  Array.prototype.slice.call(arguments).forEach(add)\n\n  return output\n\n  function add (source) {\n    if (Array.isArray(source)) {\n      source.forEach(add)\n      return this\n    }\n\n    sources.push(source);\n    source.once('end', remove.bind(null, source))\n    source.once('error', output.emit.bind(output, 'error'))\n    source.pipe(output, {end: false})\n    return this\n  }\n\n  function isEmpty () {\n    return sources.length == 0;\n  }\n\n  function remove (source) {\n    sources = sources.filter(function (it) { return it !== source })\n    if (!sources.length && output.readable) { output.end() }\n  }\n}\n","'use strict';\nconst isStream = require('is-stream');\nconst getStream = require('get-stream');\nconst mergeStream = require('merge-stream');\n\n// `input` option\nconst handleInput = (spawned, input) => {\n\t// Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852\n\t// @todo remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0\n\tif (input === undefined || spawned.stdin === undefined) {\n\t\treturn;\n\t}\n\n\tif (isStream(input)) {\n\t\tinput.pipe(spawned.stdin);\n\t} else {\n\t\tspawned.stdin.end(input);\n\t}\n};\n\n// `all` interleaves `stdout` and `stderr`\nconst makeAllStream = (spawned, {all}) => {\n\tif (!all || (!spawned.stdout && !spawned.stderr)) {\n\t\treturn;\n\t}\n\n\tconst mixed = mergeStream();\n\n\tif (spawned.stdout) {\n\t\tmixed.add(spawned.stdout);\n\t}\n\n\tif (spawned.stderr) {\n\t\tmixed.add(spawned.stderr);\n\t}\n\n\treturn mixed;\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\nconst getBufferedData = async (stream, streamPromise) => {\n\tif (!stream) {\n\t\treturn;\n\t}\n\n\tstream.destroy();\n\n\ttry {\n\t\treturn await streamPromise;\n\t} catch (error) {\n\t\treturn error.bufferedData;\n\t}\n};\n\nconst getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {\n\tif (!stream || !buffer) {\n\t\treturn;\n\t}\n\n\tif (encoding) {\n\t\treturn getStream(stream, {encoding, maxBuffer});\n\t}\n\n\treturn getStream.buffer(stream, {maxBuffer});\n};\n\n// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\nconst getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {\n\tconst stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});\n\tconst stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});\n\tconst allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});\n\n\ttry {\n\t\treturn await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n\t} catch (error) {\n\t\treturn Promise.all([\n\t\t\t{error, signal: error.signal, timedOut: error.timedOut},\n\t\t\tgetBufferedData(stdout, stdoutPromise),\n\t\t\tgetBufferedData(stderr, stderrPromise),\n\t\t\tgetBufferedData(all, allPromise)\n\t\t]);\n\t}\n};\n\nconst validateInputSync = ({input}) => {\n\tif (isStream(input)) {\n\t\tthrow new TypeError('The `input` option cannot be a stream in sync mode');\n\t}\n};\n\nmodule.exports = {\n\thandleInput,\n\tmakeAllStream,\n\tgetSpawnedResult,\n\tvalidateInputSync\n};\n\n","'use strict';\n\nconst nativePromisePrototype = (async () => {})().constructor.prototype;\nconst descriptors = ['then', 'catch', 'finally'].map(property => [\n\tproperty,\n\tReflect.getOwnPropertyDescriptor(nativePromisePrototype, property)\n]);\n\n// The return value is a mixin of `childProcess` and `Promise`\nconst mergePromise = (spawned, promise) => {\n\tfor (const [property, descriptor] of descriptors) {\n\t\t// Starting the main `promise` is deferred to avoid consuming streams\n\t\tconst value = typeof promise === 'function' ?\n\t\t\t(...args) => Reflect.apply(descriptor.value, promise(), args) :\n\t\t\tdescriptor.value.bind(promise);\n\n\t\tReflect.defineProperty(spawned, property, {...descriptor, value});\n\t}\n\n\treturn spawned;\n};\n\n// Use promises instead of `child_process` events\nconst getSpawnedPromise = spawned => {\n\treturn new Promise((resolve, reject) => {\n\t\tspawned.on('exit', (exitCode, signal) => {\n\t\t\tresolve({exitCode, signal});\n\t\t});\n\n\t\tspawned.on('error', error => {\n\t\t\treject(error);\n\t\t});\n\n\t\tif (spawned.stdin) {\n\t\t\tspawned.stdin.on('error', error => {\n\t\t\t\treject(error);\n\t\t\t});\n\t\t}\n\t});\n};\n\nmodule.exports = {\n\tmergePromise,\n\tgetSpawnedPromise\n};\n\n","'use strict';\nconst normalizeArgs = (file, args = []) => {\n\tif (!Array.isArray(args)) {\n\t\treturn [file];\n\t}\n\n\treturn [file, ...args];\n};\n\nconst NO_ESCAPE_REGEXP = /^[\\w.-]+$/;\nconst DOUBLE_QUOTES_REGEXP = /\"/g;\n\nconst escapeArg = arg => {\n\tif (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {\n\t\treturn arg;\n\t}\n\n\treturn `\"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\\\\"')}\"`;\n};\n\nconst joinCommand = (file, args) => {\n\treturn normalizeArgs(file, args).join(' ');\n};\n\nconst getEscapedCommand = (file, args) => {\n\treturn normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');\n};\n\nconst SPACES_REGEXP = / +/g;\n\n// Handle `execa.command()`\nconst parseCommand = command => {\n\tconst tokens = [];\n\tfor (const token of command.trim().split(SPACES_REGEXP)) {\n\t\t// Allow spaces to be escaped by a backslash if not meant as a delimiter\n\t\tconst previousToken = tokens[tokens.length - 1];\n\t\tif (previousToken && previousToken.endsWith('\\\\')) {\n\t\t\t// Merge previous token with current one\n\t\t\ttokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n\t\t} else {\n\t\t\ttokens.push(token);\n\t\t}\n\t}\n\n\treturn tokens;\n};\n\nmodule.exports = {\n\tjoinCommand,\n\tgetEscapedCommand,\n\tparseCommand\n};\n","'use strict';\nconst path = require('path');\nconst childProcess = require('child_process');\nconst crossSpawn = require('cross-spawn');\nconst stripFinalNewline = require('strip-final-newline');\nconst npmRunPath = require('npm-run-path');\nconst onetime = require('onetime');\nconst makeError = require('./lib/error');\nconst normalizeStdio = require('./lib/stdio');\nconst {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} = require('./lib/kill');\nconst {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = require('./lib/stream');\nconst {mergePromise, getSpawnedPromise} = require('./lib/promise');\nconst {joinCommand, parseCommand, getEscapedCommand} = require('./lib/command');\n\nconst DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;\n\nconst getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {\n\tconst env = extendEnv ? {...process.env, ...envOption} : envOption;\n\n\tif (preferLocal) {\n\t\treturn npmRunPath.env({env, cwd: localDir, execPath});\n\t}\n\n\treturn env;\n};\n\nconst handleArguments = (file, args, options = {}) => {\n\tconst parsed = crossSpawn._parse(file, args, options);\n\tfile = parsed.command;\n\targs = parsed.args;\n\toptions = parsed.options;\n\n\toptions = {\n\t\tmaxBuffer: DEFAULT_MAX_BUFFER,\n\t\tbuffer: true,\n\t\tstripFinalNewline: true,\n\t\textendEnv: true,\n\t\tpreferLocal: false,\n\t\tlocalDir: options.cwd || process.cwd(),\n\t\texecPath: process.execPath,\n\t\tencoding: 'utf8',\n\t\treject: true,\n\t\tcleanup: true,\n\t\tall: false,\n\t\twindowsHide: true,\n\t\t...options\n\t};\n\n\toptions.env = getEnv(options);\n\n\toptions.stdio = normalizeStdio(options);\n\n\tif (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {\n\t\t// #116\n\t\targs.unshift('/q');\n\t}\n\n\treturn {file, args, options, parsed};\n};\n\nconst handleOutput = (options, value, error) => {\n\tif (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n\t\t// When `execa.sync()` errors, we normalize it to '' to mimic `execa()`\n\t\treturn error === undefined ? undefined : '';\n\t}\n\n\tif (options.stripFinalNewline) {\n\t\treturn stripFinalNewline(value);\n\t}\n\n\treturn value;\n};\n\nconst execa = (file, args, options) => {\n\tconst parsed = handleArguments(file, args, options);\n\tconst command = joinCommand(file, args);\n\tconst escapedCommand = getEscapedCommand(file, args);\n\n\tvalidateTimeout(parsed.options);\n\n\tlet spawned;\n\ttry {\n\t\tspawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);\n\t} catch (error) {\n\t\t// Ensure the returned error is always both a promise and a child process\n\t\tconst dummySpawned = new childProcess.ChildProcess();\n\t\tconst errorPromise = Promise.reject(makeError({\n\t\t\terror,\n\t\t\tstdout: '',\n\t\t\tstderr: '',\n\t\t\tall: '',\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false\n\t\t}));\n\t\treturn mergePromise(dummySpawned, errorPromise);\n\t}\n\n\tconst spawnedPromise = getSpawnedPromise(spawned);\n\tconst timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);\n\tconst processDone = setExitHandler(spawned, parsed.options, timedPromise);\n\n\tconst context = {isCanceled: false};\n\n\tspawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));\n\tspawned.cancel = spawnedCancel.bind(null, spawned, context);\n\n\tconst handlePromise = async () => {\n\t\tconst [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);\n\t\tconst stdout = handleOutput(parsed.options, stdoutResult);\n\t\tconst stderr = handleOutput(parsed.options, stderrResult);\n\t\tconst all = handleOutput(parsed.options, allResult);\n\n\t\tif (error || exitCode !== 0 || signal !== null) {\n\t\t\tconst returnedError = makeError({\n\t\t\t\terror,\n\t\t\t\texitCode,\n\t\t\t\tsignal,\n\t\t\t\tstdout,\n\t\t\t\tstderr,\n\t\t\t\tall,\n\t\t\t\tcommand,\n\t\t\t\tescapedCommand,\n\t\t\t\tparsed,\n\t\t\t\ttimedOut,\n\t\t\t\tisCanceled: context.isCanceled,\n\t\t\t\tkilled: spawned.killed\n\t\t\t});\n\n\t\t\tif (!parsed.options.reject) {\n\t\t\t\treturn returnedError;\n\t\t\t}\n\n\t\t\tthrow returnedError;\n\t\t}\n\n\t\treturn {\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\texitCode: 0,\n\t\t\tstdout,\n\t\t\tstderr,\n\t\t\tall,\n\t\t\tfailed: false,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false\n\t\t};\n\t};\n\n\tconst handlePromiseOnce = onetime(handlePromise);\n\n\thandleInput(spawned, parsed.options.input);\n\n\tspawned.all = makeAllStream(spawned, parsed.options);\n\n\treturn mergePromise(spawned, handlePromiseOnce);\n};\n\nmodule.exports = execa;\n\nmodule.exports.sync = (file, args, options) => {\n\tconst parsed = handleArguments(file, args, options);\n\tconst command = joinCommand(file, args);\n\tconst escapedCommand = getEscapedCommand(file, args);\n\n\tvalidateInputSync(parsed.options);\n\n\tlet result;\n\ttry {\n\t\tresult = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);\n\t} catch (error) {\n\t\tthrow makeError({\n\t\t\terror,\n\t\t\tstdout: '',\n\t\t\tstderr: '',\n\t\t\tall: '',\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false\n\t\t});\n\t}\n\n\tconst stdout = handleOutput(parsed.options, result.stdout, result.error);\n\tconst stderr = handleOutput(parsed.options, result.stderr, result.error);\n\n\tif (result.error || result.status !== 0 || result.signal !== null) {\n\t\tconst error = makeError({\n\t\t\tstdout,\n\t\t\tstderr,\n\t\t\terror: result.error,\n\t\t\tsignal: result.signal,\n\t\t\texitCode: result.status,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: result.error && result.error.code === 'ETIMEDOUT',\n\t\t\tisCanceled: false,\n\t\t\tkilled: result.signal !== null\n\t\t});\n\n\t\tif (!parsed.options.reject) {\n\t\t\treturn error;\n\t\t}\n\n\t\tthrow error;\n\t}\n\n\treturn {\n\t\tcommand,\n\t\tescapedCommand,\n\t\texitCode: 0,\n\t\tstdout,\n\t\tstderr,\n\t\tfailed: false,\n\t\ttimedOut: false,\n\t\tisCanceled: false,\n\t\tkilled: false\n\t};\n};\n\nmodule.exports.command = (command, options) => {\n\tconst [file, ...args] = parseCommand(command);\n\treturn execa(file, args, options);\n};\n\nmodule.exports.commandSync = (command, options) => {\n\tconst [file, ...args] = parseCommand(command);\n\treturn execa.sync(file, args, options);\n};\n\nmodule.exports.node = (scriptPath, args, options = {}) => {\n\tif (args && !Array.isArray(args) && typeof args === 'object') {\n\t\toptions = args;\n\t\targs = [];\n\t}\n\n\tconst stdio = normalizeStdio.node(options);\n\tconst defaultExecArgv = process.execArgv.filter(arg => !arg.startsWith('--inspect'));\n\n\tconst {\n\t\tnodePath = process.execPath,\n\t\tnodeOptions = defaultExecArgv\n\t} = options;\n\n\treturn execa(\n\t\tnodePath,\n\t\t[\n\t\t\t...nodeOptions,\n\t\t\tscriptPath,\n\t\t\t...(Array.isArray(args) ? args : [])\n\t\t],\n\t\t{\n\t\t\t...options,\n\t\t\tstdin: undefined,\n\t\t\tstdout: undefined,\n\t\t\tstderr: undefined,\n\t\t\tstdio,\n\t\t\tshell: false\n\t\t}\n\t);\n};\n","'use strict'\n\nvar PATH\n// windows calls it's path 'Path' usually, but this is not guaranteed.\nif (process.platform === 'win32') {\n  PATH = 'Path'\n  Object.keys(process.env).forEach(e => {\n    if (e.match(/^PATH$/i)) {\n      PATH = e\n    }\n  })\n} else {\n  PATH = 'PATH'\n}\n\nmodule.exports = PATH\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.sync = void 0;\r\nconst which_1 = __importDefault(require(\"@zkochan/which\"));\r\nconst execa_1 = __importDefault(require(\"execa\"));\r\nconst path_name_1 = __importDefault(require(\"path-name\"));\r\nconst pathCache = new Map();\r\nfunction sync(file, args, options) {\r\n    var _a;\r\n    try {\r\n        which_1.default.sync(file, { path: (_a = options === null || options === void 0 ? void 0 : options.cwd) !== null && _a !== void 0 ? _a : process.cwd });\r\n    }\r\n    catch (err) {\r\n        // If the command is not found in the current directory, there is no need to resolve the command to full location\r\n        // as there is no danger of binary planting attack on Windows\r\n        if (err.code === 'ENOENT') {\r\n            return execa_1.default.sync(file, args, options);\r\n        }\r\n    }\r\n    const fileAbsolutePath = getCommandAbsolutePathSync(file, options);\r\n    return execa_1.default.sync(fileAbsolutePath, args, options);\r\n}\r\nexports.sync = sync;\r\nfunction getCommandAbsolutePathSync(file, options) {\r\n    var _a, _b;\r\n    if (file.includes('\\\\') || file.includes('/'))\r\n        return file;\r\n    const path = (_b = (_a = options === null || options === void 0 ? void 0 : options.env) === null || _a === void 0 ? void 0 : _a[path_name_1.default]) !== null && _b !== void 0 ? _b : process.env[path_name_1.default];\r\n    const key = JSON.stringify([path, file]);\r\n    let fileAbsolutePath = pathCache.get(key);\r\n    if (fileAbsolutePath == null) {\r\n        fileAbsolutePath = which_1.default.sync(file, { path });\r\n        pathCache.set(key, fileAbsolutePath);\r\n    }\r\n    if (fileAbsolutePath == null) {\r\n        throw new Error(`Couldn't find ${file}`);\r\n    }\r\n    return fileAbsolutePath;\r\n}\r\nfunction default_1(file, args, options) {\r\n    var _a;\r\n    try {\r\n        which_1.default.sync(file, { path: (_a = options === null || options === void 0 ? void 0 : options.cwd) !== null && _a !== void 0 ? _a : process.cwd });\r\n    }\r\n    catch (err) {\r\n        // If the command is not found in the current directory, there is no need to resolve the command to full location\r\n        // as there is no danger of binary planting attack on Windows\r\n        if (err.code === 'ENOENT') {\r\n            return (0, execa_1.default)(file, args, options);\r\n        }\r\n    }\r\n    const fileAbsolutePath = getCommandAbsolutePathSync(file, options);\r\n    return (0, execa_1.default)(fileAbsolutePath, args, options);\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isGitRepo = isGitRepo;\nexports.getCurrentBranch = getCurrentBranch;\nexports.isWorkingTreeClean = isWorkingTreeClean;\nexports.isRemoteHistoryClean = isRemoteHistoryClean;\nconst execa_1 = __importDefault(require(\"execa\"));\n// git checks logic is from https://github.com/sindresorhus/np/blob/master/source/git-tasks.js\nasync function isGitRepo() {\n    try {\n        await (0, execa_1.default)('git', ['rev-parse', '--git-dir']);\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\nasync function getCurrentBranch() {\n    try {\n        const { stdout } = await (0, execa_1.default)('git', ['symbolic-ref', '--short', 'HEAD']);\n        return stdout;\n    }\n    catch {\n        // Command will fail with code 1 if the HEAD is detached.\n        return null;\n    }\n}\nasync function isWorkingTreeClean() {\n    try {\n        const { stdout: status } = await (0, execa_1.default)('git', ['status', '--porcelain']);\n        if (status !== '') {\n            return false;\n        }\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nasync function isRemoteHistoryClean() {\n    let history;\n    try { // Gracefully handle no remote set up.\n        const { stdout } = await (0, execa_1.default)('git', ['rev-list', '--count', '--left-only', '@{u}...HEAD']);\n        history = stdout;\n    }\n    catch {\n        history = null;\n    }\n    if (history && history !== '0') {\n        return false;\n    }\n    return true;\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getWantedLockfileName = getWantedLockfileName;\nconst constants_1 = require(\"@pnpm/constants\");\nconst git_utils_1 = require(\"@pnpm/git-utils\");\nasync function getWantedLockfileName(opts = { useGitBranchLockfile: false, mergeGitBranchLockfiles: false }) {\n    if (opts.useGitBranchLockfile && !opts.mergeGitBranchLockfiles) {\n        const currentBranchName = await (0, git_utils_1.getCurrentBranch)();\n        if (currentBranchName) {\n            return constants_1.WANTED_LOCKFILE.replace('.yaml', `.${stringifyBranchName(currentBranchName)}.yaml`);\n        }\n    }\n    return constants_1.WANTED_LOCKFILE;\n}\n/**\n * 1. Git branch name may contains slashes, which is not allowed in filenames\n * 2. Filesystem may be case-insensitive, so we need to convert branch name to lowercase\n */\nfunction stringifyBranchName(branchName = '') {\n    return branchName.replace(/[^\\w.-]/g, '!').toLowerCase();\n}\n//# sourceMappingURL=lockfileName.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEPENDENCIES_OR_PEER_FIELDS = exports.DEPENDENCIES_FIELDS = void 0;\n// NOTE: The order in this array is important.\nexports.DEPENDENCIES_FIELDS = [\n    'optionalDependencies',\n    'dependencies',\n    'devDependencies',\n];\nexports.DEPENDENCIES_OR_PEER_FIELDS = [\n    ...exports.DEPENDENCIES_FIELDS,\n    'peerDependencies',\n];\n//# sourceMappingURL=misc.js.map","function _isTransformer(obj) {\n  return obj != null && typeof obj['@@transducer/step'] === 'function';\n}\n\nmodule.exports = _isTransformer;","var _isArray =\n/*#__PURE__*/\nrequire(\"./_isArray.js\");\n\nvar _isTransformer =\n/*#__PURE__*/\nrequire(\"./_isTransformer.js\");\n/**\n * Returns a function that dispatches with different strategies based on the\n * object in list position (last argument). If it is an array, executes [fn].\n * Otherwise, if it has a function with one of the given method names, it will\n * execute that function (functor case). Otherwise, if it is a transformer,\n * uses transducer created by [transducerCreator] to return a new transformer\n * (transducer case).\n * Otherwise, it will default to executing [fn].\n *\n * @private\n * @param {Array} methodNames properties to check for a custom implementation\n * @param {Function} transducerCreator transducer factory if object is transformer\n * @param {Function} fn default ramda implementation\n * @return {Function} A function that dispatches on object in list position\n */\n\n\nfunction _dispatchable(methodNames, transducerCreator, fn) {\n  return function () {\n    if (arguments.length === 0) {\n      return fn();\n    }\n\n    var obj = arguments[arguments.length - 1];\n\n    if (!_isArray(obj)) {\n      var idx = 0;\n\n      while (idx < methodNames.length) {\n        if (typeof obj[methodNames[idx]] === 'function') {\n          return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));\n        }\n\n        idx += 1;\n      }\n\n      if (_isTransformer(obj)) {\n        var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));\n        return transducer(obj);\n      }\n    }\n\n    return fn.apply(this, arguments);\n  };\n}\n\nmodule.exports = _dispatchable;","function _map(fn, functor) {\n  var idx = 0;\n  var len = functor.length;\n  var result = Array(len);\n\n  while (idx < len) {\n    result[idx] = fn(functor[idx]);\n    idx += 1;\n  }\n\n  return result;\n}\n\nmodule.exports = _map;","var _curry1 =\n/*#__PURE__*/\nrequire(\"./_curry1.js\");\n\nvar _isArray =\n/*#__PURE__*/\nrequire(\"./_isArray.js\");\n\nvar _isString =\n/*#__PURE__*/\nrequire(\"./_isString.js\");\n/**\n * Tests whether or not an object is similar to an array.\n *\n * @private\n * @category Type\n * @category List\n * @sig * -> Boolean\n * @param {*} x The object to test.\n * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.\n * @example\n *\n *      _isArrayLike([]); //=> true\n *      _isArrayLike(true); //=> false\n *      _isArrayLike({}); //=> false\n *      _isArrayLike({length: 10}); //=> false\n *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true\n *      _isArrayLike({nodeType: 1, length: 1}) // => false\n */\n\n\nvar _isArrayLike =\n/*#__PURE__*/\n_curry1(function isArrayLike(x) {\n  if (_isArray(x)) {\n    return true;\n  }\n\n  if (!x) {\n    return false;\n  }\n\n  if (typeof x !== 'object') {\n    return false;\n  }\n\n  if (_isString(x)) {\n    return false;\n  }\n\n  if (x.length === 0) {\n    return true;\n  }\n\n  if (x.length > 0) {\n    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);\n  }\n\n  return false;\n});\n\nmodule.exports = _isArrayLike;","var XWrap =\n/*#__PURE__*/\nfunction () {\n  function XWrap(fn) {\n    this.f = fn;\n  }\n\n  XWrap.prototype['@@transducer/init'] = function () {\n    throw new Error('init not implemented on XWrap');\n  };\n\n  XWrap.prototype['@@transducer/result'] = function (acc) {\n    return acc;\n  };\n\n  XWrap.prototype['@@transducer/step'] = function (acc, x) {\n    return this.f(acc, x);\n  };\n\n  return XWrap;\n}();\n\nfunction _xwrap(fn) {\n  return new XWrap(fn);\n}\n\nmodule.exports = _xwrap;","function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0:\n      return function () {\n        return fn.apply(this, arguments);\n      };\n\n    case 1:\n      return function (a0) {\n        return fn.apply(this, arguments);\n      };\n\n    case 2:\n      return function (a0, a1) {\n        return fn.apply(this, arguments);\n      };\n\n    case 3:\n      return function (a0, a1, a2) {\n        return fn.apply(this, arguments);\n      };\n\n    case 4:\n      return function (a0, a1, a2, a3) {\n        return fn.apply(this, arguments);\n      };\n\n    case 5:\n      return function (a0, a1, a2, a3, a4) {\n        return fn.apply(this, arguments);\n      };\n\n    case 6:\n      return function (a0, a1, a2, a3, a4, a5) {\n        return fn.apply(this, arguments);\n      };\n\n    case 7:\n      return function (a0, a1, a2, a3, a4, a5, a6) {\n        return fn.apply(this, arguments);\n      };\n\n    case 8:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n        return fn.apply(this, arguments);\n      };\n\n    case 9:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n        return fn.apply(this, arguments);\n      };\n\n    case 10:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n        return fn.apply(this, arguments);\n      };\n\n    default:\n      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n}\n\nmodule.exports = _arity;","var _arity =\n/*#__PURE__*/\nrequire(\"./internal/_arity.js\");\n\nvar _curry2 =\n/*#__PURE__*/\nrequire(\"./internal/_curry2.js\");\n/**\n * Creates a function that is bound to a context.\n * Note: `R.bind` does not provide the additional argument-binding capabilities of\n * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n *\n * @func\n * @memberOf R\n * @since v0.6.0\n * @category Function\n * @category Object\n * @sig (* -> *) -> {*} -> (* -> *)\n * @param {Function} fn The function to bind to context\n * @param {Object} thisObj The context to bind `fn` to\n * @return {Function} A function that will execute in the context of `thisObj`.\n * @see R.partial\n * @example\n *\n *      const log = R.bind(console.log, console);\n *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}\n *      // logs {a: 2}\n * @symb R.bind(f, o)(a, b) = f.call(o, a, b)\n */\n\n\nvar bind =\n/*#__PURE__*/\n_curry2(function bind(fn, thisObj) {\n  return _arity(fn.length, function () {\n    return fn.apply(thisObj, arguments);\n  });\n});\n\nmodule.exports = bind;","var _isArrayLike =\n/*#__PURE__*/\nrequire(\"./_isArrayLike.js\");\n\nvar _xwrap =\n/*#__PURE__*/\nrequire(\"./_xwrap.js\");\n\nvar bind =\n/*#__PURE__*/\nrequire(\"../bind.js\");\n\nfunction _arrayReduce(xf, acc, list) {\n  var idx = 0;\n  var len = list.length;\n\n  while (idx < len) {\n    acc = xf['@@transducer/step'](acc, list[idx]);\n\n    if (acc && acc['@@transducer/reduced']) {\n      acc = acc['@@transducer/value'];\n      break;\n    }\n\n    idx += 1;\n  }\n\n  return xf['@@transducer/result'](acc);\n}\n\nfunction _iterableReduce(xf, acc, iter) {\n  var step = iter.next();\n\n  while (!step.done) {\n    acc = xf['@@transducer/step'](acc, step.value);\n\n    if (acc && acc['@@transducer/reduced']) {\n      acc = acc['@@transducer/value'];\n      break;\n    }\n\n    step = iter.next();\n  }\n\n  return xf['@@transducer/result'](acc);\n}\n\nfunction _methodReduce(xf, acc, obj, methodName) {\n  return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));\n}\n\nvar symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\n\nfunction _reduce(fn, acc, list) {\n  if (typeof fn === 'function') {\n    fn = _xwrap(fn);\n  }\n\n  if (_isArrayLike(list)) {\n    return _arrayReduce(fn, acc, list);\n  }\n\n  if (typeof list['fantasy-land/reduce'] === 'function') {\n    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');\n  }\n\n  if (list[symIterator] != null) {\n    return _iterableReduce(fn, acc, list[symIterator]());\n  }\n\n  if (typeof list.next === 'function') {\n    return _iterableReduce(fn, acc, list);\n  }\n\n  if (typeof list.reduce === 'function') {\n    return _methodReduce(fn, acc, list, 'reduce');\n  }\n\n  throw new TypeError('reduce: list must be array or iterable');\n}\n\nmodule.exports = _reduce;","module.exports = {\n  init: function () {\n    return this.xf['@@transducer/init']();\n  },\n  result: function (result) {\n    return this.xf['@@transducer/result'](result);\n  }\n};","var _curry2 =\n/*#__PURE__*/\nrequire(\"./_curry2.js\");\n\nvar _xfBase =\n/*#__PURE__*/\nrequire(\"./_xfBase.js\");\n\nvar XMap =\n/*#__PURE__*/\nfunction () {\n  function XMap(f, xf) {\n    this.xf = xf;\n    this.f = f;\n  }\n\n  XMap.prototype['@@transducer/init'] = _xfBase.init;\n  XMap.prototype['@@transducer/result'] = _xfBase.result;\n\n  XMap.prototype['@@transducer/step'] = function (result, input) {\n    return this.xf['@@transducer/step'](result, this.f(input));\n  };\n\n  return XMap;\n}();\n\nvar _xmap =\n/*#__PURE__*/\n_curry2(function _xmap(f, xf) {\n  return new XMap(f, xf);\n});\n\nmodule.exports = _xmap;","var _arity =\n/*#__PURE__*/\nrequire(\"./_arity.js\");\n\nvar _isPlaceholder =\n/*#__PURE__*/\nrequire(\"./_isPlaceholder.js\");\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curryN(length, received, fn) {\n  return function () {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n\n      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n\n      combined[combinedIdx] = result;\n\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n\n      combinedIdx += 1;\n    }\n\n    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n  };\n}\n\nmodule.exports = _curryN;","var _arity =\n/*#__PURE__*/\nrequire(\"./internal/_arity.js\");\n\nvar _curry1 =\n/*#__PURE__*/\nrequire(\"./internal/_curry1.js\");\n\nvar _curry2 =\n/*#__PURE__*/\nrequire(\"./internal/_curry2.js\");\n\nvar _curryN =\n/*#__PURE__*/\nrequire(\"./internal/_curryN.js\");\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      const sumArgs = (...args) => R.sum(args);\n *\n *      const curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      const f = curriedAddFourNumbers(1, 2);\n *      const g = f(3);\n *      g(4); //=> 10\n */\n\n\nvar curryN =\n/*#__PURE__*/\n_curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n\n  return _arity(length, _curryN(length, [], fn));\n});\n\nmodule.exports = curryN;","var _curry2 =\n/*#__PURE__*/\nrequire(\"./internal/_curry2.js\");\n\nvar _dispatchable =\n/*#__PURE__*/\nrequire(\"./internal/_dispatchable.js\");\n\nvar _map =\n/*#__PURE__*/\nrequire(\"./internal/_map.js\");\n\nvar _reduce =\n/*#__PURE__*/\nrequire(\"./internal/_reduce.js\");\n\nvar _xmap =\n/*#__PURE__*/\nrequire(\"./internal/_xmap.js\");\n\nvar curryN =\n/*#__PURE__*/\nrequire(\"./curryN.js\");\n\nvar keys =\n/*#__PURE__*/\nrequire(\"./keys.js\");\n/**\n * Takes a function and\n * a [functor](https://github.com/fantasyland/fantasy-land#functor),\n * applies the function to each of the functor's values, and returns\n * a functor of the same shape.\n *\n * Ramda provides suitable `map` implementations for `Array` and `Object`,\n * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.\n *\n * Dispatches to the `map` method of the second argument, if present.\n *\n * Acts as a transducer if a transformer is given in list position.\n *\n * Also treats functions as functors and will compose them together.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig Functor f => (a -> b) -> f a -> f b\n * @param {Function} fn The function to be called on every element of the input `list`.\n * @param {Array} list The list to be iterated over.\n * @return {Array} The new list.\n * @see R.transduce, R.addIndex, R.pluck, R.project\n * @example\n *\n *      const double = x => x * 2;\n *\n *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]\n *\n *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}\n * @symb R.map(f, [a, b]) = [f(a), f(b)]\n * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }\n * @symb R.map(f, functor_o) = functor_o.map(f)\n */\n\n\nvar map =\n/*#__PURE__*/\n_curry2(\n/*#__PURE__*/\n_dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {\n  switch (Object.prototype.toString.call(functor)) {\n    case '[object Function]':\n      return curryN(functor.length, function () {\n        return fn.call(this, functor.apply(this, arguments));\n      });\n\n    case '[object Object]':\n      return _reduce(function (acc, key) {\n        acc[key] = fn(functor[key]);\n        return acc;\n      }, {}, keys(functor));\n\n    default:\n      return _map(fn, functor);\n  }\n}));\n\nmodule.exports = map;","var _curry2 =\n/*#__PURE__*/\nrequire(\"./internal/_curry2.js\");\n/**\n * Returns a partial copy of an object omitting the keys specified.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @sig [String] -> {String: *} -> {String: *}\n * @param {Array} names an array of String property names to omit from the new object\n * @param {Object} obj The object to copy from\n * @return {Object} A new object with properties from `names` not on it.\n * @see R.pick\n * @example\n *\n *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}\n */\n\n\nvar omit =\n/*#__PURE__*/\n_curry2(function omit(names, obj) {\n  var result = {};\n  var index = {};\n  var idx = 0;\n  var len = names.length;\n\n  while (idx < len) {\n    index[names[idx]] = 1;\n    idx += 1;\n  }\n\n  for (var prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n\n  return result;\n});\n\nmodule.exports = omit;","var _curry2 =\n/*#__PURE__*/\nrequire(\"./internal/_curry2.js\");\n/**\n * Returns a partial copy of an object containing only the keys that satisfy\n * the supplied predicate.\n *\n * @func\n * @memberOf R\n * @since v0.8.0\n * @category Object\n * @sig ((v, k) -> Boolean) -> {k: v} -> {k: v}\n * @param {Function} pred A predicate to determine whether or not a key\n *        should be included on the output object.\n * @param {Object} obj The object to copy from\n * @return {Object} A new object with only properties that satisfy `pred`\n *         on it.\n * @see R.pick, R.filter\n * @example\n *\n *      const isUpperCase = (val, key) => key.toUpperCase() === key;\n *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}\n */\n\n\nvar pickBy =\n/*#__PURE__*/\n_curry2(function pickBy(test, obj) {\n  var result = {};\n\n  for (var prop in obj) {\n    if (test(obj[prop], prop, obj)) {\n      result[prop] = obj[prop];\n    }\n  }\n\n  return result;\n});\n\nmodule.exports = pickBy;","var _curry2 =\n/*#__PURE__*/\nrequire(\"./internal/_curry2.js\");\n/**\n * Returns a partial copy of an object containing only the keys specified. If\n * the key does not exist, the property is ignored.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @sig [k] -> {k: v} -> {k: v}\n * @param {Array} names an array of String property names to copy onto a new object\n * @param {Object} obj The object to copy from\n * @return {Object} A new object with only properties from `names` on it.\n * @see R.omit, R.props\n * @example\n *\n *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}\n */\n\n\nvar pick =\n/*#__PURE__*/\n_curry2(function pick(names, obj) {\n  var result = {};\n  var idx = 0;\n\n  while (idx < names.length) {\n    if (names[idx] in obj) {\n      result[names[idx]] = obj[names[idx]];\n    }\n\n    idx += 1;\n  }\n\n  return result;\n});\n\nmodule.exports = pick;","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertToLockfileFile = convertToLockfileFile;\nexports.convertToLockfileObject = convertToLockfileObject;\nconst dependency_path_1 = require(\"@pnpm/dependency-path\");\nconst types_1 = require(\"@pnpm/types\");\nconst isEmpty_1 = __importDefault(require(\"ramda/src/isEmpty\"));\nconst map_1 = __importDefault(require(\"ramda/src/map\"));\nconst omit_1 = __importDefault(require(\"ramda/src/omit\"));\nconst pickBy_1 = __importDefault(require(\"ramda/src/pickBy\"));\nconst pick_1 = __importDefault(require(\"ramda/src/pick\"));\nconst constants_1 = require(\"@pnpm/constants\");\nfunction convertToLockfileFile(lockfile) {\n    const packages = {};\n    const snapshots = {};\n    for (const [depPath, pkg] of Object.entries(lockfile.packages ?? {})) {\n        snapshots[depPath] = (0, pick_1.default)([\n            'dependencies',\n            'optionalDependencies',\n            'transitivePeerDependencies',\n            'optional',\n            'id',\n        ], pkg);\n        const pkgId = (0, dependency_path_1.removeSuffix)(depPath);\n        if (!packages[pkgId]) {\n            packages[pkgId] = (0, pick_1.default)([\n                'bundledDependencies',\n                'cpu',\n                'deprecated',\n                'engines',\n                'hasBin',\n                'libc',\n                'name',\n                'os',\n                'peerDependencies',\n                'peerDependenciesMeta',\n                'resolution',\n                'version',\n            ], pkg);\n        }\n    }\n    const newLockfile = {\n        ...lockfile,\n        snapshots,\n        packages,\n        lockfileVersion: constants_1.LOCKFILE_VERSION,\n        importers: mapValues(lockfile.importers, convertProjectSnapshotToInlineSpecifiersFormat),\n    };\n    if (newLockfile.settings?.peersSuffixMaxLength === 1000) {\n        newLockfile.settings = (0, omit_1.default)(['peersSuffixMaxLength'], newLockfile.settings);\n    }\n    if (newLockfile.settings?.injectWorkspacePackages === false) {\n        delete newLockfile.settings.injectWorkspacePackages;\n    }\n    return normalizeLockfile(newLockfile);\n}\nfunction normalizeLockfile(lockfile) {\n    const lockfileToSave = {\n        ...lockfile,\n        importers: (0, map_1.default)((importer) => {\n            const normalizedImporter = {};\n            if (importer.dependenciesMeta != null && !(0, isEmpty_1.default)(importer.dependenciesMeta)) {\n                normalizedImporter.dependenciesMeta = importer.dependenciesMeta;\n            }\n            for (const depType of types_1.DEPENDENCIES_FIELDS) {\n                if (!(0, isEmpty_1.default)(importer[depType] ?? {})) {\n                    normalizedImporter[depType] = importer[depType];\n                }\n            }\n            if (importer.publishDirectory) {\n                normalizedImporter.publishDirectory = importer.publishDirectory;\n            }\n            return normalizedImporter;\n        }, lockfile.importers ?? {}),\n    };\n    if ((0, isEmpty_1.default)(lockfileToSave.packages) || (lockfileToSave.packages == null)) {\n        delete lockfileToSave.packages;\n    }\n    if ((0, isEmpty_1.default)(lockfileToSave.snapshots) || (lockfileToSave.snapshots == null)) {\n        delete lockfileToSave.snapshots;\n    }\n    if (lockfileToSave.time) {\n        lockfileToSave.time = pruneTimeInLockfile(lockfileToSave.time, lockfile.importers ?? {});\n    }\n    if ((lockfileToSave.catalogs != null) && (0, isEmpty_1.default)(lockfileToSave.catalogs)) {\n        delete lockfileToSave.catalogs;\n    }\n    if ((lockfileToSave.overrides != null) && (0, isEmpty_1.default)(lockfileToSave.overrides)) {\n        delete lockfileToSave.overrides;\n    }\n    if ((lockfileToSave.patchedDependencies != null) && (0, isEmpty_1.default)(lockfileToSave.patchedDependencies)) {\n        delete lockfileToSave.patchedDependencies;\n    }\n    if (!lockfileToSave.packageExtensionsChecksum) {\n        delete lockfileToSave.packageExtensionsChecksum;\n    }\n    if (!lockfileToSave.ignoredOptionalDependencies?.length) {\n        delete lockfileToSave.ignoredOptionalDependencies;\n    }\n    if (!lockfileToSave.pnpmfileChecksum) {\n        delete lockfileToSave.pnpmfileChecksum;\n    }\n    return lockfileToSave;\n}\nfunction pruneTimeInLockfile(time, importers) {\n    const rootDepPaths = new Set();\n    for (const importer of Object.values(importers)) {\n        for (const depType of types_1.DEPENDENCIES_FIELDS) {\n            for (const [depName, ref] of Object.entries(importer[depType] ?? {})) {\n                const suffixStart = ref.version.indexOf('(');\n                const refWithoutPeerSuffix = suffixStart === -1 ? ref.version : ref.version.slice(0, suffixStart);\n                const depPath = refToRelative(refWithoutPeerSuffix, depName);\n                if (!depPath)\n                    continue;\n                rootDepPaths.add(depPath);\n            }\n        }\n    }\n    return (0, pickBy_1.default)((_, depPath) => rootDepPaths.has(depPath), time);\n}\nfunction refToRelative(reference, pkgName) {\n    if (reference.startsWith('link:')) {\n        return null;\n    }\n    if (reference.startsWith('file:')) {\n        return reference;\n    }\n    if (!reference.includes('/') || !reference.replace(/(?:\\([^)]+\\))+$/, '').includes('/')) {\n        return `/${pkgName}@${reference}`;\n    }\n    return reference;\n}\nfunction convertToLockfileObject(lockfile) {\n    const { importers, ...rest } = lockfile;\n    const packages = {};\n    for (const [depPath, pkg] of Object.entries(lockfile.snapshots ?? {})) {\n        const pkgId = (0, dependency_path_1.removeSuffix)(depPath);\n        packages[depPath] = Object.assign(pkg, lockfile.packages?.[pkgId]);\n    }\n    return {\n        ...(0, omit_1.default)(['snapshots'], rest),\n        packages,\n        importers: mapValues(importers ?? {}, revertProjectSnapshot),\n    };\n}\nfunction convertProjectSnapshotToInlineSpecifiersFormat(projectSnapshot) {\n    const { specifiers, ...rest } = projectSnapshot;\n    if (specifiers == null)\n        return projectSnapshot;\n    const convertBlock = (block) => block != null\n        ? convertResolvedDependenciesToInlineSpecifiersFormat(block, { specifiers })\n        : block;\n    return {\n        ...rest,\n        dependencies: convertBlock(projectSnapshot.dependencies ?? {}),\n        optionalDependencies: convertBlock(projectSnapshot.optionalDependencies ?? {}),\n        devDependencies: convertBlock(projectSnapshot.devDependencies ?? {}),\n    };\n}\nfunction convertResolvedDependenciesToInlineSpecifiersFormat(resolvedDependencies, { specifiers }) {\n    return mapValues(resolvedDependencies, (version, depName) => ({\n        specifier: specifiers[depName],\n        version,\n    }));\n}\nfunction revertProjectSnapshot(from) {\n    const specifiers = {};\n    function moveSpecifiers(from) {\n        const resolvedDependencies = {};\n        for (const [depName, { specifier, version }] of Object.entries(from)) {\n            const existingValue = specifiers[depName];\n            if (existingValue != null && existingValue !== specifier) {\n                throw new Error(`Project snapshot lists the same dependency more than once with conflicting versions: ${depName}`);\n            }\n            specifiers[depName] = specifier;\n            resolvedDependencies[depName] = version;\n        }\n        return resolvedDependencies;\n    }\n    const dependencies = from.dependencies == null\n        ? from.dependencies\n        : moveSpecifiers(from.dependencies);\n    const devDependencies = from.devDependencies == null\n        ? from.devDependencies\n        : moveSpecifiers(from.devDependencies);\n    const optionalDependencies = from.optionalDependencies == null\n        ? from.optionalDependencies\n        : moveSpecifiers(from.optionalDependencies);\n    return {\n        ...from,\n        specifiers,\n        dependencies,\n        devDependencies,\n        optionalDependencies,\n    };\n}\nfunction mapValues(obj, mapper) {\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n        result[key] = mapper(value, key);\n    }\n    return result;\n}\n//# sourceMappingURL=lockfileFormatConverters.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.writeWantedLockfile = writeWantedLockfile;\nexports.writeCurrentLockfile = writeCurrentLockfile;\nexports.writeLockfileFile = writeLockfileFile;\nexports.isEmptyLockfile = isEmptyLockfile;\nexports.writeLockfiles = writeLockfiles;\nconst fs_1 = require(\"fs\");\nconst path_1 = __importDefault(require(\"path\"));\nconst constants_1 = require(\"@pnpm/constants\");\nconst rimraf_1 = __importDefault(require(\"@zkochan/rimraf\"));\nconst js_yaml_1 = __importDefault(require(\"js-yaml\"));\nconst isEmpty_1 = __importDefault(require(\"ramda/src/isEmpty\"));\nconst write_file_atomic_1 = __importDefault(require(\"write-file-atomic\"));\nconst logger_1 = require(\"./logger\");\nconst sortLockfileKeys_1 = require(\"./sortLockfileKeys\");\nconst lockfileName_1 = require(\"./lockfileName\");\nconst lockfileFormatConverters_1 = require(\"./lockfileFormatConverters\");\nasync function writeFileAtomic(filename, data) {\n    return new Promise((resolve, reject) => {\n        (0, write_file_atomic_1.default)(filename, data, {}, (err) => {\n            (err != null) ? reject(err) : resolve();\n        });\n    });\n}\nconst LOCKFILE_YAML_FORMAT = {\n    blankLines: true,\n    lineWidth: -1, // This is setting line width to never wrap\n    noCompatMode: true,\n    noRefs: true,\n    sortKeys: false,\n};\nasync function writeWantedLockfile(pkgPath, wantedLockfile, opts) {\n    const wantedLockfileName = await (0, lockfileName_1.getWantedLockfileName)(opts);\n    return writeLockfile(wantedLockfileName, pkgPath, wantedLockfile);\n}\nasync function writeCurrentLockfile(virtualStoreDir, currentLockfile) {\n    // empty lockfile is not saved\n    if (isEmptyLockfile(currentLockfile)) {\n        await (0, rimraf_1.default)(path_1.default.join(virtualStoreDir, 'lock.yaml'));\n        return;\n    }\n    await fs_1.promises.mkdir(virtualStoreDir, { recursive: true });\n    return writeLockfile('lock.yaml', virtualStoreDir, currentLockfile);\n}\nasync function writeLockfile(lockfileFilename, pkgPath, wantedLockfile) {\n    const lockfilePath = path_1.default.join(pkgPath, lockfileFilename);\n    const lockfileToStringify = (0, lockfileFormatConverters_1.convertToLockfileFile)(wantedLockfile);\n    return writeLockfileFile(lockfilePath, lockfileToStringify);\n}\nfunction writeLockfileFile(lockfilePath, wantedLockfile) {\n    const yamlDoc = yamlStringify(wantedLockfile);\n    return writeFileAtomic(lockfilePath, yamlDoc);\n}\nfunction yamlStringify(lockfile) {\n    const sortedLockfile = (0, sortLockfileKeys_1.sortLockfileKeys)(lockfile);\n    return js_yaml_1.default.dump(sortedLockfile, LOCKFILE_YAML_FORMAT);\n}\nfunction isEmptyLockfile(lockfile) {\n    return Object.values(lockfile.importers).every((importer) => (0, isEmpty_1.default)(importer.specifiers ?? {}) && (0, isEmpty_1.default)(importer.dependencies ?? {}));\n}\nasync function writeLockfiles(opts) {\n    const wantedLockfileName = await (0, lockfileName_1.getWantedLockfileName)(opts);\n    const wantedLockfilePath = path_1.default.join(opts.wantedLockfileDir, wantedLockfileName);\n    const currentLockfilePath = path_1.default.join(opts.currentLockfileDir, 'lock.yaml');\n    const wantedLockfileToStringify = (0, lockfileFormatConverters_1.convertToLockfileFile)(opts.wantedLockfile);\n    const yamlDoc = yamlStringify(wantedLockfileToStringify);\n    // in most cases the `pnpm-lock.yaml` and `node_modules/.pnpm-lock.yaml` are equal\n    // in those cases the YAML document can be stringified only once for both files\n    // which is more efficient\n    if (opts.wantedLockfile === opts.currentLockfile) {\n        await Promise.all([\n            writeFileAtomic(wantedLockfilePath, yamlDoc),\n            (async () => {\n                if (isEmptyLockfile(opts.wantedLockfile)) {\n                    await (0, rimraf_1.default)(currentLockfilePath);\n                }\n                else {\n                    await fs_1.promises.mkdir(path_1.default.dirname(currentLockfilePath), { recursive: true });\n                    await writeFileAtomic(currentLockfilePath, yamlDoc);\n                }\n            })(),\n        ]);\n        return;\n    }\n    logger_1.lockfileLogger.debug({\n        message: `\\`${constants_1.WANTED_LOCKFILE}\\` differs from \\`${path_1.default.relative(opts.wantedLockfileDir, currentLockfilePath)}\\``,\n        prefix: opts.wantedLockfileDir,\n    });\n    const currentLockfileToStringify = (0, lockfileFormatConverters_1.convertToLockfileFile)(opts.currentLockfile);\n    const currentYamlDoc = yamlStringify(currentLockfileToStringify);\n    await Promise.all([\n        writeFileAtomic(wantedLockfilePath, yamlDoc),\n        (async () => {\n            if (isEmptyLockfile(opts.wantedLockfile)) {\n                await (0, rimraf_1.default)(currentLockfilePath);\n            }\n            else {\n                await fs_1.promises.mkdir(path_1.default.dirname(currentLockfilePath), { recursive: true });\n                await writeFileAtomic(currentLockfilePath, currentYamlDoc);\n            }\n        })(),\n    ]);\n}\n//# sourceMappingURL=write.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.existsNonEmptyWantedLockfile = existsNonEmptyWantedLockfile;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst lockfileName_1 = require(\"./lockfileName\");\nasync function existsNonEmptyWantedLockfile(pkgPath, opts = {\n    useGitBranchLockfile: false,\n    mergeGitBranchLockfiles: false,\n}) {\n    const wantedLockfile = await (0, lockfileName_1.getWantedLockfileName)(opts);\n    return new Promise((resolve, reject) => {\n        fs_1.default.access(path_1.default.join(pkgPath, wantedLockfile), (err) => {\n            if (err == null) {\n                resolve(true);\n                return;\n            }\n            if (err.code === 'ENOENT') {\n                resolve(false);\n                return;\n            }\n            reject(err);\n        });\n    });\n}\n//# sourceMappingURL=existsWantedLockfile.js.map","/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nmodule.exports = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LockfileMissingDependencyError = exports.FetchError = exports.PnpmError = void 0;\nconst constants_1 = require(\"@pnpm/constants\");\nclass PnpmError extends Error {\n    constructor(code, message, opts) {\n        super(message);\n        this.code = code.startsWith('ERR_PNPM_') ? code : `ERR_PNPM_${code}`;\n        this.hint = opts?.hint;\n        this.attempts = opts?.attempts;\n    }\n}\nexports.PnpmError = PnpmError;\nclass FetchError extends PnpmError {\n    constructor(request, response, hint) {\n        const _request = {\n            url: request.url,\n        };\n        if (request.authHeaderValue) {\n            _request.authHeaderValue = hideAuthInformation(request.authHeaderValue);\n        }\n        const message = `GET ${request.url}: ${response.statusText} - ${response.status}`;\n        // NOTE: For security reasons, some registries respond with 404 on authentication errors as well.\n        // So we print authorization info on 404 errors as well.\n        if (response.status === 401 || response.status === 403 || response.status === 404) {\n            hint = hint ? `${hint}\\n\\n` : '';\n            if (_request.authHeaderValue) {\n                hint += `An authorization header was used: ${_request.authHeaderValue}`;\n            }\n            else {\n                hint += 'No authorization header was set for the request.';\n            }\n        }\n        super(`FETCH_${response.status}`, message, { hint });\n        this.request = _request;\n        this.response = response;\n    }\n}\nexports.FetchError = FetchError;\nfunction hideAuthInformation(authHeaderValue) {\n    const [authType, token] = authHeaderValue.split(' ');\n    if (token == null)\n        return '[hidden]';\n    if (token.length < 20) {\n        return `${authType} [hidden]`;\n    }\n    return `${authType} ${token.substring(0, 4)}[hidden]`;\n}\nclass LockfileMissingDependencyError extends PnpmError {\n    constructor(depPath) {\n        const message = `Broken lockfile: no entry for '${depPath}' in ${constants_1.WANTED_LOCKFILE}`;\n        super('LOCKFILE_MISSING_DEPENDENCY', message, {\n            hint: 'This issue is probably caused by a badly resolved merge conflict.\\n' +\n                'To fix the lockfile, run \\'pnpm install --no-frozen-lockfile\\'.',\n        });\n    }\n}\nexports.LockfileMissingDependencyError = LockfileMissingDependencyError;\n//# sourceMappingURL=index.js.map","'use strict'\n\nmodule.exports = function comverToSemver (comver) {\n  if (!comver.includes('.')) return `${comver}.0.0`\n  return `${comver}.0`\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeLockfileChanges = mergeLockfileChanges;\nconst comver_to_semver_1 = __importDefault(require(\"comver-to-semver\"));\nconst semver_1 = __importDefault(require(\"semver\"));\nfunction mergeLockfileChanges(ours, theirs) {\n    const newLockfile = {\n        importers: {},\n        lockfileVersion: semver_1.default.gt((0, comver_to_semver_1.default)(theirs.lockfileVersion.toString()), (0, comver_to_semver_1.default)(ours.lockfileVersion.toString()))\n            ? theirs.lockfileVersion\n            : ours.lockfileVersion,\n    };\n    const pnpmfileChecksum = ours.pnpmfileChecksum ?? theirs.pnpmfileChecksum; // Install should automatically detect change later\n    if (pnpmfileChecksum) {\n        newLockfile.pnpmfileChecksum = pnpmfileChecksum;\n    }\n    const ignoredOptionalDependencies = [...new Set([\n            ...ours.ignoredOptionalDependencies ?? [],\n            ...theirs.ignoredOptionalDependencies ?? [],\n        ])];\n    if (ignoredOptionalDependencies.length) {\n        newLockfile.ignoredOptionalDependencies = ignoredOptionalDependencies;\n    }\n    for (const importerId of Array.from(new Set([...Object.keys(ours.importers), ...Object.keys(theirs.importers)]))) {\n        newLockfile.importers[importerId] = {\n            specifiers: {},\n        };\n        for (const key of ['dependencies', 'devDependencies', 'optionalDependencies']) {\n            newLockfile.importers[importerId][key] = mergeDict(ours.importers[importerId]?.[key] ?? {}, theirs.importers[importerId]?.[key] ?? {}, mergeVersions);\n            if (Object.keys(newLockfile.importers[importerId][key] ?? {}).length === 0) {\n                delete newLockfile.importers[importerId][key];\n            }\n        }\n        newLockfile.importers[importerId].specifiers = mergeDict(ours.importers[importerId]?.specifiers ?? {}, theirs.importers[importerId]?.specifiers ?? {}, takeChangedValue);\n    }\n    const packages = {};\n    for (const depPath of (Array.from(new Set([...Object.keys(ours.packages ?? {}), ...Object.keys(theirs.packages ?? {})])))) {\n        const ourPkg = ours.packages?.[depPath];\n        const theirPkg = theirs.packages?.[depPath];\n        const pkg = {\n            ...ourPkg,\n            ...theirPkg,\n        };\n        for (const key of ['dependencies', 'optionalDependencies']) {\n            pkg[key] = mergeDict(ourPkg?.[key] ?? {}, theirPkg?.[key] ?? {}, mergeVersions);\n            if (Object.keys(pkg[key] ?? {}).length === 0) {\n                delete pkg[key];\n            }\n        }\n        packages[depPath] = pkg;\n    }\n    newLockfile.packages = packages;\n    return newLockfile;\n}\nfunction mergeDict(ourDict, theirDict, valueMerger) {\n    const newDict = {};\n    for (const key of Object.keys(ourDict).concat(Object.keys(theirDict))) {\n        const changedValue = valueMerger(ourDict[key], theirDict[key]);\n        if (changedValue) {\n            newDict[key] = changedValue;\n        }\n    }\n    return newDict;\n}\nfunction takeChangedValue(ourValue, theirValue) {\n    if (ourValue === theirValue || theirValue == null)\n        return ourValue;\n    return theirValue;\n}\nfunction mergeVersions(ourValue, theirValue) {\n    if (ourValue === theirValue || !theirValue)\n        return ourValue;\n    if (!ourValue)\n        return theirValue;\n    const [ourVersion] = ourValue.split('(');\n    const [theirVersion] = theirValue.split('(');\n    if (semver_1.default.gt(ourVersion, theirVersion)) {\n        return ourValue;\n    }\n    return theirValue;\n}\n//# sourceMappingURL=index.js.map","'use strict';\n\nmodule.exports = string => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof string}`);\n\t}\n\n\t// Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n\t// conversion translates it to FEFF (UTF-16 BOM)\n\tif (string.charCodeAt(0) === 0xFEFF) {\n\t\treturn string.slice(1);\n\t}\n\n\treturn string;\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.autofixMergeConflicts = autofixMergeConflicts;\nexports.isDiff = isDiff;\nconst lockfile_merger_1 = require(\"@pnpm/lockfile.merger\");\nconst js_yaml_1 = __importDefault(require(\"js-yaml\"));\nconst lockfileFormatConverters_1 = require(\"./lockfileFormatConverters\");\nconst MERGE_CONFLICT_PARENT = '|||||||';\nconst MERGE_CONFLICT_END = '>>>>>>>';\nconst MERGE_CONFLICT_THEIRS = '=======';\nconst MERGE_CONFLICT_OURS = '<<<<<<<';\nfunction autofixMergeConflicts(fileContent) {\n    const { ours, theirs } = parseMergeFile(fileContent);\n    return (0, lockfile_merger_1.mergeLockfileChanges)((0, lockfileFormatConverters_1.convertToLockfileObject)(js_yaml_1.default.load(ours)), (0, lockfileFormatConverters_1.convertToLockfileObject)(js_yaml_1.default.load(theirs)));\n}\nfunction parseMergeFile(fileContent) {\n    const lines = fileContent.split(/[\\n\\r]+/);\n    let state = 'top';\n    const ours = [];\n    const theirs = [];\n    while (lines.length > 0) {\n        const line = lines.shift();\n        if (line.startsWith(MERGE_CONFLICT_PARENT)) {\n            state = 'parent';\n            continue;\n        }\n        if (line.startsWith(MERGE_CONFLICT_OURS)) {\n            state = 'ours';\n            continue;\n        }\n        if (line === MERGE_CONFLICT_THEIRS) {\n            state = 'theirs';\n            continue;\n        }\n        if (line.startsWith(MERGE_CONFLICT_END)) {\n            state = 'top';\n            continue;\n        }\n        if (state === 'top' || state === 'ours')\n            ours.push(line);\n        if (state === 'top' || state === 'theirs')\n            theirs.push(line);\n    }\n    return { ours: ours.join('\\n'), theirs: theirs.join('\\n') };\n}\nfunction isDiff(fileContent) {\n    return fileContent.includes(MERGE_CONFLICT_OURS) &&\n        fileContent.includes(MERGE_CONFLICT_THEIRS) &&\n        fileContent.includes(MERGE_CONFLICT_END);\n}\n//# sourceMappingURL=gitMergeFile.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getGitBranchLockfileNames = getGitBranchLockfileNames;\nexports.cleanGitBranchLockfiles = cleanGitBranchLockfiles;\nconst fs_1 = require(\"fs\");\nconst path_1 = __importDefault(require(\"path\"));\nasync function getGitBranchLockfileNames(lockfileDir) {\n    const files = await fs_1.promises.readdir(lockfileDir);\n    // eslint-disable-next-line regexp/no-useless-non-capturing-group\n    const gitBranchLockfileNames = files.filter(file => file.match(/^pnpm-lock.(?:.*).yaml$/));\n    return gitBranchLockfileNames;\n}\nasync function cleanGitBranchLockfiles(lockfileDir) {\n    const gitBranchLockfiles = await getGitBranchLockfileNames(lockfileDir);\n    await Promise.all(gitBranchLockfiles.map(async (file) => {\n        const filepath = path_1.default.join(lockfileDir, file);\n        await fs_1.promises.unlink(filepath);\n    }));\n}\n//# sourceMappingURL=gitBranchLockfile.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readCurrentLockfile = readCurrentLockfile;\nexports.readWantedLockfileAndAutofixConflicts = readWantedLockfileAndAutofixConflicts;\nexports.readWantedLockfile = readWantedLockfile;\nexports.createLockfileObject = createLockfileObject;\nconst fs_1 = require(\"fs\");\nconst path_1 = __importDefault(require(\"path\"));\nconst util_1 = __importDefault(require(\"util\"));\nconst constants_1 = require(\"@pnpm/constants\");\nconst error_1 = require(\"@pnpm/error\");\nconst lockfile_merger_1 = require(\"@pnpm/lockfile.merger\");\nconst comver_to_semver_1 = __importDefault(require(\"comver-to-semver\"));\nconst js_yaml_1 = __importDefault(require(\"js-yaml\"));\nconst semver_1 = __importDefault(require(\"semver\"));\nconst strip_bom_1 = __importDefault(require(\"strip-bom\"));\nconst errors_1 = require(\"./errors\");\nconst gitMergeFile_1 = require(\"./gitMergeFile\");\nconst logger_1 = require(\"./logger\");\nconst lockfileName_1 = require(\"./lockfileName\");\nconst gitBranchLockfile_1 = require(\"./gitBranchLockfile\");\nconst lockfileFormatConverters_1 = require(\"./lockfileFormatConverters\");\nasync function readCurrentLockfile(virtualStoreDir, opts) {\n    const lockfilePath = path_1.default.join(virtualStoreDir, 'lock.yaml');\n    return (await _read(lockfilePath, virtualStoreDir, opts)).lockfile;\n}\nasync function readWantedLockfileAndAutofixConflicts(pkgPath, opts) {\n    return _readWantedLockfile(pkgPath, {\n        ...opts,\n        autofixMergeConflicts: true,\n    });\n}\nasync function readWantedLockfile(pkgPath, opts) {\n    return (await _readWantedLockfile(pkgPath, opts)).lockfile;\n}\nasync function _read(lockfilePath, prefix, // only for logging\nopts) {\n    let lockfileRawContent;\n    try {\n        lockfileRawContent = (0, strip_bom_1.default)(await fs_1.promises.readFile(lockfilePath, 'utf8'));\n    }\n    catch (err) {\n        if (!(util_1.default.types.isNativeError(err) && 'code' in err && err.code === 'ENOENT')) {\n            throw err;\n        }\n        return {\n            lockfile: null,\n            hadConflicts: false,\n        };\n    }\n    let lockfile;\n    let hadConflicts;\n    try {\n        lockfile = (0, lockfileFormatConverters_1.convertToLockfileObject)(js_yaml_1.default.load(lockfileRawContent)); // eslint-disable-line\n        hadConflicts = false;\n    }\n    catch (err) {\n        if (!opts.autofixMergeConflicts || !(0, gitMergeFile_1.isDiff)(lockfileRawContent)) {\n            throw new error_1.PnpmError('BROKEN_LOCKFILE', `The lockfile at \"${lockfilePath}\" is broken: ${err.message}`);\n        }\n        hadConflicts = true;\n        lockfile = (0, gitMergeFile_1.autofixMergeConflicts)(lockfileRawContent);\n        logger_1.lockfileLogger.info({\n            message: `Merge conflict detected in ${constants_1.WANTED_LOCKFILE} and successfully merged`,\n            prefix,\n        });\n    }\n    if (lockfile) {\n        const lockfileSemver = (0, comver_to_semver_1.default)((lockfile.lockfileVersion ?? 0).toString());\n        if (!opts.wantedVersions ||\n            opts.wantedVersions.length === 0 ||\n            opts.wantedVersions.some((wantedVersion) => {\n                if (semver_1.default.major(lockfileSemver) !== semver_1.default.major((0, comver_to_semver_1.default)(wantedVersion)))\n                    return false;\n                if (lockfile.lockfileVersion !== '6.1' && semver_1.default.gt(lockfileSemver, (0, comver_to_semver_1.default)(wantedVersion))) {\n                    logger_1.lockfileLogger.warn({\n                        message: `Your ${constants_1.WANTED_LOCKFILE} was generated by a newer version of pnpm. ` +\n                            `It is a compatible version but it might get downgraded to version ${wantedVersion}`,\n                        prefix,\n                    });\n                }\n                return true;\n            })) {\n            return { lockfile, hadConflicts };\n        }\n    }\n    if (opts.ignoreIncompatible) {\n        logger_1.lockfileLogger.warn({\n            message: `Ignoring not compatible lockfile at ${lockfilePath}`,\n            prefix,\n        });\n        return { lockfile: null, hadConflicts: false };\n    }\n    throw new errors_1.LockfileBreakingChangeError(lockfilePath);\n}\nfunction createLockfileObject(importerIds, opts) {\n    const importers = {};\n    for (const importerId of importerIds) {\n        importers[importerId] = {\n            dependencies: {},\n            specifiers: {},\n        };\n    }\n    return {\n        importers,\n        lockfileVersion: opts.lockfileVersion || constants_1.LOCKFILE_VERSION,\n        settings: {\n            autoInstallPeers: opts.autoInstallPeers,\n            excludeLinksFromLockfile: opts.excludeLinksFromLockfile,\n            peersSuffixMaxLength: opts.peersSuffixMaxLength,\n        },\n    };\n}\nasync function _readWantedLockfile(pkgPath, opts) {\n    const lockfileNames = [constants_1.WANTED_LOCKFILE];\n    if (opts.useGitBranchLockfile) {\n        const gitBranchLockfileName = await (0, lockfileName_1.getWantedLockfileName)(opts);\n        if (gitBranchLockfileName !== constants_1.WANTED_LOCKFILE) {\n            lockfileNames.unshift(gitBranchLockfileName);\n        }\n    }\n    let result = { lockfile: null, hadConflicts: false };\n    /* eslint-disable no-await-in-loop */\n    for (const lockfileName of lockfileNames) {\n        result = await _read(path_1.default.join(pkgPath, lockfileName), pkgPath, { ...opts, autofixMergeConflicts: true });\n        if (result.lockfile) {\n            if (opts.mergeGitBranchLockfiles) {\n                result.lockfile = await _mergeGitBranchLockfiles(result.lockfile, pkgPath, pkgPath, opts);\n            }\n            break;\n        }\n    }\n    /* eslint-enable no-await-in-loop */\n    return result;\n}\nasync function _mergeGitBranchLockfiles(lockfile, lockfileDir, prefix, opts) {\n    if (!lockfile) {\n        return lockfile;\n    }\n    const gitBranchLockfiles = (await _readGitBranchLockfiles(lockfileDir, prefix, opts)).map(({ lockfile }) => lockfile);\n    let mergedLockfile = lockfile;\n    for (const gitBranchLockfile of gitBranchLockfiles) {\n        if (!gitBranchLockfile) {\n            continue;\n        }\n        mergedLockfile = (0, lockfile_merger_1.mergeLockfileChanges)(mergedLockfile, gitBranchLockfile);\n    }\n    return mergedLockfile;\n}\nasync function _readGitBranchLockfiles(lockfileDir, prefix, opts) {\n    const files = await (0, gitBranchLockfile_1.getGitBranchLockfileNames)(lockfileDir);\n    return Promise.all(files.map((file) => _read(path_1.default.join(lockfileDir, file), prefix, opts)));\n}\n//# sourceMappingURL=read.js.map","module.exports={A:\"ie\",B:\"edge\",C:\"firefox\",D:\"chrome\",E:\"safari\",F:\"opera\",G:\"ios_saf\",H:\"op_mini\",I:\"android\",J:\"bb\",K:\"op_mob\",L:\"and_chr\",M:\"and_ff\",N:\"ie_mob\",O:\"and_uc\",P:\"samsung\",Q:\"and_qq\",R:\"baidu\",S:\"kaios\"};\n","module.exports.browsers = require('../../data/browsers')\n","module.exports={\"0\":\"117\",\"1\":\"20\",\"2\":\"21\",\"3\":\"22\",\"4\":\"23\",\"5\":\"24\",\"6\":\"25\",\"7\":\"26\",\"8\":\"27\",\"9\":\"118\",A:\"10\",B:\"11\",C:\"12\",D:\"7\",E:\"8\",F:\"9\",G:\"15\",H:\"80\",I:\"135\",J:\"4\",K:\"6\",L:\"13\",M:\"14\",N:\"16\",O:\"17\",P:\"18\",Q:\"79\",R:\"81\",S:\"83\",T:\"84\",U:\"85\",V:\"86\",W:\"87\",X:\"88\",Y:\"89\",Z:\"90\",a:\"91\",b:\"92\",c:\"93\",d:\"94\",e:\"95\",f:\"96\",g:\"97\",h:\"98\",i:\"99\",j:\"100\",k:\"101\",l:\"102\",m:\"103\",n:\"104\",o:\"105\",p:\"106\",q:\"107\",r:\"108\",s:\"109\",t:\"110\",u:\"111\",v:\"112\",w:\"113\",x:\"114\",y:\"115\",z:\"116\",AB:\"119\",BB:\"120\",CB:\"121\",DB:\"122\",EB:\"123\",FB:\"124\",GB:\"125\",HB:\"126\",IB:\"127\",JB:\"128\",KB:\"129\",LB:\"130\",MB:\"131\",NB:\"132\",OB:\"133\",PB:\"134\",QB:\"136\",RB:\"5\",SB:\"19\",TB:\"28\",UB:\"29\",VB:\"30\",WB:\"31\",XB:\"32\",YB:\"33\",ZB:\"34\",aB:\"35\",bB:\"36\",cB:\"37\",dB:\"38\",eB:\"39\",fB:\"40\",gB:\"41\",hB:\"42\",iB:\"43\",jB:\"44\",kB:\"45\",lB:\"46\",mB:\"47\",nB:\"48\",oB:\"49\",pB:\"50\",qB:\"51\",rB:\"52\",sB:\"53\",tB:\"54\",uB:\"55\",vB:\"56\",wB:\"57\",xB:\"58\",yB:\"60\",zB:\"62\",\"0B\":\"63\",\"1B\":\"64\",\"2B\":\"65\",\"3B\":\"66\",\"4B\":\"67\",\"5B\":\"68\",\"6B\":\"69\",\"7B\":\"70\",\"8B\":\"71\",\"9B\":\"72\",AC:\"73\",BC:\"74\",CC:\"75\",DC:\"76\",EC:\"77\",FC:\"78\",GC:\"137\",HC:\"11.1\",IC:\"12.1\",JC:\"15.5\",KC:\"16.0\",LC:\"17.0\",MC:\"18.0\",NC:\"3\",OC:\"59\",PC:\"61\",QC:\"82\",RC:\"138\",SC:\"139\",TC:\"3.2\",UC:\"10.1\",VC:\"15.2-15.3\",WC:\"15.4\",XC:\"16.1\",YC:\"16.2\",ZC:\"16.3\",aC:\"16.4\",bC:\"16.5\",cC:\"17.1\",dC:\"17.2\",eC:\"17.3\",fC:\"17.4\",gC:\"17.5\",hC:\"18.1\",iC:\"18.2\",jC:\"18.3\",kC:\"18.4\",lC:\"18.5\",mC:\"11.5\",nC:\"4.2-4.3\",oC:\"5.5\",pC:\"2\",qC:\"140\",rC:\"141\",sC:\"3.5\",tC:\"3.6\",uC:\"3.1\",vC:\"5.1\",wC:\"6.1\",xC:\"7.1\",yC:\"9.1\",zC:\"13.1\",\"0C\":\"14.1\",\"1C\":\"15.1\",\"2C\":\"15.6\",\"3C\":\"16.6\",\"4C\":\"17.6\",\"5C\":\"TP\",\"6C\":\"9.5-9.6\",\"7C\":\"10.0-10.1\",\"8C\":\"10.5\",\"9C\":\"10.6\",AD:\"11.6\",BD:\"4.0-4.1\",CD:\"5.0-5.1\",DD:\"6.0-6.1\",ED:\"7.0-7.1\",FD:\"8.1-8.4\",GD:\"9.0-9.2\",HD:\"9.3\",ID:\"10.0-10.2\",JD:\"10.3\",KD:\"11.0-11.2\",LD:\"11.3-11.4\",MD:\"12.0-12.1\",ND:\"12.2-12.5\",OD:\"13.0-13.1\",PD:\"13.2\",QD:\"13.3\",RD:\"13.4-13.7\",SD:\"14.0-14.4\",TD:\"14.5-14.8\",UD:\"15.0-15.1\",VD:\"15.6-15.8\",WD:\"16.6-16.7\",XD:\"17.6-17.7\",YD:\"all\",ZD:\"2.1\",aD:\"2.2\",bD:\"2.3\",cD:\"4.1\",dD:\"4.4\",eD:\"4.4.3-4.4.4\",fD:\"5.0-5.4\",gD:\"6.2-6.4\",hD:\"7.2-7.4\",iD:\"8.2\",jD:\"9.2\",kD:\"11.1-11.2\",lD:\"12.0\",mD:\"13.0\",nD:\"14.0\",oD:\"15.0\",pD:\"19.0\",qD:\"14.9\",rD:\"13.52\",sD:\"2.5\",tD:\"3.0-3.1\"};\n","module.exports.browserVersions = require('../../data/browserVersions')\n","module.exports={A:{A:{K:0,D:0,E:0,F:0.0324821,A:0,B:0.438508,oC:0},B:\"ms\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"oC\",\"K\",\"D\",\"E\",\"F\",\"A\",\"B\",\"\",\"\",\"\"],E:\"IE\",F:{oC:962323200,K:998870400,D:1161129600,E:1237420800,F:1300060800,A:1346716800,B:1381968000}},B:{A:{\"0\":0.003623,\"9\":0.003623,C:0,L:0,M:0,G:0,N:0,O:0,P:0.097821,Q:0,H:0,R:0,S:0,T:0,U:0,V:0,W:0,X:0,Y:0,Z:0,a:0,b:0.010869,c:0,d:0,e:0,f:0,g:0,h:0,i:0,j:0,k:0,l:0,m:0,n:0,o:0,p:0,q:0,r:0.003623,s:0.047099,t:0,u:0,v:0,w:0.007246,x:0.014492,y:0.007246,z:0,AB:0.003623,BB:0.03623,CB:0.007246,DB:0.014492,EB:0.007246,FB:0.007246,GB:0.007246,HB:0.021738,IB:0.014492,JB:0.014492,KB:0.014492,LB:0.025361,MB:0.065214,NB:0.079706,OB:1.34051,PB:3.0252,I:0,QB:0},B:\"webkit\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"C\",\"L\",\"M\",\"G\",\"N\",\"O\",\"P\",\"Q\",\"H\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"0\",\"9\",\"AB\",\"BB\",\"CB\",\"DB\",\"EB\",\"FB\",\"GB\",\"HB\",\"IB\",\"JB\",\"KB\",\"LB\",\"MB\",\"NB\",\"OB\",\"PB\",\"I\",\"QB\",\"\",\"\"],E:\"Edge\",F:{\"0\":1694649600,\"9\":1697155200,C:1438128000,L:1447286400,M:1470096000,G:1491868800,N:1508198400,O:1525046400,P:1542067200,Q:1579046400,H:1581033600,R:1586736000,S:1590019200,T:1594857600,U:1598486400,V:1602201600,W:1605830400,X:1611360000,Y:1614816000,Z:1618358400,a:1622073600,b:1626912000,c:1630627200,d:1632441600,e:1634774400,f:1637539200,g:1641427200,h:1643932800,i:1646265600,j:1649635200,k:1651190400,l:1653955200,m:1655942400,n:1659657600,o:1661990400,p:1664755200,q:1666915200,r:1670198400,s:1673481600,t:1675900800,u:1678665600,v:1680825600,w:1683158400,x:1685664000,y:1689897600,z:1692576000,AB:1698969600,BB:1701993600,CB:1706227200,DB:1708732800,EB:1711152000,FB:1713398400,GB:1715990400,HB:1718841600,IB:1721865600,JB:1724371200,KB:1726704000,LB:1729123200,MB:1731542400,NB:1737417600,OB:1740614400,PB:1741219200,I:1743984000,QB:null},D:{C:\"ms\",L:\"ms\",M:\"ms\",G:\"ms\",N:\"ms\",O:\"ms\",P:\"ms\"}},C:{A:{\"0\":0,\"1\":0,\"2\":0,\"3\":0,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0.094198,pC:0.007246,NC:0,J:0,RB:0,K:0,D:0,E:0,F:0,A:0,B:0.025361,C:0,L:0,M:0,G:0,N:0,O:0,P:0,SB:0,TB:0,UB:0,VB:0,WB:0,XB:0,YB:0,ZB:0,aB:0,bB:0,cB:0,dB:0,eB:0,fB:0,gB:0,hB:0,iB:0,jB:0.003623,kB:0,lB:0,mB:0,nB:0,oB:0,pB:0,qB:0,rB:0.028984,sB:0.014492,tB:0,uB:0.007246,vB:0.007246,wB:0,xB:0,OC:0.007246,yB:0,PC:0,zB:0,\"0B\":0,\"1B\":0,\"2B\":0,\"3B\":0,\"4B\":0,\"5B\":0,\"6B\":0,\"7B\":0,\"8B\":0,\"9B\":0.003623,AC:0,BC:0,CC:0,DC:0,EC:0,FC:0.010869,Q:0,H:0,R:0,QC:0,S:0,T:0,U:0,V:0,W:0,X:0.007246,Y:0,Z:0,a:0,b:0,c:0,d:0.003623,e:0,f:0,g:0,h:0,i:0,j:0,k:0,l:0,m:0,n:0,o:0,p:0,q:0,r:0,s:0.003623,t:0,u:0,v:0,w:0.003623,x:0,y:0.213757,z:0,AB:0,BB:0.003623,CB:0,DB:0,EB:0,FB:0,GB:0.014492,HB:0,IB:0.007246,JB:0.083329,KB:0,LB:0,MB:0.003623,NB:0.007246,OB:0.018115,PB:0.025361,I:0.347808,QB:1.11951,GC:0.007246,RC:0,SC:0,qC:0,rC:0,sC:0,tC:0},B:\"moz\",C:[\"pC\",\"NC\",\"sC\",\"tC\",\"J\",\"RB\",\"K\",\"D\",\"E\",\"F\",\"A\",\"B\",\"C\",\"L\",\"M\",\"G\",\"N\",\"O\",\"P\",\"SB\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"TB\",\"UB\",\"VB\",\"WB\",\"XB\",\"YB\",\"ZB\",\"aB\",\"bB\",\"cB\",\"dB\",\"eB\",\"fB\",\"gB\",\"hB\",\"iB\",\"jB\",\"kB\",\"lB\",\"mB\",\"nB\",\"oB\",\"pB\",\"qB\",\"rB\",\"sB\",\"tB\",\"uB\",\"vB\",\"wB\",\"xB\",\"OC\",\"yB\",\"PC\",\"zB\",\"0B\",\"1B\",\"2B\",\"3B\",\"4B\",\"5B\",\"6B\",\"7B\",\"8B\",\"9B\",\"AC\",\"BC\",\"CC\",\"DC\",\"EC\",\"FC\",\"Q\",\"H\",\"R\",\"QC\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"0\",\"9\",\"AB\",\"BB\",\"CB\",\"DB\",\"EB\",\"FB\",\"GB\",\"HB\",\"IB\",\"JB\",\"KB\",\"LB\",\"MB\",\"NB\",\"OB\",\"PB\",\"I\",\"QB\",\"GC\",\"RC\",\"SC\",\"qC\",\"rC\"],E:\"Firefox\",F:{\"0\":1693267200,\"1\":1361232000,\"2\":1364860800,\"3\":1368489600,\"4\":1372118400,\"5\":1375747200,\"6\":1379376000,\"7\":1386633600,\"8\":1391472000,\"9\":1695686400,pC:1161648000,NC:1213660800,sC:1246320000,tC:1264032000,J:1300752000,RB:1308614400,K:1313452800,D:1317081600,E:1317081600,F:1320710400,A:1324339200,B:1327968000,C:1331596800,L:1335225600,M:1338854400,G:1342483200,N:1346112000,O:1349740800,P:1353628800,SB:1357603200,TB:1395100800,UB:1398729600,VB:1402358400,WB:1405987200,XB:1409616000,YB:1413244800,ZB:1417392000,aB:1421107200,bB:1424736000,cB:1428278400,dB:1431475200,eB:1435881600,fB:1439251200,gB:1442880000,hB:1446508800,iB:1450137600,jB:1453852800,kB:1457395200,lB:1461628800,mB:1465257600,nB:1470096000,oB:1474329600,pB:1479168000,qB:1485216000,rB:1488844800,sB:1492560000,tB:1497312000,uB:1502150400,vB:1506556800,wB:1510617600,xB:1516665600,OC:1520985600,yB:1525824000,PC:1529971200,zB:1536105600,\"0B\":1540252800,\"1B\":1544486400,\"2B\":1548720000,\"3B\":1552953600,\"4B\":1558396800,\"5B\":1562630400,\"6B\":1567468800,\"7B\":1571788800,\"8B\":1575331200,\"9B\":1578355200,AC:1581379200,BC:1583798400,CC:1586304000,DC:1588636800,EC:1591056000,FC:1593475200,Q:1595894400,H:1598313600,R:1600732800,QC:1603152000,S:1605571200,T:1607990400,U:1611619200,V:1614038400,W:1616457600,X:1618790400,Y:1622505600,Z:1626134400,a:1628553600,b:1630972800,c:1633392000,d:1635811200,e:1638835200,f:1641859200,g:1644364800,h:1646697600,i:1649116800,j:1651536000,k:1653955200,l:1656374400,m:1658793600,n:1661212800,o:1663632000,p:1666051200,q:1668470400,r:1670889600,s:1673913600,t:1676332800,u:1678752000,v:1681171200,w:1683590400,x:1686009600,y:1688428800,z:1690848000,AB:1698105600,BB:1700524800,CB:1702944000,DB:1705968000,EB:1708387200,FB:1710806400,GB:1713225600,HB:1715644800,IB:1718064000,JB:1720483200,KB:1722902400,LB:1725321600,MB:1727740800,NB:1730160000,OB:1732579200,PB:1736208000,I:1738627200,QB:1741046400,GC:1743465600,RC:1745884800,SC:null,qC:null,rC:null}},D:{A:{\"0\":0.094198,\"1\":0,\"2\":0,\"3\":0,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0.057968,J:0,RB:0,K:0,D:0,E:0,F:0,A:0,B:0,C:0,L:0,M:0,G:0,N:0,O:0,P:0,SB:0,TB:0,UB:0,VB:0,WB:0,XB:0,YB:0,ZB:0,aB:0,bB:0,cB:0,dB:0.003623,eB:0.007246,fB:0.003623,gB:0.007246,hB:0.007246,iB:0.007246,jB:0.007246,kB:0.007246,lB:0.003623,mB:0.007246,nB:0.018115,oB:0.018115,pB:0.007246,qB:0.007246,rB:0.010869,sB:0.007246,tB:0.007246,uB:0.007246,vB:0.014492,wB:0.007246,xB:0.010869,OC:0.007246,yB:0.007246,PC:0,zB:0,\"0B\":0,\"1B\":0,\"2B\":0,\"3B\":0.021738,\"4B\":0,\"5B\":0,\"6B\":0.010869,\"7B\":0.010869,\"8B\":0,\"9B\":0,AC:0.007246,BC:0.003623,CC:0.007246,DC:0.003623,EC:0.014492,FC:0.010869,Q:0.068837,H:0.010869,R:0.014492,S:0.028984,T:0.003623,U:0.010869,V:0.014492,W:0.057968,X:0.014492,Y:0.003623,Z:0.007246,a:0.03623,b:0.010869,c:0.014492,d:0.028984,e:0.007246,f:0.007246,g:0.018115,h:0.03623,i:0.010869,j:0.028984,k:0.014492,l:0.014492,m:0.076083,n:0.050722,o:0.010869,p:0.021738,q:0.025361,r:0.039853,s:0.912996,t:0.018115,u:0.03623,v:0.03623,w:0.10869,x:0.054345,y:0.032607,z:0.101444,AB:0.03623,BB:0.086952,CB:0.094198,DB:0.076083,EB:0.086952,FB:0.123182,GB:0.344185,HB:0.152166,IB:0.101444,JB:0.130428,KB:0.101444,LB:0.152166,MB:1.17747,NB:0.815175,OB:5.89462,PB:9.91615,I:0.021738,QB:0.014492,GC:0,RC:0,SC:0},B:\"webkit\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"J\",\"RB\",\"K\",\"D\",\"E\",\"F\",\"A\",\"B\",\"C\",\"L\",\"M\",\"G\",\"N\",\"O\",\"P\",\"SB\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"TB\",\"UB\",\"VB\",\"WB\",\"XB\",\"YB\",\"ZB\",\"aB\",\"bB\",\"cB\",\"dB\",\"eB\",\"fB\",\"gB\",\"hB\",\"iB\",\"jB\",\"kB\",\"lB\",\"mB\",\"nB\",\"oB\",\"pB\",\"qB\",\"rB\",\"sB\",\"tB\",\"uB\",\"vB\",\"wB\",\"xB\",\"OC\",\"yB\",\"PC\",\"zB\",\"0B\",\"1B\",\"2B\",\"3B\",\"4B\",\"5B\",\"6B\",\"7B\",\"8B\",\"9B\",\"AC\",\"BC\",\"CC\",\"DC\",\"EC\",\"FC\",\"Q\",\"H\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"0\",\"9\",\"AB\",\"BB\",\"CB\",\"DB\",\"EB\",\"FB\",\"GB\",\"HB\",\"IB\",\"JB\",\"KB\",\"LB\",\"MB\",\"NB\",\"OB\",\"PB\",\"I\",\"QB\",\"GC\",\"RC\",\"SC\"],E:\"Chrome\",F:{\"0\":1694476800,\"1\":1337040000,\"2\":1340668800,\"3\":1343692800,\"4\":1348531200,\"5\":1352246400,\"6\":1357862400,\"7\":1361404800,\"8\":1364428800,\"9\":1696896000,J:1264377600,RB:1274745600,K:1283385600,D:1287619200,E:1291248000,F:1296777600,A:1299542400,B:1303862400,C:1307404800,L:1312243200,M:1316131200,G:1316131200,N:1319500800,O:1323734400,P:1328659200,SB:1332892800,TB:1369094400,UB:1374105600,VB:1376956800,WB:1384214400,XB:1389657600,YB:1392940800,ZB:1397001600,aB:1400544000,bB:1405468800,cB:1409011200,dB:1412640000,eB:1416268800,fB:1421798400,gB:1425513600,hB:1429401600,iB:1432080000,jB:1437523200,kB:1441152000,lB:1444780800,mB:1449014400,nB:1453248000,oB:1456963200,pB:1460592000,qB:1464134400,rB:1469059200,sB:1472601600,tB:1476230400,uB:1480550400,vB:1485302400,wB:1489017600,xB:1492560000,OC:1496707200,yB:1500940800,PC:1504569600,zB:1508198400,\"0B\":1512518400,\"1B\":1516752000,\"2B\":1520294400,\"3B\":1523923200,\"4B\":1527552000,\"5B\":1532390400,\"6B\":1536019200,\"7B\":1539648000,\"8B\":1543968000,\"9B\":1548720000,AC:1552348800,BC:1555977600,CC:1559606400,DC:1564444800,EC:1568073600,FC:1571702400,Q:1575936000,H:1580860800,R:1586304000,S:1589846400,T:1594684800,U:1598313600,V:1601942400,W:1605571200,X:1611014400,Y:1614556800,Z:1618272000,a:1621987200,b:1626739200,c:1630368000,d:1632268800,e:1634601600,f:1637020800,g:1641340800,h:1643673600,i:1646092800,j:1648512000,k:1650931200,l:1653350400,m:1655769600,n:1659398400,o:1661817600,p:1664236800,q:1666656000,r:1669680000,s:1673308800,t:1675728000,u:1678147200,v:1680566400,w:1682985600,x:1685404800,y:1689724800,z:1692057600,AB:1698710400,BB:1701993600,CB:1705968000,DB:1708387200,EB:1710806400,FB:1713225600,GB:1715644800,HB:1718064000,IB:1721174400,JB:1724112000,KB:1726531200,LB:1728950400,MB:1731369600,NB:1736812800,OB:1738627200,PB:1741046400,I:1743465600,QB:1745884800,GC:null,RC:null,SC:null}},E:{A:{J:0,RB:0,K:0,D:0,E:0,F:0,A:0,B:0,C:0,L:0,M:0.014492,G:0.003623,uC:0,TC:0,vC:0,wC:0,xC:0,yC:0,UC:0,HC:0.007246,IC:0.007246,zC:0.032607,\"0C\":0.043476,\"1C\":0.014492,VC:0.003623,WC:0.010869,JC:0.014492,\"2C\":0.148543,KC:0.032607,XC:0.021738,YC:0.018115,ZC:0.039853,aC:0.014492,bC:0.025361,\"3C\":0.199265,LC:0.010869,cC:0.123182,dC:0.018115,eC:0.021738,fC:0.050722,gC:0.086952,\"4C\":0.264479,MC:0.03623,hC:0.115936,iC:0.057968,jC:1.4021,kC:0.018115,lC:0,\"5C\":0},B:\"webkit\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"uC\",\"TC\",\"J\",\"RB\",\"vC\",\"K\",\"wC\",\"D\",\"xC\",\"E\",\"F\",\"yC\",\"A\",\"UC\",\"B\",\"HC\",\"C\",\"IC\",\"L\",\"zC\",\"M\",\"0C\",\"G\",\"1C\",\"VC\",\"WC\",\"JC\",\"2C\",\"KC\",\"XC\",\"YC\",\"ZC\",\"aC\",\"bC\",\"3C\",\"LC\",\"cC\",\"dC\",\"eC\",\"fC\",\"gC\",\"4C\",\"MC\",\"hC\",\"iC\",\"jC\",\"kC\",\"lC\",\"5C\",\"\"],E:\"Safari\",F:{uC:1205798400,TC:1226534400,J:1244419200,RB:1275868800,vC:1311120000,K:1343174400,wC:1382400000,D:1382400000,xC:1410998400,E:1413417600,F:1443657600,yC:1458518400,A:1474329600,UC:1490572800,B:1505779200,HC:1522281600,C:1537142400,IC:1553472000,L:1568851200,zC:1585008000,M:1600214400,\"0C\":1619395200,G:1632096000,\"1C\":1635292800,VC:1639353600,WC:1647216000,JC:1652745600,\"2C\":1658275200,KC:1662940800,XC:1666569600,YC:1670889600,ZC:1674432000,aC:1679875200,bC:1684368000,\"3C\":1690156800,LC:1695686400,cC:1698192000,dC:1702252800,eC:1705881600,fC:1709596800,gC:1715558400,\"4C\":1722211200,MC:1726444800,hC:1730073600,iC:1733875200,jC:1737936000,kC:1743379200,lC:null,\"5C\":null}},F:{A:{\"0\":0.684747,\"1\":0,\"2\":0,\"3\":0,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,F:0,B:0,C:0,G:0,N:0,O:0,P:0,SB:0,TB:0,UB:0,VB:0,WB:0,XB:0,YB:0,ZB:0,aB:0,bB:0,cB:0,dB:0,eB:0,fB:0.003623,gB:0,hB:0,iB:0,jB:0,kB:0,lB:0.010869,mB:0,nB:0,oB:0,pB:0,qB:0,rB:0,sB:0,tB:0,uB:0,vB:0,wB:0,xB:0,yB:0,zB:0,\"0B\":0,\"1B\":0,\"2B\":0,\"3B\":0,\"4B\":0,\"5B\":0,\"6B\":0,\"7B\":0,\"8B\":0,\"9B\":0,AC:0,BC:0,CC:0,DC:0,EC:0,FC:0,Q:0,H:0,R:0,QC:0,S:0,T:0,U:0,V:0,W:0.025361,X:0.007246,Y:0,Z:0,a:0,b:0,c:0,d:0,e:0.032607,f:0,g:0,h:0,i:0,j:0,k:0,l:0.018115,m:0,n:0,o:0,p:0,q:0,r:0,s:0,t:0,u:0,v:0,w:0,x:0.003623,y:0,z:0.202888,\"6C\":0,\"7C\":0,\"8C\":0,\"9C\":0,HC:0,mC:0,AD:0,IC:0},B:\"webkit\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"F\",\"6C\",\"7C\",\"8C\",\"9C\",\"B\",\"HC\",\"mC\",\"AD\",\"C\",\"IC\",\"G\",\"N\",\"O\",\"P\",\"SB\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"TB\",\"UB\",\"VB\",\"WB\",\"XB\",\"YB\",\"ZB\",\"aB\",\"bB\",\"cB\",\"dB\",\"eB\",\"fB\",\"gB\",\"hB\",\"iB\",\"jB\",\"kB\",\"lB\",\"mB\",\"nB\",\"oB\",\"pB\",\"qB\",\"rB\",\"sB\",\"tB\",\"uB\",\"vB\",\"wB\",\"xB\",\"yB\",\"zB\",\"0B\",\"1B\",\"2B\",\"3B\",\"4B\",\"5B\",\"6B\",\"7B\",\"8B\",\"9B\",\"AC\",\"BC\",\"CC\",\"DC\",\"EC\",\"FC\",\"Q\",\"H\",\"R\",\"QC\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"0\",\"\",\"\",\"\"],E:\"Opera\",F:{\"0\":1739404800,\"1\":1393891200,\"2\":1399334400,\"3\":1401753600,\"4\":1405987200,\"5\":1409616000,\"6\":1413331200,\"7\":1417132800,\"8\":1422316800,F:1150761600,\"6C\":1223424000,\"7C\":1251763200,\"8C\":1267488000,\"9C\":1277942400,B:1292457600,HC:1302566400,mC:1309219200,AD:1323129600,C:1323129600,IC:1352073600,G:1372723200,N:1377561600,O:1381104000,P:1386288000,SB:1390867200,TB:1425945600,UB:1430179200,VB:1433808000,WB:1438646400,XB:1442448000,YB:1445904000,ZB:1449100800,aB:1454371200,bB:1457308800,cB:1462320000,dB:1465344000,eB:1470096000,fB:1474329600,gB:1477267200,hB:1481587200,iB:1486425600,jB:1490054400,kB:1494374400,lB:1498003200,mB:1502236800,nB:1506470400,oB:1510099200,pB:1515024000,qB:1517961600,rB:1521676800,sB:1525910400,tB:1530144000,uB:1534982400,vB:1537833600,wB:1543363200,xB:1548201600,yB:1554768000,zB:1561593600,\"0B\":1566259200,\"1B\":1570406400,\"2B\":1573689600,\"3B\":1578441600,\"4B\":1583971200,\"5B\":1587513600,\"6B\":1592956800,\"7B\":1595894400,\"8B\":1600128000,\"9B\":1603238400,AC:1613520000,BC:1612224000,CC:1616544000,DC:1619568000,EC:1623715200,FC:1627948800,Q:1631577600,H:1633392000,R:1635984000,QC:1638403200,S:1642550400,T:1644969600,U:1647993600,V:1650412800,W:1652745600,X:1654646400,Y:1657152000,Z:1660780800,a:1663113600,b:1668816000,c:1668643200,d:1671062400,e:1675209600,f:1677024000,g:1679529600,h:1681948800,i:1684195200,j:1687219200,k:1690329600,l:1692748800,m:1696204800,n:1699920000,o:1699920000,p:1702944000,q:1707264000,r:1710115200,s:1711497600,t:1716336000,u:1719273600,v:1721088000,w:1724284800,x:1727222400,y:1732665600,z:1736294400},D:{F:\"o\",B:\"o\",C:\"o\",\"6C\":\"o\",\"7C\":\"o\",\"8C\":\"o\",\"9C\":\"o\",HC:\"o\",mC:\"o\",AD:\"o\",IC:\"o\"}},G:{A:{E:0,TC:0,BD:0,nC:0.00289898,CD:0,DD:0.00869695,ED:0.00724746,FD:0,GD:0.00434848,HD:0.0202929,ID:0.00144949,JD:0.0333383,KD:0.153646,LD:0.0101464,MD:0.00579797,ND:0.14205,OD:0.00289898,PD:0.00579797,QD:0.00579797,RD:0.0202929,SD:0.124656,TD:0.0608787,UD:0.0333383,VC:0.0333383,WC:0.0405858,JC:0.0463837,VD:0.568201,KC:0.0797221,XC:0.165242,YC:0.08552,ZC:0.150747,aC:0.0333383,bC:0.0623282,WD:0.672564,LC:0.0405858,cC:0.0724746,dC:0.0550807,eC:0.0768231,fC:0.153646,gC:0.340631,XD:0.988554,MC:0.276853,hC:0.905933,iC:0.405858,jC:8.46503,kC:0.126106,lC:0},B:\"webkit\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"TC\",\"BD\",\"nC\",\"CD\",\"DD\",\"ED\",\"E\",\"FD\",\"GD\",\"HD\",\"ID\",\"JD\",\"KD\",\"LD\",\"MD\",\"ND\",\"OD\",\"PD\",\"QD\",\"RD\",\"SD\",\"TD\",\"UD\",\"VC\",\"WC\",\"JC\",\"VD\",\"KC\",\"XC\",\"YC\",\"ZC\",\"aC\",\"bC\",\"WD\",\"LC\",\"cC\",\"dC\",\"eC\",\"fC\",\"gC\",\"XD\",\"MC\",\"hC\",\"iC\",\"jC\",\"kC\",\"lC\",\"\",\"\"],E:\"Safari on iOS\",F:{TC:1270252800,BD:1283904000,nC:1299628800,CD:1331078400,DD:1359331200,ED:1394409600,E:1410912000,FD:1413763200,GD:1442361600,HD:1458518400,ID:1473724800,JD:1490572800,KD:1505779200,LD:1522281600,MD:1537142400,ND:1553472000,OD:1568851200,PD:1572220800,QD:1580169600,RD:1585008000,SD:1600214400,TD:1619395200,UD:1632096000,VC:1639353600,WC:1647216000,JC:1652659200,VD:1658275200,KC:1662940800,XC:1666569600,YC:1670889600,ZC:1674432000,aC:1679875200,bC:1684368000,WD:1690156800,LC:1694995200,cC:1698192000,dC:1702252800,eC:1705881600,fC:1709596800,gC:1715558400,XD:1722211200,MC:1726444800,hC:1730073600,iC:1733875200,jC:1737936000,kC:1743379200,lC:null}},H:{A:{YD:0.05},B:\"o\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"YD\",\"\",\"\",\"\"],E:\"Opera Mini\",F:{YD:1426464000}},I:{A:{NC:0,J:0,I:0.871727,ZD:0,aD:0,bD:0,cD:0,nC:0.000262095,dD:0,eD:0.000961014},B:\"webkit\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"ZD\",\"aD\",\"bD\",\"NC\",\"J\",\"cD\",\"nC\",\"dD\",\"eD\",\"I\",\"\",\"\",\"\"],E:\"Android Browser\",F:{ZD:1256515200,aD:1274313600,bD:1291593600,NC:1298332800,J:1318896000,cD:1341792000,nC:1374624000,dD:1386547200,eD:1401667200,I:1743379200}},J:{A:{D:0,A:0},B:\"webkit\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"D\",\"A\",\"\",\"\",\"\"],E:\"Blackberry Browser\",F:{D:1325376000,A:1359504000}},K:{A:{A:0,B:0,C:0,H:1.04047,HC:0,mC:0,IC:0},B:\"o\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"A\",\"B\",\"HC\",\"mC\",\"C\",\"IC\",\"H\",\"\",\"\",\"\"],E:\"Opera Mobile\",F:{A:1287100800,B:1300752000,HC:1314835200,mC:1318291200,C:1330300800,IC:1349740800,H:1709769600},D:{H:\"webkit\"}},L:{A:{I:44.6783},B:\"webkit\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"I\",\"\",\"\",\"\"],E:\"Chrome for Android\",F:{I:1743379200}},M:{A:{GC:0.350735},B:\"moz\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"GC\",\"\",\"\",\"\"],E:\"Firefox for Android\",F:{GC:1743465600}},N:{A:{A:0,B:0},B:\"ms\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"A\",\"B\",\"\",\"\",\"\"],E:\"IE Mobile\",F:{A:1340150400,B:1353456000}},O:{A:{JC:0.848141},B:\"webkit\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"JC\",\"\",\"\",\"\"],E:\"UC Browser for Android\",F:{JC:1710115200},D:{JC:\"webkit\"}},P:{A:{\"1\":0,\"2\":0.0219344,\"3\":0.0219344,\"4\":0.0329016,\"5\":0.0438688,\"6\":0.0438688,\"7\":0.0877377,\"8\":1.96313,J:0.0329016,fD:0,gD:0,hD:0.0109672,iD:0,jD:0,UC:0,kD:0,lD:0,mD:0,nD:0,oD:0,KC:0,LC:0.0109672,MC:0,pD:0},B:\"webkit\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"J\",\"fD\",\"gD\",\"hD\",\"iD\",\"jD\",\"UC\",\"kD\",\"lD\",\"mD\",\"nD\",\"oD\",\"KC\",\"LC\",\"MC\",\"pD\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"\",\"\",\"\"],E:\"Samsung Internet\",F:{\"1\":1677369600,\"2\":1684454400,\"3\":1689292800,\"4\":1697587200,\"5\":1711497600,\"6\":1715126400,\"7\":1717718400,\"8\":1725667200,J:1461024000,fD:1481846400,gD:1509408000,hD:1528329600,iD:1546128000,jD:1554163200,UC:1567900800,kD:1582588800,lD:1593475200,mD:1605657600,nD:1618531200,oD:1629072000,KC:1640736000,LC:1651708800,MC:1659657600,pD:1667260800}},Q:{A:{qD:0.229572},B:\"webkit\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"qD\",\"\",\"\",\"\"],E:\"QQ Browser\",F:{qD:1710288000}},R:{A:{rD:0},B:\"webkit\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"rD\",\"\",\"\",\"\"],E:\"Baidu Browser\",F:{rD:1710201600}},S:{A:{sD:0.012754,tD:0},B:\"moz\",C:[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"sD\",\"tD\",\"\",\"\",\"\"],E:\"KaiOS Browser\",F:{sD:1527811200,tD:1631664000}}};\n","'use strict'\n\nconst browsers = require('./browsers').browsers\nconst versions = require('./browserVersions').browserVersions\nconst agentsData = require('../../data/agents')\n\nfunction unpackBrowserVersions(versionsData) {\n  return Object.keys(versionsData).reduce((usage, version) => {\n    usage[versions[version]] = versionsData[version]\n    return usage\n  }, {})\n}\n\nmodule.exports.agents = Object.keys(agentsData).reduce((map, key) => {\n  let versionsData = agentsData[key]\n  map[browsers[key]] = Object.keys(versionsData).reduce((data, entry) => {\n    if (entry === 'A') {\n      data.usage_global = unpackBrowserVersions(versionsData[entry])\n    } else if (entry === 'C') {\n      data.versions = versionsData[entry].reduce((list, version) => {\n        if (version === '') {\n          list.push(null)\n        } else {\n          list.push(versions[version])\n        }\n        return list\n      }, [])\n    } else if (entry === 'D') {\n      data.prefix_exceptions = unpackBrowserVersions(versionsData[entry])\n    } else if (entry === 'E') {\n      data.browser = versionsData[entry]\n    } else if (entry === 'F') {\n      data.release_date = Object.keys(versionsData[entry]).reduce(\n        (map2, key2) => {\n          map2[versions[key2]] = versionsData[entry][key2]\n          return map2\n        },\n        {}\n      )\n    } else {\n      // entry is B\n      data.prefix = versionsData[entry]\n    }\n    return data\n  }, {})\n  return map\n}, {})\n","module.exports = {\n\t\"0.20\": \"39\",\n\t\"0.21\": \"41\",\n\t\"0.22\": \"41\",\n\t\"0.23\": \"41\",\n\t\"0.24\": \"41\",\n\t\"0.25\": \"42\",\n\t\"0.26\": \"42\",\n\t\"0.27\": \"43\",\n\t\"0.28\": \"43\",\n\t\"0.29\": \"43\",\n\t\"0.30\": \"44\",\n\t\"0.31\": \"45\",\n\t\"0.32\": \"45\",\n\t\"0.33\": \"45\",\n\t\"0.34\": \"45\",\n\t\"0.35\": \"45\",\n\t\"0.36\": \"47\",\n\t\"0.37\": \"49\",\n\t\"1.0\": \"49\",\n\t\"1.1\": \"50\",\n\t\"1.2\": \"51\",\n\t\"1.3\": \"52\",\n\t\"1.4\": \"53\",\n\t\"1.5\": \"54\",\n\t\"1.6\": \"56\",\n\t\"1.7\": \"58\",\n\t\"1.8\": \"59\",\n\t\"2.0\": \"61\",\n\t\"2.1\": \"61\",\n\t\"3.0\": \"66\",\n\t\"3.1\": \"66\",\n\t\"4.0\": \"69\",\n\t\"4.1\": \"69\",\n\t\"4.2\": \"69\",\n\t\"5.0\": \"73\",\n\t\"6.0\": \"76\",\n\t\"6.1\": \"76\",\n\t\"7.0\": \"78\",\n\t\"7.1\": \"78\",\n\t\"7.2\": \"78\",\n\t\"7.3\": \"78\",\n\t\"8.0\": \"80\",\n\t\"8.1\": \"80\",\n\t\"8.2\": \"80\",\n\t\"8.3\": \"80\",\n\t\"8.4\": \"80\",\n\t\"8.5\": \"80\",\n\t\"9.0\": \"83\",\n\t\"9.1\": \"83\",\n\t\"9.2\": \"83\",\n\t\"9.3\": \"83\",\n\t\"9.4\": \"83\",\n\t\"10.0\": \"85\",\n\t\"10.1\": \"85\",\n\t\"10.2\": \"85\",\n\t\"10.3\": \"85\",\n\t\"10.4\": \"85\",\n\t\"11.0\": \"87\",\n\t\"11.1\": \"87\",\n\t\"11.2\": \"87\",\n\t\"11.3\": \"87\",\n\t\"11.4\": \"87\",\n\t\"11.5\": \"87\",\n\t\"12.0\": \"89\",\n\t\"12.1\": \"89\",\n\t\"12.2\": \"89\",\n\t\"13.0\": \"91\",\n\t\"13.1\": \"91\",\n\t\"13.2\": \"91\",\n\t\"13.3\": \"91\",\n\t\"13.4\": \"91\",\n\t\"13.5\": \"91\",\n\t\"13.6\": \"91\",\n\t\"14.0\": \"93\",\n\t\"14.1\": \"93\",\n\t\"14.2\": \"93\",\n\t\"15.0\": \"94\",\n\t\"15.1\": \"94\",\n\t\"15.2\": \"94\",\n\t\"15.3\": \"94\",\n\t\"15.4\": \"94\",\n\t\"15.5\": \"94\",\n\t\"16.0\": \"96\",\n\t\"16.1\": \"96\",\n\t\"16.2\": \"96\",\n\t\"17.0\": \"98\",\n\t\"17.1\": \"98\",\n\t\"17.2\": \"98\",\n\t\"17.3\": \"98\",\n\t\"17.4\": \"98\",\n\t\"18.0\": \"100\",\n\t\"18.1\": \"100\",\n\t\"18.2\": \"100\",\n\t\"18.3\": \"100\",\n\t\"19.0\": \"102\",\n\t\"19.1\": \"102\",\n\t\"20.0\": \"104\",\n\t\"20.1\": \"104\",\n\t\"20.2\": \"104\",\n\t\"20.3\": \"104\",\n\t\"21.0\": \"106\",\n\t\"21.1\": \"106\",\n\t\"21.2\": \"106\",\n\t\"21.3\": \"106\",\n\t\"21.4\": \"106\",\n\t\"22.0\": \"108\",\n\t\"22.1\": \"108\",\n\t\"22.2\": \"108\",\n\t\"22.3\": \"108\",\n\t\"23.0\": \"110\",\n\t\"23.1\": \"110\",\n\t\"23.2\": \"110\",\n\t\"23.3\": \"110\",\n\t\"24.0\": \"112\",\n\t\"24.1\": \"112\",\n\t\"24.2\": \"112\",\n\t\"24.3\": \"112\",\n\t\"24.4\": \"112\",\n\t\"24.5\": \"112\",\n\t\"24.6\": \"112\",\n\t\"24.7\": \"112\",\n\t\"24.8\": \"112\",\n\t\"25.0\": \"114\",\n\t\"25.1\": \"114\",\n\t\"25.2\": \"114\",\n\t\"25.3\": \"114\",\n\t\"25.4\": \"114\",\n\t\"25.5\": \"114\",\n\t\"25.6\": \"114\",\n\t\"25.7\": \"114\",\n\t\"25.8\": \"114\",\n\t\"25.9\": \"114\",\n\t\"26.0\": \"116\",\n\t\"26.1\": \"116\",\n\t\"26.2\": \"116\",\n\t\"26.3\": \"116\",\n\t\"26.4\": \"116\",\n\t\"26.5\": \"116\",\n\t\"26.6\": \"116\",\n\t\"27.0\": \"118\",\n\t\"27.1\": \"118\",\n\t\"27.2\": \"118\",\n\t\"27.3\": \"118\",\n\t\"28.0\": \"120\",\n\t\"28.1\": \"120\",\n\t\"28.2\": \"120\",\n\t\"28.3\": \"120\",\n\t\"29.0\": \"122\",\n\t\"29.1\": \"122\",\n\t\"29.2\": \"122\",\n\t\"29.3\": \"122\",\n\t\"29.4\": \"122\",\n\t\"30.0\": \"124\",\n\t\"30.1\": \"124\",\n\t\"30.2\": \"124\",\n\t\"30.3\": \"124\",\n\t\"30.4\": \"124\",\n\t\"30.5\": \"124\",\n\t\"31.0\": \"126\",\n\t\"31.1\": \"126\",\n\t\"31.2\": \"126\",\n\t\"31.3\": \"126\",\n\t\"31.4\": \"126\",\n\t\"31.5\": \"126\",\n\t\"31.6\": \"126\",\n\t\"31.7\": \"126\",\n\t\"32.0\": \"128\",\n\t\"32.1\": \"128\",\n\t\"32.2\": \"128\",\n\t\"32.3\": \"128\",\n\t\"33.0\": \"130\",\n\t\"33.1\": \"130\",\n\t\"33.2\": \"130\",\n\t\"33.3\": \"130\",\n\t\"33.4\": \"130\",\n\t\"34.0\": \"132\",\n\t\"34.1\": \"132\",\n\t\"34.2\": \"132\",\n\t\"34.3\": \"132\",\n\t\"34.4\": \"132\",\n\t\"34.5\": \"132\",\n\t\"35.0\": \"134\",\n\t\"35.1\": \"134\",\n\t\"35.2\": \"134\",\n\t\"36.0\": \"136\",\n\t\"36.1\": \"136\",\n\t\"37.0\": \"138\"\n};","function BrowserslistError(message) {\n  this.name = 'BrowserslistError'\n  this.message = message\n  this.browserslist = true\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, BrowserslistError)\n  }\n}\n\nBrowserslistError.prototype = Error.prototype\n\nmodule.exports = BrowserslistError\n","module.exports = {\n  1: 'ls', // WHATWG Living Standard\n  2: 'rec', // W3C Recommendation\n  3: 'pr', // W3C Proposed Recommendation\n  4: 'cr', // W3C Candidate Recommendation\n  5: 'wd', // W3C Working Draft\n  6: 'other', // Non-W3C, but reputable\n  7: 'unoff' // Unofficial, Editor's Draft or W3C \"Note\"\n}\n","module.exports = {\n  y: 1 << 0,\n  n: 1 << 1,\n  a: 1 << 2,\n  p: 1 << 3,\n  u: 1 << 4,\n  x: 1 << 5,\n  d: 1 << 6\n}\n","'use strict'\n\nconst statuses = require('../lib/statuses')\nconst supported = require('../lib/supported')\nconst browsers = require('./browsers').browsers\nconst versions = require('./browserVersions').browserVersions\n\nconst MATH2LOG = Math.log(2)\n\nfunction unpackSupport(cipher) {\n  // bit flags\n  let stats = Object.keys(supported).reduce((list, support) => {\n    if (cipher & supported[support]) list.push(support)\n    return list\n  }, [])\n\n  // notes\n  let notes = cipher >> 7\n  let notesArray = []\n  while (notes) {\n    let note = Math.floor(Math.log(notes) / MATH2LOG) + 1\n    notesArray.unshift(`#${note}`)\n    notes -= Math.pow(2, note - 1)\n  }\n\n  return stats.concat(notesArray).join(' ')\n}\n\nfunction unpackFeature(packed) {\n  let unpacked = {\n    status: statuses[packed.B],\n    title: packed.C,\n    shown: packed.D\n  }\n  unpacked.stats = Object.keys(packed.A).reduce((browserStats, key) => {\n    let browser = packed.A[key]\n    browserStats[browsers[key]] = Object.keys(browser).reduce(\n      (stats, support) => {\n        let packedVersions = browser[support].split(' ')\n        let unpacked2 = unpackSupport(support)\n        packedVersions.forEach(v => (stats[versions[v]] = unpacked2))\n        return stats\n      },\n      {}\n    )\n    return browserStats\n  }, {})\n  return unpacked\n}\n\nmodule.exports = unpackFeature\nmodule.exports.default = unpackFeature\n","'use strict'\n\nconst browsers = require('./browsers').browsers\n\nfunction unpackRegion(packed) {\n  return Object.keys(packed).reduce((list, browser) => {\n    let data = packed[browser]\n    list[browsers[browser]] = Object.keys(data).reduce((memo, key) => {\n      let stats = data[key]\n      if (key === '_') {\n        stats.split(' ').forEach(version => (memo[version] = null))\n      } else {\n        memo[key] = stats\n      }\n      return memo\n    }, {})\n    return list\n  }, {})\n}\n\nmodule.exports = unpackRegion\nmodule.exports.default = unpackRegion\n","var feature = require('caniuse-lite/dist/unpacker/feature').default\nvar region = require('caniuse-lite/dist/unpacker/region').default\nvar fs = require('fs')\nvar path = require('path')\n\nvar BrowserslistError = require('./error')\n\nvar IS_SECTION = /^\\s*\\[(.+)]\\s*$/\nvar CONFIG_PATTERN = /^browserslist-config-/\nvar SCOPED_CONFIG__PATTERN = /@[^/]+(?:\\/[^/]+)?\\/browserslist-config(?:-|$|\\/)/\nvar FORMAT =\n  'Browserslist config should be a string or an array ' +\n  'of strings with browser queries'\n\nvar dataTimeChecked = false\nvar statCache = {}\nvar configPathCache = {}\nvar parseConfigCache = {}\n\nfunction checkExtend(name) {\n  var use = ' Use `dangerousExtend` option to disable.'\n  if (!CONFIG_PATTERN.test(name) && !SCOPED_CONFIG__PATTERN.test(name)) {\n    throw new BrowserslistError(\n      'Browserslist config needs `browserslist-config-` prefix. ' + use\n    )\n  }\n  if (name.replace(/^@[^/]+\\//, '').indexOf('.') !== -1) {\n    throw new BrowserslistError(\n      '`.` not allowed in Browserslist config name. ' + use\n    )\n  }\n  if (name.indexOf('node_modules') !== -1) {\n    throw new BrowserslistError(\n      '`node_modules` not allowed in Browserslist config.' + use\n    )\n  }\n}\n\nfunction isFile(file) {\n  return fs.existsSync(file) && fs.statSync(file).isFile()\n}\nfunction isDirectory(dir) {\n  return fs.existsSync(dir) && fs.statSync(dir).isDirectory()\n}\n\nfunction eachParent(file, callback, cache) {\n  var loc = path.resolve(file)\n  var pathsForCacheResult = []\n  var result\n  do {\n    if (!pathInRoot(loc)) {\n      break\n    }\n    if (cache && loc in cache) {\n      result = cache[loc]\n      break\n    }\n    pathsForCacheResult.push(loc)\n\n    if (!isDirectory(loc)) {\n      continue\n    }\n\n    var locResult = callback(loc)\n    if (typeof locResult !== 'undefined') {\n      result = locResult\n      break\n    }\n  } while (loc !== (loc = path.dirname(loc)))\n\n  if (cache && !process.env.BROWSERSLIST_DISABLE_CACHE) {\n    pathsForCacheResult.forEach(function (cachePath) {\n      cache[cachePath] = result\n    })\n  }\n  return result\n}\n\nfunction pathInRoot(p) {\n  if (!process.env.BROWSERSLIST_ROOT_PATH) return true\n  var rootPath = path.resolve(process.env.BROWSERSLIST_ROOT_PATH)\n  if (path.relative(rootPath, p).substring(0, 2) === '..') {\n    return false\n  }\n  return true\n}\n\nfunction check(section) {\n  if (Array.isArray(section)) {\n    for (var i = 0; i < section.length; i++) {\n      if (typeof section[i] !== 'string') {\n        throw new BrowserslistError(FORMAT)\n      }\n    }\n  } else if (typeof section !== 'string') {\n    throw new BrowserslistError(FORMAT)\n  }\n}\n\nfunction pickEnv(config, opts) {\n  if (typeof config !== 'object') return config\n\n  var name\n  if (typeof opts.env === 'string') {\n    name = opts.env\n  } else if (process.env.BROWSERSLIST_ENV) {\n    name = process.env.BROWSERSLIST_ENV\n  } else if (process.env.NODE_ENV) {\n    name = process.env.NODE_ENV\n  } else {\n    name = 'production'\n  }\n\n  if (opts.throwOnMissing) {\n    if (name && name !== 'defaults' && !config[name]) {\n      throw new BrowserslistError(\n        'Missing config for Browserslist environment `' + name + '`'\n      )\n    }\n  }\n\n  return config[name] || config.defaults\n}\n\nfunction parsePackage(file) {\n  var text = fs\n    .readFileSync(file)\n    .toString()\n    .replace(/^\\uFEFF/m, '')\n  var list\n  if (text.indexOf('\"browserslist\"') >= 0) {\n    list = JSON.parse(text).browserslist\n  } else if (text.indexOf('\"browserlist\"') >= 0) {\n    var config = JSON.parse(text)\n    if (config.browserlist && !config.browserslist) {\n      throw new BrowserslistError(\n        '`browserlist` key instead of `browserslist` in ' + file\n      )\n    }\n  }\n  if (Array.isArray(list) || typeof list === 'string') {\n    list = { defaults: list }\n  }\n  for (var i in list) {\n    check(list[i])\n  }\n\n  return list\n}\n\nfunction parsePackageOrReadConfig(file) {\n  if (file in parseConfigCache) {\n    return parseConfigCache[file]\n  }\n\n  var isPackage = path.basename(file) === 'package.json'\n  var result = isPackage ? parsePackage(file) : module.exports.readConfig(file)\n\n  if (!process.env.BROWSERSLIST_DISABLE_CACHE) {\n    parseConfigCache[file] = result\n  }\n  return result\n}\n\nfunction latestReleaseTime(agents) {\n  var latest = 0\n  for (var name in agents) {\n    var dates = agents[name].releaseDate || {}\n    for (var key in dates) {\n      if (latest < dates[key]) {\n        latest = dates[key]\n      }\n    }\n  }\n  return latest * 1000\n}\n\nfunction getMonthsPassed(date) {\n  var now = new Date()\n  var past = new Date(date)\n\n  var years = now.getFullYear() - past.getFullYear()\n  var months = now.getMonth() - past.getMonth()\n\n  return years * 12 + months\n}\n\nfunction normalizeStats(data, stats) {\n  if (!data) {\n    data = {}\n  }\n  if (stats && 'dataByBrowser' in stats) {\n    stats = stats.dataByBrowser\n  }\n\n  if (typeof stats !== 'object') return undefined\n\n  var normalized = {}\n  for (var i in stats) {\n    var versions = Object.keys(stats[i])\n    if (versions.length === 1 && data[i] && data[i].versions.length === 1) {\n      var normal = data[i].versions[0]\n      normalized[i] = {}\n      normalized[i][normal] = stats[i][versions[0]]\n    } else {\n      normalized[i] = stats[i]\n    }\n  }\n\n  return normalized\n}\n\nfunction normalizeUsageData(usageData, data) {\n  for (var browser in usageData) {\n    var browserUsage = usageData[browser]\n    // https://github.com/browserslist/browserslist/issues/431#issuecomment-565230615\n    // caniuse-db returns { 0: \"percentage\" } for `and_*` regional stats\n    if ('0' in browserUsage) {\n      var versions = data[browser].versions\n      browserUsage[versions[versions.length - 1]] = browserUsage[0]\n      delete browserUsage[0]\n    }\n  }\n}\n\nmodule.exports = {\n  loadQueries: function loadQueries(ctx, name) {\n    if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {\n      checkExtend(name)\n    }\n    var queries = require(require.resolve(name, { paths: ['.', ctx.path] }))\n    if (typeof queries === 'object' && queries !== null && queries.__esModule) {\n      queries = queries.default\n    }\n    if (queries) {\n      if (Array.isArray(queries)) {\n        return queries\n      } else if (typeof queries === 'object') {\n        if (!queries.defaults) queries.defaults = []\n        return pickEnv(queries, ctx, name)\n      }\n    }\n    throw new BrowserslistError(\n      '`' +\n        name +\n        '` config exports not an array of queries' +\n        ' or an object of envs'\n    )\n  },\n\n  loadStat: function loadStat(ctx, name, data) {\n    if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {\n      checkExtend(name)\n    }\n    var stats = require(require.resolve(\n      path.join(name, 'browserslist-stats.json'),\n      { paths: ['.'] }\n    ))\n    return normalizeStats(data, stats)\n  },\n\n  getStat: function getStat(opts, data) {\n    var stats\n    if (opts.stats) {\n      stats = opts.stats\n    } else if (process.env.BROWSERSLIST_STATS) {\n      stats = process.env.BROWSERSLIST_STATS\n    } else if (opts.path && path.resolve && fs.existsSync) {\n      stats = eachParent(\n        opts.path,\n        function (dir) {\n          var file = path.join(dir, 'browserslist-stats.json')\n          return isFile(file) ? file : undefined\n        },\n        statCache\n      )\n    }\n    if (typeof stats === 'string') {\n      try {\n        stats = JSON.parse(fs.readFileSync(stats))\n      } catch (e) {\n        throw new BrowserslistError(\"Can't read \" + stats)\n      }\n    }\n    return normalizeStats(data, stats)\n  },\n\n  loadConfig: function loadConfig(opts) {\n    if (process.env.BROWSERSLIST) {\n      return process.env.BROWSERSLIST\n    } else if (opts.config || process.env.BROWSERSLIST_CONFIG) {\n      var file = opts.config || process.env.BROWSERSLIST_CONFIG\n      return pickEnv(parsePackageOrReadConfig(file), opts)\n    } else if (opts.path) {\n      return pickEnv(module.exports.findConfig(opts.path), opts)\n    } else {\n      return undefined\n    }\n  },\n\n  loadCountry: function loadCountry(usage, country, data) {\n    var code = country.replace(/[^\\w-]/g, '')\n    if (!usage[code]) {\n      var compressed\n      try {\n        compressed = require('caniuse-lite/data/regions/' + code + '.js')\n      } catch (e) {\n        throw new BrowserslistError('Unknown region name `' + code + '`.')\n      }\n      var usageData = region(compressed)\n      normalizeUsageData(usageData, data)\n      usage[country] = {}\n      for (var i in usageData) {\n        for (var j in usageData[i]) {\n          usage[country][i + ' ' + j] = usageData[i][j]\n        }\n      }\n    }\n  },\n\n  loadFeature: function loadFeature(features, name) {\n    name = name.replace(/[^\\w-]/g, '')\n    if (features[name]) return\n    var compressed\n    try {\n      compressed = require('caniuse-lite/data/features/' + name + '.js')\n    } catch (e) {\n      throw new BrowserslistError('Unknown feature name `' + name + '`.')\n    }\n    var stats = feature(compressed).stats\n    features[name] = {}\n    for (var i in stats) {\n      features[name][i] = {}\n      for (var j in stats[i]) {\n        features[name][i][j] = stats[i][j]\n      }\n    }\n  },\n\n  parseConfig: function parseConfig(string) {\n    var result = { defaults: [] }\n    var sections = ['defaults']\n\n    string\n      .toString()\n      .replace(/#[^\\n]*/g, '')\n      .split(/\\n|,/)\n      .map(function (line) {\n        return line.trim()\n      })\n      .filter(function (line) {\n        return line !== ''\n      })\n      .forEach(function (line) {\n        if (IS_SECTION.test(line)) {\n          sections = line.match(IS_SECTION)[1].trim().split(' ')\n          sections.forEach(function (section) {\n            if (result[section]) {\n              throw new BrowserslistError(\n                'Duplicate section ' + section + ' in Browserslist config'\n              )\n            }\n            result[section] = []\n          })\n        } else {\n          sections.forEach(function (section) {\n            result[section].push(line)\n          })\n        }\n      })\n\n    return result\n  },\n\n  readConfig: function readConfig(file) {\n    if (!isFile(file)) {\n      throw new BrowserslistError(\"Can't read \" + file + ' config')\n    }\n\n    return module.exports.parseConfig(fs.readFileSync(file))\n  },\n\n  findConfigFile: function findConfigFile(from) {\n    return eachParent(\n      from,\n      function (dir) {\n        var config = path.join(dir, 'browserslist')\n        var pkg = path.join(dir, 'package.json')\n        var rc = path.join(dir, '.browserslistrc')\n\n        var pkgBrowserslist\n        if (isFile(pkg)) {\n          try {\n            pkgBrowserslist = parsePackage(pkg)\n          } catch (e) {\n            if (e.name === 'BrowserslistError') throw e\n            console.warn(\n              '[Browserslist] Could not parse ' + pkg + '. Ignoring it.'\n            )\n          }\n        }\n\n        if (isFile(config) && pkgBrowserslist) {\n          throw new BrowserslistError(\n            dir + ' contains both browserslist and package.json with browsers'\n          )\n        } else if (isFile(rc) && pkgBrowserslist) {\n          throw new BrowserslistError(\n            dir +\n              ' contains both .browserslistrc and package.json with browsers'\n          )\n        } else if (isFile(config) && isFile(rc)) {\n          throw new BrowserslistError(\n            dir + ' contains both .browserslistrc and browserslist'\n          )\n        } else if (isFile(config)) {\n          return config\n        } else if (isFile(rc)) {\n          return rc\n        } else if (pkgBrowserslist) {\n          return pkg\n        }\n      },\n      configPathCache\n    )\n  },\n\n  findConfig: function findConfig(from) {\n    var configFile = this.findConfigFile(from)\n\n    return configFile ? parsePackageOrReadConfig(configFile) : undefined\n  },\n\n  clearCaches: function clearCaches() {\n    dataTimeChecked = false\n    statCache = {}\n    configPathCache = {}\n    parseConfigCache = {}\n\n    this.cache = {}\n  },\n\n  oldDataWarning: function oldDataWarning(agentsObj) {\n    if (dataTimeChecked) return\n    dataTimeChecked = true\n    if (process.env.BROWSERSLIST_IGNORE_OLD_DATA) return\n\n    var latest = latestReleaseTime(agentsObj)\n    var monthsPassed = getMonthsPassed(latest)\n\n    if (latest !== 0 && monthsPassed >= 6) {\n      var months = monthsPassed + ' ' + (monthsPassed > 1 ? 'months' : 'month')\n      console.warn(\n        'Browserslist: browsers data (caniuse-lite) is ' +\n          months +\n          ' old. Please run:\\n' +\n          '  npx update-browserslist-db@latest\\n' +\n          '  Why you should do it regularly: ' +\n          'https://github.com/browserslist/update-db#readme'\n      )\n    }\n  },\n\n  currentNode: function currentNode() {\n    return 'node ' + process.versions.node\n  },\n\n  env: process.env\n}\n","var AND_REGEXP = /^\\s+and\\s+(.*)/i\nvar OR_REGEXP = /^(?:,\\s*|\\s+or\\s+)(.*)/i\n\nfunction flatten(array) {\n  if (!Array.isArray(array)) return [array]\n  return array.reduce(function (a, b) {\n    return a.concat(flatten(b))\n  }, [])\n}\n\nfunction find(string, predicate) {\n  for (var max = string.length, n = 1; n <= max; n++) {\n    var parsed = string.substr(-n, n)\n    if (predicate(parsed, n, max)) {\n      return string.slice(0, -n)\n    }\n  }\n  return ''\n}\n\nfunction matchQuery(all, query) {\n  var node = { query: query }\n  if (query.indexOf('not ') === 0) {\n    node.not = true\n    query = query.slice(4)\n  }\n\n  for (var name in all) {\n    var type = all[name]\n    var match = query.match(type.regexp)\n    if (match) {\n      node.type = name\n      for (var i = 0; i < type.matches.length; i++) {\n        node[type.matches[i]] = match[i + 1]\n      }\n      return node\n    }\n  }\n\n  node.type = 'unknown'\n  return node\n}\n\nfunction matchBlock(all, string, qs) {\n  var node\n  return find(string, function (parsed, n, max) {\n    if (AND_REGEXP.test(parsed)) {\n      node = matchQuery(all, parsed.match(AND_REGEXP)[1])\n      node.compose = 'and'\n      qs.unshift(node)\n      return true\n    } else if (OR_REGEXP.test(parsed)) {\n      node = matchQuery(all, parsed.match(OR_REGEXP)[1])\n      node.compose = 'or'\n      qs.unshift(node)\n      return true\n    } else if (n === max) {\n      node = matchQuery(all, parsed.trim())\n      node.compose = 'or'\n      qs.unshift(node)\n      return true\n    }\n    return false\n  })\n}\n\nmodule.exports = function parse(all, queries) {\n  if (!Array.isArray(queries)) queries = [queries]\n  return flatten(\n    queries.map(function (block) {\n      var qs = []\n      do {\n        block = matchBlock(all, block, qs)\n      } while (block)\n      return qs\n    })\n  )\n}\n","var jsReleases = require('node-releases/data/processed/envs.json')\nvar agents = require('caniuse-lite/dist/unpacker/agents').agents\nvar e2c = require('electron-to-chromium/versions')\nvar jsEOL = require('node-releases/data/release-schedule/release-schedule.json')\nvar path = require('path')\n\nvar BrowserslistError = require('./error')\nvar env = require('./node')\nvar parseWithoutCache = require('./parse') // Will load browser.js in webpack\n\nvar YEAR = 365.259641 * 24 * 60 * 60 * 1000\nvar ANDROID_EVERGREEN_FIRST = '37'\nvar OP_MOB_BLINK_FIRST = 14\n\n// Helpers\n\nfunction isVersionsMatch(versionA, versionB) {\n  return (versionA + '.').indexOf(versionB + '.') === 0\n}\n\nfunction isEolReleased(name) {\n  var version = name.slice(1)\n  return browserslist.nodeVersions.some(function (i) {\n    return isVersionsMatch(i, version)\n  })\n}\n\nfunction normalize(versions) {\n  return versions.filter(function (version) {\n    return typeof version === 'string'\n  })\n}\n\nfunction normalizeElectron(version) {\n  var versionToUse = version\n  if (version.split('.').length === 3) {\n    versionToUse = version.split('.').slice(0, -1).join('.')\n  }\n  return versionToUse\n}\n\nfunction nameMapper(name) {\n  return function mapName(version) {\n    return name + ' ' + version\n  }\n}\n\nfunction getMajor(version) {\n  return parseInt(version.split('.')[0])\n}\n\nfunction getMajorVersions(released, number) {\n  if (released.length === 0) return []\n  var majorVersions = uniq(released.map(getMajor))\n  var minimum = majorVersions[majorVersions.length - number]\n  if (!minimum) {\n    return released\n  }\n  var selected = []\n  for (var i = released.length - 1; i >= 0; i--) {\n    if (minimum > getMajor(released[i])) break\n    selected.unshift(released[i])\n  }\n  return selected\n}\n\nfunction uniq(array) {\n  var filtered = []\n  for (var i = 0; i < array.length; i++) {\n    if (filtered.indexOf(array[i]) === -1) filtered.push(array[i])\n  }\n  return filtered\n}\n\nfunction fillUsage(result, name, data) {\n  for (var i in data) {\n    result[name + ' ' + i] = data[i]\n  }\n}\n\nfunction generateFilter(sign, version) {\n  version = parseFloat(version)\n  if (sign === '>') {\n    return function (v) {\n      return parseLatestFloat(v) > version\n    }\n  } else if (sign === '>=') {\n    return function (v) {\n      return parseLatestFloat(v) >= version\n    }\n  } else if (sign === '<') {\n    return function (v) {\n      return parseFloat(v) < version\n    }\n  } else {\n    return function (v) {\n      return parseFloat(v) <= version\n    }\n  }\n\n  function parseLatestFloat(v) {\n    return parseFloat(v.split('-')[1] || v)\n  }\n}\n\nfunction generateSemverFilter(sign, version) {\n  version = version.split('.').map(parseSimpleInt)\n  version[1] = version[1] || 0\n  version[2] = version[2] || 0\n  if (sign === '>') {\n    return function (v) {\n      v = v.split('.').map(parseSimpleInt)\n      return compareSemver(v, version) > 0\n    }\n  } else if (sign === '>=') {\n    return function (v) {\n      v = v.split('.').map(parseSimpleInt)\n      return compareSemver(v, version) >= 0\n    }\n  } else if (sign === '<') {\n    return function (v) {\n      v = v.split('.').map(parseSimpleInt)\n      return compareSemver(version, v) > 0\n    }\n  } else {\n    return function (v) {\n      v = v.split('.').map(parseSimpleInt)\n      return compareSemver(version, v) >= 0\n    }\n  }\n}\n\nfunction parseSimpleInt(x) {\n  return parseInt(x)\n}\n\nfunction compare(a, b) {\n  if (a < b) return -1\n  if (a > b) return +1\n  return 0\n}\n\nfunction compareSemver(a, b) {\n  return (\n    compare(parseInt(a[0]), parseInt(b[0])) ||\n    compare(parseInt(a[1] || '0'), parseInt(b[1] || '0')) ||\n    compare(parseInt(a[2] || '0'), parseInt(b[2] || '0'))\n  )\n}\n\n// this follows the npm-like semver behavior\nfunction semverFilterLoose(operator, range) {\n  range = range.split('.').map(parseSimpleInt)\n  if (typeof range[1] === 'undefined') {\n    range[1] = 'x'\n  }\n  // ignore any patch version because we only return minor versions\n  // range[2] = 'x'\n  switch (operator) {\n    case '<=':\n      return function (version) {\n        version = version.split('.').map(parseSimpleInt)\n        return compareSemverLoose(version, range) <= 0\n      }\n    case '>=':\n    default:\n      return function (version) {\n        version = version.split('.').map(parseSimpleInt)\n        return compareSemverLoose(version, range) >= 0\n      }\n  }\n}\n\n// this follows the npm-like semver behavior\nfunction compareSemverLoose(version, range) {\n  if (version[0] !== range[0]) {\n    return version[0] < range[0] ? -1 : +1\n  }\n  if (range[1] === 'x') {\n    return 0\n  }\n  if (version[1] !== range[1]) {\n    return version[1] < range[1] ? -1 : +1\n  }\n  return 0\n}\n\nfunction resolveVersion(data, version) {\n  if (data.versions.indexOf(version) !== -1) {\n    return version\n  } else if (browserslist.versionAliases[data.name][version]) {\n    return browserslist.versionAliases[data.name][version]\n  } else {\n    return false\n  }\n}\n\nfunction normalizeVersion(data, version) {\n  var resolved = resolveVersion(data, version)\n  if (resolved) {\n    return resolved\n  } else if (data.versions.length === 1) {\n    return data.versions[0]\n  } else {\n    return false\n  }\n}\n\nfunction filterByYear(since, context) {\n  since = since / 1000\n  return Object.keys(agents).reduce(function (selected, name) {\n    var data = byName(name, context)\n    if (!data) return selected\n    var versions = Object.keys(data.releaseDate).filter(function (v) {\n      var date = data.releaseDate[v]\n      return date !== null && date >= since\n    })\n    return selected.concat(versions.map(nameMapper(data.name)))\n  }, [])\n}\n\nfunction cloneData(data) {\n  return {\n    name: data.name,\n    versions: data.versions,\n    released: data.released,\n    releaseDate: data.releaseDate\n  }\n}\n\nfunction byName(name, context) {\n  name = name.toLowerCase()\n  name = browserslist.aliases[name] || name\n  if (context.mobileToDesktop && browserslist.desktopNames[name]) {\n    var desktop = browserslist.data[browserslist.desktopNames[name]]\n    if (name === 'android') {\n      return normalizeAndroidData(cloneData(browserslist.data[name]), desktop)\n    } else {\n      var cloned = cloneData(desktop)\n      cloned.name = name\n      return cloned\n    }\n  }\n  return browserslist.data[name]\n}\n\nfunction normalizeAndroidVersions(androidVersions, chromeVersions) {\n  var iFirstEvergreen = chromeVersions.indexOf(ANDROID_EVERGREEN_FIRST)\n  return androidVersions\n    .filter(function (version) {\n      return /^(?:[2-4]\\.|[34]$)/.test(version)\n    })\n    .concat(chromeVersions.slice(iFirstEvergreen))\n}\n\nfunction copyObject(obj) {\n  var copy = {}\n  for (var key in obj) {\n    copy[key] = obj[key]\n  }\n  return copy\n}\n\nfunction normalizeAndroidData(android, chrome) {\n  android.released = normalizeAndroidVersions(android.released, chrome.released)\n  android.versions = normalizeAndroidVersions(android.versions, chrome.versions)\n  android.releaseDate = copyObject(android.releaseDate)\n  android.released.forEach(function (v) {\n    if (android.releaseDate[v] === undefined) {\n      android.releaseDate[v] = chrome.releaseDate[v]\n    }\n  })\n  return android\n}\n\nfunction checkName(name, context) {\n  var data = byName(name, context)\n  if (!data) throw new BrowserslistError('Unknown browser ' + name)\n  return data\n}\n\nfunction unknownQuery(query) {\n  return new BrowserslistError(\n    'Unknown browser query `' +\n      query +\n      '`. ' +\n      'Maybe you are using old Browserslist or made typo in query.'\n  )\n}\n\n// Adjusts last X versions queries for some mobile browsers,\n// where caniuse data jumps from a legacy version to the latest\nfunction filterJumps(list, name, nVersions, context) {\n  var jump = 1\n  switch (name) {\n    case 'android':\n      if (context.mobileToDesktop) return list\n      var released = browserslist.data.chrome.released\n      jump = released.length - released.indexOf(ANDROID_EVERGREEN_FIRST)\n      break\n    case 'op_mob':\n      var latest = browserslist.data.op_mob.released.slice(-1)[0]\n      jump = getMajor(latest) - OP_MOB_BLINK_FIRST + 1\n      break\n    default:\n      return list\n  }\n  if (nVersions <= jump) {\n    return list.slice(-1)\n  }\n  return list.slice(jump - 1 - nVersions)\n}\n\nfunction isSupported(flags, withPartial) {\n  return (\n    typeof flags === 'string' &&\n    (flags.indexOf('y') >= 0 || (withPartial && flags.indexOf('a') >= 0))\n  )\n}\n\nfunction resolve(queries, context) {\n  return parseQueries(queries).reduce(function (result, node, index) {\n    if (node.not && index === 0) {\n      throw new BrowserslistError(\n        'Write any browsers query (for instance, `defaults`) ' +\n          'before `' +\n          node.query +\n          '`'\n      )\n    }\n    var type = QUERIES[node.type]\n    var array = type.select.call(browserslist, context, node).map(function (j) {\n      var parts = j.split(' ')\n      if (parts[1] === '0') {\n        return parts[0] + ' ' + byName(parts[0], context).versions[0]\n      } else {\n        return j\n      }\n    })\n\n    if (node.compose === 'and') {\n      if (node.not) {\n        return result.filter(function (j) {\n          return array.indexOf(j) === -1\n        })\n      } else {\n        return result.filter(function (j) {\n          return array.indexOf(j) !== -1\n        })\n      }\n    } else {\n      if (node.not) {\n        var filter = {}\n        array.forEach(function (j) {\n          filter[j] = true\n        })\n        return result.filter(function (j) {\n          return !filter[j]\n        })\n      }\n      return result.concat(array)\n    }\n  }, [])\n}\n\nfunction prepareOpts(opts) {\n  if (typeof opts === 'undefined') opts = {}\n\n  if (typeof opts.path === 'undefined') {\n    opts.path = path.resolve ? path.resolve('.') : '.'\n  }\n\n  return opts\n}\n\nfunction prepareQueries(queries, opts) {\n  if (typeof queries === 'undefined' || queries === null) {\n    var config = browserslist.loadConfig(opts)\n    if (config) {\n      queries = config\n    } else {\n      queries = browserslist.defaults\n    }\n  }\n\n  return queries\n}\n\nfunction checkQueries(queries) {\n  if (!(typeof queries === 'string' || Array.isArray(queries))) {\n    throw new BrowserslistError(\n      'Browser queries must be an array or string. Got ' + typeof queries + '.'\n    )\n  }\n}\n\nvar cache = {}\nvar parseCache = {}\n\nfunction browserslist(queries, opts) {\n  opts = prepareOpts(opts)\n  queries = prepareQueries(queries, opts)\n  checkQueries(queries)\n\n  var needsPath = parseQueries(queries).some(function (node) {\n    return QUERIES[node.type].needsPath\n  })\n  var context = {\n    ignoreUnknownVersions: opts.ignoreUnknownVersions,\n    dangerousExtend: opts.dangerousExtend,\n    mobileToDesktop: opts.mobileToDesktop,\n    env: opts.env\n  }\n  // Removing to avoid using context.path without marking query as needsPath\n  if (needsPath) {\n    context.path = opts.path\n  }\n\n  env.oldDataWarning(browserslist.data)\n  var stats = env.getStat(opts, browserslist.data)\n  if (stats) {\n    context.customUsage = {}\n    for (var browser in stats) {\n      fillUsage(context.customUsage, browser, stats[browser])\n    }\n  }\n\n  var cacheKey = JSON.stringify([queries, context])\n  if (cache[cacheKey]) return cache[cacheKey]\n\n  var result = uniq(resolve(queries, context)).sort(function (name1, name2) {\n    name1 = name1.split(' ')\n    name2 = name2.split(' ')\n    if (name1[0] === name2[0]) {\n      // assumptions on caniuse data\n      // 1) version ranges never overlaps\n      // 2) if version is not a range, it never contains `-`\n      var version1 = name1[1].split('-')[0]\n      var version2 = name2[1].split('-')[0]\n      return compareSemver(version2.split('.'), version1.split('.'))\n    } else {\n      return compare(name1[0], name2[0])\n    }\n  })\n  if (!env.env.BROWSERSLIST_DISABLE_CACHE) {\n    cache[cacheKey] = result\n  }\n  return result\n}\n\nfunction parseQueries(queries) {\n  var cacheKey = JSON.stringify(queries)\n  if (cacheKey in parseCache) return parseCache[cacheKey]\n  var result = parseWithoutCache(QUERIES, queries)\n  if (!env.env.BROWSERSLIST_DISABLE_CACHE) {\n    parseCache[cacheKey] = result\n  }\n  return result\n}\n\nbrowserslist.parse = function (queries, opts) {\n  opts = prepareOpts(opts)\n  queries = prepareQueries(queries, opts)\n  checkQueries(queries)\n  return parseQueries(queries)\n}\n\n// Will be filled by Can I Use data below\nbrowserslist.cache = {}\nbrowserslist.data = {}\nbrowserslist.usage = {\n  global: {},\n  custom: null\n}\n\n// Default browsers query\nbrowserslist.defaults = ['> 0.5%', 'last 2 versions', 'Firefox ESR', 'not dead']\n\n// Browser names aliases\nbrowserslist.aliases = {\n  fx: 'firefox',\n  ff: 'firefox',\n  ios: 'ios_saf',\n  explorer: 'ie',\n  blackberry: 'bb',\n  explorermobile: 'ie_mob',\n  operamini: 'op_mini',\n  operamobile: 'op_mob',\n  chromeandroid: 'and_chr',\n  firefoxandroid: 'and_ff',\n  ucandroid: 'and_uc',\n  qqandroid: 'and_qq'\n}\n\n// Can I Use only provides a few versions for some browsers (e.g. and_chr).\n// Fallback to a similar browser for unknown versions\n// Note op_mob is not included as its chromium versions are not in sync with Opera desktop\nbrowserslist.desktopNames = {\n  and_chr: 'chrome',\n  and_ff: 'firefox',\n  ie_mob: 'ie',\n  android: 'chrome' // has extra processing logic\n}\n\n// Aliases to work with joined versions like `ios_saf 7.0-7.1`\nbrowserslist.versionAliases = {}\n\nbrowserslist.clearCaches = env.clearCaches\nbrowserslist.parseConfig = env.parseConfig\nbrowserslist.readConfig = env.readConfig\nbrowserslist.findConfigFile = env.findConfigFile\nbrowserslist.findConfig = env.findConfig\nbrowserslist.loadConfig = env.loadConfig\n\nbrowserslist.coverage = function (browsers, stats) {\n  var data\n  if (typeof stats === 'undefined') {\n    data = browserslist.usage.global\n  } else if (stats === 'my stats') {\n    var opts = {}\n    opts.path = path.resolve ? path.resolve('.') : '.'\n    var customStats = env.getStat(opts)\n    if (!customStats) {\n      throw new BrowserslistError('Custom usage statistics was not provided')\n    }\n    data = {}\n    for (var browser in customStats) {\n      fillUsage(data, browser, customStats[browser])\n    }\n  } else if (typeof stats === 'string') {\n    if (stats.length > 2) {\n      stats = stats.toLowerCase()\n    } else {\n      stats = stats.toUpperCase()\n    }\n    env.loadCountry(browserslist.usage, stats, browserslist.data)\n    data = browserslist.usage[stats]\n  } else {\n    if ('dataByBrowser' in stats) {\n      stats = stats.dataByBrowser\n    }\n    data = {}\n    for (var name in stats) {\n      for (var version in stats[name]) {\n        data[name + ' ' + version] = stats[name][version]\n      }\n    }\n  }\n\n  return browsers.reduce(function (all, i) {\n    var usage = data[i]\n    if (usage === undefined) {\n      usage = data[i.replace(/ \\S+$/, ' 0')]\n    }\n    return all + (usage || 0)\n  }, 0)\n}\n\nfunction nodeQuery(context, node) {\n  var matched = browserslist.nodeVersions.filter(function (i) {\n    return isVersionsMatch(i, node.version)\n  })\n  if (matched.length === 0) {\n    if (context.ignoreUnknownVersions) {\n      return []\n    } else {\n      throw new BrowserslistError(\n        'Unknown version ' + node.version + ' of Node.js'\n      )\n    }\n  }\n  return ['node ' + matched[matched.length - 1]]\n}\n\nfunction sinceQuery(context, node) {\n  var year = parseInt(node.year)\n  var month = parseInt(node.month || '01') - 1\n  var day = parseInt(node.day || '01')\n  return filterByYear(Date.UTC(year, month, day, 0, 0, 0), context)\n}\n\nfunction coverQuery(context, node) {\n  var coverage = parseFloat(node.coverage)\n  var usage = browserslist.usage.global\n  if (node.place) {\n    if (node.place.match(/^my\\s+stats$/i)) {\n      if (!context.customUsage) {\n        throw new BrowserslistError('Custom usage statistics was not provided')\n      }\n      usage = context.customUsage\n    } else {\n      var place\n      if (node.place.length === 2) {\n        place = node.place.toUpperCase()\n      } else {\n        place = node.place.toLowerCase()\n      }\n      env.loadCountry(browserslist.usage, place, browserslist.data)\n      usage = browserslist.usage[place]\n    }\n  }\n  var versions = Object.keys(usage).sort(function (a, b) {\n    return usage[b] - usage[a]\n  })\n  var coveraged = 0\n  var result = []\n  var version\n  for (var i = 0; i < versions.length; i++) {\n    version = versions[i]\n    if (usage[version] === 0) break\n    coveraged += usage[version]\n    result.push(version)\n    if (coveraged >= coverage) break\n  }\n  return result\n}\n\nvar QUERIES = {\n  last_major_versions: {\n    matches: ['versions'],\n    regexp: /^last\\s+(\\d+)\\s+major\\s+versions?$/i,\n    select: function (context, node) {\n      return Object.keys(agents).reduce(function (selected, name) {\n        var data = byName(name, context)\n        if (!data) return selected\n        var list = getMajorVersions(data.released, node.versions)\n        list = list.map(nameMapper(data.name))\n        list = filterJumps(list, data.name, node.versions, context)\n        return selected.concat(list)\n      }, [])\n    }\n  },\n  last_versions: {\n    matches: ['versions'],\n    regexp: /^last\\s+(\\d+)\\s+versions?$/i,\n    select: function (context, node) {\n      return Object.keys(agents).reduce(function (selected, name) {\n        var data = byName(name, context)\n        if (!data) return selected\n        var list = data.released.slice(-node.versions)\n        list = list.map(nameMapper(data.name))\n        list = filterJumps(list, data.name, node.versions, context)\n        return selected.concat(list)\n      }, [])\n    }\n  },\n  last_electron_major_versions: {\n    matches: ['versions'],\n    regexp: /^last\\s+(\\d+)\\s+electron\\s+major\\s+versions?$/i,\n    select: function (context, node) {\n      var validVersions = getMajorVersions(Object.keys(e2c), node.versions)\n      return validVersions.map(function (i) {\n        return 'chrome ' + e2c[i]\n      })\n    }\n  },\n  last_node_major_versions: {\n    matches: ['versions'],\n    regexp: /^last\\s+(\\d+)\\s+node\\s+major\\s+versions?$/i,\n    select: function (context, node) {\n      return getMajorVersions(browserslist.nodeVersions, node.versions).map(\n        function (version) {\n          return 'node ' + version\n        }\n      )\n    }\n  },\n  last_browser_major_versions: {\n    matches: ['versions', 'browser'],\n    regexp: /^last\\s+(\\d+)\\s+(\\w+)\\s+major\\s+versions?$/i,\n    select: function (context, node) {\n      var data = checkName(node.browser, context)\n      var validVersions = getMajorVersions(data.released, node.versions)\n      var list = validVersions.map(nameMapper(data.name))\n      list = filterJumps(list, data.name, node.versions, context)\n      return list\n    }\n  },\n  last_electron_versions: {\n    matches: ['versions'],\n    regexp: /^last\\s+(\\d+)\\s+electron\\s+versions?$/i,\n    select: function (context, node) {\n      return Object.keys(e2c)\n        .slice(-node.versions)\n        .map(function (i) {\n          return 'chrome ' + e2c[i]\n        })\n    }\n  },\n  last_node_versions: {\n    matches: ['versions'],\n    regexp: /^last\\s+(\\d+)\\s+node\\s+versions?$/i,\n    select: function (context, node) {\n      return browserslist.nodeVersions\n        .slice(-node.versions)\n        .map(function (version) {\n          return 'node ' + version\n        })\n    }\n  },\n  last_browser_versions: {\n    matches: ['versions', 'browser'],\n    regexp: /^last\\s+(\\d+)\\s+(\\w+)\\s+versions?$/i,\n    select: function (context, node) {\n      var data = checkName(node.browser, context)\n      var list = data.released.slice(-node.versions).map(nameMapper(data.name))\n      list = filterJumps(list, data.name, node.versions, context)\n      return list\n    }\n  },\n  unreleased_versions: {\n    matches: [],\n    regexp: /^unreleased\\s+versions$/i,\n    select: function (context) {\n      return Object.keys(agents).reduce(function (selected, name) {\n        var data = byName(name, context)\n        if (!data) return selected\n        var list = data.versions.filter(function (v) {\n          return data.released.indexOf(v) === -1\n        })\n        list = list.map(nameMapper(data.name))\n        return selected.concat(list)\n      }, [])\n    }\n  },\n  unreleased_electron_versions: {\n    matches: [],\n    regexp: /^unreleased\\s+electron\\s+versions?$/i,\n    select: function () {\n      return []\n    }\n  },\n  unreleased_browser_versions: {\n    matches: ['browser'],\n    regexp: /^unreleased\\s+(\\w+)\\s+versions?$/i,\n    select: function (context, node) {\n      var data = checkName(node.browser, context)\n      return data.versions\n        .filter(function (v) {\n          return data.released.indexOf(v) === -1\n        })\n        .map(nameMapper(data.name))\n    }\n  },\n  last_years: {\n    matches: ['years'],\n    regexp: /^last\\s+(\\d*.?\\d+)\\s+years?$/i,\n    select: function (context, node) {\n      return filterByYear(Date.now() - YEAR * node.years, context)\n    }\n  },\n  since_y: {\n    matches: ['year'],\n    regexp: /^since (\\d+)$/i,\n    select: sinceQuery\n  },\n  since_y_m: {\n    matches: ['year', 'month'],\n    regexp: /^since (\\d+)-(\\d+)$/i,\n    select: sinceQuery\n  },\n  since_y_m_d: {\n    matches: ['year', 'month', 'day'],\n    regexp: /^since (\\d+)-(\\d+)-(\\d+)$/i,\n    select: sinceQuery\n  },\n  popularity: {\n    matches: ['sign', 'popularity'],\n    regexp: /^(>=?|<=?)\\s*(\\d+|\\d+\\.\\d+|\\.\\d+)%$/,\n    select: function (context, node) {\n      var popularity = parseFloat(node.popularity)\n      var usage = browserslist.usage.global\n      return Object.keys(usage).reduce(function (result, version) {\n        if (node.sign === '>') {\n          if (usage[version] > popularity) {\n            result.push(version)\n          }\n        } else if (node.sign === '<') {\n          if (usage[version] < popularity) {\n            result.push(version)\n          }\n        } else if (node.sign === '<=') {\n          if (usage[version] <= popularity) {\n            result.push(version)\n          }\n        } else if (usage[version] >= popularity) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  popularity_in_my_stats: {\n    matches: ['sign', 'popularity'],\n    regexp: /^(>=?|<=?)\\s*(\\d+|\\d+\\.\\d+|\\.\\d+)%\\s+in\\s+my\\s+stats$/,\n    select: function (context, node) {\n      var popularity = parseFloat(node.popularity)\n      if (!context.customUsage) {\n        throw new BrowserslistError('Custom usage statistics was not provided')\n      }\n      var usage = context.customUsage\n      return Object.keys(usage).reduce(function (result, version) {\n        var percentage = usage[version]\n        if (percentage == null) {\n          return result\n        }\n\n        if (node.sign === '>') {\n          if (percentage > popularity) {\n            result.push(version)\n          }\n        } else if (node.sign === '<') {\n          if (percentage < popularity) {\n            result.push(version)\n          }\n        } else if (node.sign === '<=') {\n          if (percentage <= popularity) {\n            result.push(version)\n          }\n        } else if (percentage >= popularity) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  popularity_in_config_stats: {\n    matches: ['sign', 'popularity', 'config'],\n    regexp: /^(>=?|<=?)\\s*(\\d+|\\d+\\.\\d+|\\.\\d+)%\\s+in\\s+(\\S+)\\s+stats$/,\n    select: function (context, node) {\n      var popularity = parseFloat(node.popularity)\n      var stats = env.loadStat(context, node.config, browserslist.data)\n      if (stats) {\n        context.customUsage = {}\n        for (var browser in stats) {\n          fillUsage(context.customUsage, browser, stats[browser])\n        }\n      }\n      if (!context.customUsage) {\n        throw new BrowserslistError('Custom usage statistics was not provided')\n      }\n      var usage = context.customUsage\n      return Object.keys(usage).reduce(function (result, version) {\n        var percentage = usage[version]\n        if (percentage == null) {\n          return result\n        }\n\n        if (node.sign === '>') {\n          if (percentage > popularity) {\n            result.push(version)\n          }\n        } else if (node.sign === '<') {\n          if (percentage < popularity) {\n            result.push(version)\n          }\n        } else if (node.sign === '<=') {\n          if (percentage <= popularity) {\n            result.push(version)\n          }\n        } else if (percentage >= popularity) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  popularity_in_place: {\n    matches: ['sign', 'popularity', 'place'],\n    regexp: /^(>=?|<=?)\\s*(\\d+|\\d+\\.\\d+|\\.\\d+)%\\s+in\\s+((alt-)?\\w\\w)$/,\n    select: function (context, node) {\n      var popularity = parseFloat(node.popularity)\n      var place = node.place\n      if (place.length === 2) {\n        place = place.toUpperCase()\n      } else {\n        place = place.toLowerCase()\n      }\n      env.loadCountry(browserslist.usage, place, browserslist.data)\n      var usage = browserslist.usage[place]\n      return Object.keys(usage).reduce(function (result, version) {\n        var percentage = usage[version]\n        if (percentage == null) {\n          return result\n        }\n\n        if (node.sign === '>') {\n          if (percentage > popularity) {\n            result.push(version)\n          }\n        } else if (node.sign === '<') {\n          if (percentage < popularity) {\n            result.push(version)\n          }\n        } else if (node.sign === '<=') {\n          if (percentage <= popularity) {\n            result.push(version)\n          }\n        } else if (percentage >= popularity) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  cover: {\n    matches: ['coverage'],\n    regexp: /^cover\\s+(\\d+|\\d+\\.\\d+|\\.\\d+)%$/i,\n    select: coverQuery\n  },\n  cover_in: {\n    matches: ['coverage', 'place'],\n    regexp: /^cover\\s+(\\d+|\\d+\\.\\d+|\\.\\d+)%\\s+in\\s+(my\\s+stats|(alt-)?\\w\\w)$/i,\n    select: coverQuery\n  },\n  supports: {\n    matches: ['supportType', 'feature'],\n    regexp: /^(?:(fully|partially)\\s+)?supports\\s+([\\w-]+)$/,\n    select: function (context, node) {\n      env.loadFeature(browserslist.cache, node.feature)\n      var withPartial = node.supportType !== 'fully'\n      var features = browserslist.cache[node.feature]\n      var result = []\n      for (var name in features) {\n        var data = byName(name, context)\n        // Only check desktop when latest released mobile has support\n        var iMax = data.released.length - 1\n        while (iMax >= 0) {\n          if (data.released[iMax] in features[name]) break\n          iMax--\n        }\n        var checkDesktop =\n          context.mobileToDesktop &&\n          name in browserslist.desktopNames &&\n          isSupported(features[name][data.released[iMax]], withPartial)\n        data.versions.forEach(function (version) {\n          var flags = features[name][version]\n          if (flags === undefined && checkDesktop) {\n            flags = features[browserslist.desktopNames[name]][version]\n          }\n          if (isSupported(flags, withPartial)) {\n            result.push(name + ' ' + version)\n          }\n        })\n      }\n      return result\n    }\n  },\n  electron_range: {\n    matches: ['from', 'to'],\n    regexp: /^electron\\s+([\\d.]+)\\s*-\\s*([\\d.]+)$/i,\n    select: function (context, node) {\n      var fromToUse = normalizeElectron(node.from)\n      var toToUse = normalizeElectron(node.to)\n      var from = parseFloat(node.from)\n      var to = parseFloat(node.to)\n      if (!e2c[fromToUse]) {\n        throw new BrowserslistError('Unknown version ' + from + ' of electron')\n      }\n      if (!e2c[toToUse]) {\n        throw new BrowserslistError('Unknown version ' + to + ' of electron')\n      }\n      return Object.keys(e2c)\n        .filter(function (i) {\n          var parsed = parseFloat(i)\n          return parsed >= from && parsed <= to\n        })\n        .map(function (i) {\n          return 'chrome ' + e2c[i]\n        })\n    }\n  },\n  node_range: {\n    matches: ['from', 'to'],\n    regexp: /^node\\s+([\\d.]+)\\s*-\\s*([\\d.]+)$/i,\n    select: function (context, node) {\n      return browserslist.nodeVersions\n        .filter(semverFilterLoose('>=', node.from))\n        .filter(semverFilterLoose('<=', node.to))\n        .map(function (v) {\n          return 'node ' + v\n        })\n    }\n  },\n  browser_range: {\n    matches: ['browser', 'from', 'to'],\n    regexp: /^(\\w+)\\s+([\\d.]+)\\s*-\\s*([\\d.]+)$/i,\n    select: function (context, node) {\n      var data = checkName(node.browser, context)\n      var from = parseFloat(normalizeVersion(data, node.from) || node.from)\n      var to = parseFloat(normalizeVersion(data, node.to) || node.to)\n      function filter(v) {\n        var parsed = parseFloat(v)\n        return parsed >= from && parsed <= to\n      }\n      return data.released.filter(filter).map(nameMapper(data.name))\n    }\n  },\n  electron_ray: {\n    matches: ['sign', 'version'],\n    regexp: /^electron\\s*(>=?|<=?)\\s*([\\d.]+)$/i,\n    select: function (context, node) {\n      var versionToUse = normalizeElectron(node.version)\n      return Object.keys(e2c)\n        .filter(generateFilter(node.sign, versionToUse))\n        .map(function (i) {\n          return 'chrome ' + e2c[i]\n        })\n    }\n  },\n  node_ray: {\n    matches: ['sign', 'version'],\n    regexp: /^node\\s*(>=?|<=?)\\s*([\\d.]+)$/i,\n    select: function (context, node) {\n      return browserslist.nodeVersions\n        .filter(generateSemverFilter(node.sign, node.version))\n        .map(function (v) {\n          return 'node ' + v\n        })\n    }\n  },\n  browser_ray: {\n    matches: ['browser', 'sign', 'version'],\n    regexp: /^(\\w+)\\s*(>=?|<=?)\\s*([\\d.]+)$/,\n    select: function (context, node) {\n      var version = node.version\n      var data = checkName(node.browser, context)\n      var alias = browserslist.versionAliases[data.name][version]\n      if (alias) version = alias\n      return data.released\n        .filter(generateFilter(node.sign, version))\n        .map(function (v) {\n          return data.name + ' ' + v\n        })\n    }\n  },\n  firefox_esr: {\n    matches: [],\n    regexp: /^(firefox|ff|fx)\\s+esr$/i,\n    select: function () {\n      return ['firefox 128']\n    }\n  },\n  opera_mini_all: {\n    matches: [],\n    regexp: /(operamini|op_mini)\\s+all/i,\n    select: function () {\n      return ['op_mini all']\n    }\n  },\n  electron_version: {\n    matches: ['version'],\n    regexp: /^electron\\s+([\\d.]+)$/i,\n    select: function (context, node) {\n      var versionToUse = normalizeElectron(node.version)\n      var chrome = e2c[versionToUse]\n      if (!chrome) {\n        throw new BrowserslistError(\n          'Unknown version ' + node.version + ' of electron'\n        )\n      }\n      return ['chrome ' + chrome]\n    }\n  },\n  node_major_version: {\n    matches: ['version'],\n    regexp: /^node\\s+(\\d+)$/i,\n    select: nodeQuery\n  },\n  node_minor_version: {\n    matches: ['version'],\n    regexp: /^node\\s+(\\d+\\.\\d+)$/i,\n    select: nodeQuery\n  },\n  node_patch_version: {\n    matches: ['version'],\n    regexp: /^node\\s+(\\d+\\.\\d+\\.\\d+)$/i,\n    select: nodeQuery\n  },\n  current_node: {\n    matches: [],\n    regexp: /^current\\s+node$/i,\n    select: function (context) {\n      return [env.currentNode(resolve, context)]\n    }\n  },\n  maintained_node: {\n    matches: [],\n    regexp: /^maintained\\s+node\\s+versions$/i,\n    select: function (context) {\n      var now = Date.now()\n      var queries = Object.keys(jsEOL)\n        .filter(function (key) {\n          return (\n            now < Date.parse(jsEOL[key].end) &&\n            now > Date.parse(jsEOL[key].start) &&\n            isEolReleased(key)\n          )\n        })\n        .map(function (key) {\n          return 'node ' + key.slice(1)\n        })\n      return resolve(queries, context)\n    }\n  },\n  phantomjs_1_9: {\n    matches: [],\n    regexp: /^phantomjs\\s+1.9$/i,\n    select: function () {\n      return ['safari 5']\n    }\n  },\n  phantomjs_2_1: {\n    matches: [],\n    regexp: /^phantomjs\\s+2.1$/i,\n    select: function () {\n      return ['safari 6']\n    }\n  },\n  browser_version: {\n    matches: ['browser', 'version'],\n    regexp: /^(\\w+)\\s+(tp|[\\d.]+)$/i,\n    select: function (context, node) {\n      var version = node.version\n      if (/^tp$/i.test(version)) version = 'TP'\n      var data = checkName(node.browser, context)\n      var alias = normalizeVersion(data, version)\n      if (alias) {\n        version = alias\n      } else {\n        if (version.indexOf('.') === -1) {\n          alias = version + '.0'\n        } else {\n          alias = version.replace(/\\.0$/, '')\n        }\n        alias = normalizeVersion(data, alias)\n        if (alias) {\n          version = alias\n        } else if (context.ignoreUnknownVersions) {\n          return []\n        } else {\n          throw new BrowserslistError(\n            'Unknown version ' + version + ' of ' + node.browser\n          )\n        }\n      }\n      return [data.name + ' ' + version]\n    }\n  },\n  browserslist_config: {\n    matches: [],\n    regexp: /^browserslist config$/i,\n    needsPath: true,\n    select: function (context) {\n      return browserslist(undefined, context)\n    }\n  },\n  extends: {\n    matches: ['config'],\n    regexp: /^extends (.+)$/i,\n    needsPath: true,\n    select: function (context, node) {\n      return resolve(env.loadQueries(context, node.config), context)\n    }\n  },\n  defaults: {\n    matches: [],\n    regexp: /^defaults$/i,\n    select: function (context) {\n      return resolve(browserslist.defaults, context)\n    }\n  },\n  dead: {\n    matches: [],\n    regexp: /^dead$/i,\n    select: function (context) {\n      var dead = [\n        'Baidu >= 0',\n        'ie <= 11',\n        'ie_mob <= 11',\n        'bb <= 10',\n        'op_mob <= 12.1',\n        'samsung 4'\n      ]\n      return resolve(dead, context)\n    }\n  },\n  unknown: {\n    matches: [],\n    regexp: /^(\\w+)$/i,\n    select: function (context, node) {\n      if (byName(node.query, context)) {\n        throw new BrowserslistError(\n          'Specify versions in Browserslist query for browser ' + node.query\n        )\n      } else {\n        throw unknownQuery(node.query)\n      }\n    }\n  }\n}\n\n// Get and convert Can I Use data\n\n;(function () {\n  for (var name in agents) {\n    var browser = agents[name]\n    browserslist.data[name] = {\n      name: name,\n      versions: normalize(agents[name].versions),\n      released: normalize(agents[name].versions.slice(0, -3)),\n      releaseDate: agents[name].release_date\n    }\n    fillUsage(browserslist.usage.global, name, browser.usage_global)\n\n    browserslist.versionAliases[name] = {}\n    for (var i = 0; i < browser.versions.length; i++) {\n      var full = browser.versions[i]\n      if (!full) continue\n\n      if (full.indexOf('-') !== -1) {\n        var interval = full.split('-')\n        for (var j = 0; j < interval.length; j++) {\n          browserslist.versionAliases[name][interval[j]] = full\n        }\n      }\n    }\n  }\n\n  browserslist.nodeVersions = jsReleases.map(function (release) {\n    return release.version\n  })\n})()\n\nmodule.exports = browserslist\n","'use strict'\n\nlet _localeCompare\nfunction localeCompare(x, y) {\n  if (_localeCompare === undefined) {\n    // Lazily call new Intl.Collator() because in Node it can take 10-14ms.\n    _localeCompare = new Intl.Collator().compare\n  }\n  return _localeCompare(x, y)\n}\n\nfunction assert(truthy, message = 'assert failed') {\n  if (truthy) {\n    return\n  }\n  throw new TypeError(message)\n}\n\nfunction base64(a) {\n  let ret\n  if (a.length < 65535) {\n    ret = btoa(String.fromCodePoint.apply(String, a))\n  } else {\n    ret = ''\n    for (const value of a) {\n      ret += String.fromCodePoint(value)\n    }\n    ret = btoa(ret)\n  }\n  return ret\n}\n\nfunction eq(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n  for (let i = a.byteLength - 1; i >= 0; i--) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction fmt_hash(a) {\n  if (a.byteLength < 32) {\n    throw new TypeError('meta_hash too short')\n  }\n  let hash = ''\n  for (let i = 0; i < 32; i += 1) {\n    let c = hex(a[i])\n    if (i < 8 || (16 <= i && i < 24)) {\n      c = c.toUpperCase()\n    }\n    hash += c\n    if (i < 31 && (i + 1) % 8 === 0) {\n      hash += '-'\n    }\n  }\n  return hash\n}\n\nfunction fmt_integrity(a) {\n  if (a.byteLength < 65) {\n    throw new TypeError('integrity too short')\n  }\n  const tag = a[0]\n  a = a.subarray(1)\n  let out\n  if (tag === 1) {\n    out = 'sha1-'\n  } else if (tag === 2) {\n    out = 'sha256-'\n  } else if (tag === 3) {\n    out = 'sha384-'\n  } else if (tag === 4) {\n    out = 'sha512-'\n  } else {\n    return ''\n  }\n  out += base64(a)\n  return out\n}\n\nfunction fmt_resolution(a, buffers) {\n  if (a.byteLength < 64) {\n    throw new TypeError('resolution too short')\n  }\n  const tag = a[0]\n  const view2 = new DataView(a.buffer, a.byteOffset, a.byteLength)\n  let pos = 8\n  if (tag === 2 /* npm */) {\n    pos += 8\n    const major = view2.getUint32((pos += 4) - 4, true)\n    const minor = view2.getUint32((pos += 4) - 4, true)\n    const patch = view2.getUint32((pos += 4) - 4, true)\n    pos += 4\n    const version_tag = new Uint8Array(view2.buffer, view2.byteOffset + pos, 32)\n    const pre = str(version_tag.subarray(0, 8), buffers)\n    const build = str(version_tag.subarray(16, 24), buffers)\n    let v = `${major}.${minor}.${patch}`\n    if (pre) {\n      v += '-' + pre\n    }\n    if (build) {\n      v += '+' + build\n    }\n    return v\n  }\n  if (\n    tag === 4 /* folder */ ||\n    tag === 8 /* local_tarball */ ||\n    tag === 80 /* remote_tarball */ ||\n    tag === 72 /* workspace */ ||\n    tag === 64 /* symlink */ ||\n    tag === 100 /* single_file_module */\n  ) {\n    let v = str(\n      new Uint8Array(view2.buffer, view2.byteOffset + pos, 8),\n      buffers\n    )\n    if (tag === 72 /* workspace */) {\n      v = `workspace:${v}`\n    }\n    if (tag === 64 /* symlink */) {\n      v = `link:${v}`\n    }\n    if (tag === 100 /* single_file_module */) {\n      v = `module:${v}`\n    }\n    return v\n  }\n  if (\n    tag === 32 /* git */ ||\n    tag === 16 /* github */ ||\n    tag === 24 /* gitlab */\n  ) {\n    let out =\n      tag === 32 /* git */\n        ? 'git+'\n        : tag === 16 /* github */\n          ? 'github:'\n          : 'gitlab:'\n    const owner = str(\n      new Uint8Array(view2.buffer, view2.byteOffset + pos, 8),\n      buffers\n    )\n    const repo = str(\n      new Uint8Array(view2.buffer, view2.byteOffset + pos + 8, 8),\n      buffers\n    )\n    if (owner) {\n      out += owner + '/'\n    } else if (is_scp(repo)) {\n      out += 'ssh://'\n    }\n    out += repo\n    pos += 16\n    const commitish = str(\n      new Uint8Array(view2.buffer, view2.byteOffset + pos, 8),\n      buffers\n    )\n    let resolved = str(\n      new Uint8Array(view2.buffer, view2.byteOffset + pos + 8, 8),\n      buffers\n    )\n    if (resolved) {\n      out += '#'\n      let i = -1\n      if ((i = resolved.lastIndexOf('-')) >= 0) {\n        resolved = resolved.slice(i + 1)\n      }\n      out += resolved\n    } else if (commitish) {\n      out += `#${commitish}`\n    }\n    return out\n  }\n  return ''\n}\n\nfunction fmt_specs(name, specs, version) {\n  specs = Array.from(new Set(specs.map(e => e || `^${version}`))).sort()\n  let out = ''\n  let comma = false\n  for (const spec of specs) {\n    const item = `${name}@${spec}`\n    if (comma) {\n      out += ', '\n    }\n    out += quote(item)\n    comma = true\n  }\n  return `${out}:`\n}\n\nfunction fmt_url(a, buffers) {\n  if (a.byteLength < 64) {\n    throw new TypeError('resolution too short')\n  }\n  return a[0] === 2 /* npm */\n    ? str(new Uint8Array(a.buffer, a.byteOffset + 8, 8), buffers)\n    : fmt_resolution(a, buffers)\n}\n\nfunction hex(a) {\n  return (256 + a).toString(16).slice(1)\n}\n\nfunction is_scp(s) {\n  if (s.length < 3) {\n    return false\n  }\n  let at = -1\n  for (let i = 0, { length } = s; i < length; i += 1) {\n    if (s[i] === '@') {\n      if (at < 0) {\n        at = i\n      }\n    } else if (s[i] === ':') {\n      if (s.slice(i).startsWith('://')) {\n        return false\n      }\n      return at >= 0 ? i > at + 1 : i > 0\n    } else if (s[i] === '/') {\n      return at >= 0 && i > at + 1\n    }\n  }\n  return false\n}\n\nfunction quote(s) {\n  return s.startsWith('true') ||\n    s.startsWith('false') ||\n    /[:\\s\\n\\\\\",[\\]|\\t!]/g.test(s) ||\n    /^[0-9]/g.test(s) ||\n    !/^[a-zA-Z]/g.test(s)\n    ? JSON.stringify(s)\n    : s\n}\n\nfunction slice(data, a, item) {\n  const { 0: off, 1: length } = to_u32(a)\n  return Array.from({ length }, (_, i) =>\n    data.subarray(item * off + item * i, item * off + item * i + item)\n  )\n}\n\nfunction str(a, buffers) {\n  if ((a[7] & 128) === 0) {\n    const i = a.indexOf(0)\n    if (i >= 0) {\n      a = a.subarray(0, i)\n    }\n    return new TextDecoder().decode(a)\n  }\n  const [off, len] = to_u32(a)\n  return new TextDecoder().decode(\n    buffers.string_bytes.subarray(off, off + (len & ~2147483648))\n  )\n}\n\nfunction to_u32(a) {\n  if (a.byteOffset % 4 === 0) {\n    return new Uint32Array(a.buffer, a.byteOffset, a.byteLength / 4)\n  }\n  const view2 = new DataView(a.buffer, a.byteOffset, a.byteLength)\n  return Uint32Array.from({ length: a.byteLength / 4 }, (_, i) =>\n    view2.getUint32(i * 4, true)\n  )\n}\n\nfunction parse(buf) {\n  let pos = 0\n  const view =\n    buf instanceof ArrayBuffer\n      ? new DataView(buf)\n      : new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n  const header_bytes = new TextEncoder().encode(\n    '#!/usr/bin/env bun\\nbun-lockfile-format-v0\\n'\n  )\n  const u32 = () => {\n    if (pos + 4 > view.byteLength) {\n      throw new TypeError('too short')\n    }\n    return view.getUint32((pos += 4) - 4, true)\n  }\n  const u64 = () => {\n    if (pos + 8 > view.byteLength) {\n      throw new TypeError('too short')\n    }\n    const a = view.getUint32((pos += 4) - 4, true)\n    const b = view.getUint32((pos += 4) - 4, true)\n    return a + b * 2 ** 32\n  }\n  const read = n => {\n    if (pos + n > view.byteLength) {\n      throw new TypeError('too short')\n    }\n    return new Uint8Array(view.buffer, view.byteOffset + (pos += n) - n, n)\n  }\n  const header_buf = read(header_bytes.byteLength)\n  assert(eq(header_buf, header_bytes), 'invalid lockfile')\n  const format = u32()\n  assert(format === 2, 'outdated lockfile version')\n  const meta_hash = read(32)\n  const end = u64()\n  assert(end <= view.byteLength, 'lockfile is missing data')\n  const list_len = u64()\n  assert(\n    list_len < 2 ** 32,\n    'lockfile validation failed: list is impossibly long'\n  )\n  const input_alignment = u64()\n  assert(input_alignment === 8)\n  const field_count = u64()\n  assert(field_count === 8)\n  const begin_at = u64()\n  const end_at = u64()\n  assert(\n    begin_at <= end && end_at <= end && begin_at <= end_at,\n    'lockfile validation failed: invalid package list range'\n  )\n  pos = begin_at\n  const packages = Object.entries({\n    name: 8,\n    name_hash: 8,\n    resolution: 64,\n    dependencies: 8,\n    resolutions: 8,\n    meta: 88,\n    bin: 20,\n    scripts: 48\n  }).reduce(\n    (list, [field, len]) => {\n      const data = read(len * list_len)\n      list.forEach((a, i) => {\n        a[field] = data.subarray(i * len, i * len + len)\n      })\n      return list\n    },\n    Array.from({ length: list_len }, () => ({}))\n  )\n  pos = end_at\n  const buffers = [\n    'trees',\n    'hoisted_dependencies',\n    'resolutions',\n    // u32[]\n    'dependencies',\n    // name(8) + name_hash(8) + behavior(1) + tag(1) + literal(8) = 26[]\n    'extern_strings',\n    'string_bytes'\n  ].reduce((a, key) => {\n    const start = u64()\n    const end2 = u64()\n    pos = start\n    a[key] = read(end2 - start)\n    pos = end2\n    return a\n  }, {})\n  const requested_versions = Array(list_len)\n  requested_versions[0] = []\n  for (let i = 1; i < list_len; i += 1) {\n    let resolutions = to_u32(buffers.resolutions.subarray())\n    let dependencies = buffers.dependencies.subarray()\n    let k = -1\n    const all_requested_versions = []\n    while ((k = resolutions.indexOf(i)) >= 0) {\n      all_requested_versions.push(dependencies.subarray(k * 26, k * 26 + 26))\n      dependencies = dependencies.subarray(k * 26 + 26)\n      resolutions = resolutions.subarray(k + 1)\n    }\n    requested_versions[i] = all_requested_versions\n  }\n  let ResolutionTag\n  ;(ResolutionTag2 => {\n    ResolutionTag2[(ResolutionTag2['uninitialized'] = 0)] = 'uninitialized'\n    ResolutionTag2[(ResolutionTag2['root'] = 1)] = 'root'\n    ResolutionTag2[(ResolutionTag2['npm'] = 2)] = 'npm'\n    ResolutionTag2[(ResolutionTag2['folder'] = 4)] = 'folder'\n    ResolutionTag2[(ResolutionTag2['local_tarball'] = 8)] = 'local_tarball'\n    ResolutionTag2[(ResolutionTag2['github'] = 16)] = 'github'\n    ResolutionTag2[(ResolutionTag2['gitlab'] = 24)] = 'gitlab'\n    ResolutionTag2[(ResolutionTag2['git'] = 32)] = 'git'\n    ResolutionTag2[(ResolutionTag2['symlink'] = 64)] = 'symlink'\n    ResolutionTag2[(ResolutionTag2['workspace'] = 72)] = 'workspace'\n    ResolutionTag2[(ResolutionTag2['remote_tarball'] = 80)] = 'remote_tarball'\n    ResolutionTag2[(ResolutionTag2['single_file_module'] = 100)] =\n      'single_file_module'\n  })(ResolutionTag || (ResolutionTag = {}))\n  const out = [\n    '# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.',\n    '# yarn lockfile v1',\n    `# bun ./bun.lockb --hash: ${fmt_hash(meta_hash)}`,\n    ''\n  ]\n  const order = Array.from({ length: list_len }, (_, i) => i)\n    .slice(1)\n    .sort((a, b) => {\n      const pa = packages[a]\n      const pb = packages[b]\n      return (\n        localeCompare(str(pa.name, buffers), str(pb.name, buffers)) ||\n        localeCompare(\n          fmt_resolution(pa.resolution, buffers),\n          fmt_resolution(pb.resolution, buffers)\n        )\n      )\n    })\n  for (const i of order) {\n    const a = packages[i]\n    const name = str(a.name, buffers)\n    const resolution = a.resolution\n    const meta = a.meta\n    const dependencies = slice(buffers.dependencies, a.dependencies, 26)\n    const dependency_versions = requested_versions[i]\n    const version = fmt_resolution(resolution, buffers)\n    const versions = dependency_versions.map(b =>\n      str(b.subarray(18, 18 + 8), buffers)\n    )\n    const url = fmt_url(resolution, buffers)\n    const integrity = fmt_integrity(meta.subarray(20, 85))\n    out.push('')\n    out.push(fmt_specs(name, versions, version))\n    out.push(`  version ${JSON.stringify(version)}`)\n    out.push(`  resolved ${JSON.stringify(url)}`)\n    if (integrity) {\n      out.push(`  integrity ${integrity}`)\n    }\n    if (dependencies.length > 0) {\n      let Behavior\n      ;(Behavior2 => {\n        Behavior2[(Behavior2['_'] = 0)] = '_'\n        Behavior2[(Behavior2['normal'] = 2)] = 'normal'\n        Behavior2[(Behavior2['optional'] = 4)] = 'optional'\n        Behavior2[(Behavior2['dev'] = 8)] = 'dev'\n        Behavior2[(Behavior2['peer'] = 16)] = 'peer'\n        Behavior2[(Behavior2['workspace'] = 32)] = 'workspace'\n      })(Behavior || (Behavior = {}))\n      let behavior = 0 /* _ */\n      for (const dependency of dependencies) {\n        const dep_behavior = dependency[16]\n        if (behavior !== dep_behavior) {\n          if ((dep_behavior & 4) /* optional */ > 0) {\n            out.push('  optionalDependencies:')\n          } else if ((dep_behavior & 2) /* normal */ > 0) {\n            out.push('  dependencies:')\n          } else if ((dep_behavior & 8) /* dev */ > 0) {\n            out.push('  devDependencies:')\n          } else {\n            continue\n          }\n          behavior = dep_behavior\n        }\n        const dep_name = str(dependency.subarray(0, 8), buffers)\n        const literal = str(dependency.subarray(18, 18 + 8), buffers)\n        out.push(`    ${quote(dep_name)} \"${literal}\"`)\n      }\n    }\n  }\n  out.push('')\n  return out.join('\\n')\n}\n\nmodule.exports = {\n  parse\n}\n"],"names":["cause","seen","currentErr","stackWithCauses","messageWithCauses","_AbstractStore_save","backend","clear","set","write","get","reset","bold","dim","italic","underline","overline","inverse","hidden","strikethrough","black","red","green","yellow","blue","magenta","cyan","white","gray","bgBlack","bgRed","bgGreen","bgYellow","bgBlue","bgMagenta","bgCyan","bgWhite","bgGray","Signals","constructor","callback","process","signal","whenExit","isUpdateAvailable","notify","updater","ttl","timestampFetch","timestampNotification","version","Store","_CodeOrName","Name","emptyStr","toString","item","addCodeArg","code","expr","i","getProperty","requireScope","code_1","UsedValueState","parent","toName","_newName","setValue","itemIndex","ValueScope","name","nameOrPrefix","prefix","scope_2","ADD","optimizeNodes","Def","_n","Assign","names","AssignOp","Label","AnyCode","ParentNode","nodes","subtractNames","BlockNode","render","Root","If","e","For","ForLoop","optimizeNames","to","ForIter","Return","Try","_a","Catch","Finally","scopeName","getScopeValue","scopeRefs","scopeCode","_def","const","let","var","object","if","elseIf","forOf","forBody","label","break","return","try","catchCode","throw","toHash","hash","checkUnknownRules","self","schemaPath","unescapeFragment","unescapeJsonPointer","resultToName","gen","mergeToName","setEvaluated","mergeValues","items","evaluatedPropsToName","codegen_1","data","valCxt","parentData","vErrors","errors","util_1","names_1","schemaType","it","allErrors","returnErrors","schemaEnv","keyword","params","propertyName","topBoolOrEmptySchema","validateName","falseSchemaError","schema","requireApplicability","value","hasRequiredDataType","rules_1","getSchemaTypes","opts","coerceSpecificType","dataType","assignParentData","parentDataProperty","cond","correct","numCond","checkDataTypes","types","assignDefault","cxt","missingProperty","ref","isOwnProperty","allSchemaProperties","callValidateCode","errorPath","regExp","key","validateArray","valid","dataProp","dataPropType","requireKeyword","hasRequiredKeyword","errSchemaPath","topSchemaRef","compositeRule","assignValid","reportErrs","validateAsync","checkAsyncKeyword","requireSubschema","hasRequiredSubschema","require$$1","getSubschema","fastDeepEqual","keys","cb","_traverse","additionalItems","contains","additionalProperties","propertyNames","not","then","else","allOf","anyOf","oneOf","$defs","definitions","properties","patternProperties","dependencies","default","enum","required","maximum","minimum","exclusiveMaximum","exclusiveMinimum","multipleOf","maxLength","minLength","pattern","format","maxItems","minItems","uniqueItems","maxProperties","minProperties","pre","post","requireResolve","hasRequiredResolve","equal","traverse","SIMPLE_INLINED","countKeys","id","resolveUrl","uriResolver","pathPrefix","localRefs","addRef","_resolve","schOrRef","checkAmbiguosRef","addAnchor","dataType_1","applicability_1","subschema_1","validateFunctionCode","isSchemaObj","checkKeywords","topSchemaObjCode","validateFunction","checkNoDefault","typeAndKeywords","returnResults","resetEvaluated","subSchemaObjCode","schemaCxtHasRules","updateContext","checkAsyncSchema","checkRefsAndKeywords","schemaKeywords","commentKeyword","useDefaults","keywordCode","checkKeywordTypes","type","dataTypes","failResult","fail","fail$data","schemaCode","error","$dataError","assign","def","invalid$DataSchema","props","requireValidation_error","requireRef_error","compileSchema","rootId","lines","ownProperties","dataNames","dataPathArr","dataLevel","definedProperties","ValidationError","baseId","validate","dynamicProps","dynamicItems","resolveRef","_sch","schemaId","inlineOrCompile","a","A","b","B","c","C","d","D","E","f","F","scopedChars","HEX","isIPV4","host","address","zone","endIpv6","tokenCount","endipv6Encountered","isZone","buffer","isIPV6","newHost","escapedHost","out","skip","input","output","uriTokens","utils","stringArrayToHexStripped","components","wsComponents","urnComponents","uuidComponents","scheme","domainHost","parse","serialize","skipNormalize","schemes","normalizeComponentEncoding","skipEscape","base","relative","options","target","uriA","uriB","s","length","userinfo","port","path","query","fragment","parsed","isIP","schemeHandler","fastUriModule","enumerable","validation_error_1","ref_error_1","compile_1","codegen_2","resolve_1","uri_1","META_IGNORE_OPTIONS","nullable","jsonPointers","missingRefs","processCode","sourceCode","strictDefaults","strictKeywords","deprecatedOptions","MAX_EXPRESSION","strictSchema","strictNumbers","strictTypes","strictTuples","strictRequired","loopRequired","loopEnum","meta","messages","inlineRefs","unicodeRegExp","int32range","Ajv","prefixes","checkOptions","addInitialSchemas","_addVocabularies","_dataRefSchema","defaultMeta","v","sch","loadSchema","runCompileAsync","loadMetaSchema","$ref","_compileAsync","checkLoaded","missingSchema","missingRef","addSchema","getSchema","root","removeSchema","addVocabulary","checkKeyword","schOrEnv","callRootRef","env","callRef","callValidate","passCxt","addErrorsFrom","addEvaluatedFrom","schEvaluated","id_1","requireLimitNumber","okStr","message","ucs2length","pos","ucs2length_1","allErrorsMode","j","validateUniqueItems","canOptimize","wrongType","vSchema","limitNumber_1","multipleOf_1","limitLength_1","pattern_1","limitProperties_1","required_1","uniqueItems_1","const_1","enum_1","requireAdditionalItems","len","validateAdditionalItems","schemaProp","requireContains","max","maxContains","min","block","checkLimits","requireDependencies","exports","deps","splitDependencies","validatePropertyDeps","Object","missing","property","checkAdditionalProperties","isAdditional","definedProp","deleteAdditional","additionalProperty","applyAdditionalSchema","additionalProperties_1","allProps","prop","applyPropertySchema","hasRequiredPatternProperties","defineProperty","validateProperties","checkMatchingProperties","requireNot","hasRequiredNot","hasRequiredAnyOf","passing","hasThen","hasElse","ifClause","validateIf","properties_1","patternProperties_1","allOf_1","if_1","$data","validate$DataFormat","fDef","unknownFmt","validateFormat","formatDef","unknownMsg","metadata","requireDiscriminator","hasRequiredDiscriminator","types_1","tagName","discrError","validateMapping","applyTagSchema","oneOfMapping","hasRequired","addMapping","module","draft7MetaSchema","_addDefaultMetaSchema","ErrorWithCause","ponyCause","replaceNode","clone","copy","atDocument","explicit","add","onError","tagNames","visit","Value","aliasObjects","prevAnchors","sourceObjects","val","aliasCount","count","res","ctx","reviver","anchors","keep","mapKeyWarned","maxAliasCount","Node","toJSON","map","anchor","node","tagObj","aliasDuplicateObjects","keepUndefined","configurable","writable","addIn","getIn","setIn","lineWidth","minContentWidth","onOverflow","escStart","escEnd","end","split","folds","prev","ch","overflow","escapedFolds","implicitKey","start","str","singleQuote","blockEndNewlines","header","literalFallback","inFlow","tags","defaultStringType","blockQuote","defaultKeyType","directives","doubleQuotedAsJSON","doubleQuotedMinMultiLineLength","falseStr","flowCollectionPadding","indentSeq","nullStr","simpleKeys","trueStr","verifyAliasOrder","indent","indentStep","obj","doc","anchors$1","onTagObj","allNullValues","explicitKey","vsb","vcb","valueComment","chompKeep","ws","onChompKeep","identify","tag","test","resolve","addToJSMap","strCtx","log","onComment","commentString","itemIndent","reqNewline","replacer","blockItemPrefix","flowChars","collection","createNode","seq","actualString","stringify","source","n","intAsBigInt","cn","pairs","omap","nodeClass","seenKeys","sign","parts","toStringDefaults","hasDirectives","contentComment","_replacer","keepSourceTokens","logLevel","prettyErrors","strict","stringKeys","uniqueKeys","createAlias","setAnchors","setSchema","opt","resolveKnownTags","toJS","json","mapAsMap","onAnchor","col","startOnNewline","reqSpace","tab","hasSpace","commentSep","atNewline","hasNewline","found","comma","composeEmptyNode","indicator","next","offset","sep","flow","loop","coll","newlineAfterProp","comment","range","contentStart","prevMoreIndented","_type","badChar","first","line","match","x","u","U","r","t","N","_","L","P","scalar","st","isSrcToken","_directives","atKey","atRoot","parentIndent","atComment","afterEmptyLine","decorate","Array","streamInfo","depth","afterKey","setBlockScalarValue","setFlowScalarValue","cst","atLineEnd","getLine","nl","sp","top","atIndentedComment","lineCounter","empty","_reviver","dist","$schema","ignore","issues","beta","enabled","projectReportsEnabled","pullRequestAlertsEnabled","v1","socketYmlSchemaV1","readFile","projectIgnorePaths","issueRules","githubApp","ignoreUsers","dependencyOverviewEnabled","authenticatedProjectReports","coerceTypes","logger","removeAdditional","fileContent","parsedContent","config","socketYmlSchema","TMP_KEY_IGNORE","define","_make","mark","negative","body","unignored","matchedRule","checkPath","ignorecase","ignoreCase","allowRelativePaths","_initCache","slices","createFilter","ignoreModule","result","relaxZeros","negatives","state","toRegexRange","stops","nines","stop","zeros","digits","tokens","string","toRegexRange_1","wrap","step","positives","index","transform","fillRange","toRegex","strictZeros","queue","stash","q","walk","expand_1","constants","MAX_LENGTH","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKSLASH","CHAR_BACKTICK","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOLLAR","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","push","brackets","stack","open","close","commas","ranges","before","parse_1","braces","braces_1","START_ANCHOR","QMARK","DOTS_SLASH","NO_DOTS","NO_DOT_SLASH","NO_DOTS_SLASH","alnum","alpha","ascii","blank","cntrl","digit","graph","lower","print","punct","space","upper","word","xdigit","REGEX_BACKSLASH","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REGEX_SPECIAL_CHARS_GLOBAL","REGEX_REMOVE_BACKSLASH","REPLACEMENTS","CHAR_BACKWARD_SLASH","CHAR_GRAVE_ACCENT","isGlob","backslashes","braceEscaped","advance","isBrace","finished","slashes","token","isExtglob","negatedExtglob","isBracket","negated","lastIndex","glob","prevIndex","scan_1","dot","consumed","backtrack","parens","quotes","globstar","consume","extglobs","conditions","inner","extglob","extglobStar","fastpaths","append","extglobClose","outputIndex","tokensIndex","brace","extglobOpen","negate","rest","prior","onMatch","onResult","posix","isMatch","picomatch","picomatch_1","patterns","list","omit","micromatch","capture","expand","micromatch_1","pathSeparator","joinPath_1","includeBasePath","pushDirectory_1","paths","relativePaths","pushFile_1","onlyCounts","getArray_1","groupFiles_1","dir","resolveSymlink","suppressErrors","invokeCallback","report","maxFiles","walkDirectory","withFileTypes","fs_1","entries","enqueue","dequeue","counter","_files","_directories","desc","o","__setModuleDefault","walker","groups","counts","symlinks","resolvedPath","sync_1","apiBuilder","withPromise","sync","SEP","windows","builder","require","pm","maxDepth","filters","group","withBasePath","withRelativePaths","withDirs","withFullPaths","withErrors","withSymlinks","resolvePaths","normalize","onlyDirs","crawlWithOptions","globWithOptions","__exportStar","isNodeMode","patternsParts","partRegexes","regexes","console","newCommonPath","expandDirectories","ignorePatterns","matchPatterns","commonPath","depthOffset","nocase","resolveSymlinks","fdirOptions","yoctocolorsCjs","URL","createConnection","method","setHost","headers","connection","agent","timeout","requestOptions","request","socket","hpagent","HttpsProxyAgent","mod","nextChrUpper","chr","camelcase","notCamelcase","argString","prevC","opening","args","DefaultValuesForTypeKey","mixin","alias","array","boolean","configObjects","configuration","coerce","envPrefix","narg","number","__","aliases","arrays","bools","strings","numbers","configs","nargs","coercions","flags","extendAliases","defaults","checkConfiguration","m","setArg","letters","broken","notFlags","applyEnvVars","setConfigObjects","argv","toEat","available","argsToSet","addNewAlias","setKey","keyProperties","newAliases","setConfigObject","applied","duplicate","hasAllFlags","aliasArrays","change","combined","yargsParser","deep","shouldRecurse","isLastLastCharPreserved","isLastCharLower","isLastLastCharUpper","isLastCharUpper","pascalCase","preserveConsecutiveUppercase","_deleteIfExpired","_getOrDeleteIfExpired","_getItemValue","_peek","_set","_moveToRecent","expiry","oldCacheSize","forEach","maxSize","locale","cache$2","includeEmptyLines","MAX_SAFE_INTEGER","debug","src","re","safeRe","createToken","loose","compareIdentifiers","inc","skipWhitespace","license","left","conjunction","right","licensesWithVersions","identifier","transformed","ast","validForOldPackages","validForNewPackages","unlicensed","spdx","commonjs","_onabort","aborted","addEventListener","warnACPolyfill","printACPolyfillWarning","Stack","pop","starts","ttls","sizes","keyMap","keyList","valList","free","ttlResolution","maxEntrySize","ignoreFetchAbort","warned","status","cachedNow","size","find","fn","rforEach","purgeStale","allowStale","deleted","entry","dump","noUpdateTTL","__staleWhileFetching","has","peek","context","fmp","ac","__abortController","__returned","forceRefresh","sshtemplate","committish","sshurltemplate","edittemplate","browsetemplate","treepath","browsetreetemplate","hashformat","browseblobtemplate","docstemplate","httpstemplate","filetemplate","shortcuttemplate","pathtemplate","bugstemplate","project","hosts$1","protocols","domain","blobpath","editpath","gittemplate","tarballtemplate","user","giturl","auth","defaultRepresentation","LRUCache","byDomain","GitHost","gitHosts","cache$1","browse","browseFile","noCommittish","file","edit","getDefaultRepresentation","arr","boundArgs","bound","Empty","assert","async_hooks","buffer_ieee754","child_process","cluster","crypto","_debug_agent","_debugger","dgram","diagnostics_channel","dns","events","freelist","fs","_http_agent","_http_client","_http_common","_http_incoming","_http_outgoing","_http_server","http","http2","https","inspector","_linklist","net","os","perf_hooks","punycode","querystring","readline","repl","smalloc","_stream_duplex","_stream_transform","_stream_wrap","_stream_passthrough","_stream_readable","_stream_writable","stream","string_decoder","sys","timers","_tls_common","_tls_legacy","_tls_wrap","tls","trace_events","tty","url","util","v8","vm","wasi","worker_threads","zlib","dependancies","dependecies","depdenencies","devEependencies","depends","devDependences","devDepenencies","devdependencies","repostitory","repo","prefereGlobal","hompage","hampage","autohr","autor","contributers","publicationConfig","script","web","server","tests","topLevel","bugs","warn","fixRepositoryField","fixTypos","fixScriptsField","fixFilesField","fixBinField","fixManField","fixBundleDependenciesField","fixDependencies","objectifyDeps","addOptionalDepsToDeps","fixModulesField","fixKeywordsField","fixVersionField","fixPeople","modifyPeople","fixNameField","fixDescriptionField","fixReadmeField","fixBugsField","fixHomepageField","fixLicenseField","dv","depTypes","repositories","missingRepository","brokenGitUrl","nonObjectScripts","nonStringScript","nonArrayFiles","invalidFilename","nonArrayBundleDependencies","nonStringBundleDependency","nonDependencyBundleDependency","nonObjectDependencies","nonStringDependency","deprecatedArrayDependencies","deprecatedModules","nonArrayKeywords","nonStringKeyword","conflictingName","nonStringDescription","missingDescription","missingReadme","missingLicense","nonEmailUrlBugsString","nonUrlBugsUrlField","nonEmailBugsEmailField","emptyNormalizedBugs","nonUrlHomepage","invalidLicense","typo","providedName","probableName","thingsToFix","fixer","cwd","stopAt","throwIfNoEntry","directory","jsTokens","closed","nonASCIIidentifierStartChars","cp","isFirst","strictBind","reverseKeywords","rgb","channels","labels","hsl","hsv","hwb","cmyk","xyz","lab","lch","hex","ansi16","ansi256","hcg","apple","convert$1","h","l","rdif","gdif","bdif","k","y","currentClosestDistance","currentClosestKeyword","z","t2","t1","t3","lmin","wh","bl","g","ansi","color","colorString","grayscale","hue","pure","mg","cur","wrappedFn","models","convert","routeModels","ansiStyles$1","modifier","redBright","greenBright","yellowBright","blueBright","magentaBright","cyanBright","whiteBright","bgColor","bgBlackBright","bgRedBright","bgGreenBright","bgYellowBright","bgBlueBright","bgMagentaBright","bgCyanBright","bgWhiteBright","codes","styles","forceColor$1","hasBasic","supportsColor","stderr","results","current","tmp","chunk","chunks","applyOptions","chalk","ansiStyles","closeRe","lib$1","__proto__","invalid","tokenize","highlighted","level","forceColor","lib$2","marker","column","linesAbove","linesBelow","markerLines","markerLine","frame","deprecationWarningShown","oneBased","Error","codeFrame","highlightCode","location","decamelized","separator","passthroughOptions","minimistOptions","mapObj","cache","keyContainsDashes","filter","aliasIsSet","choicesNotAnArray","choicesNotMatchFlagType","defaultNotInChoices","errorMessages","helpText","inferType","help","autoHelp","autoVersion","booleanDefault","allowUnknownFlags","allowParentFlags","helpIndent","flag","parserFlags","parserOptions","exclude","isRequired","validateFlags","validateChoices","pkg","description","showVersion","meow","FLAG_INCLUDE_PRERELEASE","FLAG_LOOSE","debug_1","safeSrc","parseOptions_1","identifiers","rcompareIdentifiers","semver","valid_1","clean_1","identifierBase","inc_1","diff_1","major_1","minor_1","patch_1","prerelease_1","compare_1","rcompare_1","compareLoose_1","compareBuild_1","sort_1","rsort_1","gt_1","lt_1","eq_1","neq_1","gte_1","lte_1","cmp_1","coerceRtlRegex","coerce_1","lrucache","rangeList","rangeMap","intersects","caretTrimReplace","testComparator","comp","ret","gtlt","pr","p","M","from","comparator","satisfies_1","toComparators_1","rangeObj","versions","maxSV","maxSatisfying_1","minSV","minSatisfying_1","minver","comparators","compver","setMin","minVersion_1","ANY","gtfn","ltefn","ltfn","ecomp","high","low","outside_1","gtr_1","ltr_1","r1","r2","intersects_1","simplify","sub","dom","sawNonNull","eqSet","gtltComp","needDomLTPre","hasDomGT","hasDomLT","needDomGTPre","subset_1","ansiEscapes","setCwd","supportsColor_1","stdout","major","minor","supportsHyperlinks","declarations","writeFile","mkdir","recursive","pwshProg","shTarget","shLongProg","cmd","sh","pwsh","lib","promises_1","isexe","checkStat","checkMode","pathExt","pathExtExe","ignoreErrors","isDockerCached","cachedResult","humanReadableOutput","AppXq0fevzme2pys62n3e0fbqa7peapykr8v","MSEdgeDHTML","MSEdgeHTM","FirefoxURL","ChromeHTML","BraveHTML","BraveBHTML","BraveSSHTM","arch","isConfigFileExists","encoding","mountPoint","latestError","wait","background","newInstance","allowNonzeroExitCode","app","appArguments","arguments","chrome","firefox","edge","command","cliArguments","encodedArguments","exeLocalXdgOpen","subprocess","wsl","defineLazyProperty","darwin","win32","linux","ia32","x64","escapeStringRegexp","colorName","route","colorConvert","hasFlag","templates","onlyFirst","stripAnsiModule","text","columns","field","formatted","PurlError","decodeURIComponent","decode","decodePurlComponent","REUSED_SEARCH_PARAMS_OFFSET","LOOP_SENTINEL","objects","recursiveFreeze","namespace","purl","trimLeadingSlashes","isObject","isNonEmptyString","encodeURIComponent","REUSED_SEARCH_PARAMS","encode","encodeSubpath","helpersForProp","nsObject","helpers","createHelpersNamespaceObject","isBlank","collapsed","qualifiers","normalizeVersion","lang","isNullishOrEmptyString","validateVersion","encodeVersion","localeCompare","qualifierKey","qualifierValue","subpath","purlComponent","purlQualifierNames","PurlQualifierNames","RepositoryUrl","DownloadUrl","VcsUrl","FileName","Checksum","encodeComponent","replaceUnderscoresWithDashes","validateRequiredByType","legacyNames","conan","cran","golang","maven","mlflow","npm","oci","pub","swift","PurlComponent","PurlType","typeHelpers","purlStr","maybeUrlWithAuth","pathname","rawVersion","rawName","rawNamespace","searchParams","rawQualifiers","Reflect","packageUrl","packageurlJs","baseUrl","accept","mediaType","removeUndefinedProperties","mergedOptions","part","template","operator","expression","DEFAULTS","quotedPairRE","safeParse","requestCopy","authorization","fetchResponse","redirect","duplex","responseHeaders","response","octokitResponse","endpoint","hook","orig","remove","registry","bindApi","tokenType","previews","requestDefaults","info","octokit","octokitOptions","requestLog","done","mapFn","earlyExit","iterator","paginate","paginateRest","actions","getRepoPermissions","updateRepoVariable","activity","apps","addRepoToInstallation","removeRepoFromInstallation","billing","getSharedStorageBillingUser","checks","codeScanning","getAlert","renamedParameters","alert_id","listAlertsInstances","codeSecurity","updateEnterpriseConfiguration","codesOfConduct","codespaces","listInOrganization","org_id","copilot","dependabot","updateAlert","dependencyGraph","emojis","gists","git","gitignore","hostedCompute","updateNetworkConfigurationForOrg","interactions","getRestrictionsForYourPublicRepos","removeRestrictionsForYourPublicRepos","setRestrictionsForYourPublicRepos","updateMilestone","licenses","markdown","migrations","listReposForUser","unlockRepoForOrg","oidc","updateOidcCustomSubTemplateForOrg","orgs","addSecurityManagerTeam","deprecated","enableOrDisableSecurityProductOnAllOrgRepos","listSecurityManagerTeams","removeSecurityManagerTeam","packages","getAllPackageVersionsForAPackageOwnedByAnOrg","getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser","restorePackageVersionForUser","privateRegistries","updateOrgPrivateRegistry","projects","addCollaborator","createCard","createColumn","createForAuthenticatedUser","createForOrg","createForRepo","delete","deleteCard","deleteColumn","getCard","getColumn","getPermissionForUser","listCards","listCollaborators","listColumns","listForOrg","listForRepo","listForUser","moveCard","moveColumn","removeCollaborator","update","updateCard","updateColumn","pulls","updateReviewComment","rateLimit","reactions","listForTeamDiscussionInOrg","repos","acceptInvitation","addAppAccessRestrictions","mapToData","addStatusCheckContexts","addTeamAccessRestrictions","addUserAccessRestrictions","declineInvitation","downloadArchive","removeAppAccessRestrictions","removeStatusCheckContexts","removeTeamAccessRestrictions","removeUserAccessRestrictions","setAppAccessRestrictions","setStatusCheckContexts","setTeamAccessRestrictions","setUserAccessRestrictions","updateStatusCheckPotection","search","issuesAndPullRequests","secretScanning","securityAdvisories","updateRepositoryAdvisory","teams","addOrUpdateProjectPermissionsInOrg","addOrUpdateProjectPermissionsLegacy","checkPermissionsForProjectInOrg","checkPermissionsForProjectLegacy","listProjectsInOrg","listProjectsLegacy","removeProjectInOrg","removeProjectLegacy","users","addEmailForAuthenticated","createGpgKeyForAuthenticated","createPublicSshKeyForAuthenticated","deleteEmailForAuthenticated","deleteGpgKeyForAuthenticated","deletePublicSshKeyForAuthenticated","getGpgKeyForAuthenticated","getPublicSshKeyForAuthenticated","listBlockedByAuthenticated","listEmailsForAuthenticated","listFollowedByAuthenticated","listGpgKeysForAuthenticated","listPublicEmailsForAuthenticated","listPublicSshKeysForAuthenticated","setPrimaryEmailVisibilityForAuthenticated","decorations","scope","newMethods","options2","legacyRestEndpointMethods","globalThis","AS","abort","emitWarning","ZeroArray","unsafeExposeInternals","isBackgroundFetch","indexes","rindexes","isStale","disposeAfter","getRemainingTTL","#initializeTTLTracking","hosts","hosts_1","parseUrl","fromUrl","builtinModules","blacklist","warnings","META","KEYS","standard","flush","notice","verbose","silly","timing","pause","resume","time","LEVELS","read","reject","homedir","spec","raw","rawSpec","where","noGitPlus","full","resolvedUrl","specUrl","originalError","setGitAttrs","npaModule","chdir","polyfills","setTimeout","eagCounter","callback_","threw","legacyStreams","ReadStream","WriteStream","Stream","clone_1","gracefulQueue","previousSymbol","publishQueue","resetQueue","fs$closeSync","gracefulFs","FileReadStream","FileWriteStream","that","retry","retryTimer","copyFileSync","createReadStream","proc","node_events_1","isStream","EMITEND","ASYNC","isEndish","isArrayBufferView","isObjectModeOptions","setEncoding","Buffer","paused","ended","unpipe","ev","removeAllListeners","emittedEnd","Minipass","on","emit","err","hexDigest","SPEC_ALGORITHMS","shouldAddFirstSep","complement","isEmpty","concat","single","merge","pickAlgorithm","acc","istream","sri","digest","checker","verified","hashes","graceful_fs_1","isAbsolute","indexOfPeersSuffix","patchHashIndex","peersIndex","parseDepPath","peersSuffix","pkgId","tryGetPackageId","sepIndex","packageName","registries","dependencyPath","patchHash","semver_1","nonSemverVersion","filename","depPathToFilenameUnescaped","depPath","dirName","dp","DepType","dev","devDepPaths","prodDepPaths","walked","notProdOnly","detectDepTypesInSubGraph","rimrafModule","force","maxRetries","sourceKeys","YAMLException","exception","head","lineStart","tail","lineEnd","lineEnds","lineStarts","foundLineNo","snippet","multi","sequence","mapping","fallback","implicit","kind","construct","_null","predicate","represent","defaultStyle","bool","lowercase","uppercase","hasDigits","int","binary","octal","decimal","hexadecimal","styleAliases","float","fraction","delta","year","day","hour","minute","second","tz_hour","timestamp","instanceOf","bitlen","bits","tailbits","pair","pairHasKey","_default","simpleEscapeMap","throwError","throwWarning","handle","_character","destination","overridableKeys","keyNode","_result","lineBreaks","_position","following","captureStart","hasPendingContent","preceding","skipSeparationSpace","captureEnd","hexLength","hexResult","isMapping","keyTag","_line","isPair","storeMappingPair","readNext","chomping","didReadContent","detectedIndent","textIndent","emptyLines","atMoreIndented","folding","detected","valueNode","atExplicitKey","allowCompact","isVerbatim","isNamed","tagHandle","indentStatus","atNewLine","hasContent","allowBlockCollections","flowIndent","blockIndent","typeList","directiveName","directiveArgs","composeNode","ESCAPE_SEQUENCES","cpu","engines","resolution","libc","style","QUOTING_TYPE_DOUBLE","position","cIsNsCharOrWhitespace","STYLE_SINGLE","STYLE_LITERAL","STYLE_FOLDED","STYLE_DOUBLE","char","prevChar","hasLineBreak","hasFoldableLine","previousLineBreak","moreIndented","curr","escapeSeq","objectKeyList","pairBuffer","objectKey","objectValue","detectType","compact","singleLineOnly","writeBlockMapping","writeBlockSequence","writeScalar","tagStr","duplicatesIndexes","inspectNode","jsYaml","_isPlaceholder_1","_curry1_1","_has_1","_isArguments_1","_isObject_1","_isString_1","_isTypedArray_1","_curry1","empty_1","_curry2_1","_arrayFromIterator_1","idx","_includesWith_1","_functionName_1","_objectIs_1","ks","nIdx","keys_1","type_1","_equals_1","_curry2","equals_1","isEmpty_1","MurmurHash3","k1","h1","signals_js_1","global","ObjectDefineProperty","Math","signalExitWrap","load","unload","SignalExitFallback","onExit","SignalExit","libModule","promisify","activeFiles","tmpfile","fd","removeOnExitHandler","cleanup","fastSafeStringify","decirc","deterministicDecirc","replacerStack","individual","format_1","fastTime","hostname","scache","remoteAddress","remotePort","newObj","objectToOut","errorToOut","requestToOut","outputs","stringified","bole","hasObjMode","bole_1","descriptor","_classCallCheck","buf","customInspect","_this","emitErrorNT","destroy_1","destroy","undestroy","errorOrDestroy","Base","NodeError","createErrorType","determiner","msg","getHighWaterMark","TempCtor","ctor","inheritsModule","onCorkedFinish","require$$6","Duplex","onwrite","realHasInstance","Writable","er","isBuf","last","doWrite","finishMaybe","clearBuffer","prefinish","require$$2","Readable","safeBuffer","retried","nb","StringDecoder","called","writableEnded","readable","readableEnded","endOfStream","iter","async_iterator","asyncGeneratorStep","objectMode","reading","from_1","require$$8","skipChunkCheck","onEofChunk","maybeReadMore","doRead","dest","cleanedUp","prependListener","hasUnpiped","afterTransform","needTransform","transforming","writecb","writechunk","writeencoding","Transform","destroyed","streams","destroys","pipeline_1","inherits","highWaterMark","through2Module","mapper","matcher","split2","EOL","ndjson","__importDefault","seenInput","seenOutput","newValue","sortDirectKeys","sortDeepKeys","compare","object_key_sorting_1","prepare","ROOT_KEYS","sortLockfileKeys","lockfile","priority","pathext","mode","isexe_1","core","is","which_1","pathKeyModule","resolved","resolveCommand_1","shebangRegex","shebangCommand","readShebang_1","original","errno","syscall","enoent","notFoundError","crossSpawnModule","previous","mimicFnModule","calledFunctions","function_","mimicFn","onetimeModule","action","signalsByName","isCanceled","exitCode","stdio","stdioModule","emitter","signalExitModule","loaded","signals","sigListeners","sig","forceKillAfterTimeout","spawned","timedOut","killSignal","timeoutKill","detached","removeExitHandler","kill","setExitHandler","isStream_1","PassThrough","maxBuffer","rejectPromise","getStreamModule","mergeStream","sources","all","mixed","validateInputSync","promise","getSpawnedPromise","parseCommand","getEscapedCommand","execPath","stripFinalNewline","extendEnv","preferLocal","windowsHide","validateTimeout","killed","failed","execaModule","nodeOptions","stdin","shell","PATH","pathName","fileAbsolutePath","pathCache","default_1","isWorkingTreeClean","isRemoteHistoryClean","history","requireLockfileName","_isTransformer_1","_dispatchable_1","_map_1","_isArrayLike_1","XWrap","_xwrap_1","_arity_1","bind_1","_reduce_1","_xfBase","_xmap_1","argsIdx","combinedIdx","_curryN_1","curryN_1","_dispatchable","map_1","omit_1","pickBy_1","pick_1","hasRequiredLockfileFormatConverters","convertToLockfileFile","normalizeLockfile","importers","normalizedImporter","lockfileToSave","convertProjectSnapshotToInlineSpecifiersFormat","specifiers","convertResolvedDependenciesToInlineSpecifiersFormat","mapValues","revertProjectSnapshot","moveSpecifiers","constants_1","logger_1","sortLockfileKeys_1","writeWantedLockfile","writeLockfile","yamlStringify","isEmptyLockfile","writeLockfiles","normalizePath","requireLib","_request","hint","comverToSemver","ignoredOptionalDependencies","ourPkg","js_yaml_1","lockfileFormatConverters_1","MERGE_CONFLICT_THEIRS","autofixMergeConflicts","theirs","parseMergeFile","getGitBranchLockfileNames","errors_1","gitMergeFile_1","hadConflicts","browsers","G","H","I","J","K","O","Q","R","S","browserVersions","T","V","W","X","Y","Z","w","AB","BB","CB","DB","EB","FB","GB","HB","IB","JB","KB","LB","MB","NB","OB","PB","QB","RB","SB","TB","UB","VB","WB","XB","YB","ZB","aB","bB","cB","dB","eB","fB","gB","hB","iB","jB","kB","lB","mB","nB","oB","pB","qB","rB","sB","tB","uB","vB","wB","xB","yB","zB","AC","BC","CC","DC","EC","FC","GC","HC","IC","JC","KC","LC","MC","NC","OC","PC","QC","RC","SC","TC","UC","VC","WC","XC","YC","ZC","aC","bC","cC","dC","eC","fC","gC","hC","iC","jC","kC","lC","mC","nC","oC","pC","qC","rC","sC","tC","uC","vC","wC","xC","yC","zC","AD","BD","CD","DD","ED","FD","GD","HD","ID","JD","KD","LD","MD","ND","OD","PD","QD","RD","SD","TD","UD","VD","WD","XD","YD","ZD","aD","bD","cD","dD","eD","fD","gD","hD","iD","jD","kD","lD","mD","nD","oD","pD","qD","rD","sD","tD","agents","map2","BrowserslistError","statuses","supported","notesArray","unpacked","packedVersions","featureModule","stats","memo","regionModule","pathsForCacheResult","check","parseConfigCache","latest","normalized","browserUsage","loadQueries","getStat","loadConfig","normalizeUsageData","usage","loadFeature","features","parseConfig","sections","readConfig","findConfigFile","pkgBrowserslist","findConfig","clearCaches","dataTimeChecked","oldDataWarning","currentNode","qs","versionToUse","selected","android","queries","name1","name2","parseCache","browserslist","custom","fx","ff","ios","explorer","blackberry","explorermobile","operamini","operamobile","chromeandroid","firefoxandroid","ucandroid","qqandroid","and_chr","and_ff","ie_mob","place","coveraged","last_major_versions","regexp","select","last_versions","last_electron_major_versions","last_node_major_versions","last_browser_major_versions","matches","last_electron_versions","last_node_versions","last_browser_versions","unreleased_versions","unreleased_electron_versions","unreleased_browser_versions","last_years","since_y","since_y_m","since_y_m_d","popularity","popularity_in_my_stats","popularity_in_config_stats","popularity_in_place","cover","cover_in","supports","iMax","electron_range","node_range","browser_range","electron_ray","node_ray","browser_ray","firefox_esr","opera_mini_all","electron_version","node_major_version","node_minor_version","node_patch_version","current_node","maintained_node","phantomjs_1_9","phantomjs_2_1","browser_version","browserslist_config","needsPath","extends","dead","unknown","released","releaseDate","fillUsage","browserslist_1"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACO;AACL;AACF;AACA;AACA;;AAC0BA;;;;AAGtB;AACA;AACA;AACE;;AAEF;AACA;;AAEF;AACF;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACO;AACL;AACA;AACA;AAEE;;;AAIF;AACF;AACA;AACA;AACA;AACE;;AAEA;;;AAIEC;;AAGE;AACF;AAEAC;AACF;AACF;;AAEA;AACA;AACA;AACA;AACO;AACL;AACE;AACF;;AAEA;AACA;AACE;AAEA;AAGF;;AAIA;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;AAEA;;AAEA;AACA;;AAEA;AAEA;;AAEA;;AAEA;AACED;;AAEF;AACE;AACF;AACF;;AAEA;AACA;AACA;AACA;AACaE;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;;;AAIA;AACA;;AAEA;AAEA;AAEA;AACEF;;AAIA;AAGF;AACE;AACF;AACF;;AAEA;AACA;AACA;AACA;AACaG;;;;;;;;;;ACvIb;AACA;;;AAGI;AAEI;AACJ;AACJ;;ACRA;AACA;;AAEI;;AAEA;AACJ;AACA;AACI;;AAEA;AACJ;AACA;AAEA;AACA;AACI;;AAEI;AACA;AACAC;;;AACYC;AAAQ;AACpB;AAEA;;;AAGI;AACJ;;AAEA;AACJ;AACA;AACAC;AACI;;;AAIJ;;AAEI;AACA;;AAGA;AACJ;AACAC;AACI;AACA;AAEA;;AAEA;AACJ;AACJ;AACAH;;ACvDA;AAKA;AACA;AACI;;AAEI;;AAEIC;;AAEQ;;AAEA;;AAEJG;AACI;AACA;AACA;AACJ;AACJ;AACJ;AACJ;AACJ;;ACzBA;AACA;AACA;AACA;;ACHA;AAEA;AACA;AACI;AACIC;;AAEQ;AACJ;;AAGA;AACJ;AACJ;AACJ;AACA;;AAEQ;AAEA;AACJ;AACJ;AACA;AACA;AACI;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;A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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;AACA;;;AAIJ;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;AAII;AACI+f;;AAER;AACI;AACI;;AAEI;AACI;;;AAOIvc;AACpB;AACA;;;AAIY;AACA;AAIA;AACA;AAIZ;AACA;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;AACA;;;AAIJ;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGI;AACA;AACIuc;;AAER;AACI;AACI;;AAEI;AACI;;;AAOIvc;AACpB;AACA;;;AAIY;AACA;AAIA;AACA;AAIZ;AACA;AACI;AACJ;;AAEI;;;;;;AAOJ;;;;AAIA;;;;AAIA;AACI;AACJ;;AAEI;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACJ;AACA;;AAEI;AACIK;;AAGA;;;AAOR;;AAGQ;AACR;AACA;;;;;;;;;;ACtOA;AACA;AAEA;AACI;AACA;AACA;AACA;AACA;AACA;;AAEJ;AACA;AACI1B;AACJ;AACA;AACA;AACA;;AAEA;;AAEQ;AACA;AACR;AACI6d;AACI;AACAC;AACA;AACR;AACA;AACA;AACA;AACA;AACIC;AACI;AACA;AACI;;AAEI;AACJ;;;AAGQC;AACArd;;AAEJ;AACA;AAChB;AACQ;AACR;AACA;AACA;AACA;AACA;AACIsd;;;AAEsBD;AAA2Crd;;AACzD;;AAEZ;;AAEQ;AACA;AACI;AAAa;AACT;AACIud;AACA;AAEpB;AACgB;AACA;AACA;AAChB;AACY;AAAc;AACV;AACA;AACIA;AACA;AACpB;AACgB;AACA;AACI;AACA;AACpB;AAEoB;;AAEA;AACpB;AACA;AACY;;AAEI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIlB;AACI;AAEA;AACIkB;AACA;AACZ;AACQ;;AAEI;AACIA;AACA;AAChB;AACY;AAEA;AACZ;;;AAIQ;AACA;;AAEQ;;AAGAA;AACA;AAChB;AACA;AACQ;AAEAA;AACA;AACR;AACA;AACA;AACA;AACA;;AAEQ;;AAGR;;AAEA;;;;AAMQ;AACA;;;AAGQ;AAEhB;AACYC;;;AAKA;;AAIZ;AACQ;AACR;AACA;;AAC2BH;AAAiBrd;;;AACjB;;;;;;;;;;;;;;;;AC7K3B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEI;AACI;AACA;AACA;AACR;AACI;AACJ;;AAEI;AACAyd;AACIC;;AAGR;AACA;AACI;AACJ;AACA;AACA;;AAEQ;;AAGR;AACA;AACA;;AAEI;;;;AAIQC;;AAGA;AACAC;AACA;;AAEZ;AACA;AACA;AACA;AACA;;AAEY;AACI;;AAIIjW;AACpB;AAEoB;;AAEA;AACpB;AACA;;AAEQkW;;AAER;;;;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI;AACI;AACI;AACI;AACA;AAChB;;AAKA;AACA;AAEY;AACI;;;AAMhB;AACA;;;AAIgB;AAGIC;AACAA;AACpB;AACA;AACA;AAEY;;;AAMZ;AACA;AACA;;AAEA;;;;;;;;;;;ACpDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;;AAGJ;AACQ;AAEA;AAAeC;AAAeC;AAAUC;;;AAExCC;;;;;;AAOA;AACR;AACI;AAEA;AACJ;;;;;;;;;AClCA;AACA;AACA;AAEA;;;AAE0DxX;;AAC1D;AACA;AACIwW;AACI;AACA;AAEA;AACR;AACA;;;;;AACmDiB;;AAC3C;AAEA;AACIC;;AAEAC;;AAEAC;AACAC;;;AAGJ;;AACwBN;AAAK;;AAGc;AAAO;AAE1D;AACA;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AAEA;;AAEQ;;AAEApE;AACIvc;AACI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGQmgB;AACIe;;;AAKZ;AACA;AACQ;AACR;AACIC;;;;;;;AAG0BF;AAAe;AACrC;;AAEI;AACA;AACZ;AACQ;;AAER;;AAEYjZ;AACZ;AACA;;;AAGY;AACZ;;;AAGY;;;AAII;AAChB;AACA;;AAEA;AACIjF;AACI;AACA;AACI+d;AACA;AACI;AACA;AAChB;AACY;AAEZ;AACQ;AACR;AACA;AACA;AACI;AACI;;;;;AAMA;;AAEI;AAEZ;AACQ;;;;AAKA;AACR;AACI;AACJ;;;;;;;;;;;;;;;AClGA;AACA;AACA;AAEA;AACA;;AAEQ;;AAER;AACIK;AACI;AACR;AACIpe;AACI;AACR;AACA;;;;;;;;;;;;;;;AChBA;AACA;AACA;;AAGA;AACI;AACI;AACA;;AAGA;AACR;AACI;AACJ;AACA;;;AAKI;;AAEIqe;AACA;AACR;;;AAMA;AACQhY;AACR;;;;;;AAC+DmX;AAAa;AAC5E;AACA;;;AAGQlW;AACA;AACI;;AAGZ;AAEYA;AAAQgX;AAAcC;;AACtBf;AACZ;AACA;AACI;;;;AAKJ;AACYnX;AACZ;AACQ;;AAEI;AAEA;AACZ;AACQmY;AAMR;AACI;;;AAGJ;;;AAUI;AAEA;AACJ;;;;;;;;;ACtFA;AACA;AACA;AAEA;;AAEI;AACI;AACA;;AAEI/O;AACAiG;AACZ;;AAGA;AACA;AACI;AACI+I;AACAC;;AAEI;;;;AAIZ;AACA;AACA;AACA;AACA;AAEA;AACI1f;;AAEIwa;AACInT;AACAsY;AACArL;AACAsL;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEQ;AACA;AAEA9B;AACA;AAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACI+B;AACI;AAGI;;;AAQZ;AACA;AACA;AACA;AACA;AACA;;AAEQ;AACA;;;AAOR;AACA;AACA;AACA;AACA;AACA;AACIC;AACI;;AAEA;AAIR;;AAEQ;;AAGI;AACA;AAOZ;AACA;AACA;AACA;AACA;;AAEQ;AACA;;AAGA;AACR;AACA;AACA;AACA;AACA;AACIC;AACI;AACA;AACI;AACZ;;;AASA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACI;;AAGJ;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;;;AACqEC;AAAgBC;;AAA8BC;;;AAG/G;AAEA;AACA;;;AAIA;AACA;;AAKJ;;;;;;;;;;AAWA;;AAEQ;AACIC;AACA;AACI;AACI9e;AACA;AACJ;AACIA;AACA;AACJ;AACIA;AACA;AACJ;AACIA;AACpB;AACY+e;AACZ;;AAEY;AAEAC;AACAC;AACZ;AAEY;AAKZ;AACgB;AACA;AAEhB;;AAEgB;AACIC;;AAEAD;AACpB;AAEA;AACoB;AACIE;AACAC;AACAC;AACxB;AACA;AACoB;AACpB;AACoB;AAEAH;AACAI;;AAEAL;AACpB;AAEoBI;AACpB;AACA;AACA;AACQF;AACR;AACI;AAEA;AAEA;AAEA;AACA;AACI;;AAEA;AAGI;AAEA5B;AACZ;AACA;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEI;AACA;AACA;AACI;AACI6B;AACZ;;AAGgBA;AAChB;AACYJ;;AAEAI;AACZ;AACA;AACI;AACJ;;;;;;;;;;;;AC/IA;AACA;AAEA;;AAEIT;AACAC;AACJ;AACA;AACA;;AAEA;;AAGI;AACA;AACA;AAEA;AACI;AACI;;AAGA;AAEZ;AACA;AACI;AACJ;AACA;AACI;AACA;;AAEQW;AAAW;AACnB;AACA;;;;;AAKJ;;AAEYvf;AACAwf;AACAJ;AACZ;;AAGgB;AACI;;;AAGI;AACI;AACIK;AACA;AACJ;AACIA;AACA;AACJ;AACIA;AACA;AACJ;AACIA;AACA;AACJ;AACIA;AACA;AACJ;AACIA;AACA;AACJ;AACIA;AACA;AACJ;AACIA;AACA;AACJ;AACI;AAIhC;AACwBzf;;AAExB;AACoB;AACJ;AACI;AAGIA;AACxB;AAEA;;;AAK4Byf;AACAzf;AAC5B;AACwByf;AACxB;;AAGwBzf;;AAExB;AACoB;AACJ;AACIA;AACpB;AACA;AACIyf;;AAIJ;AACA;;AAGqC;AAGjC;;;AAKJ;AACA;;AACYC;;AACR;;AAII;AACA;;AAOR;AA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;;;;;;;;;;;;ACNA;AACA;AACA;;;AAIA;;AACyB9b;AAAK;;AAGtB2b;AACA/X;AACAgY;;AAEAiB;AACH;AAEGlB;;AAEA/X;AACAgY;AACAC;;AAEAgB;AACH;AAEGlB;AACA/X;AACAgY;AACAC;AACAC;AACAe;AACH;AAEGlB;AACA/X;AACAgY;AACAC;AACAC;AAA2BkB;AAAa;AACxCH;AAAc7c;AAAO;AACxB;AAEG2b;AACA/X;AACAgY;AACAC;AACAC;AACAe;AACR;AAEA;AACIjZ;AACAgY;AACAC;AACAC;;AAEI;AACR;;AAEA;;;;;;;;;;;;AC1DA;AACA;AAEA;AACIH;AAA8C;AAC9C/X;AACAgY;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIE;AACI;;AAER;AAEA;AACY;;;AAIA;AACZ;;AAGY;AACZ;;AAEIe;;;AAA2B7c;AAAK;AAC5B;AAEA;AACA;AACA;AACIyZ;AAIZ;;;AAKYA;AACZ;AAEY;AACZ;;AAGQ;;;AAGI;AACA;;AAEZ;AACYA;AACZ;;;;AACgEzZ;;AAChE;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AAEA;AACI;AACI;AACI;AACA;;;AAMI;;;AAMIid;AAGpB;AACgBrjB;AAChB;;AAEA;AACA;AAGI;AACJ;AACA;;AACY0iB;AAAQ;;;;AAIhB;;;AAKQ;AACI;AACI/a;AACAvB;;AAIpB;AAEgB;AACA;AACIuB;AACAvB;AACpB;;AAGA;AACA;AAEgBuB;AAChB;AACY2b;AACZ;AACI;AACJ;AACA;AACIT;AACA7Y;AACAgY;AACAE;AACAY;;;;;;;;;;;;AC1EJ;AACA;AACA;AACA;AACA;AAEA;AACI/jB;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACR;AACA;AACA;AACA;AACA;AACIof;;AAGI;;AAGA;;AAEI;AACIxW;AACAvB;AAChB;;AAGA;AACY;AAEAgY;AACZ;AACQ;AACR;AACI;;AAEI;AACAmF;AACA;AACR;AACA;;AAEA;AACIV;AACAd;AACAyB;AACAxZ;AACAgY;AACAE;;;AAGI;AAAava;;AACT;;AAEQsV;AACpB;AAEoBwG;AACpB;AACA;AACA;;;AAGIX;;;;;;;;;;;;;;;ACtEJ;AAEA;;AAAgCI;;AAC5B;AACA;AAEA;AACJ;AACA;AACInB;AACA/X;AACAgY;AACAC;;AAEAgB;;AAEJ;AACIlB;AACA/X;AACAgY;AACAC;;AAEAgB;;;;;;;;;;;;;ACtBJ;AACA;AAEA;AACIlB;AACA/X;AACAgY;AACAC;AACAC;;;AAOJ;AACIH;AACA/X;AACAgY;AACArX;AACAsX;AACAC;;AAEI;AACA;AACR;;AAEA;AACIH;AACA/X;AACAgY;AACAC;;AAEI;AACA;AACA;AACI;AACA;AAEZ;AACQ;;;;;;;;;;;;;;;;ACxCR;AAEA;AACA;AAA0CmB;AAAW;AACjD;;AAGAvD;AACA;AACI;AACI;;AAEI;AACJ;;AAEI;AACJ;;AAEI;AAChB;AACQ;AACA;AACR;AACI;;AAEJ;AACA;;AACYzZ;AAAK;AACb;AACI;AACA;AACR;AACI;AACJ;AACA;AACI2b;AACA/X;AACAgY;AACArX;AACAsX;AACAC;;;AAGJ;AACIH;AACA/X;AACAgY;AACArX;AACAsX;AACAC;;;AAGJ;AACIH;AACA/X;AACAgY;AACAC;AACAC;;;AAGJ;AACIH;AACA/X;AACAgY;AACArX;AACAsX;AACAC;;;;;;;;;;;;;;;;AClEJ;AACA;AACA;AAEA;;;AAGQ;AACR;;AAEQ;;AAWA;;AAGR;AACA;AACA;AACA;AACA;AACIhlB;;AAEI;AAKR;AACIF;AACI;;AAGA;AACI;AACZ;AAEY;AACZ;AACA;AACImhB;;AAEJ;AACIpe;;;AAIuDwhB;AAAmB;AAG9E;AACI;;AACYmB;AAAQ;AAChB;AACA;AAEQ;AAEA1lB;AAChB;AACQ;AACR;AACA;;AAEA;AACI6lB;AACAd;AACAyB;AACAxZ;AACAgY;AACAc;AACAZ;AACI;;AAKR;AAGQ;AACR;;;;;;;;;;;;;ACzFA;;AAEA;AACA;AACI;AACA;AACA;AACA;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AAEU9b;AAAK;AACX;AACA;;;AAMIsd;AACAtd;AACR;AACI;;;AAGIud;AACR;;;;;AAMYA;AACZ;AACA;AACI;AAIkC;AAEtC;AACA;AACI5B;AACA/X;AACAgY;AACArX;AACAsX;AACAC;AAA2BkB;AAAW;AACtCH;;AAEJ;AACIlB;AACA/X;AACAgY;AACArX;AACAsX;;AAEAgB;;AAEJ;AACIlB;AACA/X;AACAgY;AACJ;AACA;AACA;;AACwD;;AAC3C;;AACY;;AACmC;;AACL;AAC/C;;;;AAKA;;;AAGA;AACA;AACI;;;AAIZ;AACQ;;AAEJiB;AAAc7c;AAAK;;;;;;;;;;;;ACjGvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AASA;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;AAQA;AACI;AACA;;AAIJ;;;;AAMY;;AAKZ;AACA;AACI;AACI;AAER;;AAGA;;;AAIQ;;AAEI;;;AAKZ;AACQ;AAEA;;AAER;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AAEA;AACA;AACIrH;;;;;;;AAAmF6kB;;AAC/E;;;AAOA;AACA;;;;;;;;;;AAIR;AACQ;AAMR;AACIhH;AACI;;AAEA;AACR;AACA;;;;;;;;;;;AClCA;AACA;AACA;AAEA;;AAEI;;;AAGI;AACInO;AACAoV;;AAIZ;AACI;;;AAGQtB;;;;AAIJ;;AAER;;;;;AAKY;AAEA;;;AAGZ;AACA;AACY3E;AACAkG;AACZ;;AAEQ;AACA;;AAIR;AACA;;AAEA;AAGA;AAEQrV;AACR;AACI;;AAEQ;AACA;AACIA;;AAEhB;AAEgBA;AAChB;AACA;AAEYA;AACZ;AACA;AAEQ;AACA;AAEA;;AAGIA;AACZ;AACA;AACI;AACJ;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACI1P;AACJ;;AAEA;;AAEA;;AAEA;;;;;;;AAKYglB;AACZ;AAEYzR;AACAoQ;AACZ;AACQ;AACIU;AACAY;AACAC;AACAC;AACAC;AACAC;AACAC;AACA3kB;;;;AAGEA;AAAO;;;AAGT;;AAI8CA;AAAO;AACzD;AACR;AACQ;AAER;AACA;AACA;AACA;AACA;AACA;AACIkd;;;;AAEmD;AACvD;AACQC;AACAA;;;AAGAA;AACA;;AAGR;;AAIQ;AAEA;AACR;AACA;;AAEQ;AAER;AACA;AACI+B;AACI;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI0F;AACI;AACI;AACAhG;AACZ;;AAEA;;AAEA;AACIwE;;AAEI;AACI1c;AAAwB;AAAW;AACnC2d;;AAGA;AACA;AACA;AAEAA;AACZ;AAEYzR;AACAoQ;AACZ;;;;;;;AACoFV;;;;;AAC9CzE;AAAa;AACnD;;AAEQ;;;;;AAKImF;;AAEAnF;;;AAGJ;AAEAgH;AACA;AACR;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEQ;AACR;AACA;AACA;AACA;AACA;;AAEQ;AACI;AAEZ;;AAEY;AACZ;AACQ;AAGR;AACA;AACA;AACA;AACA;AACA;AACIrnB;;AAIJ;AACA;AACA;AACA;AACA;AACA;AACI2hB;AACI;;AAOR;AACA;AACA;AACA;;AAEQ;AACR;AACA;AACA;AACA;;AAEQ;AAEA;AACR;AACA;AACA;AACA;AACA;AACI7hB;AACI;AACR;AACY;;;AAIZ;AACA;AACA;AACA;AACA;AACA;AACI8hB;AACI;AACR;;AAEA;AAEA;AACY;;;AAIZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI0F;;AAGI;AACA;AACI;;AAIsD9kB;;AAClD+kB;AAAQC;AAAyBxe;;AACjC;AACJ;AACA;;AAIsDxG;AAAO;AACzD+kB;AAAQC;AAAwBxe;;AAChC;AACJ;AACI;AAEAue;AACA;AACJ;AAAS;AACL;AACA;AAChB;AACA;AACA;AACQ;AAMR;AACA;AACIE;;;;;;AAAyD9G;;AACrD;AACIC;AACAsD;;;AAGApD;AACAC;;AAEJ;AACA;;AACwBN;AAAK;;AAGc;AAAO;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACIQ;;AACuByG;;AAA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V;AAAY;AAE/D;AACiBzV;;;AAAqCyV;;;AAItD3J;AAAuB9L;;;AAAqCyV;;AACpE;AACA;AACA;AACA;;AAIgB;AACA;AACI9U;AACA;AACJ;AACIA;AACA;AACpB;AACI;AACJ;AACA;;AAEQ;AACA;AACA;;;AAGI;AACJ;AAAqB;;AAEjB;;;;AAMAmL;;;AAAqC6F;;AACrC;AACZ;AACQ;AACA;AAAkB;;AAEd;AAAa3R;;;AAA+CyV;;;AAE5D3J;;;;;AACA;AACZ;AACQ;AAAS;;AAEL;;AAQAA;;;;AAA6C6F;;AACzD;AACA;AACA;;;;;;;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGQ;AAAqB;;AAEjB;AAEA;AACZ;AACQ;AACA;AAAkB;;AAEd;AAEA;AACZ;AACQ;AAAwB;AACpB;AACA;;AAIA;AACZ;AACQ;AAAiB;AACb;AACA;AAGA;AACZ;AACQ;AAAS;AACL;;AAIA;AACZ;AACA;AACA;AACA;;;;AAA0ChZ;AAAK;;;AAI3C;AAEA;AAGA;AAEA;AACJ;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA+W;;;AAGQ;AACA;AACInd;;AAIZ;AACI;;AAEJ;AACA;AACA;AACA;AACA;AACAmd;AACI;AACA;AACA;AACA;AAEA;;AAEJ;AACI;AACA;;AAGI;AACA;AACI;AACI;;;AAOI/c;AACpB;AACA;AACY;AAEZ;AACA;AACI;AACJ;;;;;;;;;AC9FA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAKA;AACA;;AAEI;AACI;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACZ;AACA;AACA;;AAEI;AACI;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACA;AACA;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACZ;;AAEQ;AACA;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACA;AACI;AACZ;AACI;AACJ;AAEyBgoB;AACFA;AACDA;AACLA;AACJA;;;;;;;;;;;;;;;;;;ACrGb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAYI;AACI;AACA;AACA;AACA;AACA;AACI;AACJ;AACI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIrpB;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACQ;AACR;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;AACI;;AAGI;;AAEZ;AACQ;AACA;;AAGR;AACIspB;AACI;AACA;AACA;AAEA;AAEA;AAEA;AACR;;;AAGA;;AAEQ;AACA;;AAEI;;;AAII;AAEhB;;AAIA;AACQ;;;AAIR;AACQ;AACR;AACIC;AACI;AACA;AACIlJ;;AAEZ;;AAGQ;;AAGR;;;AAGA;;AAEQ;;;;AAIA;AACR;;;AAGA;;AAEQ;AACI;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AACJ;AACI;AAChB;AACA;;AAEQ;;;AAII;AACAqH;AACZ;AACQ;AACI;AACA;AACA;AACI;AACA;;AAEI;AACpB;;AAGA;AACA;AACY;AACI;AACA;AAIhB;AACY;;;AAGA;AACZ;AACQ;;;AAGI;AACA;AACZ;;AAEQ;AACR;;AAEQ;AACA;AAEA;AACI;AAEA;AACA;AACI;;;AAGA;AAChB;AACA;;;AAIQ;AACR;;;AAGQ;AAEA;AACI;AACA;;AAEA;AACZ;AACQ;AACR;;AAEQ;AACA;;AAGA;;AAEI;;AAEZ;AACY;AACI;AACA;AACJ;AACA;AACI;;;AAGA;AACJ;AACA;AACZ;AACgB;AACA;AACJ;AACI;AACA;AACJ;AACA;AACI;AACJ;AACA;AACItD;AACAA;;AAEA;AACA;AACJ;AACI;AAChB;AACA;;;;;AAKYoF;;AAEIC;AACA;AAChB;AAEgBA;AAChB;AACYA;AACZ;AACQ;;;AAOR;AACA;AACA;AACY;;AAIZ;;;AAGgB;AAChB;AACA;;AAEQ;AACIrF;AACAA;;AAEZ;AACQA;;AAEI;AACI;AACJ;;AAEI;AACJ;AACA;AACI;;;AAGA;AACJ;AACA;AACI;;;AAGA;AACJ;AACI;AACA;AACJ;AACA;;AAEI;AACJ;AAAU;AACN;AACA;;AAEI;AACA;AACA;AACpB;AACA;AACA;AACY;;AAEI;AAChB;AACA;;AAEQ;AACA;;AAEI;AAEZ;AAEA;AACY;;AAEI;AAEA;AAEA/D;AAChB;AACA;AACA;;;AAGQ;AACI;;AAEI;;AAGhB;AACY;AACZ;AACgBA;AAChB;AACA;AACQ;;AAGIA;AACZ;;AAEQ;AACR;;AAEQ;;AAEA;AACA;;AAEI;AAMZ;AACQ;AACR;;;;AAIQ;;AAEI;AACI;AACI6B;AACA;AACJ;AACIsH;AACAtH;AACA;AACJ;AAAW;;AAEP;;AAIH;AAAA;AACD;AACI;AACpB;AACA;AACQ;AAEA;AACI;AAGI;AAEhB;;;AAGgB;;AAGhB;AACY;;AAGIsH;AAChB;AACA;AACA;AACA;AACQ;AACA/I;AACA;;;;AAMR;;AAGgB;AACA;AACA;AAEA;AACA;;AAMhB;AACA;;;AAGQ;AACR;;AAEQ;AACA;AACA;AACA;;;;AAIQ;AAEAJ;AAChB;;;;AAKwBhf;AACAof;;;AAKxB;AACgB;;;AAII;AAEApf;AACpB;AACA;;AAIgBgf;AAChB;AACA;AACQ;;;AAIA;AACR;;;;;AAKY;AACZ;AACQ;AACR;AACI;AACI;AACA;AACI;AACA;;AAEZ;AAGQ;AACR;;AAEQ;AACI;;AAIA;;;;AAMA;AAAU;AACN;AACA;AACA;;;AAQhB;AACA;AACA;AACQ;AACR;;;AAGY;AACA;AACA;AAEA;AACZ;AAEY;AACA;AACA;;;AAOZ;AAGA;;AAEA;AACA;;;AAGQ;AAMR;;AAEQ;AACA;;AAEII;;AAEJ;;;;AAIR;AACQ;AACR;;AAEQ;AACA;AACA;;AAGR;AACA;;;;;;;;;;;;AC1sBA;AACA;AACA;AACA;AACA;AACA;AACIzgB;;AAEJ;AACA;AACA;AACA;AACQ;AACR;AACA;AACA;AACA;AACA;AACQ;;AAEI;;;AAGI;AAIhB;;;AAEwCgmB;;AAC5B;AACa0B;AAAS1B;;;;AAEb0B;AAAW1B;;;AAEhC;AACA;;;;;;;;;;;;ACnCA;AACA;AAEA;;AAII;AACJ;;AAEI;AACI;AACI;AACA;AACA;AACI;AACJ;AACI;AAChB;AACA;AACI;AACJ;;;AAGQ;AACA;AACA;AACA;AACA;AACI;AACJ;AACI;AACZ;AACA;;;AAGQ;;AAEA;AAAkB;AACd;AACA;AACZ;AACQ;AACI;AACZ;AACQ;AACI;AACZ;AACA;AACA;;AAEI;AAEA;AACAgB;AACI;AACI;AACA;AACA;AACA;AACA;AACI;AAChB;AACA;;AAEA;AAAA;;AAGA;;AAEI;AACI;AACI;;;AAOI;AACI;AAIpB;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AAC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wB;AACA;AACxB;AACA;AACA;AACA;AACQ;AACA;AACR;;AAEQ;;AAEI;;AAEQ;AACA;;AAIqBA;;;AAIzB;AACJ;AACA;;AAEyBA;;AAEjB;AACI;AACA;AACA;AACIkI;AACA1I;AACA2D;AACA;AAC5B;AACA;;AAEA;AACgB;AACJ;AACA;;;AAII;AACJ;AACI;AAEA;AACqBnD;;AAGrB;AAChB;AACQ;AACI;AACA;AACI;AACA;AAChB;AACA;AACQ;AACA;AACR;;AAEQ;AACA;AACI;;AAEI;AACA6I;AAChB;;;AAIgB;AACA;AACI;AACoB7I;;AAGpB;AACJ;AACI;AACoBA;AAAWjY;AAAWke;;AAIlBle;AAAWke;;AACnC;AACJ;AACA;AACA;AACA;AACA;AACI;AACoBjG;;AAKpB;AACJ;AACA;AACA;AACA;AAA6B;;AAEzB;AACoBA;AAAWjY;AAASke;;AAIhBle;AAASke;;AACjC;AACpB;AACgB;AACA;;AAEI;AACpB;AACY;AACZ;;AAIgB;AACA;AAChB;AACA;AAEY;AACA;AAII;AACA;AAChB;AAGgB;AACA;;AAEA;AACAA;AACA;AACIpY;;;AAGA5I;;AAAiB8C;AAASke;;;;AAG9B;AAChB;AAEgB;AAChB;AACA;AACA;;;;;;AAMgB0C;AAChB;AACA;;;;;;;AAOA;;;AAGY;AACA;AACA;AACA;AACI;AACJ;;AAEQ9a;;;AAGAW;AACA8U;;AAER;AACA;;AAEQzV;;;;AAIA5I;AACAua;;AAER;;AAEQ3R;;;AAGA5I;AAAU+a;;;AAElB;AAAyB;;AAErB;AACA;AACAA;;AAEInS;;;AAGA5I;;AAAiB2c;;;AAErC;AACY;AAAsB;;AAElB;AACA;;AAEI/T;;;AAGA5I;;AAAiB8C;AAAWke;;;AAEhD;AACA;AACQ;AACR;AACI6C;AACI;AAEA;AAEA;AACR;;AAEQ;;;AAOR;AACA;;;AAGY;AACA;AACA;AACA;AACA;AACA;AACI;AACA;AACA;AACJ;;AAEZ;AACY;AACA;AACA;AACZ;;;AAOA;AACA;AACA;;;;;;;;;;;ACv8BA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGI;AACA;;AACSC;AAA4BzE;;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAEyBA;;;;AAGrB;;AAGQ9C;AACAA;AACZ;AACI;AAEA;AAA2BwH;AAAa;AAC5C;AACA;;;;AAEyB1E;;;;AAGzB;;;AAGQ;;AAII;AACZ;AACA;;AAEQ9C;AACAA;AACR;AACI;AACJ;AACA;;AAEI;AACIyH;AACR;AAEQvW;AACR;AACI;AACA;AAEA8O;AACA;;AAKJ;AACI;AAAgCvD;;AACpC;AACA;;;AAGQkG;AACR;AAEQzR;AACR;;AAGI;AACI;;AACkD2O;;AAAgBA;;AAC1E;;;AAEgBxC;AAAa;AACrB;AAER;AACI;AAEA;AACJ;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIgBqK;AACAA;AACFA;AACGA;AACKA;AACHA;AACNA;AACEA;AACKA;AACFA;AACLA;AACCA;AACAA;AACEA;AACHA;AACDA;AACEA;AACCA;AACAA;;AAEFA;AACMA;AACLA;AACDA;AACYA;AACJA;AACJA;AACJA;AACKA;;;;;;;;;;AC/ClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACEC;AACAtb;AACA5D;AACEmf;AACEvb;AACA5I;AAAS4I;;AACToG;;AAEFoV;AACExb;AACAoG;AACA3J;AACAf;AAAwBsE;AAAiB;;AAE3Cyb;AAAQzb;AAAiBoG;AAAgB7J;;AACzCmf;AAAW1b;AAAiBoG;AAAgB7J;;AAC5Cof;AAAyB3b;AAAiBoG;AAAgB7J;;AAC1Dqf;AAA4B5b;AAAiBoG;AAAgB7J;AAAe;;AAE9EgB;AACA7B;;AAGFmgB;AACEC;;;;;;;;;;;ACpCMC;AAAQ;;AAERxf;;;AACAyS;;;AACA3K;;;AAEAyX;;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACER;AACAtb;AACA5D;AACEnK;AAAW+N;;AACXgc;AACEhc;AACA5I;AAAS4I;;AACTzD;;AAEF0f;AACEjc;AACAvD;AACAf;AAAwBsE;;AACxBzD;;AAEF2f;AACElc;AACA5D;AACEsf;AAAW1b;AAAiBoG;;AAC5B+V;AACEnc;AACA5I;AAAS4I;;AACToG;;AAEFuV;AAAyB3b;AAAiBoG;;AAC1CwV;AAA4B5b;AAAiBoG;;AAC7CgW;AAA6Bpc;AAAiBoG;;AAC9CiW;AAA+Brc;AAAiBoG;AAAc;;AAEhE3J;AACAf;AACAa;AACD;;;AAGHb;;;AAIA1D;AACAskB;AACAC;AACA1c;;AAGF;AACE;AACA2c;AACF;AAEA;;AAEA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACE;;AAGEC;;;AAGE;AACN;AACI;AAAwE1tB;AAAY;AACxF;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACE;;AAGE2tB;;AAEA;AAAmE3tB;AAAY;AACnF;AAEE;AACE;AACA;AACE;AACN;AACA;AAEE;AACE;AAKJ;AAEE;AACF;;AAEA;AACA;AACA;AACA;;AAEE;AACE;AACJ;;AAIE;AACF;;AAGA;AACA;AACA;AACA;AACA;AACEuC;;;AAGF;;;AAGA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEE;AACE;AACJ;;AAEA;AACE;AACEW;AACA+pB;AACAC;AACAC;;;;;;;;;;AAIJ;;AAGE;AACF;;AAEA;;AAEE;AAAiBjqB;;AAEjB;AACE;AACJ;AAEE;AACF;AAEA0qB;;;;;AAKEC;;;;;;;;;;;;;ACzNF;;;AAKA;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAOA;;AAEA;AACA;AACEC;AACF;;;AAIE/Q;AAAoCnT;AAAK;AACzC;;;AAKF;;AAEA;AACA;AACA;AAIA;AACA;AAAA;;AAIA;;;AAESuM;AAAM;;;;AAIf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAIA;AACA;AACA;;AAKA;AACE;AACF;AACA;AACA;AACA;;AASA;AACA;AACA;AACA;AACE;;AAGWA;AAAM;AACb;AACN;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAOA;;AAKA;AACE;AAEF;AACA;AACA;;AAKA;AACE;AAMF;AACA;AACA;AACA;AACA;AACA;;AAGA;AACI;AAGJ;AACE;AACF;AACA;AACA;AACI;AAEJ;AACM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAAA;AAEA;AAGA;AACE;AACF;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AAAA;AAIA;AACE;AACF;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACI;AACJ;AACA;AACA;AACA;AACA;;;AAGA;AAIA;AACA;AACA;AACI;AAKJ;AACI;AAKJ;AACA;;AAEA;AACI;AAEJ;;AAIA;AACA;AACA;AAAA;AAEA;AACA;;AAKA;AACE;AACF;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACI+T;AACJ;AAAA;AAEA;AAAA;;;;;AAUA;AACE;AACE;AACJ;AACA;AACA;;AAEA;AACA;AAAA;;AAGA;AACA;AAAA;;;AAME;AACF;AACI;AACJ;AACA;AAAA;;AAGA;AACA;AAAA;;AAIA;;;AAGA;AACA;AAMA;;AAEA;;;AAMA;AAAA;AAGA;AAIA;AACE3nB;;;;AAYEwrB;AACAA;AACAA;AACJ;;AAGI;AAEA;;AAEJ;AAEI;AACJ;;AAGI;AAEA;;AAEJ;AAEI;AACJ;AAEEC;;AAIF;;AAII;AAIA;AACJ;AACA;;;AAIEC;;;;;AAKF;;AAEIC;AACAC;AACJ;AAEEA;AACF;AACA;AAAA;AAEA;AACA;AAAA;AAGE;AAEA;;AAUF;;;;AAIA;;AAGA;AACI;AACE;;AAEA;AACN;AAEI;AACEjgB;AACEA;;AAER;AAEI;;;AAGE;AACN;AACA;;AAEA;;;;;AAWA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACEuX;;;AAGE;AAEA;;AACSyI;AAAQ;;AAErB;AACA;AACA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;;AAE1B;AACN;;AAEA;AACA;AACA;;;;AAIM;AAEA;AACEA;AACR;;;AAIUA;AACA;AACV;;;AAIU;AACV;AAEQA;AACR;AAEM0pB;AAAOriB;AAAcrH;AAAK;AAC1B;AACN;;AAEA;AACA;AACA;;;AAGM4hB;;AAGA;AACEva;AACAwiB;AACAC;;;AAGAC;AACAC;AACAvuB;;AAGFmX;AACAgX;AACAF;AAAOriB;AAAcrH;AAAK;AAC1B;AACN;;AAEA;AACA;AACA;;;AAGM;AACE0pB;AAAOriB;AAAcrH;AAAK;AAC1B;AACR;;AAGM4S;;AAGA8W;;AAAa1pB;;AACb4hB;;AAGA;AACN;;AAEA;AACA;AACA;;AAEI;AACE;;;AAGEhP;AAAuBvL;;;AAC/B;AAEMqiB;AAAOriB;AAAerH;AAAK;;AAE3B;AACN;;AAEA;AACA;AACA;;AAEI;AACE;;AAGE0pB;AAAOriB;AAAcrH;AAAK;AAC1B;AACR;AAEM;;;;AAKE;;;;AAIE;AACV;;;AAIQ;AACR;AAEM;;;AAIEiqB;AACA9Q;;AAEA;AACR;AAEMuQ;AAAOriB;AAAarH;AAAK;AACzB;AACN;;AAEA;AACA;AACA;;AAEI0pB;AAAOriB;AAAcrH;AAAK;AAC9B;;AAEA;;AAEI4S;AAEA;AACEA;AACE;;;;;AAKR;AACA;;AAEA;;;AAGA;AACMvY;AACN;AACA;AAEEqvB;AAAOriB;;AACP;;AAGF6iB;;;;;;;;;ACxUA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAKE;AACE;;AAEE;AACElf;AACR;AACQA;AACR;AACA;AACA;AACIA;AACJ;AAEE;;AAEF;AACE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAmf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE;AACE;AACJ;AACE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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E;AAEF;AACE;AAEF;AACE;AAEF;AAAS;AACP;;;;AAMA;AACR;AACA;;;AAIE;AAEA;;AAEF;AAEE;;AAGFqvB;;;;;;;;;;AC/jCA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE;AACE;;AAEE;AACE;;AAER;AACM;;AAEF;AACJ;AAEE;;AAGE;AACJ;AAEE;AACA;;AAKA;;AAGA;;AAEE;AAAqB;AAAYtH;AAAc4L;AAAeC;;;AAElE;;;;;AAG4BzjB;;;AAAyD0jB;AAAK;AACtF;;;;;;;;AAAkEC;;AAElE;AACEvuB;AACN;;;AAIM;AACN;AAEI;AACE;AACEA;AACR;;AAEM;AACN;AAEI;AACEA;AACN;AACI;;AAGF;;AAEF;AAEE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAEiDsuB;;AAC/C;AACE;AACJ;;;AAGaC;AAAgB3jB;;AAC7B;AAEE;AACA;AACA;;;;;AAMF;;;AAIMsV;AACN;AACMA;AACN;AACA;;AAEWqO;;AAAgC3jB;;;;AAG3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA4jB;AACE;;;;AAIF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA;;;AAE0B;AAAYd;;;;AAGtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAc;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA;;;AAGA;AAEE;;;;AAKA;;AAEF;;;;AAKA;AAEE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA;AACE;AACE;AACJ;AAEE;AAAe/B;AAAgBiB;;;;AAIjC;AAEE;AACEjhB;AACJ;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA+hB;;AAEI;AACA;;;AAGA;AACJ;;;AAGA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEAC;;;;;;;;;;;;;;;;;;;AClVA;AACA;AACA;;;AAIE;AACA;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGEC;AACAC;AAEA;AACA;AACA;;;AAIEtwB;AACA;AACEyN;AACN;;AAGE;;AACiD;AAAYuiB;;AAC3D;;AAGA;AACE;;;AAKA;AACEO;AACR;AACQA;AACArX;AACR;AACA;AACA;AAEE;AACA;AAEA;AACE;;AAEJ;;;AAIA;AACA;AAEE;;;AAGF;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAsX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA;;AAEA;AACA;AACA;;AAEAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA;;AAEE;;;;AAKExwB;;;AAGiD;AAAYgwB;AAAQ;AAEvE;AACE;AACEvJ;AACN;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE;;AAEF;AAEE;AACE;AACJ;AAEE;;AAEI;AACN;;AAGM;AACN;AACA;AAEE;AAA0C;AAAYpiB;;;;AAGxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE;AACE;AACJ;AACE;;AAEA;AACA;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE;;;;AAKI;AACN;AACA;AACE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE;;;AAIE;AACE;AACN;AACA;AACE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE;;AAEF;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE;;AAC6C;AAAYosB;;AACzD;AAEA;AACE;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA;;;AAGI;;AAEJ;AACA;AACE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA;;AAEE;;AAEF;AACE;;;AAGF;AACA;AACA;;AAEAA;;AAEE;AAAoC;AAAYE;;;;AAGlD;AACA;AACA;;AAEA;;AAEAC;;;;;;;;;;;;;;;;;;;;;;ACxdAjc;AAA+CnT;AAAW;AACrCkL;;;;AAIrB;AACA;AAC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;ACpEF;;;AAEe;;AACN;;AACY;;AACT;;AACF;;AACa;;AACH;;AACG;;AACA;;AACG;;AACf;;AACS;;AACI;;AACA;AACtBzI;AACF;;AAGE;;;AAIA;;AAEF;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACE;AAEA;AACA;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AACA;AAAclpB;AAAW4hB;AAAUsK;;AAEnC;;;AAGE/S;AACA;;;;AAKA;;AAGEgT;;;AAIEC;AACR;AACM;AACN;AAEI;AACEjC;AAEA;;AAEIgC;AACAE;AACA;AACV;;AAGUlC;AACA;AACV;AAEQ;AACEmC;AACAJ;AACAK;;AAGE;AACZ;AAEU;AACV;AAEQ;AACED;AACAJ;AACAK;;AAGE;AACZ;AAEU;AACV;;AAGUpC;;AAGEiC;AACAE;AACAC;AACA;AACZ;AACA;AACA;;AAGQ;AACR;AAEM;AACN;;AAGMC;AACA5G;AACA6G;AAAUzsB;AAAW4hB;AAAUsK;;;;AAI7B1S;AACA;AACR;;AAGM;AACN;AAEI;;;AAQI0S;AACAQ;AACAH;AACA;AACEI;AACV;;AAGU;;AAEIR;;AAEA;AACd;;AAGcD;AACAK;AACA;AACd;AACA;AACU;AACV;AACQ;AACR;AACA;;;AAIML;AACAK;;AAGE;AACR;AACM;AACN;;AAGML;AACAK;;AAGE;AACR;AACM;AACN;;AAGM;;AAEIJ;AACAE;AACA;AACV;;AAGUO;AACAV;AACAK;AACA;AACV;AACA;;AAGQ;AACR;AAEM;AACN;AAEI;AACEM;AACArT;AACA;AACN;;AAGM0S;;AAGE;;AAEIC;;AAEA;AACZ;;AAGYI;AACA;AACZ;AACA;AACQ;AACR;AACM;AACN;;AAGMA;;AAGE;AACR;AAEM;AACN;AACA;AAEE;AACEG;AACAR;AACJ;;;;;;AAQIzS;AACAqT;AACJ;;;AAIIC;AACJ;AACI/gB;AACA+gB;AACJ;AACI/gB;AACJ;AAEE;AACE;;AAEJ;AACA;AAEE;;AAGE;AACEA;AACN;AACA;AAEE;;;;;;;;;;;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AACEvuB;AACN;;;AAIM;AACN;AAEI;AACE;AACEA;AACR;;AAEM;AACN;AAEI;AACEA;AACN;AACI;;AAGF;;AAEF;AAEE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAEiDsuB;;AAC/C;AACE;AACJ;;;AAGaC;AAAgB3jB;;AAC7B;AAEE;AACA;AACA;;;;;AAMF;;;AAIMsV;AACN;AACMA;AACN;AACA;;AAEWqO;;AAAgC3jB;;;;AAG3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE;;;;AAIF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA4jB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA;;;AAE0B;AAAYd;;;;AAGtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAc;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA;;;AAGA;AAEE;;;;AAKA;;AAEF;;;;AAKA;AAEE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA;AACE;AACE;AACJ;AAEE;AAAe/B;AAAgBiB;;;;AAIjC;AAEE;AACEjhB;AACJ;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA+hB;;AAEI;AACA;;;AAGA;AACJ;;;AAGA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEAC;;;;;;;;;AClVA;AACA;;AAGA;AACE;AACF;AACI3iB;AAAY;AAAYylB;;AAC5B;AAEE;AACF;AAEAxe;AACA0b;;;;;;;;ACfA1b;AAA+CnT;AAAW;AAC3C4xB;;AAEf;;AAEA;;AAEIC;AACAC;;AAGJ;AAAA;AAEA;;AAEI5lB;AACI6lB;AACA9B;;AAEA+B;;;;;;;;AAKA;AACR;AACIC;AACI;AACA;AACR;;AAEQ;AACA;AACR;AACIC;AACI;AACA;AACR;AACIC;AACI;AACA;AACR;AACIC;AACI;AACA;AACR;;AAEQ;AACA;AACR;;AAEQ;AACA;AACR;AACIC;AACI;AACA;AACA;AACR;AACIC;AACI;AACA;AACR;AACIC;AAAeC;;AACX;AACA;AACA;AACR;;AAEQ;AACA;AACR;AACIC;AACI;AACA;AACR;;;AAGQ;AACR;AACIC;AACI;AACA;AACA;AACR;;AAEQ;AACA;AACR;AACI9C;AACI;AACA;AACR;;AAEQ;AACR;;AAEA;;AAEQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI+C;;;;;AAEI;AACR;;;AAGY;AACZ;AACQ;AAA4CzF;AAAS;AAC7D;AACI0F;AACI;AACR;;AAEY;AACZ;AACQ;;AAEIjE;;AAEZ;AACQ;AACA;AACR;AACA;;;;;;;;;;;ACrIAxb;AAA+CnT;AAAW;;;;;;;;;;;ACCtD;;;AAGE8wB;AAAS7jB;;;;;AACf;;;AAGI;AACA8jB;AACJ;AACA;AACI;;AAEJ5d;AAA+CnT;AAAW;AAC1D+S;AACA;AACAI;AAAyClG;;;AAAgE;AAAA;AACzG4lB;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B/7B;AAAgBmW;;;;;AAI1C;AAEyBnW;AAAsBmW;;AACnD;AACE;;;AAGF;AACA;AACA;AACA;AACE6lB;AAAuE9yB;AAAYiN;AAAgB;AAGrG;AAAsEjN;;;AAEtE;;;;;;;;AAQA;AACA0iB;AACA;AACA;;;AAGA;;;AAGA;AACE;AACA;AACA;;;AAGEqQ;AACA;AACA;;AAEEC;AACN;AACIC;AACJ;AACE;AACE;AACA;AACE;AACN;AACI;AACE;AACA;AACA;;;;AAIE;AACA;AACE;AACV;AACQ;;AAEE;AACV;;AAEU;AACV;AACQ3hB;AACR;;AAEQ;AACR;AACA;AACI;;AAEJ;AACA;AAA4BiM;;;AAE1B;;;AAGF;AACA;;;;AAIA;;;AAGA;AACA;;;;;AAKA;AACA;AACE;AACE;AACJ;;AAEE;AACF;AACA;AACE2V;AACF;;AAEA;;;;;AAKE;;AAEA;;AAEF;;AAEIhO;AACJ;AACE;AACEA;AACJ;;AAEA;AACE;;AAEE;;;AAGEld;AACN;;AAEI;AACA;;AAEA;;AAEE;;;AAGE;AACR;;AAEQ;AACR;AACMmrB;AACN;AACInrB;;;AAGJ;AACE;AACF;AACA;;AAAqC4a;AAAawQ;AAAwB;AACxE;;AAEF;;AAEA;AACE;;AAEF;;;AAGE;;AAEI;AACN;AACI;AACEC;AACN;AACA;AACE;;AAEI;AACN;AACI;AACEC;AACN;;AAEA;AACA;;AACWhT;AAAsBsC;;AACjC;AACA;AACE;AACF;;;;AAII;AACJ;AACE;AACF;AACA;AACE;AACE;;AAEJ;AACE;AACF;AACA;AACE;;AAEF;;;AAGA;AACE;;AAEF;AACE;AACE3S;AACAsjB;AACAC;;;AAGF;;AAEEvX;AACJ;AACE;;;;AAIF;AACE;;AAEEwX;AACJ;AACE;;AAEEA;AACJ;AACE;AACF;;AAGQ;AACA;AACA;AACExX;AACV;AACQ;;;AAIF;AACA;AACA;AACEA;AACR;AACQA;AACR;AACM;AACN;AACM;AACA;;AAEFoT;AACAK;AACAgE;;;AAGAC;AACJ;;;;;AAKA;AACE;;;AAGF;;;;AAIA;;AAEA;AACE3rB;AACA;;AAEEiU;AACJ;AACE;AACA;AACE;AACJ;AACE;AACF;AACA;AACE;AACE;AACJ;AACE;AAA2F;AAAY6S;AAA6B;AACpI;AACA;AACF;AACA;AACE;AACE;AACJ;AACE;AAA2F;AAAYA;AAA6B;AACpI;AACA;AACF;;;;;;;;;;;;;;;AClUA;AACA;AACA;AACA;AAEA;;;AAGA;AAEC;AACA;AAEA;AACC;AACA;AAEA;AACF;AACG;AACH;;AAEA;;AAEA;AACA;;;;AAKE;;AAEChC;;AAEH;;AAIE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoDF8G;;;;;;;;;;;;;;ACxFQC;AAAG;AAEX;;;;;;AAE+C;;AAE3C;AAGA;AACJ;AAEEC;AACE;;AAEEC;AACA7pB;AACAuC;;AAEAunB;AACAC;AAAW;AAAqCC;;;AAChDC;AACAC;;;AAIA;;AAEN;AAEI;AACEC;AACN;AAEI;;;;AAIE;AACEz7B;AACR;;AAEQA;AACR;AACK;AAED07B;;AAEC;AAEDA;;AAEE17B;AACD;;AAGL;AACA;AAEA;;;;;;AAE+C;;AAE3C;AAGA;AACJ;AAEEk7B;AACE;;AAEEC;AACA7pB;AACAuC;;AAEAunB;AACAC;AAAW;AAAqCC;;;AAChDC;AACAC;;;AAIA;;AAEN;;AAEA;AACI;AACEC;AACN;AAEI;;;;AAIE;AACE;AAA8C;AAAYE;AAAQ;AAClE37B;AACR;;AAEQA;AACR;AACK;AAED07B;;AAEC;AAEDA;;AAEE17B;AACD;;AAGL;AACA;AAEA47B;;AAEEC;;;;;;;ACzH4BC;AACjBD;;;;;;;;;;ACDb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;;;;AAKA;AACA;AACA;AACA;;;;;;AAMA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;ACroBA;AACI;;AAEIhb;AACJ;AACA;AACI;AACJ;;;AAII;;AAEI;AACA;AACIkb;AACAC;AACJ;AACA;AACID;;AAGAE;AACJ;AACJ;AACA;AACJ;AACJ;AACA;AACI;;;AAGA;AACI;AACA;AACA;;AAEA;AAEIC;AACJ;AACJ;AACA;AACJ;AACA;;AAGI;;;AAMA;AACJ;AACA;AACI;AACI;AACJ;AACAC;;;;;;AAMA;AACIC;AACAxrB;AACA;AACI;AACIxP;AACJ;AACA;AACJ;;AAEIi7B;AACJ;AAEIA;AACJ;;AAGAC;AACJ;AACA;AACJ;AACA;AACA;AACIC;AACAA;AACAA;AACAA;AACJ;AACA;AACA;;AAEQC;AACJ;AACA1pB;AACI;AACI2pB;AACAC;AACAC;AACAvR;AACAwR;AACAC;AACAC;AACApe;AACA1T;AACA+xB;AACAC;AACAnD;AACA5M;AACAgQ;AACAC;AACAv0B;;AAEJ;AACA;AACA;AACA;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACIw0B;AACAC;AACAC;AACAC;AACAC;AACAhF;AACAsB;AACA2D;AACAC;AACAC;AACA5zB;;;AAGJ;AACA;;AAEI;AACI;AACI6yB;AACA1P;AACAgQ;;;;AAIR;AACIU;AACJ;AACAA;AACAA;AACJ;AACA;AACIA;AACAA;AACJ;AACA;AACIA;AACAA;AACJ;AACA;AACIA;AACAA;AACJ;AACA;AACIA;AACAA;AACJ;AACA;AACIA;AACAA;AACJ;AACA;AACIpjB;AACI;AACIojB;AACAA;AACJ;AACJ;AACJ;AACA;AACIpjB;AACI;AACIojB;AACAA;AACJ;AACJ;AACJ;AACA;AACI;AACI;AACIA;AACJ;;AAGApjB;;AAEQojB;AACJ;AACJ;AACJ;AACJ;AACAC;;AAEI;AACIC;AACJ;AACJ;;AAEAC;;AAEA;AAAkD7V;AAAM;;AAExD;AACI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAKI;;AAGA8V;AACA;;AAEQ38B;AACJ;AAEIA;AACJ;AAEI48B;AACJ;AACJ;AACJ;AAEID;AACA;AACIp1B;AACAq1B;AACJ;;AAGAD;AACA;AACIp1B;;;AAGA;;AAGA;AAEIge;AACA;AAIIqX;AACA58B;;AAGA48B;AACA58B;AACJ;AAEI48B;AACJ;AACJ;AACJ;;AAGAD;AACA;;AAEA;AACJ;AAEIpX;A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;AACJ;AACJ;AACAD;;AAEQ;AACJ;AACA;;AAEIE;AACJ;AACJ;AACA;AACJ;AACA;;AAEA;AACA;AACI;AAEA;AACJ;AACA;;AAMA;AACA;AACA;AAGA;AACA;AACI;;AAEI;AACJ;AACJ;AACA;AACA;;;AAGQ;;;AAGJvF;;;AAGI;;;;AAKA;;AAGA;AACJ;AACJ;AACA;AACI;;AAEJ;AACAwF;;AAEA;AACAA;AACAA;AACAA;AACA;AACA;AAKA;AACA;AACC/rB;AACCgsB;;;;AAID;AACC;AACD;;;AAEO/rB;AAAM;;;AAGb;;AAEA;AACA;;;AAGE;AACD;AACA;AAAwBgsB;AAAoB;;AAE3C;AACD;;;AAKA;AACAhsB;AACD;AACA;AACD;AACA;AACC;;AAEA;AACA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKC;AACC;AACAisB;;AAECvS;AACAwS;AACAC;AACAC;AACArS;AACD;;AAECoS;AACAC;AACAF;AACD;AACCA;AACAC;AACAC;AACD;AACD;AACA;AACD;AACA;;AAEC;AACD;AACA;;;;AAMA;AACA;AACC;AACC;AACD;AACArsB;AACCssB;AACAC;;;AAGD;;AAIA;AACC1tB;AACD;AACA;AACC;AACD;;;AAOA;AACC;AACC;AACD;AACA;AACD;AACA;AACA;AACCA;AACD;;AAEAA;;AAECA;AACD;AACA;AACD;AACA;AACCpS;AACC;;AAEC;AACD;AACA;AACC;AACD;AACA;;AAEA;AACA;AACA;;AAED;;AAEC;AACC;AACD;;;AAGA;AACD;AACA+/B;AACC;AACC;;AAEA;AACA;AACD;AACA;AACD;AACAC;;;;AAIC;AACD;AACAC;AACC;AACD;AACAC;AACC;AACA;AACD;AACAC;;;AAGC;;AAEC;AACA;AACA;AACD;AACD;AACAC;AACC;AACA;AACD;;AAEC;AACC;;;;AAIE;AACD;AACD;AACD;AACA;AACC;;;AAGC;AACD;AACD;AACD;;;;AAIE;AACD;;;;AAIE;;AAED;AACD;AACD;AACAniC;;;;;AAME;;AAECoiC;AACD;AACD;AACC;;AAAuBA;AAAM;AAC9B;AACA;AACD;;;AAGE;AACD;;AAEC;AACD;AACA;AACD;;;;AAIC;;;AAGA;AACD;;;AAGC;;AAEA;;AAED;AACAriC;AACC;AACA;;AAED;;AAEC;AACC;AACD;;AAEA;;AAEC;AACA;AACA;AACD;;;AAGC;AACA;AACA;;AAED;;AAED;;AAEC;AACC;AACD;AACD;;AAEC;AACC;AACD;AACD;;AAEC;AACC;;;AAGC;AACD;AACD;AACA;AACC;;;;AAIE;AACD;AACD;AACD;AACD;;AAEC;AACA;AACC;AACA;;;AAGC;AACD;AACD;AACA8H;AACA;AACC;AACA;;;;AAIE;AACD;AACD;AACD;AACD;;AAEC;AACC;AACD;AACD;;AAEC;AACC;AACD;;;;AAIEw6B;AACD;AACD;AACA;AACD;AACAzI;AACC;AACD;AACA0I;AACC;;AAEA;AACD;;AAEC;AACD;AACD;AACA;AACC;;AAEA;;AAEA;AACD;AACA;AAA8BC;AAAgB;AAC9C;AAMA;AACC;AACC;AACD;;;AAGCX;;AAEAN;AACAO;AACD;AACA;;AAEC;AACC;AACA;;AAEA;AACD;;;AAGC;AACCl3B;AACD;AACC;;AAAgD63B;AAAeX;AAA4B;AAC3F;AACCY;AACD;AACA93B;AACD;AACD;AACA;;;AAGF;AACA;AACC;;AAEA;AACA;AACD;AACA;;AAEC;AACA;AACCiY;AACD;;AAECR;AACD;AACA;AACD;AACA;;AAEA;AACA;AACC;;AAEC;AACD;;AAED;AACA;AACA;AACC;;AAEC;AACD;;AAEA;AACD;AACA;;AAEE6B;AACAye;AACD;AACA;AACC;AAGD;AACA;AACC;AAGD;;AAEC;AAGD;AACA;AACC;AAGD;;AAEC;AACD;AACA;AACA;AACD;AACA;;AAEA;AACA;AAOA;AAEA;AACA;AAEA;AACA;AAUA;AACEzS;;;AAGA0S;AAMF;AAAYxmB;AAAW;AACtB;;;;AAIE8T;AACF;;AAEA9T;AACA;AACA;AACA;AACA;;;;;;AAUI/S;AAGF;AACA;;;AAGA;;AAEAw5B;AACA7Y;AACA8Y;AACAC;AACAC;;AAEFC;AACAA;AACAA;AACAA;AAGAA;AAGAA;AAEAA;AAEAA;AAEAA;AAEAA;AACAA;;;;;AAUAA;;;;;AAeAA;AACAA;AACAA;;AAKAA;;;AAMAA;AACAA;;AAEAA;AACAA;AACAA;AACAA;;AAEAA;AACAA;AACAA;AACAA;;;;;AAYAA;AACAA;AACAA;AACD;AACA;AACA;AAAoCC;AAAY;AAChD;AACA;;AAEI;AACF;AACA;AACE;AACF;AACA;AACF;AACA;AACA;AACA;AACE;AACA;;;;AAIA;AACA;AAKF;AAEA;AACEC;AAGF;AACA;;AAAoBP;AAAiB;AACrC;AAAQI;AAAYhZ;AAAE;AACtB;AACA;AAAQmZ;AAAmB;AAC3B;AACEnhC;AACEuT;;AAEE;AAEE;AACF;;AAEA;AACF;AACE;AACF;AACA;AACE;AAGF;AACAstB;;AAEA;AACA;;;AAGE;AACF;;AAEA;AACA;AACA;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;AACA;;AAEA;AACE;AACE;;AAEE;AACE;AACF;AACF;AACA;AACF;AACF;AACA;;AAEF;AACAj1B;AACE;AACA;AACE;AACF;;AAEF;AACA5K;;AAEA;;AAEE6/B;AACA;;AAEI;AACF;;AAEF;AACA;AACE;AACF;AACA;AACF;;AAEE;;AAEA;AACA;AAKF;;AAEE;;AAEA;AACA;AACE;AACF;AACE;AACF;AACE;AACF;;;AAGE;AACA;;AAEA;AACE;AACF;AACE;AACF;AACE;AACF;AACE;AACF;AACE;AACF;;AAEJ;;AAEE;;AAEA;;;AAGE;AACA;;AAEA;AACE;AACF;AACE;AACF;AACE;AACF;AACE;AACF;AACE;AACF;;AAEJ;AACAO;AACE;AACE;AACE;;;;;AAKA;AACF;AACE;;;;AAIA;AACF;AACE;;;AAGA;AACF;AACE;;AAEA;;AAEA;AACF;AACE;;AAMA;;;;AAIA;AACF;AACE;;AAEA;;;AAGA;AACF;AACE;;AAEA;;AAEA;AACF;AAAY;;AAEV;AACE;AACF;AACA;AACE;AACF;AACE;AACA;;AAEI;;AAEF;AACF;AACA;AACE;AACE;AACF;AACA;AACF;AACF;AACA;AACE;;;AAGA;AACA;;;AAGE;AACF;;AAEA;AACF;AACA;AACF;AACA;AACE;AACJ;AACA;AACA;AACE;AACF;AACA;AACF;AACF;AACA;AACA;AACA;;AAEI;AACF;;AAEE;;;AAGE;AACF;AACA;AACF;AACF;AACA;AACA;AACA;AACE;AACA;AACF;AACA;AACA;AACA;AACE;AACA;AACF;AACA;AACA;AAyjBA;AAiCA;AAgEA;AAGA;AACA;;;AAGI;AACF;;;AAGI;AACA;AACA;AACE7T;;AAEF;AACF;;;AAGI;AACF;AACF;AACF;;;AAGA;;AAEE;AACA;AACA;AACEL;AACA;AACE;AACF;AACF;AACA;AACE;AACF;AACA;AACExe;AACAwe;;AAEJ;;;AAGA;;AAEE;;AAEE;AACF;AACA;AACF;;AAEE;AACE;;AACSxe;AAAqBwe;;AAChC;AACF;;AAEE;AACE;;AACSxe;AAAoBwe;;AAC/B;AACF;;;AAGE;;;AAGIxe;AACAwe;;;;AAIAxe;AACAwe;;AAEJ;AACAK;AACF;;AAEE;AAMF;;;AAGE8T;AACA;AACE;AACF;AACA;;AAEE;AAEF;AACApU;AACF;AACA;AACF;AACA;;;AAGI;AACF;;;AAGA;;AAEE;;AAEA;AACAM;AACF;;AAEE;AACA;AACE3G;;AAEF;AACF;;AAEE;AACE;AACA;AACEA;;AAEF;AACA;AACF;AACF;;;;AAIE;AACA;AACEA;AACAsG;AACA;AACE;AACF;AACF;;AAEA;AACEtG;AACAsG;;AACSoU;;AACX;AACA/T;AACF;;AAEE;AACA;AACE3G;AACA;;;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACF;AACF;;AAEE;;AAEE;AACF;AACA;AACA;AACE;AACF;AACA;AACF;;;AAOA;AACA;;AAEI;;AAEE;AACF;AACA;AACE;AACF;AACA;;AAEE;AACF;;AAEE2a;AACAC;AACAC;;;AAGN;AACA;AACA;AACA;AACA;AACE;AACF;AACA;AACF;AACA;AACA;AACA;AACE;AACF;AACA;AACA;AACA;;;AAGI;;AAEA;AACF;AACF;AACA;AACE;AACA;AACA;AACF;AACA;AAqCA;AACA;AACA;AAEI;AACF;AAEE;AACF;AAEE;AACF;AAEE;AACF;AAEE;AACF;AAEE;AACF;AAEE;AACF;AAEE;AACF;AAEE;AAEF;AAEE;AAEF;AAEE;AACF;AAEE;AACF;AAEE;AAGF;;;AAIE;;AAEA;AACF;;AAGA;AAEE;AACF;AAEE;AACF;AAEE;AACF;AAEE;AACF;AAEE;AACF;AAEE;AACF;AAEE;AACF;AAEE;AACF;;AAGA;AAEE;AACF;AAEE;AAMF;AAEE;AAQF;AAEF;AAEI;AACA;AAGF;AAEE;;;AAGA;AACF;AACF;AAEI;AACF;;AAOA;AAEE;AACF;AACFC;AACA;AA+BA;AACA;AACA;AACE;AACE;;AAEE;AACF;AACF;AACA;AACF;AACA;AACE;AACA;AACE;AACA;;AAEA;AACF;AACA;AACF;AACA;AACE;AACE;AACA;;AAEE;AAIA;;AAEE;AACF;AACF;AACF;AACA;AACF;AACA;AACEnuB;AACA;;AAEE;AACF;AACA;;;AAMA;AACAouB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACAC;AACE;AACE;AACF;;AAEF;;;AAGA;AACAA;;;AAGA;AACAA;;;AAGA;AACA;AACF;AACA;;;;AAYI;AACF;;AAEA;AACE;AACF;AACF;AACA;AACA;AACA;AAMA;AACA;;AAEA;AACA;AACE;AACE;AACA;AAIF;AACE;AAIF;AACF;AACA;AACE;;AAEEC;;AAEA;AACA;;AAKIC;AACAC;AACAC;;;;AAIAF;AACAC;;;AAGJ;AACE;AACED;AACAC;;;;AAIA;AACA;;AAIA;AACF;AACA;AACF;AACF;AACA;;AAEIA;AACAD;AACAG;;;AAGJ;;AAEIF;AACAD;AACAG;;AAEJ;AACF;AACA;AACAznB;AAAgDnT;AAAY;AAC5D66B;AACA;AAKA;AACA;AACA;AACI;AAGJ;AACA;AACA;AACA;;;AAGQC;;AAEAC;AACAC;AACI;AACJ;;;AAGAriC;AACIsiC;AACJ;AACAniC;;AAEI;AAEA;AACA;;;AAGA;AACA;AACJ;;;;;AAMAoiC;;;AASR;AACA;AACA;AACA;AAWA;;;AAGQ;AACJ;AACJ;AACA;;;;;AAKQ;AACA;AAEAC;;AAEAA;AACA;AACJ;AACAxiC;AACI;AACI;AACJ;AACA;;AAEJ;;;AAGA;AACAyiC;;AAEA;AACJ;AACA;AACI;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGQC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAnc;AACApG;;;;;;;AAOAwiB;;;;;;;;AAQR;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;;AAEYlpB;;AAAcmpB;;;;;;;;;AAAiIzC;AAAa0C;;;;;;;AAAkJC;AAAkB;;AAEpU;AACJ;;;AAGI;AACJ;AACA;AACA;;;;;AAKQ;AACJ;AACA;AACI;AACJ;AACJ;;AAGI;AACJ;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACI;AACJ;AACA;AACI;AACA;AACJ;AAEI;AACA;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;;AAEQ;AACJ;AACJ;AACA;AACI;AACJ;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;AAEI;AACI;AACJ;AACA;AACJ;AACA;AACI;AACJ;AACA;;AAEI;AACIC;AACA;;AAGJ;AACJ;AACJ;;AAEI;AACJ;;;;AAII;AACA;AACA;;AAEIT;AACA;AACI;AACI;;AAEA;AACJ;;;AAGA;AACJ;;AAEJ;AACID;;;AAGA;AACI;AACA;AACA;;;AAIAW;AACA;AACAA;AACJ;;;;AAIA;AACA;AACIC;AACA;;;AAGA;AACJ;AACA;;AAEJ;;;AAGQ;AACJ;AACA;AACA;AACA;AACI;AACJ;;;;AAIJ;AACI;AACA;AACA;;AAER;AACA;AACA;AACA;AACA;;;AAGI;AACA;AACA;AACI;AACAV;;AAEJ;AACI;AACI;AACJ;AACA;AACI;AACI;AACI;AACJ;AACAW;AACA;AACI;AACJ;AACJ;;AAKA;AACJ;AACA;;;AAGAX;AACA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AACV;AAAWA;;AACX;AAAYA;;AACZ;AAAeA;AAAW;;AAE5B;AACEI;;;;AAGmCvkC;;AACrC;AACA;AACE;AACE;AACF;AACA;AACA;AACE;AACEwkC;;AAEF;AACAC;AACF;AACA;AACF;;;AAGA;AACA;AACE;AACE;AACF;AACA;AAAkB;;;;AAClB;;AAEA;;;AAGA;;;AAGA;AACA;AACA;AACF;AACAthC;;AAEA;;;AAGA;;;AAGA;AACAuhC;AACE;;AAEA;AACA;;;AAC2D3yB;AAAK;AAChE;;;AACyDE;AAAmBF;AAAK;AACnF;AACA4yB;AACE;;;AAC2D5yB;AAAK;AAChE;;;AACyDE;AAAmBF;AAAK;AACnF;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;;AAE4C;AAAS6yB;AAAoB;AACzE;AACAC;;AACyC;AAAS9yB;AAAK;AACvD;AACA+yB;;AACyC;AAAS/yB;AAAK;AACvD;AACAgzB;;AAEA;;AAEE;;AAEA;AACA;AACF;AACF;AACA;AACER;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI;AACIS;AACJ;AACA;;AAEA;AACA;AACJ;AACA;;;AAGQA;AACJ;AACA;AACJ;AACA;;AAEI;AACIlmB;AACA;AACIA;AACJ;AACJ;AACA;AACJ;AACA;;AAEI;AACI;AACJ;AACA;AACA;AACA;;AAEQ;AAIA;AACI;AACJ;AACA;AACJ;AACA;;AAKJ;;;AAGImmB;AACJ;AACAC;;AAEI;AACAC;AACAD;;AAEJ;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACCE;AACA;AAIA;AACA;AACAC;AACA;AAIAC;AACAx1B;AACA;AAIAy1B;AACA;AAIAC;AACA;AAIAjN;AACA;AAIAtM;AACA;AAIAwZ;AACA;AAIAC;AACAC;AACAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIA;AACA;AACAlC;AACA;AAIAmC;AACA;AAIAC;AACAC;AACA;AAIA;AAIA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;;;AAUAC;AACArrB;AACA;AAIAsrB;AACA;AAIA;AACA;AACA;AACAC;AACA;AAIA/0B;AACA;AAIA;AACA;AACA;AACA;AACAg1B;AACA;AAIA7oC;AACA;AAIA8oC;AACA;AAIAC;AACA;AAIAC;AACA;AAIA;AACA;AACAC;AACA;AAIAC;AACAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACAC;AACA;AAIAC;AACA;AAIA;AACA;AAKA;AAIAC;AACA;AAIA;AACA;AACAC;AACA;AAIAC;AACAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIA;AACA;AACA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAIAC;AACA;AAID;AACA;AACA;AACC;AACA;AACA;;;AAGC;AACA;;AAEC;AACD;;;AAGA;;;AAGA;AACA;AACD;;AAED;AACA;AACC;AACA;AACC;AACD;AACA;;AAEE;AACD;AACD;AACA;AACD;AACA;AACC;AACC;AACD;AACA;AAGA;;AAEA;AACA;AACC;;AAEE;AACD;AACD;AACA;AACD;AACA;AACD;AACA;AACA;AACC;AACD;AACA;AACA;;AAEI;AACF;;AAEE;AACF;;;AAGA;AACEh3B;AACF;AACA;AACA;AACA;AACEvQ;AACF;AACA;AACF;AACA;AACCwnC;AACAC;AACAC;AACAC;AACAC;AACA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACD;AACA;AACCC;AACA9pC;AACD;AACA;AACC+pC;AACAC;AACD;AACA;AACCC;AACAC;AACAL;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEM;AACAC;;AAEI;;AAEF;AACA;AACE;AACF;AACA;;AAEI19B;;;AAGJ;;AAEA;AACE;AACA;;AAGA;AACF;AACA;AACE;AACF;;AAEF29B;AACE7xB;AACE;AACE;AACF;;;AAGJ8xB;AACE;AACE;AACF;AACA;AACE;;AAEA;AACF;AACA9xB;;AAEI;AACA;;AAEA;AACF;;;AAGJ+xB;AACE;;AAEE;;AAEF;;AAEI;AACE;AACA;AACF;AACE;AACF;;AAEJ;;AAEFC;AACE;AACE;AACF;AACA;;AAEE;;;AAGA;;AAEA;;AAEF;;AAEFC;AACE;AACE;AACF;AACA;AACExmC;AACF;;AAEFymC;;;;AAIIzmC;;AAEF;AACA;AACE;;AAEF;AACEA;AACE;AACE;AACA;AACF;AACE;AACEA;AACF;AACA;AACE;AACAA;AACF;AACA;AACF;;AAEJ;;AAEF0mC;AACEC;AACAC;AACA;;AAEE;AACE;AACF;AACA;AACE;;AAEA;AACF;AACAryB;;AAEE;AACE;AACA;AACF;AACA;AACA;;AAEA;;;;AAINsyB;;AAEI;;AAEF;;AAEFC;AACE;;AAEA;AACA;;AAEE;AACF;;AAEI;AACE;AACA;AACF;AACE;AACF;;AAEJ;;AAEFC;;AAEE;;AAEE;AACF;;;AAGA;;AAEA;;AAEFC;AACEC;AACAA;;AAEFC;AACE;AACE55B;AAAY6R;;AACd;;AAEA;AACA;AACA;;AAEE;AACF;AACA;AACE;AACF;;;AAGA;;AAEA;;AAEA;;AAEFgoB;;AAEI;;AAEF;;;AAGA;AACA;;AAEA;AACA;AACE;AACF;;AAEFC;AACE;AACE;;AAEF;;AAEFC;AACE;;AAEE;;AACgBjD;;AAChB;AACF;AACE;AACE;;;;AAEA;;;;AAEA;AACE;AACF;AACF;;AAEE;AACApkC;;AAEE;AACEA;AACF;AACE;AACF;AACF;;AAEE;AACEA;AACF;AACE;AACF;AACF;AACF;AACA;;AAEE;AACF;AACF;;AAEFsnC;AACE;;AAEE;AACEtnC;AACF;AACF;AACA;AACE;AACF;AACA;AACE;;AAEF;;AAEEA;AACF;;AAEFunC;;;AAGI;AACF;AACA;AAKE;AACF;AACA;AACE;AACF;AACF;AACF;AACA;;AAEI;AACF;AACA;AACA;AACE;AACF;AACA;AAGF;AACA;AACE;AAEF;AACA;;;AAOE;AACF;AACA;;;AAGE;;;AAEI;AACF;AACAvnC;AACF;AACA;AACF;AACA;AACE;AACE;AACF;AACA;;;;;AAKA;AACF;AACA;AACE;AACE;AACF;AACA;AACA;AACA;;;;AAIA;AACA;AACEmc;AACF;AACA;AACEA;AACF;AACA;AACF;AACA;AACE;;AAEE;AACF;AACA;;AAEErR;AACF;;AAEF;AACA;;AAEI;AACF;AACA;;AAEA;AACA;AACE;AACF;AACAo7B;;AAEA9xB;;AAEA;;AAEE;AACA;AACAozB;;AAEArV;AACF;AACA;AACF;AACA;AACEsV;AACE;AACE;AACF;AACAznC;AACF;AACF;AACA;;AAEI;AACF;;AAEE;AACEkmC;AACAD;;AAEF;AACF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCyB;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACD;AACA;AACA;AACA;AACE;AACA;;AAEE;AACF;AACE;AACA/S;;AAEF;AACF;AACA;AACE;AACEgT;AACAC;AACF;;AAEF;AACA;AACA;AACA1V;AACA;AACA;AAEA;AACA;AACE;AACF;AACA2V;AACA;;AAEItD;AACA/mB;AACF;;AAEEA;AACF;AACA;AACE+mB;AACF;AACA;;AAIA;;;;AAIAsD;AACEC;AACF;;AAEF;AACA;AACE;AACF;AACA;AACA;AACA;AACCC;AACAjhC;AACAkhC;AACD;AACC;;AACOt4B;AAAI;AACXs4B;;AAEC;;AAEC;AAAuCC;AAAqB;AAC5D;AACC;AACD;;AAEDC;AACD;AACD;AACA;AACA;AACA;AACAt1B;AACEnT;AACF;AACA0oC;AACAA;AACE;AAAarhC;AAAiBrH;AAAiB2oC;;AAC1C;AAQL;AACF;AACA;AACA;AACAx1B;AACEnT;AACF;AACAs6B;AACAA;AACAA;AACA;AACA;AACA;AACA;AACAsO;AACA;AACA;AACA;;AAEE;AACEz3B;AACA;AACAA;AACA;AACF;AACA;AACF;AACA;AACE;AACA;AACA;AACA;;AAEE;AACF;AACA;AACF;AACA;AACE;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACF;AACA;;AAEE;AACE;AACA;;AAEE;AACE03B;AACF;AACF;AACA;AACEC;AACA;AACE;AACF;AACF;AACE;AACF;AACF;AACA;AACF;AACA;AACA31B;AACEnT;AACF;AACAR;AACAA;AACAA;AACAA;AACAA;AACA;AACEA;AACAue;AACAgrB;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACE;AACF;AACA;AACE;AACF;AACA;;AAEA;AACA;AACE;AACF;AACC;AACA51B;AACEnT;AACF;AACAmT;AACElG;;;AAGA;AACF;AACAkG;AACElG;;;AAGA;AACF;AACAkG;AACElG;;;AAGA;AACF;AACAkG;AACElG;;;AAGA;AACF;AACAkG;AACElG;;;AAGA;AACF;AACAkG;AACElG;;;AAGA;AACF;AACAkG;AACElG;;;AAGA;AACF;AACAkG;AACElG;;;AAGA;AACF;;;AAGD;AACA;AAAe8F;AAAW;AAC1B;AACA;AACC;AACC;AACD;AACA;AACD;AACA;AAAoBA;AAAW;AAC/B;AAAqBA;AAAW;AAChC;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD;AACA;AACA;AACA;AACC;AACCi2B;AACD;AACD;AACA;AACCC;AAAMC;AAAaC;;AACnBC;AAAMF;AAAaC;;AACnBE;AAAMH;AAAaC;;AACnBG;AAAMJ;AAAaC;;AACnBI;AAAOL;AAAaC;;AACpBK;AAAMN;AAAaC;;AACnBM;AAAMP;AAAaC;;AACnBO;AAAMR;AAAaC;;AACnBQ;AAAMT;;;AACN1pC;AAAU0pC;;;AACVU;AAASV;;;AACTW;AAAUX;;;AACVY;AAAMZ;AAAaC;;AACnBY;AAAQb;AAAaC;;AACrBnxC;AAAOkxC;;AAA6B;AACrC;AACA;AACC;;AAEE;AACD;;AAEC;AACD;AACA;AACC;AACD;AACA;AACA;AACA;AACA;;AACqDlpC;AAAe;;AACjBA;AAAa;AACjE;AACD;AACAgqC;AACC;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAECC;AACD;AACCA;AACD;;AAEA;;AAEA;;;AAGCA;AACD;AACAC;;AAEC59B;AACD;AACCA;AACD;;AAEA;;AAED;AACA09B;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;;AAECG;AACAC;AACAC;;;AAGA;AACCJ;AACD;AACCA;AACD;;AAECA;AACD;AACCA;AACD;AACD;AACA;AAKD;AACAD;AACC;AACA;AACA;AACA;;;;AAID;AACAA;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACAM;AACA9gC;AACAmtB;AACA4T;AACA;AACD;AACA;;AAMA;AACAP;AACC;AACA;AACC;AACD;;AAEA;AACA;AACC;AACC;AACA;;AAECQ;AACAC;AACD;AACD;AACD;AACA;AACD;AACAT;;AAEA;AACAA;AACC;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACD;AACAA;;AAEC;AACA;AACA;AACA;AACA;AACA;AACAzpB;AACAgqB;AACAG;;;;AAIAR;AACA9gC;AACAE;AACA;AACD;AACA0gC;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGC;AACD;;AAECW;AACD;AACCA;AACD;AACAC;AACA3B;;;;AAIE4B;AACD;;AAECA;AACD;AACA;;AAEA;AACCzzB;AACD;AACCA;AACD;AACCA;AACD;AACA6xB;AACD;AACA;AACD;AACAe;AACC;AACA;AACA;;;AAGA;AACA;AACAE;;;AAGA76B;;;AAGD;AACA26B;AACC;AACA;AACA;;;;;AAKA;AACA36B;AACA;AACC;AACC;AACD;AACC;AACD;AACC;AACD;AACC;AACD;AACC;AACD;AACC;AACF;AACD;AACA26B;AACC;AACA;AACA;;AAEA;AACA;AACA;AACAE;AACAY;;;;AAIAZ;;AAED;AACAF;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAECe;AACAC;AACD;;;AAGAnhC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACC;AACA;AACA;AAAQ6W;AAAOuqB;AAAO3hC;AAAQ;AAC9B;AAAQoX;AAAOuqB;AAAO3hC;AAAQ;AAC9B;AAAQoX;AAAQuqB;AAAO3hC;AAAO;AAC9B;AAAQoX;AAAQuqB;AAAO3hC;AAAO;AAC9B;AAAQoX;AAAOuqB;AAAQ3hC;AAAO;AAC9B;AAAQoX;AAAOuqB;AAAQ3hC;AAAO;AAC/B;AACA;AACD;AACA0gC;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACAtpB;AACAuqB;AACA3hC;AACA;AACD;AACA0gC;AACC;AACA;AACA;AACA;AACA;AACA;AACAtpB;AACAuqB;AACA3hC;;;;AAUAoX;AACAuqB;AACA3hC;AACA;AACD;AACA0gC;AACC;AACA;AACA;AACA;AACA;AACA;AACAzpB;AACAgqB;AACAG;;;;AAIAR;AACA9gC;AACAE;AACA;AACD;AACA0gC;AACC;AACA;AACA;AACA;AACA;AACA;AACAO;AACAhqB;AACAmqB;;;;AAIAH;AACAhqB;AACAmqB;AACAnqB;AACAgqB;AACAG;AACA;AACD;AACAV;AACC;AACA;AACA;AACA;AACA;AACA;;;;AAICC;AACD;AACAzgC;AACA;AACD;AACAwgC;AACC;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACD;AACAA;AACC;AACA;AACA;;;;AAIC;AACD;AACA;;AAKCkB;AACD;AACA;AACD;AACAlB;AACC;AACD;AACAA;AACC;AACA;AACA;AACA;;AAEE;AACD;;AAEC;AACD;AACA;AACD;AACA;AAIA;AACD;AACAA;AACC;AACA;;AAEEmB;AACD;AACAA;AACA;AACD;AACA;;;;AAIA;AACD;AACAnB;;;AAGE;AACD;AACA9U;AACA;AACA;AACA;;AAEA;AACD;AACA8U;;;;AAMA;AACAA;AACC;;AAEC;AACD;AACA;;AAECoB;;AAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACD;AACApB;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAECqB;AACD;AACCA;AACD;;AAECC;AACD;;AAGA;;AAGA;;AAEA;AACAA;AACAA;AACA;AACD;AACAtB;AACC;AACA;;;;AAICxgC;AACD;;AAEA;;;AAGA;AACA;AACD;AACAwgC;AACC;AACA;AACA;;;;AAIA;AACA;AACD;AACAA;AACC;AACA;AACA;;AAEC;AACD;;AAEA;AACA;AACA;;AAEA;AACC;AACCuB;AAAaA;AAAaA;AAAa;AACxC;AACCA;AAAaA;AAAaA;AAAa;AACxC;AACCA;AAAaA;AAAaA;AAAa;AACxC;AACCA;AAAaA;AAAaA;AAAa;AACxC;AACCA;AAAaA;AAAaA;AAAa;AACxC;AACCA;AAAaA;AAAaA;AAC5B;AACAC;AACA;AAKD;AACAxB;AACC;AACA;;;;;AAKA;AACA;AACD;AACAA;AACC;AACA;;;AAGA;AACC19B;;;AAID;AACA;AACD;AACA09B;AACC;AACA;;AAEA;AACD;AACAA;AACC;AACA;AACA;AACA;;;;AAIA;AACA;AACD;AACAA;;AAEA;AACAA;;AAEA;AACAA;;AAEA;AACAA;;AAEA;AACAA;;AAEA;AACAA;;AAEA;AACAA;;AAEA;AACAA;AACC;AACA;;;AAGD;AACAA;AACC;AACA;AACD;AACA;AACA;AACA;;AAEC;AACA;AACC/e;;AAEC5wB;;AAEF;AACA;AACD;AACA;AACC;AACA;AACA4wB;;AAEC;;AAEA;AACC;AACA;AACA;;;AAGC1E;AACD;AACD;AACD;AACA;AACD;AACA;;AAEE;;AAEF;AACA;;AAEC;AACA;AACA;;AAEC6V;AACAqP;AACD;;AAEA;AACD;AACA;AACC;;AAEA;AACA;AACC;AACA;AACA;AACC;AACD;;AAED;AACA;AACD;AACA;AACA;AACA;AACA;AACA;AACC;AACC;AACC;AACD;AACA;;AAEA;;;;AAIAC;AACD;AACA;AACD;AACA;AACC;AACC;AACC;AACD;AACA;;AAEA;AACA;AACA;AACC;AACCxmB;AACD;AACD;AACA;;;AAGAwmB;AACD;AACA;AACD;AACAC;AACCC;;AACuD5rC;AAAsC;;AACxCA;AAAoC;AACzF;AACA;AACA6rC;AACC;;AAEAD;AACD;AACD;AACA;AACAE;AACC;;AAEA;;AAEC;;AAED;;AAEC;;AAED;;AAEC;;;AAGA;AACA;AACCC;AACCh1C;AACAC;AACAC;AACAC;AACAC;AACAE;AACAC;AACAC;;AAED4zC;AACC3zC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAg0C;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEDC;AACCt0C;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAg0C;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACD;;;;AAIA;;AAEC;;AAECljB;AACAC;;AAEDmI;AACA+a;AACD;AACA75B;AACCnT;AACAiN;AACD;AACAkG;AACCnT;AACAiN;AACD;AACD;AACA;AACA;AACAggC;AACAA;AACAA;AACC/B;;AAED+B;AACCpD;;AAEDoD;AACChE;;AAEDgE;AACC/B;;AAED+B;AACCpD;;AAEDoD;AACChE;;;AAGA;AACC;AACD;AACA;;AAEC1nC;AACD;;AAEC0rC;AACAA;AACD;;AAECA;AACAA;AACD;;AAECA;AACAA;AACD;AACD;AACA;AACD;AACA95B;AACClG;AACAnW;AACD;AACD;AACA;AACA;AACCogC;AACA;;AAEA;AACA;AACD;AACA;AACA;AACA;AACA;AACA;AAGCgW;AACD;AAICA;AACD;AACA;AACCA;AACD;AACA;;AAEE;AACD;;;AAGCC;;;;AAIF;AACA;;AAEE;AACD;AACA;AAGC;AACD;AACA;AACC;AACD;;AAEC;AACD;AACA;AACA;;AAEC;AAKC;AACD;AACA;AACD;;;AAGE;AACD;AACA;AACD;;;AAGA;AACA;AACC;AACD;;;;AAIE;AACC;AACD;AACC;AACF;AACD;;AAEC;AACD;;AAEC;AACD;;AAEC;AACD;AACA;AACC;AACD;AACA;AACD;AACA;AACC;;AAED;AACA;AACCC;AAEAC;AACD;AACA;AACA;AACA;AACA;AACA;AAYA;;AAEE;AACD;AACA;AACD;AACA;;;AAGC;AACA;AACC;AACCC;;AAEAA;AACD;;AAEA;AACD;AACA;AACD;AACA;;;AAGC;;AAEC;AACA;;;AAGA;AACCA;AACD;AACD;AACA;AACD;AACA;;AAEC;AACC;AACCvqB;AACD;AACD;;;;AAIE;AACC;AACD;;AAECwqB;AACD;AACCA;AACD;AACD;AACD;AACA;AACD;AACA;;;;AAICC;AACC;AACCC;;AAEA;AACAA;;;;;AAEiD;;AAEjD;AACC;AACD;AACAC;AACAD;;AAED;AACCA;AACD;AACD;;AAEA;AACC;AACA;AACD;AACA;AACD;AACC;;;AAGA;;;;;AAKA;AACA;AACCvhC;;AAEA6O;AACAA;AACD;;AAEC;;AAEC4yB;;;AAGC;;;;AAIDC;;AAED;AACAD;AACD;AACA;AACCE;AACD;;;;AAIE/2C;AACC;AACA;AACD;;AAEF;;AAECA;AACC;AACD;;AAED+2C;AACA;AACC;AACC;AACD;;AAEC/2C;AACC;AACA;;AAEC;;AAECgzB;AACAgkB;;AAED;;AAEF;;AAEF;AACAD;AACA;AACC;AACC;AACD;AACA;;AAEC/2C;AACC;AACA;;AAEC;;AAECgzB;AACAgkB;;AAED;;AAEF;;AAEF;;AAEA;AACC;AACC;;;;;AAKD36B;AACClG;AACAnW;;;;;AAKA;AACD;AACAqc;AACClG;AACAnW;;;;;AAKA;AACD;AACA86B;AAAmEze;AAEnE;AACD;;;AAGC;;;AAGC;AACD;;;AAGEsG;AACD;AACD;AACA;AACC;AACD;AACA;AACA;AACCo0B;AACD;AACA;;AAECp0B;AACD;AACAo0B;AACA;AACD;AACA;AACC;AACC;AACD;;;AAGA;AACCtwB;AACAA;AACD;;AAED;;AAEArH;AACAA;AACAA;AACD;AACA;AACA/C;AACEnT;AACF;AACA+tC;AACAA;AACA;AACA;AACA;AACA;AAAyC;AAA+C;AAAuBptB;AAAmB;AAAoD;;AAAyB;AAC/M;AAAkF;AAA2E/c;;AAAc;AAAuC;AAAoC;AAAUoqC;;AAAmB5kC;;AAAoJ;AAA0DpP;AAAsE;AAAE;AAA2C;AACplB;AACA;;;;;;;;;;AAUIi0C;;AAEJ;AACA;AACA;AACA;AACA;;;AAGI;AACE;AACE;AACF;AACA;AACE;AACF;AACA;AACE;AACF;AACF;AACA;AACE;AACF;AACA;AACE;AACF;;;AAGFC;AACE;;AAEE;;;;;AAKF;;AAEJ;AACA;;AAEE;;AAEEluC;AACF;AACE;AACA;;AAEA;AACEmuC;AACF;AACF;AACA;AACF;AACA;;AAEA;AACA;AACA;AACE;AACE;AACA;AACEprB;AACAqrB;AACF;AACA;AACF;;AAEF;AACA;;AAEA;AACA;;;AAGI;AACF;AACE;AACF;AACF;AACA;AAAar7B;AAAW;AACxB;AACA;AACC;AACC;AACD;AACA;AACD;AACA;AAAkBA;AAAW;AAC7B86B;AACC;;AAEA;;AAEC;;AAED;;AAEC;;AAED;;AAEC;;;AAGA;AACA;AACC9B;AACCh1C;AACAC;AACAC;AACAC;AACAC;AACAE;AACAC;AACAC;;AAED4zC;AACC3zC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAg0C;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEDC;AACCt0C;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAg0C;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACD;;;;AAIA;;AAEC;;AAECljB;AACAC;;AAEDmI;AACA+a;AACD;AACA75B;AACCnT;AACAiN;AACD;AACAkG;AACCnT;AACAiN;AACD;AACD;AACA;AACA;AACAggC;AACAA;AACAA;AACC/B;;AAED+B;AACCpD;;AAEDoD;AACChE;;AAEDgE;AACC/B;;AAED+B;AACCpD;;AAEDoD;AACChE;;;AAGA;AACC;AACD;AACA;;AAEC1nC;AACD;;AAEC0rC;AACAA;AACD;;AAECA;AACAA;AACD;;AAECA;AACAA;AACD;AACD;AACA;AACD;AACA95B;AACClG;AACAnW;AACD;AACD;AACA;AACA;AACCogC;AACA;;AAEA;AACA;AACD;AACA;AACA;AACA;AACA;AACA;AAGCmX;AACD;AAICA;AACD;AACA;AACCA;AACD;AACA;;AAEE;AACD;;;AAGClB;;;;AAIF;AACA;;AAEE;AACD;AACA;AAGC;AACD;AACA;AACC;AACD;;AAEC;AACD;AACA;AACA;;AAEC;AAKC;AACD;AACA;AACD;;;AAGE;AACD;AACA;AACD;;;AAGA;AACA;AACC;AACD;;;;AAIE;AACC;AACD;AACC;AACF;AACD;;AAEC;AACD;;AAEC;AACD;;AAEC;AACD;AACA;AACC;AACD;AACA;AACD;AACA;AACC;;AAED;AACA;AACCC;AAEAC;AACD;AACA;AACA;AACA;AACA;AACA;AAYA;;AAEE;AACD;AACA;AACD;AACA;;;AAGC;AACA;AACC;AACCC;;AAEAA;AACD;;AAEA;AACD;AACA;AACD;AACA;;;AAGC;;AAEC;AACA;;;AAGA;AACCA;AACD;AACD;AACA;AACD;AACA;;AAEC;AACC;AACCvqB;AACD;AACD;;;;AAIE;AACC;AACD;;AAECwqB;AACD;AACCA;AACD;AACD;AACD;AACA;AACD;AACA;;;;AAICC;AACC;AACCC;;AAEA;AACAA;;;;;AAE+C;;AAE/C;AACC;AACD;AACAC;AACAD;;AAED;AACCA;AACD;AACD;;AAEA;AACC;AACA;AACD;AACA;AACD;AACC;;;AAGA;;;;;AAKA;AACA;AACCvhC;;AAEA6O;AACAA;AACD;;AAEC;;AAEC4yB;;;AAGC;;;;AAIDC;;AAED;AACAD;AACD;AACA;AACCE;AACD;;;;AAIE/2C;AACC;AACA;AACD;;AAEF;;AAECA;AACC;AACD;;AAED+2C;AACA;AACC;AACC;AACD;;AAEC/2C;AACC;AACA;;AAEC;;AAECgzB;AACAgkB;;AAED;;AAEF;;AAEF;AACAD;AACA;AACC;AACC;AACD;AACA;;AAEC/2C;AACC;AACA;;AAEC;;AAECgzB;AACAgkB;;AAED;;AAEF;;AAEF;;AAEA;AACC;AACC;;;;;AAKD36B;AACClG;AACAnW;;;;;AAKA;AACD;AACAqc;AACClG;AACAnW;;;;;AAKA;AACD;AACA86B;AAAmEze;AAEnE;AACD;;;AAGC;;;AAGC;AACD;;;AAGEsG;AACD;AACD;AACA;AACC;AACD;AACA;AACA;AACCo0B;AACD;AACA;;AAECp0B;AACD;AACAo0B;AACA;AACD;AACA;AACC;AACC;AACD;;;AAGA;AACCtwB;AACAA;AACD;;AAED;;AAEArH;AACAA;AACAA;AACD;AACA;AACA/C;AACEnT;AACF;AACA;AACAsuC;AACA;AACA;AACA;AAAuC;AAA+C;AAAuB3tB;AAAmB;AAAkD;;AAAyB;AAC3M;AAAgF;AAA2E/c;;AAAc;AAAqC;AAAoC;AAAUoqC;;AAAmB5kC;;AAAoJ;AAA0DpP;AAAsE;AAAE;AAA2C;AAChlB;AACA;AACE;AACE;AACA;AACE+oB;AACAqrB;AACF;AACA;AACF;;AAEF;AACA;AACA;;;AAGIG;AACAt9B;;AAEJ;AACA;AACA;AACE;AACEu9B;AACAnuB;AACF;AACA;;AAEEouB;AACAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEl1B;AACF;AACA;;AAEA;AACA;;AAEA;;AAEI;;AAEEm1B;AACF;;AAEEA;AACF;;AAEA;;;AAGA;AACF;AACF;;AAEI;;AAEA;AACEA;AACF;AACF;;AAEA;AACF;;;;AAIEA;;AAEJ;AACA;AACE;AACA;AACA;AACA;AACE;;AAEF;;;;AAIEA;;AAEF;AACA;AACA;;AAEE;;AAEA;AACA;;AAEA;;AAEE;AACE;AACA;AACAC;AACA;AACEA;AACF;AACF;AACA;AACF;;AAEA;AACF;AACA;AACEC;AACF;AACA;AACE;AACF;AACE;AACF;AACF;AACA;;AAEIC;;;AAGEj2C;AACF;AACE;;;AAGF;AACF;;AAEA;AACE2gB;AACEg1B;AACAnuB;AACF;;AAEF;AACF;AACA;AAEA;;AAEC;;;AAOCA;AACD;;;AACcmuB;;AACf;AACA;AAA6CO;AAAgB;AAC5D;AACC;AACD;AACA;AACA;AAAmB1uB;AAAyBmuB;AAA2B;AACxE;AACA;AACA;AACC7zC;;;;AAIA;;AAEC;AACA;AACAq0C;AACD;;;;AAEkBC;AAAS;;AAE3B;;AAEC;AACD;AACD;AACA;AAC6Bz1B;AAAe;AAAI01B;AAAa;AAC7D;AACC;;AAEC;AACD;;;;AACkBV;;;;AAETnuB;;;AACT;AACA6F;AACA;;;AACcsoB;;AAAwDO;AAAc;;;;;AAEpF;AACA;AAAyCA;AAAc;AACxD;AACA;AAIA;AAKC;;AAEC;;;AAGD;AACA;AACA;AACCI;AACAl+B;AACD;AACCA;AACD;AACA;;AAEA;;;AAGA;AACA;AACD;AACA;;AAEA;AACA;AACA;AACC;AAGA;;AAEA;AACA;AACD;AACA;;AAA+BwhB;AAAgB;AAC9C;AACA;AACD;AACA;AACC;;AAEC;AACD;;;AAE+B;AAAY6V;AAA6B;AACvE57B;;AAEF;AACA;AACC;AACA;AACA;AACA;AACA0iC;AAIA;AACA;;AAKD;AACA;AAGEC;AACA5W;AACD;;AAGC;AAGD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAKA;AACC;AACD;AACA;AACA;;AAOD;AACA;AAAuB1lB;AAAW;AAClC;AACA;AACC;AACA;AACD;AACA;AACC;AACC;AACD;;AAED;AACA;AACA;AACE;AACA;;AAEA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AAAe;AACf;AAAgB;AAChB;AACA;AAAgB;AAChB;AAAgB;AAChB;AAAY;AACZ;AAAY;AACZ;AACA;AAAkB;AAClB;AAAmB;AACnB;AAA0B;AAC1B;AACA;AAAmB;AACnB;AAAoB;AACpB;AACA;AAAmB;AACnB;AAAoB;AACpB;AAAqB;AACrB;AAAqB;AACvB;AACA;AACE;AACF;AACA;AACA1L;AACA;AACE;AAAwB;AACxB;AACA;AAA8B;AAC9B;AAA8B;AAC9B;AAAiC;AACjC;AAAgC;AAClC;AACA;AACA;AACF;AACA;AACE;AACF;AACA;;;AAGA;AACA;;AAEA;AACA;AACE;AACA;AAGF;AACA;AACE;;AAKF;AACA;AACE;AACF;AACA;AACE;AAGF;AACA;;AAEI;AACE;AACF;;;AAGE;AACF;AACF;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACE;AACE;AACF;AACA;AACF;AACA;AACA;AACA;AACA;AACC;AACC0T;AACD;AACAA;AACD;AACA;AACC;AACCA;AACD;AACAA;AACD;AACA;AACC;AAGD;AACA;AACC;AACC;AACA;AACD;;AAED;AACA;;AAEC;AACC;AACD;AACA;AACD;AACA;AACA;AACA;AACA;AACA;AACC7O;;AAEAojC;AACC;AACCpqB;AACD;AACD;;AAEC;;AAEC3jB;AACD;AACA;AACA;AACA;AACA;AACCvB;AAASqH;;AACV;AACA;;;AAEQA;AAAI;AACX;AACC;AACC;AACD;AACA;;AAECqiB;;AAA4B;AAAmB;AAChD;AACCA;AACD;AACD;;;AAEQ9lB;AAAqB;AAC5B;AACA;AACA;AACC;AACD;;AAED;;;AAGA;AACD;AACD;AACA;AACD;AACA2rC;AACAA;AACA;AACA;AACA;AAAcx8B;AAAW;AACzB;AACA;AACA;AACA;AAKA;AACC7G;AACCgsB;;;;AAID;AACC;AACD;;;AAEO/rB;AAAM;;;AAGb;;AAEA;AACA;;;AAGE;AACD;AACA;AAAwBgsB;AAAoB;AAC5C;;AAEC;AACD;;;AAKA;AACAhsB;AACD;AACA;AACD;AACAqjC;AACC;;AAEA;AACA;AACD;AACAA;AACA;AACA;AACA;AACC;;AAEA;;AAEA;AACD;AACA;AAA4BrW;AAAgB;AAC5C;AACA;AAMA;AACC;AACC;AACD;;AAECkW;;AAEAnX;AACD;;AAEC;;AAEA;;AAEC;AACA;AACC32B;AACD;AACC;AAAqC8tC;AAAS;AAC9C;AAAwB;AACvBI;AACD;AACAluC;AACD;AACD;AACA;;AAED;AACD;AACA;AACC;;AAEA;AACA;AACD;;AC7wRA;AAA+D8tC;AAAc;AAE7E;;ACEA;AACC;AACC9Y;AACCmZ;AACCC;;;AAGDC;AACCD;AACA1+B;;AAED4+B;;AAEC5+B;;AAED6+B;AACCH;;;AAGC;AACD;;AAEDI;AACCJ;AACA1+B;AACD;AACD;;;AAKD;;AAGC;;AAAoBA;AAAO;AAC1B;AACA;AAEA;AACC++B;AACD;AACD;AACD;AAEA;;AAEA;AACD;AAEA;AACC;AACC9jC;AACA+jC;AACD;AAEA;AACC;AACD;;;AAICxd;AACD;AAEA;;;;AAICyd;AACAnlC;AACAolC;AACAC;AACAC;AACAC;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CQ;AACR;AACQ;AACR;AACQ;AACR;AACQ;AACR;;AAEA;;AAGI;;AAEJ;;;AAIM;AACA;;AAEA;AACE;AACR;AACQ;AACR;AACQ;AACR;AACQ;AACR;AACQ;AACR;;AAEA;;AAEA;AACA;AACEO;AACE;AACE;AACE;AACR;AACA;AACM;;;;AAII;AACV;AACA;AACA;AAEI;AACE;AACE;;;;;AAKA;AACF;AACE;;;;AAIA;AACF;AACN;AACA;AACA;AACQ;;;AAGA;AACR;AACA;AACM;AACE;;AAER;;AAEQ;AACF;AACE;;AAER;AACQ;AACA;AAEF;AACN;AACA;AACA;AACA;AACQ;;AAMR;;;;AAIQ;AACF;AACN;AACA;AACA;AACA;AACQ;;AAER;;;AAGQ;AACF;AACN;AACA;AACA;AACA;AACQ;;AAER;;AAEQ;AACR;AACA;AACM;AAAY;;AAGV;AACE;AACV;AACU;AACA;;AAEI;;AAEd;AACA;AACU;AACV;AACY;AACE;AACd;AACY;AACZ;AACA;AACQ;AACR;AACA;AACU;;;AAGV;AACU;;;AAGV;AACA;;AAEA;AACA;AACQ;AACR;AACM;AACE;AACR;AACI;AACA;AACE;AACN;AACI;AACJ;AACA;AAEA6X;;;;;;;;;AC7TA;;;AAGI;AACJ;;AAEI;;;AAGE;AACN;AACI;AACJ;;AAGA1nB;;;;;;;;;ACfA;AACA;AACE;AACA;;AAEF2nB;;;;;;;;;ACLA;AACA;AACE;AACA;;AAEFC;;;;;;;;;ACLA;AAEA;AACE;AACEC;AACAzX;AACApuB;AACJ;;;;AAQI;AACJ;;AAEA8lC;;;;;;;;;AClBA;AAEA;;;AAGE;;AAGE;AACJ;AAEE;AACA;AACA;;;AAIA;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEM;AACN;;AAEA;;;AAGQ;AACR;AACM;AACN;AACA;;AAEA;AACE;AAEA;;AAEF;AAEE;;AAEF;AAEE;;AAEF;;AAEA;AACE;;AAGFC;;;;;;;;;ACzDA;AACA;AACAC;;;;;;;;;ACFA;AACA;AACAC;;;;;;;;;ACFA;AACA;AACAC;;;;;;;;;ACFA;AACA;AACE;AACA;;AAEFC;;;;;;;;;ACLA;;AAIAC;;;;;;;;;ACJA;AACA;AACAC;;;;;;;;;ACFA;AACA;AACAC;;;;;;;;;ACFA;;;;AAIE;;AAEFC;;;;;;;;;ACNA;;AAEAC;;;;;;;;;ACFA;;AAEAC;;;;;;;;;ACFA;AACA;AACAC;;;;;;;;;ACFA;AACA;AACAC;;;;;;;;;ACFA;AACA;AACAC;;;;;;;;;ACFA;AACA;AACAC;;;;;;;;;ACFA;AACA;AACAC;;;;;;;;;ACFA;AACA;AACAC;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;;AAGE;AACE;AACE;;AAEN;AACM;;AAEN;;AAGI;AACE;;AAEN;AACM;;AAEN;;AAGI;AACA;AACA;AACE;AAEF;AACE;AAEF;AACE;AAEF;AACE;AAEF;AACE;AAEF;AACE;AAEF;AACE;AACN;;AAEAC;;;;;;;;;ACnDA;AACA;;AACQvZ;AAAYhZ;;AAEpB;;AAEI;AACJ;AAEE;AACErnB;AACJ;AAEE;AACE;AACJ;AAEE4S;;AAGA;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;AACA;AACA;;AAKIoU;AACR;AACM6yB;AACN;AACA;AACIA;AACJ;;AAGI;AACJ;AAEE;AACA;AACA;AACA;AACA;AAEA;;AAEFC;;;;;;;;;AC3DA;AACEz6C;;AAEE;AACJ;;;;AAKM;AACN;AACA;AACM;;AAEA;AACN;AACA;;AAGI;AACJ;AAEE/B;AACE;AAEA;AACJ;;AAEQ;AACA;AACR;;AAGA;AAEI;AACJ;AACA;AAEAy8C;;;;;;;;;;;ACrCA;AACA;AACE16C;AACEuT;;AAGE;AAIE;AACR;;AAEA;AACA;;AAGA;AACM;AACA;;AAEA;AACN;;AAGI;AACA;;AAEJ;AACA;AACA;AACI;;AAEJ;;AAGA;AAAA;AAEA;AACA;AACA;AAAA;AAGI;;AAEJ;;AAEA;AACI;AACJ;AACM;AACA;AACA;AACE;;AAER;AACQ;AACE;AACE;AACA;AACZ;AACA;AACA;AACA;;AAGA;;AAGI;;AAEE;;;AAGN;AACQ;AACA;;;AAGR;AACU;AACV;AACA;AACA;;AAEA;AAEE3H;;AAEF;AAEE5K;;AAEF;;AAGA;AACA;AACI;AAGA;AACA;AACA;AACE;AACN;AAEI;AACJ;AACI;AACAomB;AACAyZ;;AAEJ;AACIzZ;AACAyZ;;AAEJ;AACIzZ;AACAyZ;;AAEJ;AACIzZ;AACAyZ;;AAEJ;AACA;;AAEI;AAKJ;AAAA;AAGI;AACJ;AACM8Z;;AAEE;AACD;AACP;AACI9Z;;AAEJ;AACA;AACA;AACI;AACA;AACA;AACE;;AAEN;;AAEA;AACI;AACE+Z;AACN;;AAGI9D;AACA;AACJ;AAEE+D;AACE;AACE;AACN;AAEI;AACE;AAGI;AAGI;AACE;AACD;AACF;AAEJ;AAEJ;AACL;;AAEA;;;AAGM;AACN;AAEI;;;;AAII;AACR;AACA;AAEI;AACE;AACE;AACR;AACA;AACI;AACJ;AACA;AAEAzzB;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEE4Z;;;;AAIA8Z;;;;AAE+BnC;;;;;AAKjC;AACA;AACA;;AAEE;AACA;AAEA;AACEpsB;AACE;AACD;AAEDwuB;AACJ;AAEE;;;AAGF;AACA;AACA;AACA;AACEla;AACAma;AACAna;AACAma;AACAna;AACAma;AACAna;AACAma;AACAna;AACA;;AAGF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAQA;AACE;AACA;AACEA;AACA;AAEA;AACEoa;AACN;;AAEA;AACA;AACMA;;AAEApa;AACAoa;AAEN;AACA;AACMA;AAEN;AAEIpa;AACA;AACD;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAQA;AACEA;AACA;;AAEA;AACEA;AACA;AAEA;AACEoa;AACN;;AAEA;;AAEQA;AACR;AACQA;AACR;;AAEMpa;;;AAGIoa;AAEV;AACUA;AAEV;AACA;AACQA;AAER;AACA;;;;AAIUA;AAEV;AACUA;AAEV;AACA;AACQA;AAER;AACA;AAEIpa;AACA;AACD;;AAGH;AACEA;;;AAOF;AACEma;AACA;AACA;AACEna;AACA;AACA;AACA;;AAGA;AACEqa;AACN;;AAEA;AACA;AACIC;AAEA;AACE;AACN;AACQF;AACR;AACA;AACQA;AACR;AACA;AACA;AACA;AACM;AACEjd;AACR;AACMod;;AAGN;AACA;AACQF;AACA;AACEG;AACArd;AACAod;AACV;AACUpd;AACAod;AACV;AACA;AACA;AACA;AACQF;AACA;AACEG;AACV;AACUrd;AACV;AACA;;AAGQmd;AACR;;;;;AAMMF;AAEN;AAEIpa;AAEA;AACD;;;AAGH;AACA;AACA;AACEA;AACF;AACE;;AAKF;AACEA;;;;AAMF;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;AACEya;AACJ;;AAEA;;;;AAIA;;AAEA;AAEE;AACE93C;AACJ;AACIA;AACJ;;;;;;AAMA;;AAEA;;;;AAME;;AAEI;AACN;AACA;;AAGA;AACA;AACA;AACA;AACA;AACI;AACEq9B;;AAEE;AACR;AAEM;AACE;;AAIE;AACV;AACA;AACA;;AAEA;AACI;AACJ;AAEE;;;;;;;;;;ACxiBF;AACA;AACA;;AAEI;AACJ;AAEE7gC;AACEuT;;;AAII;AACR;;AAEA;AACA;AAEIynC;AACAna;;AAEA;AACA;AAEA;;AAEJ;;AAEA;AAEIA;AACJ;;;AAII;;AAGE;AACN;AAEI;AACA;;AAEJ;;AAEA;AACI;;AAEJ;AACM;AACN;AACA;AAEE7/B;;AAEF;;;;AAMM;AACN;AAEI;;;;AAII;AACR;AACA;AAEI;AACJ;AAEE65C;AACE;AACE;AACN;AAEI;AACE;AACE;AACR;AACM;AACN;AACM;AACE;AACR;AACM;AACN;AAEItnC;;AAEJ;AACI;AAEE;AACN;;AAGM;AACN;;AAEA;AACI;AACE;AACN;AACA;AACI;AACE;AACN;AACA;AACI;AAGE;AACN;AACA;AACI;AAEE;AACN;AACA;AACI;AAEE;AACN;AACI;AACJ;AACA;AAEAgoC;AAEA;;AACQva;AAAYhZ;;AACpB;AACA;AACA;AACA;;;;;;;;;AC5IA;;;AAGIZ;;AAEA;AACJ;AACE;;AAEFo0B;;;;;;;;;ACTA;;AAEA;;AAKAC;;;;;;;;;ACPA;AACA;;;;;;AAOIC;;AAEA;AACJ;AACEC;AACE;AACJ;AACM;AACN;AACQ7hC;AACA8hC;AACR;AACA;AACG;AACD;;AAEFC;;;;;;;;;ACxBA;AACA;;;;;;AAMIH;;AAEA;AACJ;AACEC;AACE;AACJ;;AAEA;AACQ3hC;AACA8hC;AACR;AACA;AACG;AACD;;AAEFC;;;;;;;;;ACvBA;AACA;AACA;AAEA;AACE30B;AAEA;AACA;AACE;AACJ;AAEE40B;AACA;AACE;AACJ;AAEEA;AACA;AACE;;AAGAC;AACJ;;;AAGQ;AACE;;AAEV;AACYC;AACZ;AACUA;AACV;AACQ;AACA;;AAEIC;AACZ;AACU;AACF;AACA;AACR;AACU;AACV;AACQ;;AAER;AACK;AACD;AACEH;AACN;AACA;;AAGI;AACJ;AAEE;;AAEFI;;;;;;;;;AC5DA;AACA;;AAEA;AACA;;;AAGI;AACJ;;AAEAtzC;;;;;;;;;ACVA;AACA;;AACQuzC;AAAG;AACX;AACA;AACA;AACA;AACA;AACA;;AAGE17C;AACAymB;;AAGA;AACE;AACEk1B;AACAC;AACAC;AACAxB;AACAyB;AACA;AACF;AACEH;AACAC;AACAC;AACAxB;AACAyB;AACA;AACF;AACE;AACN;;AAEA;;AAEI;AACJ;;AAEA;AACA;;AAEE;AACE;;;AAKAR;AACE;AACEV;AACR;;;AAGM;AACEmB;AACR;AACQC;AACR;AACK;;AAEL;AACA;;AAEM;AACN;;AAEA;AACA;;AAGM;AACN;AACM;AACN;AACA;AACE;;AAGFC;;;;;;;;;AC/EA;AACA;AACA;AACAC;;;;;;;;;ACHA;AACA;AACA;AACAC;;;;;;;;;ACHA;;AAEEC;AACAC;AACA;;AAEFC;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACAC;;;;AAIE;AACA;;AAEE;AACE18B;;AAEEiH;AACR;AACA;AACM;;AAEN;AACMjH;AACAiH;AACN;AACA;AACE;;AAEF;;;;AAKM4J;;AAEAA;AACN;AACMA;;AAEAA;AACN;;AAEA;AACA;AACE;AACA;;;;;;;;;;;AC5CF;AACA;;AACQgrB;AAAG;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAII;AACJ;AAEEc;AACAC;;;AAIE;;AAEEC;AACA;AACE;AACR;AACA;AACA;AACA;AACA;AACA;AACI;AACE;AACN;AACA;AACE;;;;;;AAQE;AACJ;AAEE;AACE;AACE;AACN;AACMF;AACN;AACMA;AACN;AACA;AAEE;;AAEI;AACN;AACMC;AACN;AACA;AAEE;;AAEA;;;AAGF;;AAEA;AACME;AACN;AACA;AAEE;AACE;AACJ;AAEE;;AAEEC;;AAEE;AACN;AACM;AACN;AACA;;AAEA;AACE;AACE;AACE;AACN;AAEI;AACE;AACN;AAEI;AACE;AACE;AACR;AACA;AAEI;AACJ;;;AAIA;AACA;;;AAOA;;AAGIC;AACJ;AAEE;AACEC;AACAC;AACA;AACE;AACE;AAIEC;AACV;AACA;;;AAGQ;AACE;AACV;;AAEQ;AACR;AACA;AACI;AACE;AACE;AAIEH;AACV;AACA;;;AAGQ;AACE;AACV;;AAEQ;AACR;AACA;AACI;AACE;AACN;AACA;;AAEA;AACA;AACA;;AAEI;AACJ;;AAGI;AACJ;;AAEA;AACA;AACA;;AAEI;AACJ;AAEE;;;AAGF;;;AAGI;AACJ;AACE;;;;AAOF;;;AAGI;AACJ;AACE;;;AAOFI;;;;;;;;;ACtPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA3E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA17B;;;;;;AAQAsgC;AACC;AACC;AACF;AAEC;AACC;AACF;AAEC;;AAGDA;AACC;AACC;AACF;;;AAKE5C;AACF;AACEA;AACF;;AAGEA;AACF;AACEA;AACF;AAEC;;AAGD4C;AACAA;AACAA;AACAA;AAEAA;;;AAGAA;AACAA;AACAA;AACAA;AACAA;AAEAA;;;AAIE7/C;AACF;AAEC;;AAED;AAEC;;AAGD6/C;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;;AAIAA;AAEA;AACA;AACA;AACA;AACC;;AAIDA;AACC;;;AAiBA;;AAGC5C;AACF;;AAGEA;AACF;AAEC;AACCA;AACF;;;;AAMC6C;;AAGC;AAEA;AACA;AACA;AACC;AACH;;AAIE7C;AAEA;AACCA;AAIH;AACGA;AACH;;AAGA;;;;;;;;;;;;ACxJC;;AAEA;AACA;;;;;;;;;;;;ACHD;;AAEOrjC;AAAG;AAEV;AACA;AAIC89B;;AAKAA;AACD;;AAGC;AACCA;AACF;AACEA;AACF;;AAEA;AACA;;;AAIE;AACF;;;AAIElB;;;;AAIF;AAEA;;AAEE;AACF;AAEC;AAGC;AACF;AAEC;AACC;AACF;;AAGE;AACF;AAEC;AAEA;AACC;AACF;AAEC;AACD;AACA;;AAEE;AAIC;AACH;AAEE;AACF;;AAGE;AACC;AACH;AAEE;AACF;;;AAIA;AAEC;AACC;AACF;;;;AAMG;AACC;AACD;AACC;AACJ;AACA;AACA;;AAGE;AACF;;AAGE;AACF;;AAGE;AACF;AAEC;AACD;;;;AAKA;AAEAuJ;AACCtJ;AACAuJ;AACAtJ;;;;;;;;;;ACpID;AACA;;AAGC;AACD;AACE;;AAECuJ;;;;AAIH;;;AAIEA;AACAC;;;AAGF;;;AAGQtmC;AAAG;;AAGT;AACF;AAEC;AACC;AACF;;AAGE;AACF;;AAEA;;AAEE;AACF;;AAEA;AACC;AACC;AACF;AAEC;AACC;AACF;AAEC;AACC;AACF;;AAGE;AACF;;AAGE;AACF;;AAGE;;AAGC;AACC;AACC;AACL;AAEI;AACD;AACC;AACD;AACC;AACJ;AACA;AACA;;AAGA;AACE;AACC;AACH;AAEE;;AAEF;AAEC;AACD;AAEAumC;;AAECH;AACAtJ;;;;;;;;;;;ACjGD;AACA;AAEA;AAAkClhC;;;AACjC;AACD;AACE;AACC;AACH;;AAGA;AAEC;;;;AAK6EA;;AAA4B;AAE1G+J;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACO;AACH;AACA;AACA;;AAEIuD;AACJ;AACA;AACI;AACJ;;;AAII;;AAEI;AACA;AACIkb;AACAC;AACJ;AACA;AACID;;AAGAE;AACJ;AACJ;AACA;AACJ;AACJ;AACO;AACH;;;AAGA;AACI;AACA;AACA;;AAEA;AAEIC;AACJ;AACJ;AACA;AACJ;AACO;;AAGH;AACA;AAEA;;AAGA;;AAGA;AACJ;;AChEA;AACA;AACA;AACA;AACA;AACA;AACO;AACH;AACI;AACJ;AACAC;;;;;;AAMA;AACIC;AACAxrB;AACA;AACA;AACI;AACIxP;AACJ;AACA;AACJ;AACA;AACA;;AAEIi7B;AACJ;AAEIA;AACJ;;AAGAC;AACJ;AACA;AACJ;;ACvCA;AACA;AACA;AACA;AACA;AACO;AACP;AACIC;AACAA;AACAA;AACAA;AACJ;;ACXA;AACA;AACA;AACA;AACA;AAIA;AACO;;AAECC;AACJ;AACA1pB;AACI;AACI2pB;AACAC;AACAC;AACAvR;AACAwR;AACAC;AACAC;AACApe;AACA1T;AACA+xB;AACAC;AACAnD;AACA5M;AACAgQ;AACAC;AACAv0B;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACIw0B;AACAC;AACAC;AACAC;AACAC;AACAhF;AACAsB;AACA2D;AACAC;AACAC;AACA5zB;;;AAGJ;AACA;;AAEI;AACA;AACI;AACI6yB;AACA1P;AACAgQ;;;;AAIR;AACA;AACIU;AACJ;AACAA;AACAA;AACJ;AACA;AACIA;AACAA;AACJ;AACA;AACIA;AACAA;AACJ;AACA;AACIA;AACAA;AACJ;AACA;AACIA;AACAA;AACJ;AACA;AACIA;AACAA;AACJ;AACA;AACIpjB;AA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ACJ;AACA;;AAMA;;ACphCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAGA;AACA;AACI;;AAEI;AACJ;AACJ;AACA;AACA;AACA;;;AAGQ;;;;;AAKJ;AACA;;AAEI;;;AAII;;AAEJ;;AAGA;AACJ;AACJ;AACMC;AACF;;AAEJ;AACAA;;AAEA;AACAA;AACAA;AACAA;;;;;;;;;;;ACxDA;;;AAGE12B;;AAEAvB;;AAEEqgB;AACD;AACD;AACF;;;AAIE02B;AACE;;AAEJ;AACE;AACF;;;;;;AAOA;AACE;AACF;;;;;;AAOI;AACA;AACE;;;AAGD;AACL;AACE7xB;AACA;AACF;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQE8xB;AACF;;;AAEiB/qC;;AACjB;AACA;AACA;;;;AAMA;AACA;AACA;;AAKA;AAMA;AACA;AACA;AACA;AACA;AACEgrC;AAAqBC;AAAiB;AAGlC;AACA;;AAEE;AACR;AACM;AACA;AACA;;;AAIN;;AAEE;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOEC;AACAjiB;AACA/oB;AACAirC;AACJ;;;;;;AAMA;;AAEA;AACA;AACE;AASA;AACA;AACEC;AACAniB;AACA;AACAoiB;AAUJ;AACA;AAAA;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAgBE;AACEC;AAMJ;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;AASA;AACEC;AAoBJ;;AASA;;;AASA;AAMAC;;;;;;;;;;;;;;;ACpPA;;;;AAIA;;;;AAKM;;AAENlnB;AAAAmnB;;;;;AAIAC;AACA;;AAAA;AAZA;;;;AAkBY;AAKZ;;;;;;;;AAMAlmB;AACA;;AAAA;AAZY;;;;;AAsBZ;AACA;;;AAKAmmB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;AACD;AAEA;AACC;AACAD;AACC1+C;AACA4+C;AACD;AACD;AACD;;AAGD;AAEA;;;;AAKCI;;AAGCC;AACD;;AAGCA;AACD;;AAGCA;AACD;AAEA;AACCA;AACD;AACD;;AAKCA;;;AAUA;AAEA;;AAGCC;AACD;AAEA;AACC;AACA;AACAA;;AAECP;AACD;AACD;;AAEA;AAEA;;;AAGA;;AAEA;;AAED;AACC;AACCK;AACD;AACC;AACA;;AAEA;;;;AAICG;;AAGD;AAEAH;AACD;AAEA;AACCC;AACD;AAEA;AACC;AACA;;;AAGD;AACD;;AAGCA;AACD;;AAEA;;AAECA;AACD;;;AAKC;AACCG;AAEAA;;;AAGE;AACD;;AAGD;AACD;AACD;;AAIA;AACD;AAEA;AACC;AACC;AACD;AAEA;AACC;AACA5tC;AACD;AACD;AAqBA;;AAEE;AACD;;AAEO;AAAkB;;AAGxB;AACD;AAEA;AACD;AAEA;AAA+B;AAA0B;AAAI6tC;AAAG;;;AAG/D;;AAGC;AACD;;AAGD;AAEO;AAEPC;AACCC;AACAC;AACAC;AACD;AACCJ;AACCK;AACAC;AACD;AACD;AAEAL;AACCC;AACAC;AACAC;AACD;AACCJ;AACD;AAEAC;AACCC;AACAC;AACAC;AACD;AACCJ;AACD;AAEAC;AAEAA;;;;;;;;;;ACjZcM;AACb;AACC;AACF;AAEC;;;;;;;;;;;;;;ACPDC;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACrJD;;AAEA;AACA;AACA;;;AAGA;AACC;AACCxR;AACF;AACA;AAEA;AACCC;AAAMC;AAAaC;;AACnBC;AAAMF;AAAaC;;AACnBE;AAAMH;AAAaC;;AACnBG;AAAMJ;AAAaC;;AACnBI;AAAOL;AAAaC;;AACpBK;AAAMN;AAAaC;;AACnBM;AAAMP;AAAaC;;AACnBO;AAAMR;AAAaC;;AACnBQ;AAAMT;;;AACN1pC;AAAU0pC;;;AACVU;AAASV;;;AACTW;AAAUX;;;AACVY;AAAMZ;AAAaC;;AACnBY;AAAQb;AAAaC;;AACrBnxC;AAAOkxC;;AAA6B;;;AAGrC;AACA;AACC;;AAEE;AACH;;AAGG;AACH;AAEE;AACC;AACH;AAEE;AACA;AACA;AACA;;AACmDlpC;AAAe;;AACjBA;AAAa;AAChE;AACA;AAEA4rC;AACC;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAGC3B;AACF;AACEA;AACF;;AAEA;;AAEA;;;AAKEA;AACF;AAECC;;AAGC59B;AACF;AACEA;AACF;;AAEA;;;AAKAs/B;AACC;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;;;;AAMD;;AAEEzB;AACAC;AACAC;;;AAIF;AACGJ;AACH;AACGA;AACH;;AAEGA;AACH;AACGA;AACH;AACA;AAEC;;AAOD2B;AACC;AACA;AACA;AACA;;;;;AAQDA;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AAEAtB;AACA9gC;AACAmtB;AACA4T;AAEA;;;AAGD;AACA;AACA;AACA;;AAMA;AAEAqB;AACC;AACA;AACC;AACF;;AAGC;AAEA;AACC;AACC;;AAEH;AACG;;AAEH;;AAEIpB;AACAC;AACJ;AACA;AACA;AAEC;;AAGDmB;;;AAIAA;AACC;AACA;AACA;;AAED;;;;AAKC;AACA;AACA;AAEA;;AAGDA;;AAEC;AACA;AACA;AACA;AACA;AACA;AAEArrB;AACAgqB;AACAG;;;;AAMAR;AACA9gC;AACAE;AAEA;;AAGDsiC;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAIC;AACF;;AAGEjB;AACF;AACEA;AACF;AAECC;AAEA3B;;;;AAIE4B;AACH;;AAEGA;AACH;AAEE;;AAEF;AACGzzB;AACH;AACGA;AACH;AACGA;AACH;AAEE6xB;AACF;AAEC;;AAGD2C;AACC;AACA;AACA;;;AAGA;AACA;AAEA1B;;;AAGA76B;;;;AAMDu8B;AACC;AACA;AACA;;;;;AAMA;AACAv8B;AAEA;AACC;AACC;AACD;AACC;AACD;AACC;AACD;AACC;AACD;AACC;AACD;AACC;AACH;;AAGAu8B;AACC;AACA;AACA;;AAEA;AACA;AACA;AAEA1B;AACAY;;;;AAIAZ;;;;AAKD;AACA0B;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAED;;AAEEb;AACAC;AACF;;;AAICnhC;AAEA;;AAED;;;AAIC;AACA;AACA;AACA;AACC;AACA;AACA;AAAQ6W;AAAOuqB;AAAO3hC;AAAQ;AAC9B;AAAQoX;AAAOuqB;AAAO3hC;AAAQ;AAC9B;AAAQoX;AAAQuqB;AAAO3hC;AAAO;AAC9B;AAAQoX;AAAQuqB;AAAO3hC;AAAO;AAC9B;AAAQoX;AAAOuqB;AAAQ3hC;AAAO;AAC9B;AAAQoX;AAAOuqB;AAAQ3hC;AAAO;AAChC;AAEC;;AAGDsiC;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AAEAlrB;AACAuqB;AACA3hC;AAEA;;AAGDsiC;AACC;AACA;AACA;AACA;AACA;AACA;AAEAlrB;AACAuqB;AACA3hC;;AAED;;;;AAaCoX;AACAuqB;AACA3hC;AAEA;;AAGDsiC;AACC;AACA;AACA;AACA;AACA;AACA;AAEArrB;AACAgqB;AACAG;;;;AAMAR;AACA9gC;AACAE;AAEA;;AAGDsiC;AACC;AACA;AACA;AACA;AACA;AACA;AAEArB;AACAhqB;AACAmqB;;;;AAKAH;AACAhqB;AACAmqB;AAEAnqB;AACAgqB;AACAG;AAEA;;AAGDkB;AACC;AACA;AACA;AACA;AACA;AACA;;;;AAMC3B;AACF;AAECzgC;AAEA;;AAGDoiC;AACC;AACA;AACA;AACA;AACA;AACA;;;;AAMA;;AAGDA;AACC;AACA;AACA;;;;;AAMC;AACF;AAEC;;AAMCV;AACF;AAEC;;AAGDU;AACA;AACA;AACC;;AAGDA;AACC;AACA;AACA;;AAED;AACA;AACC;;AAEE;AACH;;AAGG;AACH;AAEE;AACF;AAEC;AAKA;;AAGDA;AACC;;AAED;AACC;;AAEET;AACH;AAEEA;AAEA;AACF;AAEC;;;;AAKA;;AAGDS;AACA;;;AAGE;AACF;AAEC1W;AAEA;AACA;AACA;;AAGA;;AAGD0W;;;;;AASAA;AACC;;AAEC;AACF;AAEC;;AAGCR;;AAEF;AACA;AAEC;AACA;AACA;AACA;AAEA;;AAGDQ;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGCP;AACF;AACEA;AACF;;AAGEC;AACA;;AAGA;;AAGF;;AAEA;AAECA;AACAA;AAEA;;AAGDM;AACC;AACA;;;;AAKCpiC;AACF;;AAEA;;;AAIA;AAEC;;AAGDoiC;AACC;AACA;AAEA;;;;AAKD;AAEC;;AAGDA;AACC;AACA;AACA;;AAGC;AACF;;AAGC;AACA;AACA;;AAGA;AACC;AACCL;AAAaA;AAAaA;AAAa;AACxC;AACCA;AAAaA;AAAaA;AAAa;AACxC;AACCA;AAAaA;AAAaA;AAAa;AACxC;AACCA;AAAaA;AAAaA;AAAa;AACxC;AACCA;AAAaA;AAAaA;AAAa;AACxC;AACCA;AAAaA;AAAaA;AAC7B;AAECC;AAEA;;AAODI;AACC;AACA;;;;;AAOD;AAEC;;AAGDA;AACC;AACA;;;AAKA;AACCt/B;;;AAIF;AAEC;;AAGDs/B;AACC;AACA;;AAEA;;AAGDA;AACC;AACA;AACA;AACA;;;;AAKD;AAEC;;AAGDA;;;AAIAA;;;AAIAA;;;AAIAA;;;AAIAA;;;AAIAA;;;AAIAA;;;AAIAA;AACC;AACA;;;;AAMDA;AACC;AACA;;;;;;;;;;ACl2BD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;AAOA;AACC;AAEA;AACC3gB;AACF;AACA;;AAEG5wB;;AAEH;AAEC;AACD;;AAEA;;AAEC;AACA;;AAEA4wB;;AAGC;;AAGA;AACC;AACA;AAEA;;;AAGC1E;AACJ;AACA;AACA;AAEC;AACD;AAEA;;AAEE;;AAEF;AAEA;;AAEC;AAEA;AACA;;AAEC6V;AACAqP;AACF;;AAGC;AACD;AAEcgP;AACb;;AAGA;AACA;AACC;AACA;AAEA;AACF;AACG;AACH;;AAGA;AAEC;;;;;;;;;;AC9FD;AACA;;AAIA;;AAGC;AACC;AACC;AACH;AAEE;;AAEF;;;;AAKA;;AAEE/O;AACF;AAEC;AACD;;AAGC;AACC;AACC;AACH;AAEE;;AAEF;AAEE;;AAEF;AACA;AACA;AACE;AACC;AACCxmB;AACJ;AACA;AAEE;;;AAGF;;AAEEwmB;AACF;AAEC;AACD;AAEAC;AACCC;;AAEuD5rC;AAAsC;;AACxCA;AAAoC;AAEzF;AACA;AAEA6rC;AACC;;AAGAD;AACF;AACA;AAEA8O;;;;;;;;;;;AC5EA;AAEA;;AAEC;;AAGD;;AAEC;;AAGD;;AAEC;;;AAIA;AACA;AACC3O;AACCh1C;AACH;AACGC;AACAC;AACAC;AACAC;AACAE;AACAC;AACAC;;AAED4zC;AACC3zC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAEH;AACGg0C;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;AAEDC;AACCt0C;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAEH;AACGg0C;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACH;;;AAGA;;;AAIE;;AAGC;;AAGCljB;AACAC;;AAGDmI;AAEA+a;AACH;AAEE75B;AACCnT;AACAiN;AACH;AAEEkG;AACCnT;AACAiN;AACH;AACA;AAEC;AACA;AAEAggC;AACAA;AAEAA;AACC/B;;AAED+B;AACCpD;;AAEDoD;AACChE;;AAGDgE;AACC/B;;AAED+B;AACCpD;;AAEDoD;AACChE;;;AAIA;AACC;AACH;AAEE;;AAGC1nC;AACH;;AAGG0rC;AACAA;AACH;;AAGGA;AACAA;AACH;;AAGGA;AACAA;AACH;AACA;AAEC;AACD;;AAEA;AACA95B;AACClG;AACAnW;AACD;;;;;;;;;;ACnKA6jD;AACCzjB;AACA;;AAEA;AACA;;;;;;;;;;;ACJD;AAEA;AAEA;AACA;AAGCmX;;AAKAA;AACD;;AAECA;AACD;;;AAIE;AACF;;;AAIElB;;;;AAIF;;;AAIE;AACF;AAEC;AAGC;AACF;AAEC;AACC;AACF;;AAGE;AACF;AAEC;AAEA;AACD;AACA;AACA;AACA;AACA;AACA;;AAEE;AAKC;AACH;AAEE;AACF;;;AAIG;AACH;AAEE;AACF;;;AAIA;AAEC;AACC;AACF;;;;AAMG;AACC;AACD;AACC;AACJ;AACA;AACA;;AAGE;AACF;;AAGE;AACF;;AAGE;AACF;AAEC;AACC;AACF;AAEC;AACD;;AAGC;;AAED;AAEAuJ;AACCtJ;AACAuJ;AACAtJ;;;;;;;;;;;;;;AC3HD;;;AAeE;AACF;AAEC;AACD;AAEA;;;AAGC;AAEA;AACC;AACCC;;AAEAA;AACH;;AAEA;AACA;AAEC;AACD;;;;AAMC;;AAGC;AAEA;;;AAGF;AACGA;AACH;AACA;AAEC;AACD;AAEA;;AAGC;AACC;AACCvqB;AACH;AACA;;;;AAKG;AACC;AACJ;;AAGIwqB;AACJ;AACIA;AACJ;AACA;AACA;AAEC;AACD;AAEAqN;;;;;AAKA;AACCpN;AACC;AACCC;;AAEA;AACAA;;;;;AAE+C;;AAE/C;AACC;AACJ;AAEGC;AACAD;;AAEH;AACGA;AACH;AACA;;AAIC;AACC;AACA;AACF;AAEC;;;;;;;;;;;AC7HD;AACA;AACA;AAEA;;;AAIA;;;AAGA;;AAGA;AAEA;AACCvhC;;AAED;;AAEC6O;AACAA;AACD;;AAGA;AACA;AACC;;AAEC4yB;;;AAIC;;;;AAMDC;;AAGF;AAECD;AACD;;AAEA;AACA;AACCE;AACD;;;;AAME/2C;AACC;AACA;AACH;;AAEA;;AAGCA;AACC;AACF;;AAGA+2C;AACA;AACC;AACC;AACF;;AAGE/2C;AACC;AACA;;AAEC;;AAECgzB;AACAgkB;;AAED;;AAEJ;;AAEA;AAEAD;AACA;AACC;AACC;AACF;AAEC;;AAEC/2C;AACC;AACA;;AAEC;;AAECgzB;AACAgkB;;AAED;;AAEJ;;AAEA;;AAIA;AACC;AACC;;;;;AAQD36B;AACClG;AACAnW;;;;;AAKF;AACA;AAECqc;AACClG;AACAnW;;;;;AAKF;AACA;;AAEA;AACC86B;;AAED;AACA;AAAAze;AAGC;AACD;;AAGA;;AAEC;;;AAIC;AACF;;AAGA;;AAEGsG;AACH;AACA;AAEC;AACC;AACF;;AAEA;AACA;AACA;AACC;AACA;AACCo0B;AACF;AAEC;AACD;AACA;AACA;;;AAGA;AACA;AACA;AACEp0B;AACF;;AAEA;AACCo0B;AAEA;AACD;AAEA;AACC;AACD;AACA;AACE;AACF;;;AAKC;AACCtwB;AACAA;AACF;;AAGA;;AAIArH;AACAA;;;;;;;;;;;;;;AC/NChK;AACC2uC;;;AAQD;;;;;;;;;ACXD;;;AAKAC;;;;;;;;;ACNA;AACA;AAEArhB;AACE;AACE;AACEshB;AACN;AAEI;;;;AASAn8C;AACAsN;AACJ;;;AAIA;AAEE;;AAEF;AAEE;;;AAGF;AACI8uC;AACAp8C;;AAIK;AAECo8C;AACD;AAET;AAEEA;AACE;AACEj/C;AACEpB;AACAsgD;;AAER;;;AAKI;AACJ;;;AAKQ;AACR;;AAMK;;;AAUHjwC;AACAA;AAMAA;AACApM;AACEoM;AAMJ;AACEA;;AAIA;;;;;;;;;;;;AClGF;;AACUuB;AAAM;;AAEd;AACF;AACI;AACA2uC;AAIJ;;;AAOA;AACA;;AAEA;;;AAII;AACJ;AACA;AAEAvzC;;AAEEwzC;;;;;;;;;;;AC9BMA;AAAS;;AAETC;;AAER;;;;AAIE;AACF;AAEAC;AACEC;;;;;;;;;;;ACVF;;;;AAMA10B;;;;AAIE20B;;;;;;;;;;;ACZMC;AAAa;;AAGnB;AACF;;;AAQI;AACJ;AACE;;AACMjvC;;;;;AAIF;AAGN;AACI;AACA4G;AACA;AACE;AAAkB5G;;AAChB;;AAMEga;AACV;AACA;AACA;AACM;AACA;AAAkBha;;;;AAOdga;AACV;AACA;AACA;AACA;AACE;AACF;AAEAk1B;;AAEEC;;;;;;;;;;;ACvDF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACE;AACF;;AAEA;AACA;;;AAKE;AAAkBnvC;;AAChB;AACJ;;AAGA;AACA;;AAEUzS;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;AACfA;AAAe;;AACA;AAInB;AACN;AACA;AACE;AACF;;;AAIA;;;AAIA;;;AAIA;;;AAGU6hD;AAAS;AACjB;AACEC;AACJ;AACA;;;AAGUtiD;AAAO;AACf;AACEsiD;AACJ;AACA;;AAGA;;;;AAIE;AACE12B;;AAEJ;;AAEA;;AAGA;;;;AAIE;AACEA;;AAEJ;;AAEA;;;;AAKI1L;AACJ;;AAEA;AAEA0c;;;;;;;;;;AAUE2lB;;;;;;;;;;;;;AC/HAN;AACF;;AACQO;AAAQ;;AACRC;AAAgB;;AAEhBC;;;AAGN;AAGF;;;AAMA;;AAGE;AACF;AACA;AACA;AACIC;AACA;AAGJ;AACE;AACF;;AAGE;AACF;;AAEI;AACA;AAAkB1vC;;AAChB;;AAEN;AACI;AACJ;AACE;AACF;;AAGE;AAGF;;;AAMA;;AAGA;AACE;AACF;AAEA2vC;;;;;;;AAOEC;;;;;;;;;;;;;;ACxE+B;AAAOnO;;;;AAEtC;AAGA;AACA;AAAkBzhC;;AAChB;AACA;AACA;AAAkBA;;AAChB;AACA;;AAEE6vC;AACR;AACA;AACIC;AACJ;AACE;AACF;AAEAC;AACEC;;;;;;;;;;;ACvBMT;AAAQ;;AACRU;AAAO;;;AAIf;;;AAMA;AAEA;;;AAGA;AACA;;AAEIhjC;AACJ;;AAEE;AACE;AACJ;AACA;AACA;AACE;;;AAGIijC;AACN;;;AAGMjjC;AACN;;AAEA;AACE;AACA;AAIEijC;AACJ;AACE;AACF;;AAGE;AACA;AAAa;AAAQ;;AACnB;AACA;AACJ;AACA;AACI;AACE;AACN;;AAEMC;AAAe1O;;AACrB;AACA;;AAEA;AACE;AACF;;AAGE;AAGF;;AAGA;AACA;AACE;AACF;;;AAIA;;AAGE;AACE;AAGJ;;AAIA;;AAGA;AACA;AACA;;AACUzhC;AAAM;AACd;AACE;AACJ;;AAMI;AACJ;AACE;AACF;AAEAkmB;;;;;;;AAOEkqB;;;;;;;;;;;ACtHA;AAKF;AAEAC;AACEC;;;;;;;;;;;ACTM1B;AAAS;;AACT0B;AAAsB;;AACtBd;AAAgB;;AAGtB;AACE;;AAEJ;AACI;AACJ;AACE;AACF;AAEA;AACE;AAIF;AAEA;AACE;AACF;AAEA;AACE;AACE;AACJ;AACE;AACE;AACE;AACN;AACI;AACJ;AACE;AACF;AACI;AAGF;AACE;AACE;AACN;AACA;AACE;AACF;AAEA;AACA;;AAEI;AACJ;AACA;AACA;AACE;AAAkBxvC;;AAChB;AACJ;AACI;AAG+B;AACxBzS;AAAyB;AACzBA;AAA0B;AAC3BA;AAAW;AACXA;AAAW;;AACA;AAIf;AACE;AAGR;AACM;AACN;AACA;AACE;AACF;AAEA;AACE;AACE;AACE;AACN;AACI;AACJ;AACE;AACF;;AAGE;AACE;;AAEJ;AACI;AACJ;AACE;AACF;AAEA;AACE;AACE;;AAEE;;AAEN;AACM;AACN;AACA;AACE;AACF;AAEA;AACE;AACE;AACJ;AACE;AACE;AACJ;AACE;AACF;AAEA;AACE;AACF;AAEA;AACA;AACE;AAKE;AACJ;AACA;AACA;AACE;AAAkByS;;AAChB;AACJ;AACI;AAG+B;AACxBzS;AAAyB;AACzBA;AAA0B;AAC3BA;AAAW;AACXA;AAAW;;AACA;AAIf;AACE;AAGR;AACM;AACN;AACA;AACE;AACF;AAEA;AACE;AACF;AAEA+O;;;;;;;;;;;;AAYEi0C;;;;;;;;;;;;;;;;;AC9KAC;AACF;;AACQR;AAA4B;;;;;;;AAOlCI;AACF;;;AAC0BK;;;;;;;;;AAQxBF;AACF;AAEA;;AAMA;AAEA;AACE9O;AACA3mC;AACAs0C;AACAhhD;AACArB;AACAojD;AACAO;AACAC;AACAC;;;AAIA;AACF;AAEA;;AAEA;AAEAC;AACA;AACA;;AAGMlB;AACEvhD;AACAghD;AACAriD;AACAojD;AACAO;AACAC;AACAC;;AAEF1qB;AACEprB;AACAs0C;AACAhhD;AACArB;AACAojD;AACAS;;AAEFt0C;AACExB;AACAs0C;AACAhhD;AACArB;AACA2jD;AACAP;AACAS;AACR;AACK;AAECjJ;AACAgI;AACAzpB;AACA5pB;;;;;;;;;;;AC7FNw0C;AACA;AACA;AACEC;AACEtP;AACAuP;AACAC;AACAC;AACAC;AACAC;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVQC;AAAe;;AACfzC;AAAS;;AACToB;AAA4B;;AAC5BM;AAAsB;;;;;;;AAO5BgB;AACF;;;AAC6BC;;AAE7B;AACA;;AAGE;AACA;;;AAGF;AACA;AACS;AAIT;AACI;;AAEJ;;AAGE;AACA;;AAEIC;AACN;AACI;;AAEJ;;;;AAGgBpC;;AACd;AACF;AAEA;;;AAKA;AACA;;AAGMlpB;AACN;;;;AAIU;;AAEV;;;;AAIU;;AAEV;;;;AAIU;;AAEV;;;AAGU;;AAEV;;;;AAIU;;AAEV;;;;AAIU;;AAEV;;;;AAIU;;AAEV;;;;AAIU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIU;;AAEV;;;AAGU;;AAEV;;;;AAIA;AACU;;AAEV;;;AAGA;AACA;;;AAGA;AACU;;AAEV;;;AAGU;;AAEV;;;AAGU;;AAEV;;;;AAIU;;AAEV;;;;;AAKU;;AAEV;;;AAGU;;AAEV;;;AAGU;AACV;;AAEM5pB;AACN;AACA;AACA;AACA;AACQm1C;AACE;AACE;AACE;AACE;AAGhB;AACc;AACd;;AAEY;AACE;AAGd;AACY;AACZ;AACU;;AAEV;AACQC;;;AAGR;AACQC;AACR;AACA;;AACkB5kD;AAAO;;AAEzB;AACA;AACA;;AAMY;AACE;AAGd;AACY;AACZ;AACU;;AAEV;AACQ6kD;;;AAQR;AACQC;;;AAQR;AACA;AACA;AACA;AACQC;;;AACgB1C;;AACd;AACA;AACA;AACA;AACA;AACE;AACE;AAGd;AACY;AACZ;AACU;AACE;AACE;AAGd;AACY;AACZ;AACU;AACE;AACE;AAGd;AACY;AACZ;AACU;AACE;AACE;AAGd;AACY;AACZ;AACU;AACE;AACE;AACE;AAGhB;AACc;AACd;AACY;AACE;AAGd;AACY;AACA;AAGE;AACE;AAGhB;AACc;AACd;AACA;AACU;AACA;AACE;;AAIZ;AACY;AACZ;AACA;AACA;AACU;AACE;AACE;AACE;AAGhB;AACc;AACd;;AAEc;AACE;AAGhB;AACc;AACd;AACY;AACE;AACE;AAGhB;AACc;AACd;AACY;AACE;AACE;AAGhB;AACc;AACd;AACA;AACU;;AAEV;AACQ2C;;;AAGR;AACQC;;AACU5jD;AAAI;AACZ;AAAkB4R;;AAChB;AACZ;AACY;AAG+B;AACxBzS;AAA0B;;AAChB;AAIf;AACE;AAGhB;AACc;AACd;AACA;AACU;;AAEV;AACQ0kD;;AAUR;AACA;AACK;AAEC/rB;AACA5pB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChYEyyC;AAAmB;;AACnBH;AAAS;;;AACCO;;;AACV+C;AAAa;;AACbnB;AAAkB;;AAClBoB;AAAQ;;;;AACmB7C;;AAEnC;AACE;AACA;AACA;AAEAljD;AAQE;;AAKA;;AAKA;;AAKA;;;;AAWA;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACEgmD;AACAA;AACN;AACA;AAEEhlD;;;;;;;AACsDL;;;AAEpD;AACEslD;AACN;AACIA;AACA;AACEA;AACN;AACI;AACEA;AACN;AACI;AACEA;AACN;AACI;AACJ;;;AAIA;;AAGA;AACI;AACE;AACN;AACI;AACE;AACN;;AAEA;AACI;AACJ;AACA;AACA;AACA;AACI;AACA;AACA;;AAEJ;AACA;AACA;AACA;;;AAGQ;;AAEAC;;AAKA;AACEzoD;AACD;AACT;AACA;AACA;AACI;AACE;AACN;AACA;AACA;;AAEM;AACN;;AAEY0oD;AAAQ;AAChB;;;AAME;AACN;AAEI;AACA;AAEJ;AACA;AACUA;AAEV;AACA;AACI;;AAKJ;;AAKI;AACJ;AACMC;AAIN;AAEI;AACA;AACA;AACA;AACJ;AACMC;AACN;AACA;AACMA;AAIN;AACMC;AAIN;AAEI;;AACQC;AAAY;AACpB;;AAEJ;AACMC;AACN;AAEI;;AACQrhD;AAAI;AACZ;AACJ;;AAEA;AAEI;AAQJ;AACA;;AAGEshD;AACE;AACA7mC;AACD;AACH;;AAIA8mC;;;;AAIEX;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnOAA;AACF;AAEAY;;;;AAIEZ;;;;;;;AClCK;;;AAGL;;AAGE;AAGF;AAEA;AACF;;ACZA;;AAGA;AACA;;AAEA;AACA;AACA;AACE3qB;AACAwrB;AACAtrB;AACEurB;AACA;;AAEFC;AACEl7C;AACF;AACF;;AAEA;AACA;;AAEI;AACF;AACA;;AAEE;;AAEJ;;AAEA;AACA;;AAEE;AACA;AACA;AACA;;AAEF;;AAEA;AACA;;;AAGI;;AACkD;AAAoB;AAEtE;AACE4O;AAAwB;AAAoB;AAC9C;AACF;AACA;AACF;;AAEA;AACA;AACE;AACE;;AAEA;AACF;AACA;AACF;;AAEA;AACA;AACE;;AAEEjH;;AAAwC82B;AAAI;AAAMA;;AACpD;;AAEA;;;AAGA0c;;AAEA;;AAEIC;AAGF;;AAEF;AACA;AACF;;AAEA;AACA;;AAEE;AACA;AACE;AACF;;;AAGI;AACF;;AAEF;AACF;;AAEA;AACA;AACA;AACE;AACF;AACA;AACE;;AAEE;AACF;;AAEF;;AAEA;AACA;AACE;AAAiB3R;;;;AAGb9oB;AACF;AACF;AACA;AACF;;AAEA;AACA;;AAEI;AACE06B;AACF;AACA;AACF;AACF;AACA;;AAEI;AACF;AACF;AACA;AACE5/C;AACA;AACE;AACF;AACE;AACF;AACF;AACA;AACE;AACF;AACA;;AAEA;AACA;AACE;AAA0BklB;;AAExB;AACEllB;AACA;AACEA;AACF;AACAklB;AAGF;;AAEI;;AAEIA;AAGF;AACF;;AAEI;AACEA;AACF;AACF;AACF;AACF;;AAEE;;;AAGE;AACF;;AAEI;AACEsoB;AACAA;AACF;AACF;AACF;AACA;AACEtoB;AACF;;AAEA;AACF;AACF;AACF;;AAEI;AACEA;AACF;AACF;;AAEA;AACEA;AACF;AACF;AACA;AACF;AACA;;AAEIiK;;AAEJ;AACA;AACE;AACA0wB;AAGI;;;AAGE;AACEC;AACAC;AACF;;AAEE;;AAEF;AACA;;;AAGI1Q;AACF;AACEA;AACF;AACA;AACF;AACE;AACF;AACF;;AAEA;AACF;;AAGA;AACF;AACE;AACF;AACF;;AAEA;AACA;;AAEE;AACA;AACA;AACA;AAQA;;AAEA;AACErM;AACF;;AAEA;;;AAGE;AACE/O;AAMF;AACA;AACE;;AAEEA;AACE;AACA;AACF;AACF;AACF;AACF;;AAEE+O;AACF;;;AAGE;;AAEIze;AACF;AACF;AACF;;AAEE0P;AACF;AACA;AACE1P;AACF;;;;AAEiB0P;AAAQ;AACS1P;AAAK;;;AAGzC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACE;;AAEA;AACEy7B;;;AAGAt0C;AACF;AACF;;AAEA;AACA;;;;;;;;ACpVA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAA6BrE;;;AAC7B8L;AACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE;AACE;AACJ;AAEE;;;AAME;AACJ;AAEE;AACE9L;;;;AAIJ;AACE;AACE;AACJ;AAEE;AACA;AACA;;;AAKE;AACE;AACN;AAEI6e;;AAEAlmB;AAEA;AACJ;AACMA;AAGAigD;AACN;AAEI/6B;AACJ;AAEE;AACE;AACJ;AAEE;AACF;;AAGE;AACE;AACJ;AAEE;;;AAME;AACJ;AAEE;AACE7d;;;;AAIJ;AACE;AACE;AACJ;AAEE;AACA;AACA;;;AAKE;AACE;AACN;AAEI6e;;AAEAlmB;AAEA;AACJ;AACMA;AAGAigD;AACN;AAEI/6B;AACJ;AAEE;AACE;AACJ;AAEE;AACF;;;AAEkCg7B;;;;;;;;;;ACrKlC;;AAEE;AACF;AACA;;AAEE;AACF;AACA;;AAEE;AACF;AACA;;AAEEvnD;;;;;;AAME;;AAEE;AACF;AACA;AACA;AACEwnD;AACEC;AAIF;AACF;AACAD;;AAEF;AACF;;ACpCA;;AAMA;AACA;;AAEA;AACA;AACElsB;AACE;AACF;AACF;;AAKA;AACA;;AAEE;AACA;AACA;AACA;;AAEF;AAIA;;;AAGI;AAGF;;;AAGA;AACA;AAMA;;AAEEosB;;;AAGEC;AACArsB;AACAn7B;AACA;AACA;;AAC4BynD;;AAC9B;;;;AAIE;;AAEE;AACF;;;AAGE;AACEtvC;;;AAGF;AACF;AACF;;AAEEqjB;AACF;;AAEA;AACF;AACA;AACA;;;AAGEksB;AACF;AACA;;;AAGEvsB;AACAr1B;;;AAGA;;;AAKF;AACA;AACE;AACF;AACA;;AAEI;AACF;;AAEE6hD;AACAnsB;AACF;AACF;;AAEEosB;AACA;AACED;AACAnsB;AACF;AACF;;AAEEosB;;AAEED;AACAnsB;AACF;AACF;AACAosB;AACA;AACF;AACA;;;;AAIE;AACA;AACA;;;AAGI3F;AACA;;AAEA;AACF;;;AAGF;AACE;AACF;AACF;AACA;;AAEA;AACA;AACE;AACE;AACF;;AAEE;AACF;;AAEE;;AAEF;AACA;AACF;;AAEA;AACA;AACE;AACA;;;;AAIE;AACA;AACE;;AAIF5nC;AACEwtC;AACAlqB;AACF;;;AAGF;AACEkqB;AACAlqB;AACF;AACF;;AAEA;AACA;;AChMA;;AAIA;AACA;;AAQA;AACA;;AAEA;AACA;AACA;AACE99B;AACE;;;;AAIA;AACA;;;AAGA;AACF;AACAgC;;;AAGF;;AAEA;AACA;AAUA;AACA;AACA;AACE;;;AAKE;AACA;AACE;;AAMF;AACF;;AACkEgS;AAAM;AACxE;AAGE;AACEuY;AACA;AACF;AACA;AACEA;AACF;;AAEA;;AAEF;AACA;;AAEA;;AAEE;;;;AAIE;;AAMF;AACA;AACF;AACF;;AAEA;AACA;AACE;AACA;AACE;;AAEF;;;AAGA;AACF;;AAEA;AACA;AACE+O;AACE;;AAEFF;AACAiP;AACF;AACA;;AAEIjP;AACAiP;AACF;AACF;;AC3HA;;AAEO;AACL;AACE;AACF;;;AAIA;AAEA;AACE;AACE;AACF;AACF;;AAGE;;AAEA;AAEA;;AAEA;AACF;AACF;;AC1BA;;AAEO;;AAEL;AACE3d;AACF;;AAGEu7B;AACE;;AAIJ;;AAGEA;AACE;;AAII17B;AACA;AACF;AAEE;AACF;;AAEN;;AAGE07B;;AAIM;AACF;;AAEN;AAEAv7B;AACEu7B;AACAC;AACF;AACF;;AC7CA;;AAEO;AACL;AACE;AACF;AAEA;;AAGE;AAGF;AACE;AACF;;AAGF;;AClBA;;;AAMA;AACA;AACA;AAEA;;;AAKeC;;;AAEb;AACE;;AAEF;AACF;AAYA;AACE;AACEC;;;AAIFC;AAEA;AACF;AAEA;;AAAsC;;AC5CtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACE;AACA;AACA;AACA;;AAEE35C;;AAEA45C;;AAEJ;;AAEA;AACA;;;AAGE;;AAEF;;AAEA;AACA;;;;AAOA;;AAEA;AACA;;AAEI;AACF;AACA;AACE;AAGF;;AAEA;AACEL;AACF;AACF;;ACnDA;;ACMA;AAEA;AACA;AACA;AACA;;;AAGI;;;AAGI;AACE;AACA;AACF;AACA;;;AAUF;;AAEF;AACF;;AAEA;AACF;AACA;AACA;AACA;AACA;AACE;AACE;AACA;;;AAKA;AACF;AACAjoD;AACE;AACA;AACE4mD;;;AAGE;AACAqB;AACF;AACAnB;AACEyB;AACA38C;AACF;;AAEF48C;;AAEEA;AACF;;AAEEA;AACF;;;AAGA;;AAEA;AACA;AAEI3nB;AACA4nB;AACAtc;AACAn9B;AACF;;AAIF;AACE;;AAEIN;AACF;AACF;AACE;;;AAGF;AACF;;;;AACwC;AACtC;;;AAKM;AACA;AACA;AACA;AACA;AACAg6C;AACAC;AACF;;;AAMN;AACA;AACA;AACEnuC;AACF;AACF;AACA;;;;;AAKA;;AAEF;;AClIA;;ACCA;;;AAGI;;AAEA;;AAEE;;AAIA;AACF;;;AAKE;AACF;AACF;AACF;AACAouC;;ACtBA;AACA;;AAEA;AACA;AACE;;AAEI;AACA3iD;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACE6hD;AACF;AACA;AACEA;AACF;AACAA;AACA;AACF;;AAEA;AACA;;;AAGE;AACA;AACA;;AAEE;;;AAEuBe;;;AAEjB;;;AAAoDvtB;AAAQ;AAC5D;AACA+O;;AAGShjC;;;AAET;AACAgjC;;AAEEhjC;AACEg8B;;AAEAp9B;AACF;;AAEJ;AACF;;;AAGN;;AAEA;AACA;AACE;AACE6iD;;AAEF;;AAOF;AACA;;;AAGM;AACF;;;AAGEC;AACF;;AAIA;AACE;AACF;;AAEF;AACF;;AAEA;AAC0BvuC;AACxBwuC;AACF;;AAiRA;AACA;;AAEIC;AACED;;;AAGN;AACAE;;AC9XO;;ACCP;AACEC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;AACA61C;AACA;AACF;AAEA;;;AAGE;AACF;;AAGE;;AAEA;AACF;AACA;AACA;;AAEA;AACA;AACA;AACI;AACJ;AACA;AACI;;AAEEA;AACA71C;AACA;AACN;;AAEA;;AAEA;AACE;AACF;;AAEI;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE;AACN;AACQA;AACR;;AAEQA;AACR;;;AAGA;AACM;AACF;AACA;;AAEEA;AACA;AAEF;AACE;AACN;AAEE;AACF;AAEA;AACE;AACA;AACE;AACJ;AAEE;AACE;AACJ;AAEE;AACE;AACJ;;;;;;AAOE;AACF;;;;AAKA;AACA;;;;;AAKE;;;;AAIF;AACI;AACE;AACN;;AAEA;AACE;AACF;;AAGA81C;AACAA;AACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9dA;;;;;AAQE;;;;AAIF;;AAEA;AACA;AACE;AACAx0D;AACEyvC;AACAglB;;AAEF;AACF;AAEAC;;AAGA;;AAEA;AACA;AACE;;AAGF;;AAEA;AACE;;AAEF;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AA0BA;;;AAGM;;AAEF3sB;AACJ;;;AAGM;;AAEFA;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEIA;AAEE;AACE;;;AAGE;AAGE4sB;;;AAMG;;AAEH;AAEA;AACZ;AACU;AACD;AACT;;AAEM;AACD;AACL;;AAEA;AACE5sB;AAEE;AACE;AACA;;;;AAIM6sB;AACA;AACZ;AACUC;;AAEV;AACM;AACN;;AAEA;;AAEI;AACD;AAED9sB;;;AAGE;;AAEI;;;AAGE6sB;AACA;AACV;AACQ;AACR;AACA;;AACG;;;AAIG7sB;AAIE;AACE;AACA;AACV;AACA;AACA;;AAEUA;AACE;AACD;AACF;AACF;;AAGHA;AACE;;AAEN;AACA;;AAEM;;;AAGE+sB;AACR;AACQ;;AAEI/sB;AACD;AACX;AACUA;AACV;AACA;AACM;;AAEN;;;;AAKQA;AACE;AACE;AACA;AACZ;;AAEYA;AACE;AACD;AACF;AACF;;;;AAKD;;;;AAIE+sB;AACV;AACU;;AAEI/sB;AACD;AACb;AACYA;AACZ;AACA;AACQ;;AAGR;;AAC+C;;AACzCA;AACN;AACA;;AAGI;AACA;AACE;AACE;;AAED;;AAEP;;AAGI;AACA;;;;AAII;AACR;;AAEA;;AAII;;AAEE;AACE;;AAED;;AAEP;;AAGI;AACA;;;;AAII;AACR;;AAEA;;AAGI;AACJ;AACA;AACI;AACE;AACEj+B;AACAuJ;AACR;AACM;AACE;;;AAGR;;AAEA;;;AAIA;;AAGI;AACJ;AACA;AACI;;AAGE;;;AAGN;AACM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI;AAGA;AAGA;AACA;AACE;AAEN;AAEI;AACJ;AACA;;;;;;;;;AClWA;AAEA0hD;;;AAIIC;AACAC;;AAGF;AACE;AAEAC;;;;;;;AAUA;AACA;AAEA7hD;;AAEJ;AACI;AACA;AACE;AACA;AACN;;AAII;AACE;;AAEN;AACM;;;;AAIN;AAEM;AACE;AACR;AAEM;AACN;AAEI;;;AAGJ;AACM;AACN;AAEI00B;AACE;AACE5iC;;AAEA;AACR;;AAGMA;;AAED;AACL;AAEE;AACE;AAEA+vD;;;;;;AAQA;;AAGA7hD;;AAEJ;AACI;AACA;AACE;AACA;AACN;AAEI;AACE;;AAEN;AACM;AACE;AACR;AAEM;AACN;;;AAKI;AACE;;;AAGN;AACA;AACA;;;;;;;;;ACnHA8hD;;;;;;AAUE;;AACoC;;AAIlC76C;AACD;AAED;AACF;;;;;;;;;;ACpBA;AACA;AACA;;;AAIA;AACA;AACA;;AAEA;;AAEE86C;AACF;AACEC;AACF;AACED;AACAC;AACF;;AAIA;AACE/6C;;AAEI;AACN;AACG;AACH;;AAGA;;AAKIwjB;AACAzD;;;AAGJ;AACA;AACA;AACE;AACAi7B;;AAEF;AACA;AACA;AACA;AACEvtB;AACE;;AAEJ;;AAEUwtB;AACV;AAEQ;AAED;AACP;AAEIj7C;AACEnT;AACD;AACD;AACD;AAED4gC;;AAEF;AACMytB;AACAD;AACN;AAEIj7C;AACEnT;AACD;AACD;AACD;AAE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AACE;AACN;AACI;AACA;AAEA;AACA;AACE;AACN;AACA;AAEEu3D;AACE;AACJ;AAEEn4C;AACE;AACJ;AAEEuI;AACE;;AAEE;AACN;;AAEM;;AAGE;AACR;AAEM;AAEA;AACE;AACR;AAEM;AACN;;AAEA;;;AAIA;AACA;;AAEA;AACA;AACQ6vC;AACR;AACA;AACA;AACA;AACQ;AACR;AACA;AACA;AACQ;AAEA;AACR;AACA;AACI;AACJ;AACA;;AAGE;;;AAKA;;AAGE;AAEA;AACEC;AAEAC;AACAA;AACN;AACA;AAEE;AAEA;AACED;AACAC;AACJ;;AAGI;AACJ;;AAGA;AAEA;;AAEI;AACJ;AAEEt4C;AACE;AACJ;AAEEu4C;;AAEF;;AAGI;;;AAIJ;;AAGM;AACE;AACE32D;AACV;AACA;AACA;;AAEQA;AACR;AACA;AAEI;AACJ;AAEE42D;AACE;AAGA;AACJ;AAEEL;;AACuBM;AAAY;AACrC;;AAEA;AACA;AACEC;AACE;AACA;AACE;AACE;AAGE;AACV;AACA;AACQ;AACR;AACA;AACA;AAEEnwC;AACE;;AAEE;AACN;AACI;AACA;AAUJ;;AAEA;AACA;AACA;AACEowC;AACE;AACA;;AAEI;AACR;AACM;AACD;;AAEC;AACN;AACA;AACI;AACJ;AACA;;AAGA;;AAEI;AACJ;AACE;AACE;;AAEA;;;AAGJ;;AAEA;AACA;AAEA;AACA;AACA;;AAEI;AACJ;AACE;;AAEE;AACE;AACA;AACEC;AACR;AACMA;AACN;AACI;AACD;;AAEH;;AAGA;AACE;;AAEF;;AAEA;;AAEA;AACA;;AAGA;AACE;;AAMF;;AAGA;;AAEE;;AAEE;AACA;AAIJ;AACA;AACA;AACI;AACE;AACA;AACEA;AACR;AACMA;AACN;AACI;AACD;AACH;;AAGA;AACE;AACA;AACEruB;AACAA;AACAsuB;AACA;AACAA;AACEC;AACD;;;AAGF;AACH;;AAGA;AACEA;AACA;;;AAIQ/2D;AACV;AAEA;AACM;AACN;AACA;AACE;AACA;;;AACkCg3D;AAAQ;;AAE1C1wD;AACA;AACE;AACJ;AACA;AACI;;AAEA6vD;AACAA;;AAEA;AACJ;AACA;AACI;;;;;;AAMA;AACJ;AACA;;AAGA;;;AAGEY;AACA;AACE;AAEI/2D;AACR;AAEA;AACE;AACA;AACEwoC;AACAA;AACAyuB;AACA;AACAA;AACEC;AACD;;;AAGF;AACH;;;AAIE;AACF;;;;AAKE;;;AAKErK;AACEsK;AACA;;AAEFH;;;AAGI;AAIR;AACA;AACA;AACQ;AACE;AACA;AACEH;AACZ;AACUA;AACV;AACQ;AACD;AAED;AACD;;AAEL;AAEA;;AAEA;AACA;AAEA;AACA;;AAMA;AACA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9jBA;;;;;;;;;;;;;;;;;;;AAFA;AAEM;AACNO;AACA;;AAGI;AACJ;;AAGC;;AAED;AAEW;;AAEX;;;;;;;;;;;;;;;;;ACOA;;;AAkDA;;;AAoBA;;;;AAsEA;;;;;;;;;;;;AArKe;;AAEfC;AAAsB;;AAEtBC;;;AACmCC;AAAA;AACnC;AACA;;AAEA;;AAGA;AAEM;AACN;AACS;;AAETC;;AAQA;;;AAGAA;AACa;AACb;AACA;;;;AACA;;AAEiBC;AACjB;AAAAD;;AACA;AAEA;AACajsD;AACbmsD;AACA;AACI;;AAEKnsD;;AAET;AACA;AAEA;;;AACSgsD;;;AAEE;;AAEH;AACH;;AAEI;;AAET;;;AAGQC;;;AAERG;AACA;AACAA;AACSA;AACL;;;AAGIC;;;;AAGQL;;AAChB;AAAAM;AACAF;AACA;;AAGYA;AAIZ;;;;AAGAG;;AAEAC;;;AAGQ;;AACR;AACA;AAWI;AACA;;;AAKK;;;AAITnmD;AACQ;;AAEJ;AACJ;AACAomD;;AAEIH;;AAEA;;AAEJ;;AACQ;AACc;;;;AACNN;;AAChB;AACgBC;AAChBS;AACAz4D;AACA;AAEAk4D;AACiBl4D;AAEjB;AACgBy4D;AAChBP;AACAl4D;AACQ;;AAER04D;AACA;;;;AAIAD;AACA;AAEY;;;AAGHE;;;AAGT;AACA;AACA;;;AAGA;;AAGIC;;AAIJA;;;;;AAIAC;;AAKe;AACfC;AAEA;AACAlsC;;AAGA;;AAEAksC;;;AAIKC;AACL;AACQ;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClMAC;AACA;;;AAGAC;;AAECA;;AAEDC;AACKC;;AAIDC;AAEJ;;AAEAC;AACCC;AACDJ;;;;;;AAkBIA;;;;;;;AAMJK;AACQT;;AAEJ;AACI;AACR;AAAM;;;AAGN56C;;;AAGkC;AAClCA;AACA;AAGQA;AACA;AACI;AACZ;AACAq7C;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnEqB1/C;;AAAwC;;AAG7DJ;AACAA;AACAA;;AAEAA;AAEAA;;;;;;;;;;;;;;;;;;;;;ACRc+/C;;AAEV;AAA0B5b;AAAiB6b;AAAaC;AAAe;;AAEvE;AACA;AACJ;;AAGmBF;;AAEflyB;AAAesW;AAAiB6b;AAAaC;AAAe;;AAE5D;AACA;AACJ;;;;;;;;;;;;;;;;ACbE;AACF;;AAIE;AACF;;AAIE;;AAIF;AAGA;AACE;AAEA;AACEC;AAEA;AACE1xD;AACA4K;AACN;AACA;AAEE;AACF;AAGA;;;;AAII+Y;AACJ;AAEE;AACF;;;AAKA;;;;;;;;;;;;;;;AC7CA;;AACkBjU;AAEhB;AAEA;;AAEF;;;AAKI67C;AACJ;AAEE;AACF;AAGA;AACA;AACE9d;;;;;;AAOF;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAGA;;AAEAkkB;;;;AAQAC;;;;;;;;;ACnDA;;AAGA;;;;;AAME;AACEC;AACAC;AACJ;AAEE;AACEC;AACAC;AACJ;;AAGI95C;;;AAGJ;AAGA;AACE;AACF;AAGA;;AAGE;;;;;;AAQA;;AAEA;;;AAIE+5C;AACAC;;AAGEC;AACN;AACA;;;;;;AAME;AAEA;AACE;AACArzC;AAOA6E;AAEJ;;AAGEA;;AAIA;AACE;AACA7E;AAOA6E;AAEJ;AAEE;AACF;AAGAyuC;;;;;;;;;AClGA;;;;;;;;AA2BQzuC;AACR;AACA;AACA;AAEE;AACF;AAEA;AACEhZ;;;AAII;AACN;AACA;;AAEA;;;;AAGiE;;;AACI;;;;;;;;;;AAUjE;AACJ;AACA;AAEA7E;;;;;;;;;;AC9DA;;AAEA;AACA;AAGA;;;AAII6d;;AAKI2rB;AACR;AACA;AAEI3rB;AACJ;;;AAIA;AACA;AAGA;;AACE;;;;;AAKM0uC;AACE5yC;AACA6yC;AACAC;AACAC;AACV;;;;;;;;AAOA;;AAEA;AACA;AAEE;AACExa;AACJ;AACE;AACF;;AAIE;AACF;;;;;AAQA;AACI5iC;;AAGJ;AACIA;;AAGJ;AACI;AACA;AAEJ;AACI;AAEJ;AAEEq9C;AACE;AACE;AACN;;AAGM;AACN;;AAGM;AACN;AACA;AAEEr9C;AACE;AACE;AACN;AACA;;AAIEuO;AACAA;;;AAIAA;AAEA;;AAIFplB;;;;;;;;;ACtHA;AAEA2Z;AACEw6C;AACAC;AAA6B;AAAiC;AAChE;;;;;;;;;ACLA;AAEAv3C;AACEs3C;AACAC;AAA6B;AAAiC;AAChE;;;;;;;;;ACLA;AAEAl8C;AACEi8C;AACAC;AAA6B;AAAiC;AAChE;;;;;;;;;ACAA;;AAIEv9C;AAKF;;;;;;;;;ACdA;;AAGE;AAEA;;AAIF;;AAGE;AACF;;;AAIA;AAEAw9C;AACEF;AACAn4C;AACAo4C;AACAE;AACAC;;AAC2B;;;AACA;;;AACA;;;AACA;;;AACA;AAAU;;AAErCC;AACF;;;;;;;;;AChCA;;AAGE;AAEA;AAEA;AAEF;;;AAMA;;;AAIA;AAEAC;AACEN;AACAn4C;AACAo4C;AACAE;AACAC;AACEG;AAA+B;;AAC/BC;AAA+B;;AAC/B5/B;AAA+B;AAAiC;;AAElEy/B;AACF;;;;;;;;;AChCA;AACA;;;AAMA;;AAGE;AACF;;AAGE;AACF;;AAGE;AAEA;AACIpuC;AACAwuC;;AAGJ;AAEAt7C;;AAEF;AACE;AACEA;AACJ;;AAGA;AACI;AACAA;;AAEJ;;;AAGA;AACM8M;AAEA;AACE9M;;;AAGAs7C;AACR;AACM;AACN;;AAIA;AACMxuC;AAEA;AACE9M;;AAEA;AACAs7C;AACR;AACM;AACN;;AAIA;AACMxuC;AAEA;AACE9M;;AAEA;AACAs7C;AACR;AACM;AACN;AACA;;AAEA;;AAEA;AACE;AAEA;AACEt7C;;;AAGE;AACN;AACIs7C;AACJ;;AAEA;;AAGE;AACF;;;AAGoBp3C;;;;AAIpB;AAEElE;AAEA;AACE;AACApZ;AACAoZ;AACJ;AAEE;;;;;AAMF;AAEE;AACF;;;AAKA;AAEAu7C;AACEV;AACAn4C;AACAo4C;AACAE;AACAC;AACEO;;;AACAC;;;AACAC;AAA8B;;AAClC;AACIC;AAA8B;AAA2G;;AAE3IT;AACAU;AACEJ;AACAC;AACAC;AACAC;AACJ;AACA;;;;;;;;;ACzJA;AACA;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACE;;AAGA;AAEA;AACF;AACA;;AAEI;AACJ;AAEE;AACF;;;AAKE/0D;;;AAIEA;AACJ;;;AAKA;AACI;AACJ;AACE;AACF;;AAKA;AACE;AAEA;AACE;AACE;AAAkB;AAClB;AAAkB;AAClB;AAAkB;AACxB;AACA;AACI;AACE;AAAkB;AAClB;AAAkB;AAClB;AAAkB;AACxB;AACA;AACI;AACE;AAAkB;AAClB;AAAkB;AAClB;AAAkB;AACxB;;AAEI;AACJ;AAEEuX;;AAEF;AACA;;AAEE;AACF;;;AAKA;AAEA09C;AACEhB;AACAn4C;AACAo4C;AACAE;AACAC;AACAC;AACF;;;;;;;;;ACrFA91C;AACEw1C;AAMF;;;;;;;;;;;;;;;;;;AChBA;AAEA;AAC2B;;AACV;;;AAGjB;AAC2B;;AACT;;AACA;;AACE;;AACH;;AACA;;AACA;;AACG;;AACgB;;;;AAIlC;;;AAGA;AACF;;AAGE;;;;;;;AAAmDkB;AAC/CC;;;;AAEJ70C;;;;AAKF;;AAEE80C;;AAEAC;AAEA;AAAe;AACb;AACJ;;AAEA;;AAEEC;AACAC;AACAC;AAEA;;AAEE;AAA4B;AAC1BN;AACN;;AAEA;;AAEA;;AAEE;AACEO;;;;AAIJ;;AAIE;AAEA;AACF;AAEA;AACE;AACF;AAEAC;AACEzB;AACAn4C;AACAo4C;AACAyB;AACAtB;AACF;;;;;;;;;ACrFA;;AAGE;AACF;AAEA5D;AACEwD;AACAn4C;AACF;;;;;;;;;;ACTA;;AAGA;;AAGA;;;AAKE;AAEA;;AAAe85C;;AAA+B59C;;AAEhD;;;;AAIA;;;AAGA;AACI;AAEA49C;AACJ;;AAEA;AACE;AACF;;AAGE;;;AACwC;;AAEpC59C;AACA69C;AACA3wC;;AAEN;;;AAGI;;;AAGEA;AACN;AAEI2wC;AACJ;;AAEA;;AAEEC;;;;AAKE5wC;AACJ;;;AAGA;;AAEA;AAEE;AACF;AAEA;;AACmB2wC;;;;AAEb79C;;AAEN;;;AAGI;;;;AAIEkN;AACN;;AAGA;;AAEA;;;;;;;AAQIA;AACJ;;;;AAIIA;AACJ;;;AAGIA;AACAA;AACJ;AAEE;AACF;;;AAIA;AAEA0vC;AACEX;AACAn4C;AACAo4C;AACAE;AACAC;AACF;;;;;;;;;AC1HA;AAEA;AACA;;AAGE;;;;;;;AAGIn3D;AAEJ;AACE64D;AACAC;;;;;AAQJ;AACA;AAEI;AAEA;AAEJ;AAEE;AACF;;AAGE;AACF;AAEA74C;AACE82C;AACAn4C;AACAo4C;AACF;;;;;;;;;ACzCA;AAEA;;AAGE;AAEA;;;;;AACIh3D;AAEJgoB;AAEA;AACE6wC;;AAIArzD;AAEA;AAEAwiB;AACJ;AAEE;AACF;;AAGE;AAEA;;;;;AACIhoB;AAEJgoB;AAEA;AACE6wC;AAEArzD;AAEAwiB;AACJ;AAEE;AACF;AAEAhI;AACE+2C;AACAn4C;AACAo4C;AACF;;;;;;;;;AClDA;AAEA;;AAGE;AAEA;AAASh3D;;;;AAKX;AACA;AAEE;AACF;;AAGE;AACF;AAEAtG;AACEq9D;AACAn4C;AACAo4C;AACF;;;;;;;;;AClBA+B;;AAKEt/C;AAMF;;;;;;;;;ACnBA;;AAEA;AACA;AACA;AACA;AAGA;;;;;;;;;;;;;;;AAqBkE;;AAGhE;AACF;;AAGE;AACF;;AAGE;AAIF;;AAGE;AAKF;;AAGE;;;AAIF;;AAEA;;;AAII;AACJ;AAEE;AACF;;;AAG2B;AAAS;;AACT;AAAS;;AACT;AAAS;AAClC;AACF;;;;AAKA;AAEE;AACF;;AAGA;;AAmBA;;;AAII;AACJ;AACA;AACA;;AAKA;;AAGA;;;AAGEu/C;AACF;AAGA;;;;;AAMA;AACA;;;;AAME;AACA;AAEA;;;;;;AAMF;AACA;AACE;;;AAIF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACE;;;AAEoC;;;AAGlC1nB;;AAGFnqB;AAEA;AACF;AAEA;AACE;AACF;AAEA;;AAEIgB;AACJ;AACA;AAGA;;AAII;AAEA;AACE8wC;AACN;AAEI;AACEA;AACN;;;AAKMA;AACN;;;;AAMMA;AACN;AAEI9wC;AACAA;AAEA;AACE+wC;AACN;;;;AAOI;AACED;AACN;AAEIE;AACAx7D;AAEA;AACEs7D;AACN;;;AAIA;AAEI;AACEA;AACN;;AAGMt7D;;AAEAs7D;AACN;AAEI9wC;AACJ;;;AAKE;;;AAKE;AACE;AACEixC;AACA;AAEEH;AACV;AACA;;AAEMA;AACN;;AAGA;AACA;;AAGE;AAEA;AACEA;AACJ;AAEElD;AAEA;AACE1xD;;AAGEg1D;AACAC;AACN;AACA;AACA;AAEA;;;AAKA;AACA;AACA;AACE;;AAGE;;AAEIL;AACR;AAEM;AACEM;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEIA;AACJ;AAGEA;;;AAIF;;AAGI;AACE;;AAEN;AACA;;AAEA;AACA;;AAIMpxC;AACAA;AACAA;AACA8wC;AACN;;AAEA;;AAEMhjD;AACEmF;AACArL;AACAsL;AACAvY;AACR;AACA;AACM02D;AACN;;AAEA;AAEE;AACF;;AAGE;;;;AAMF;;AAEI;;AAEJ;AACA;AACIP;AACJ;;AAGE9wC;AACAA;AACF;AAEA;;;;AAKI;;AAEIA;AACR;;AAEA;AAEI;;;;AAIJ;AAEI;;;AAIEsxC;;;;;AAMN;AACA;AACM;AACN;AACA;AAEE;AACEP;AACJ;AAEE;AACF;;AAGE;;;;AAKF;AACA;AACE;AAIEQ;;;AAKE;AACN;AACA;AAEE;AACF;AAEA;;;AAGA;AACIvxC;AACJ;AACA;AAGA;AACE;;;;;;;;;;;;;AA2BE;AACJ;AAEE;AACEwxC;;AAIE;AACN;AACA;;;AAIEC;AACAC;;;AAIIF;;AAIE;AACR;AAEA;AACMG;AAEA;AACE;AACR;;AAIM;AAEN;;;;AAIMC;AAEA;AACEF;;AAEA;AACR;;;;;AAKQ;AACR;AACA;AAEI;;;AAGED;AACAC;AACN;AAEI;AACEG;AACN;;AAGA;;;AAKI;AACJ;;;AAIE;AACF;AAEA;AACE;;;AAME;AACJ;;;;AAKEJ;AAEA;;;;;;;;AASF;AACQ;AACR;AAEA;;;AAGMA;AAEN;AACMX;AAEN;;;AAGA;AACA;AAEEA;AACF;AAEA;;;;AAWI;AACJ;;;;AAKEW;AAEA;;;;AAII;AAEN;;;AAIM;AACEG;;AAER;;AAEQ5xC;;;AAIA8xC;AACAC;AAEA;;;AAIIA;AAEZ;AACYjB;AACZ;AACA;AAEQ9wC;;AAIR;AACQ8wC;AACR;AAEMW;AAEN;;;AAGMA;AAEN;AACMX;AAEN;;;AAGA;AACA;AAEEA;AACF;AAEA;;;;;;;;;;;;;AAaMK;;;;;;;;AAUFa;AACAX;AACJ;;AAEIW;;AAEJ;AACI;AACJ;AAEE;;AAEF;;;AAKIJ;;;;;;AAQE5xC;;AAEA;AACN;AACM8wC;AACN;AACA;AACMA;AACN;AAEImB;;;AAIET;AAEA;;;AAGEI;AACR;AACA;AAEIM;;;;;;AAMAN;;AAIA;AACEO;;AAEAP;;;AAGN;AAEI;AACEQ;;;AAGN;AACMf;AACN;AAEIO;;;AAKES;;AAEN;AACMA;AACN;AACA;AAEEvB;AACF;AAEA;AACE;;AAEIwB;AACAC;AACAC;AACAC;AACAC;AACAC;;;;;AAOFC;AACJ;AACIA;AACJ;AACI;AACJ;;;;;AAQI;;AAEIN;AACR;AACQxB;AACR;;;AAIQA;AACR;AACQ2B;AACAD;AACR;AACQ1B;AACR;AAEA;AACM;AACN;AACA;AAEE;;;AACqD;;;;;AAMvD;AACA;;;;;AAQI;;;AAIJ;;;AAIA;AAEI;AACE4B;AACA;AACN;;AAEA;AACI;AAEJ;;AAEQ1yC;AACR;AACQ;AAAoB;;AAE5B;AACA;;AAEA;AACM;AACN;;AAEA;AACI;AAEJ;AACM;AACE2yC;AACR;AACQ3yC;;AAER;;AAEQ2yC;AACA3yC;;AAER;AACA;AACQ;AAAoB;;AAE5B;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACMA;AACN;AAEIuyC;AACAC;AACAE;;;;AAKJ;;AAGA;AAEE;AACF;AAEA;AACE;;;AAGIrB;;AAEAwB;;;AAGN;AACA;;AAGE;;AAEF;;;AAKI;AACE7yC;AACA8wC;AACN;;AAGM;AACN;AAEIU;AAEA;AACE;AACN;AAEIqB;;;AAIE;AACExB;;AAEA;AACR;AACA;;;AAIIA;AACAO;;AAIA;AACEd;AACN;AACM;AACN;AACA;AAEE;;;;;AAKE;AACJ;AACE;AACF;AAEA;AACE;;;;;;;;;AASIK;AACAc;AACAb;AACA0B;AACAC;AACAF;;;AAGN;AACA;;AAGE;;AAEF;;;;AAMM7yC;AACA8wC;AACN;AAEIU;AACAU;;AAEJ;AACA;AACA;AACA;AACI;;AAGI;AACEE;AACAH;AACV;AAEQY;AACAE;AACAC;;AAGR;AACQD;AACAC;AAER;AACQlC;AACR;;AAGM/8C;;AAEN;AACA;AACA;AACA;;;;AAKM;AACN;AACA;AACQ;AACR;AAEM;;AAGE;;AAER;;;AAKU;AACE+8C;AACZ;AAEU;AACEsB;AACAH;AACZ;AAEUY;AACAE;AACAC;;;;AAKAlC;AAEV;;;;AAIA;;AAGQA;AAER;;;;AAIA;AACA;;AAEA;AACA;AACA;;AAEM;;;;AAIN;AAEM;AACE;;AAER;;AAEA;AACA;;AAGQsB;AACAH;AACR;AAEML;;AAEN;AAEI;AACEd;AACN;AACM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACE;AACEsB;AACJ;;AAEA;AACE;;;;;AAKF;AAEE;AACF;;AAGE;AACIa;AACAC;;;;;AAOJ;AAEA;AACEpC;AACJ;;;AAKImC;;AAGJ;AACIC;AACAC;;AAGJ;AACIA;AACJ;;AAIE;;;AACqD;AAGnD;AACE7iD;;AAEN;AACMwgD;AACN;AACA;;;;AAKUqC;AAEA;AACErC;AACZ;AAEUoC;AACA3B;AACV;AACUT;AACV;AACA;;AAGA;AAEIxgD;AAEA;AACEwgD;AACN;AACA;;AAGIA;AACJ;;AAGIxgD;;AAEAwgD;AACJ;AAEE;;AAGF;;AAGA;AACI9wC;AAEJ;AACIA;AAEJ;;AAEA;AAEE;AACF;;;;AAQE;AAEA;AACE8wC;AACJ;;;AAKE;;AAEF;AAEE;AACEA;AACJ;AAEE9wC;AACA;AACF;;AAGE;;AAKA;;;AAKA;;AAEF;AAEE;AACE8wC;AACJ;AAEE9gC;;;AAIF;;AAGE4hC;AACA;AACF;;AAGE;;;AAGIwB;AAAgB;AAChBC;AACAC;;;;;;;AAQJ;AACEtzC;AACJ;;;;;;AAWE;;AAEIqzC;AAEA;AACED;AACR;AACQA;AACR;;AAEA;AACA;AACA;;;;AAKQC;AACAE;AAEA;AACEH;AACV;AACUA;AACV;;AAEA;AACA;AACQG;AACR;AACA;AACA;AAEE;;AAEF;AAEE;AACE;AACEC;AACN;;AAEA;AAEIC;;;AAOIH;AACR;;AAIUA;AAEV;AACUA;;AAGExC;AACZ;AAEA;AACUwC;AAEA;;AAEV;AACA;AAEQ;;AAER;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEE;AACE;;AAEJ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AAEI;AACEtxD;;AAEgC;;AAE9Bge;AACA;;AAER;AACQ;AACR;AACA;AACA;AACI;AACEhe;AACN;AACA;AACMA;AACA0xD;AAEA;;AAEI1xD;AACA;AACV;AACA;AACA;;;AAIA;AAEI;;AAEJ;AAEI;AAA4C;;AAEhD;AACMge;AACA;;AAEN;AACA;AACA;AAEE;AACEA;AACJ;AACE;AACF;;AAGE;;;;AAII5H;;;AAIJ4H;;;AAIA;AACE4xC;;;AAKE;AACN;AAEIx5C;;;;;AAMJ;AAEIu7C;AACAC;AAEA;AACE9C;AACN;;AAGM;;AAEN;;;;;AAKQ;AACR;AAEM;;;;AAMN;AAEM8C;AACN;AAEI;;;AAIJ;;AAEA;AACA;AAEEhC;;;AAOEA;;AAGAd;AACJ;AAEE+C;AACAjC;;AAIEb;AACJ;;AAIE;AAEE;;AAEEa;AACN;AACI;AACJ;;AAGId;AACJ;AACI;AACJ;AACA;AAGA;AACEprD;AACAmB;AAEA;AAEF;;AAGMnB;AACN;;AAEA;;AAEMA;AACN;AACA;;AAIE;AAEA;;AAEEorD;AACJ;;AAEA;;AAGE;;;AAGF;;;AAIA;;AAGA;AAGA;AACE;AACEjqD;AACAy1C;AACJ;AAEE;AAEA;AACE;AACJ;AAEE;AACEA;AACJ;AACA;AAGA;AACE;AAEA;AACF;AACI;AACJ;;AAEA;AACE;AACF;;;;;;;;;;;;;ACxrDA;;AAEA;AACA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAIAwX;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AAEA;;AAOA;AACEC;AACAC;AACA53B;AACA63B;AACAC;;AAGF;AACE;AAEA;;AAGA72D;AAEA;AACEkZ;AACA49C;;;AAIJ;;AAGI;AACEA;AACN;AAEIt0C;AACJ;AAEE;AACF;;AAGE;;;AAKEmxC;AACA9pD;AACJ;AACI8pD;AACA9pD;AACJ;AACI8pD;AACA9pD;AACJ;AACI;AACJ;AAEE;AACF;;AAIIktD;;;;AAKF;;;AAGA;AACA;;;;;;AAMA;;AAEA;AAEA;AACA;;;;;AAOF;;AAEA;AACA;;AAEMC;;AAEAx0C;;;;;AAMF;AACE7E;AACAq5C;AACN;;;AAGA;;AAIIx0C;AACJ;AAEE;AACF;AAEA;;AAEA;AAEA;AACE;AAEA;AACE7d;AAEA;AACE;AACN;AACA;AAEE;AACF;;AAEA;;AAEE;AACF;;AAEA;AACA;AACA;AACA;;AAEE;AAIF;;AAEA;AACA;AACA;AACA;AACA;;AAEE;AAEF;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;;;AAGF;;AACW;AACLsyD;AAEN;AAAA;;AAOA;;;AAE2C;AACmC;AAE9E;;AAEA;;AAEA;AACA;AACA;AACE;AAEF;AACA;AAAA;AASA;AAAA;AAUA;;AAIA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACE;;AACA;;AAEE;AACJ;;AAEA;AACA;AACE;AACF;;AAEA;;;AAGE;AACF;;AAGIC;AACAC;AACAC;AACAC;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;AAIA;AACA;AACA;;;AAKF;AACA;;AAEMC;AACA;AACE;AACR;;AAEMC;AACN;AACA;AACA;;AAEMD;;AAEEE;AACR;AACQ;AACEC;AACV;AACangE;AAEHogE;AACV;AACA;AACQ;AACR;;AAEMH;AACN;AACA;;AAIA;AACA;AACA;AACA;AACE;AACF;AACA;;AAEM;AACN;AACI;AACJ;AACA;;AAEI;AACJ;AACA;AACA;;AAEI;AACJ;AACE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI;;AAEJ;AACI;AACE;AACE;AACR;AACA;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACI;;AAGJ;;AAEA;;;AAGM;AACN;;AAKM;AACE;AACF;;AAEA;AACE;AAEF;;AAGA;;AAEA;AACE;AACR;AACA;AACA;;AAEA;AACA;AACE;;AAEF;;AAEE;;AAGA;AACF;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEI;;;AAGA;AACJ;AACA;AACE;AACA;;AAEF;AACE;;AAEE;AAAuB55C;AACvBg6C;;AAKAp6C;AACJ;AAEE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACE;;AAEF;AACE;AACA;AACF;;;AACsBq6C;AAAU/6C;;;AAGhC;AACA;AACA;AACA;;;AAGA;AACI;;;AAGJ;AACM/F;AACN;AACI8gD;AACJ;;AAEA;AACA;AACEp1C;AACF;;AAEIA;AACJ;AACIA;AACJ;AAEE;AACF;;AAEA;;;;AAIE;;AAGE80C;AACAO;AAEA;AACEr1C;;AAEN;AACMA;AACN;AACA;AAEE;AACF;AAEA;;;;;;AAOE;AACEllB;;AAGEA;AACN;;AAEA;AACI;AAIE;;AAEN;AACA;;AAGEqlB;AACF;;;;;;;AASE;AACErlB;;AAGEA;AACN;;AAEA;AACI;AAIE;AACE02D;AACR;AAEM;AACEA;AACR;AACQA;AACR;;AAGA;AACA;;AAGErxC;AACF;;;;AAKMm1C;;;;;;AAOJ;AAEEC;AACA;AAEA;AAEAC;AACAC;;AAGEA;AACN;AAEI;AACE;AACN;;;AAMI;AACE;AACN;;;AAIA;AACIjE;AACJ;;AAGErxC;AACF;;;;AAKMm1C;;;;;;;;AAQN;AACE;AACF;;;AAGA;AACIA;AACJ;AACA;AACI;AACJ;AAEE;AACEC;AAEA;;AAEJ;AAEIC;AACAC;;AAGEA;AACN;AAEI;AACE;AACN;;AAKI;AACE;AACEF;AACR;AACQA;AACR;AACA;;AAII;AACEA;AACN;;AAGM;AACN;AAEI;AACEA;AACN;AACMA;AACN;;;AAIA;AACI/D;AACJ;;AAGErxC;AACF;AAEA;;;AAKE;AACEhe;AAEA;AAIE;AACE;;AAER;AACUge;AACV;AACA;;AAEA;;AAGQm0C;;;AAIR;;AAEA;AACU;AACV;;AAGA;AAEM;AACN;AACA;AAEE;AACF;;AAEA;AACA;AACA;AACA;;;;AAKIoB;AACJ;;;AAIE;AAEA;;AAEF;;;;AAME;;AAEEhjC;AACJ;;AAGIijC;AACJ;;AAGIx1C;AACJ;;AAEMA;AACN;;AAEMy1C;AACA;;AAGEC;AACA;;AAER;AACA;;AAEQ;;AAER;AACA;AACA;AACMD;AACA;;AAEIE;AACV;;AAEA;AACQ;;AAER;AACA;;AAEQ;;AAER;AACA;AACA;AACM;AACEC;AACR;AACA;AACM;AACN;AACM;AACA;AACN;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACMC;;;AAMN;;AAEA;AACQA;AACR;;AAGA;AACA;AAEE;AACF;AAEA;;AAEMC;;;AAIJC;AAEA;AACE/1C;AACJ;AACEA;AACF;AAEA;AACE;;AAKEa;AACA;;AAEIi1C;AACR;AACA;AACM1f;AAEA;AACE;;AAER;AACA;AACQ+e;AAEA;AACEY;AACV;AACA;AACA;AACA;AACA;AAEA;AACElvD;AAEA;;;;AAOElM;AAA8B;AAAS;AAC3C;AAEE;AAEA;AACF;;;;;;;;;AC58BA;AACA;AAGA;AACE;AACE;;AAGJ;AAGAq7D;AACAA;AACAA;AACAA;AACAA;AACAA;AACmBA;AACGA;AACHA;AACnBA;;AAEA;;;;;;;;;;;;;ACzBE;AACF;AAEAC;;;;;;;;;ACJA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAIE;;AAEI;AACN;AACM;AACN;;AAEA;AAEAC;;;;;;;;;ACvBA;;AAEA;AAEAC;;;;;;;;;ACJA;;AAIA;AAEA;;AAGE;AACE;AACJ;AACI;;AAEJ;AAEAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdA;AAEAC;;;;;;;;;;;ACFA;AAEAC;;;;;;;;;;;;;;;;;;;;;;;;;ACYE;AACF;AAEAC;;;;;;;;;ACnBA;;AAIA;;AAIA;;AAIA;;AAIA;;AAIA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEAC;;AAEI;AACJ;AAA0D;AAE1D;AAEAC;;;;;;;;;AC3DA;;AAIA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAIE;;AAEI;AACE;AAEF;;AAEI;AACV;AAEM;;AAEI;;AAEA;AACV;AACA;;AAEA;AAEAC;;;;;;;;;;;ACpCE;;AAGEhtC;AACJ;AAEE;AACF;AAEAitC;;;;;;;;;ACXA;;AAEE;;;AAII;AACN;AAEIC;AACJ;AAEE;AACF;AAEAC;;;;;;;;;;ACdA;;;AAGA;AAEAC;;;;;;;;;ACNA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACI;AACJ;AACA;AAEAC;;;;;;;;;ACbA;;AAIA;;AAIA;AAEA;;;AAKA;AACEziE;AACF;AACA;;AAEA;;;AAKE;AACF;;;AAKE;AACE;AACE;AACN;AAEIsiE;AACJ;AAEE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAKAJ;AACE;AACF;AAEAA;AACE;AACE;AACJ;;;AAKE;;AAGE;AACEQ;AACN;AACA;AAEE;AACEC;;AAGExoD;AAEA;AACEuoD;AACR;AAEMC;AACN;AACA;AAEE;AACF;AACAC;;;;;;;;;ACnGA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEAV;AACE;AACF;AAEAW;;;;;;;;;ACpCA;;AAIA;;AAIA;;AAIA;;AAIA;;AAIA;;AAIA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAIE;AAEA;AAEA;AACE;AACD;;AAGD;;AAEF;AACA;;AAGE;AACE;AACJ;AAEE;AAEA;AACE;AACJ;AAEE;AACE;AACJ;AAEE;;AAEF;AAEE;AACE;AACA;AACA;AACE;;AAEN;AAEM;AAEF;AACA;AACA;;AAEI;AACR;AAEM;AAEF;AACE;AACE;AACR;AAEM;AAEF;AACE;AAEF;;AAEI;AACR;AAEM;AACN;AAEE;;AAGE;AACE;AACN;AAEIP;AACJ;AAEE;AACE;AACE;AACE;AACR;AAEM;AAEF;AACE;AACE;AACR;AAEM;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;AAEF;AACJ;AACM;AACN;AAEE;;AAGE;AACJ;;;AAIEA;;AAGE;;AAGE;AACN;AAEIA;AACJ;AAEE;AACF;AAEAQ;;;;;;;;;ACxLA;;AAIA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEAC;;AAEA;AAEAC;;;;;;;;;ACxCA;;AAIA;;AAIA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEAd;AACE;AACF;AAEAe;;;;;;;;;;;;;;;;;;;;;;;;;AC7BI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACI;;AAEIjmC;;AAEIA;AACZ;;AAGY;AACZ;AACK;;AAEL;AACA;AACA;AACA;AACIkmC;;;;;AAOI7iE;;AAEI;AAAQ8iE;AACR;AAAQA;AACR;AAAQA;AACR;AACIA;AACAA;AAChB;;;;;AAMY;AACIA;AACAA;AACAA;AAEAC;AACAA;A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ACE;AACA;AACA;AACA;AACA;AACN;AACA;AACIuB;AACAvB;AACE;;AAEA;;AAEA;;AAEEhG;;AAER;AACM;AACN;;AAEA;AACA;AACIuH;AACAvB;AACE;;AAEN;AACQ4zC;AACA;;AAER;AACQA;AACR;AACA;AACQA;AACR;AACM;AACN;AACA;AACIryC;AACAvB;AACE;AACN;;AAEA;AACA;AACIuB;AACAvB;AACE;;AAEA;;AAEA;AACE;AACA;;AAEA+c;;AAEE;AACE;;AAEZ;;;AAGA;AACU;AACV;AACQ;AACR;;AAEM;AACN;;AAEA;AACA;AACIxb;AACAvB;AACE;AACA;;AAEA+zC;AACAh3B;AACA;AACE;AACA;AACAwiD;AACAxiD;;AAEE;AACE;;AAEZ;;;AAGA;AACU;AACV;AACQ;AACR;;AAEM;AACN;;AAEA;AACA;AACIxb;AACAvB;AACE;AACN;AACQ4hB;AACR;AACQ49C;AACR;AACA;AACA;AACE;AACF;;;;;;;;;;ACpLA;AACA;;;;;AAKI;;;AAGE;;;AAGE;;AAER;AACA;AACI;AACJ;;AAEA;AACA;;;AAGI;AACJ;;AAEA;;AAEI;AACJ;;AAEI;AACE;;;AAGEC;;AAER;AACQ5mE;AACR;;AAEMA;;AAEN;AACMA;AACN;AACA;AACE;AACF;AACA;AACE6mE;;AAEF;;;;AAIE1hE;AACF;;;AAGI;AACA;AACA;AACA;AACJ;;AAEI;AACA;AACA;AACA;AACA;AACA;AACA;AACJ;AACA;AACA;AACEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACA;;AAEF;AACA2hE;AACEC;AACAC;AACAC;;;;;;;;;;;;AC1FF;;AAEIC;AACJ;AAEE;AACE;AACE;AACN;AACM;AACN;AACA;;AAGIpnE;;AAEJ;AACA;AAEEqnE;AACAA;AAEAhzB;AACF;;AAEA;AACA;AACE;AACE;;;;AAKJ;AACM;AACN;AACM;AACN;AACA;AACI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACC;AACD;;AAEA;AACA;AACE;AACExzB;AACJ;;AAGI;AACJ;;AAEA;AACA;AAEAymD;;;;AAIA;AACE;;AAEEC;;AAEJ;AACIA;AACJ;AAEE;AACA;AACF;AACIC;AACJ;;AAEIA;AACJ;AAEEA;AACA;;AAEFF;AACAA;AACE;AACF;AACAA;AACAA;AACE;AACF;AACAA;AACAA;AACAA;AACAA;AACAA;;;AAGAA;;;;;;;;;;;AC9GA;AACE;AACF;;;;AAII;AACE;AACA;AACN;AACI;AACJ;;AAEA;;AAEA;AACA56C;AACE+6C;;;;;;;;;;;;;ACpBF;AACA;;AAEI;;;AAGIznE;AACEqH;AACAiN;AACAsL;AACAD;AACV;AACO;AACP;;AAEA;AACA;;AAEI;;AAEE;AACA+nD;AACAC;AACAA;AACN;;AAEA;;;;;;;;;ACzBE;AACF;;AAEEC;;AAEF;AACEA;AACF;;;;;;;;;ACPA;AACA;AACA;;;;;;;;;;;ACwBAl+B;;AAUA;AACA;;;;;;AAMIm+B;;AAEJ;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEE;AACF;;;AAGA;AACA;AACA;;AAEA;;;;;;;;;AASA;AACAC;;AAEA;AACEC;AACAx0D;;AAEF;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACE;AACA;;AAEF;AACA;AACA;AACE;;AAEF;;;AAGA;;AAEA;;AAEA;;AAEA;;;AAGA;;;AAGA;AACA;AACA;AACE;AACA;;AAEF;AACA;AACA;AACE;;AAEF;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACE;AACEy0D;;;AAGJ;;;AAGA;;;;;AAKA;AACA;;;AAGA;AACA;;;AAGA;;;AAGA;AACE;;AAEF;AACE;;AAEF;;;AAGA;AACA;AACE;AACF;;AAEE;;AAEA;AACE91D;;AAEJ;AACE;;AAEF;;;;AAIQ;AACR;AACA;AACG;AACH;;AAEA;AACA;AACA;;;;AAII7K;;AAEE;AACA;AACN;AACA;AACA;AACE4gE;;;AAGF;;AAEEF;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACE;AACA;;;AAGF;;AAEE;AACE;AACA;AACA;AACA;AACJ;AACE3S;AACF;;AAEA;AACA8S;AACEf;;AAEF;AACE;AACF;AACEA;AACAjnE;AACF;;AAEA;AACA;AACA;;AAEE;;AAEEioE;;AAEAA;AACJ;AACE;AACEhB;AACAjnE;AACA;AACJ;AACE;AACF;;AAEE;;;;AAIE40C;AACJ;AACE;AACE9qC;AACAm2C;AACJ;AACE;AACA;;;AAGElF;AACJ;AACE;;AAEFitB;AACE;;AAEFA;AACE;;;;AAIF;;;AAGA;;;AAGE;AACA;;;AAGF;AACA;AACA;AACE5zD;AACAnW;;AAEF;AACA;AACA;AACE;;AAEF;AACE;AACF;;AAEA;AACA;AACA;AACEmW;AACAnW;AACE;AACJ;AACA;;AAEA;AACA;AACA;AACA;;;;AAIMiqE;AACAjoB;AACArL;AACN;AACA;;;;AAIA;AACE;AACA;AACE;;AAEEA;AACAqL;AACAioB;AACAnoE;AACA2mB;;AAEF;AACEyhD;AACN;AACM37C;AACN;;AAEA;AACI47C;AACJ;AACE;AACF;AACA;;;;;AAKE;;AAEF;;;AAGE;AACF;AACA;AACIpoE;AACJ;AACA;;AAEIypC;AACAw9B;AACJ;AACA;AACA;;AAEIx9B;AACAw9B;AACJ;AACA;AACIoB;AACJ;AACA;;;;AAIE77C;;AAEF;AACA;AACE;AACA;AACA;;;AAGA;AACF;;AAEI;AACE87C;AACN;AACI;AACEtoE;AACN;;AAEA;AACA;AACA;;;;AAIE8J;AACAu+D;AACF;;AAEA;AACA;AACA;AACA;;;AAGI5+B;AACJ;AACA;;AAEA;AACA;;AAEE;;AAEF;AACI;AACA;AACA;;;;AAIA;AACE73B;AACA;;AAEA6M;AACN;;AAEI2pD;;AAEJ;AACA;;;;AAIM57C;;AAEN;AACMA;AACN;;AAEA;AACA;AACI;AACE;AACA;AACA;;AAEA47C;;;AAGN;AACA;AACA;AACA;;AAEQ;AACR;AACA;;AAEA;;;AAGA;;AAEEt+D;;AAEFk+D;;AAEE;AACA;AACEl+D;AACA8qC;AACAqL;AACJ;AACIn2C;AACAm2C;AACJ;AACE;;AAEF;;;;AAIA;;AAEA;AACE;AACA;;;AAGF;AACA;AACA;AACE7rC;AACAnW;AACE;AACJ;AACA;;;AAGA;AACA;AACEwrC;;AAEE;AACEw9B;AACN;;AAEIx9B;AACA4+B;AACJ;AACA;AACA;;;;;;AAMA;;AAEM5+B;AACN;AACA;AACA;AACA;AACE;AACA;AACE8+B;AACA;;AAEE9+B;;AAEN;AACA;AACQ;;;AAGR;AACA;AACA;AACA;AACE;AACF;AACA;;AAEE4+B;AACA;AACE;AACJ;;;AAGA;AACA;AACE;;AAEA;AACE;;;;AAIJ;;AAEA;AACE77C;AACF;;AAEA;AACA;AACA;AACEpY;AACAnW;AACE;AACE;AACN;AACI;;AAEFF;AACF;AACA;AACI;AACE;AACN;;AAEA;AACA;AACI;AACJ;AACA;AACAiqE;AACAA;;;;;;;;;;;;;ACjmBA;;;;AAIE;;AAEF;;AAEA7+B;AACA;AACA;AACAq/B;AACA;AACA;AACE;AACA;AACE;;AAEJ;AACA;;;AAGEC;AACAT;;AAEA;;;AAGE;;AAEE;AACN;AACA;AACA;;AAEA;AACA;AACA;AACE5zD;AACAnW;AACE;AACJ;AACA;;AAEA;AACA;AACA;AACEmW;AACAnW;;AAEF;AACA;;AAEA;AACA;AACA;AACEmW;AACAnW;AACE;AACJ;AACA;;AAEA;;AAEA;AACE;;AAEF;AACA;AACE+B;AACF;;;AAGA;;AAEA;AACA;AACA;AACEoU;AACAnW;;AAEI;AACN;;;AAGEF;AACF;AACA;;AAEM;AACN;;AAEA;AACA;AACI;AACA;AACJ;AACA;;;;;;;;;;;;AC3HA;AACA;;AACQ24D;;AAER;;AAMA;AAEAgS;AACEhS;;;;;;;;;;ACQF;;AAEA;AACA;;;;AAIE;AACE;AAAW;AAAY;AAAa;AAAa;AAAc;AAAc;AAAY;AAAa;AAAe;AAAgB;AACnI;AACF;AACE;AACN;;;AAIE;AACA;AACA;AACE;AACE;AACA;AACE;AACF;AACA;AACA;AACA;AACE;AACF;AACA;AACE;AACF;AACA;AACA;AACE;AACF;;;AAGEiS;AACR;AACA;AACA;;AAEA;AACA;;AAEE;;;AAGF;;AAEA;AACA;AACA;;;AAGE;AACA;;AAEE;;;AAGEC;AACA;AACF;;AAEEA;AACA;AACF;;;AAGEA;AACA;AACF;;;AAGE;AACN;;;;AAIA;AAEAC;AACE;AACA;AACA;;AAEEhhD;AACA;;;AAGJ;AACI1mB;AACJ;;;;AAKA0nE;;AAEA;AACAA;;AAEA;AACAA;AACE;;AAEE;AACJ;;AAEE;;;AAGF;AACA;;AAEE;;AAEF;;AAEA;AACA;AACA;AACA;AACE;AACA;;;;AAIE;AACJ;;AAEED;;;AAGE;AACJ;;AAEEA;;;AAGI;AACN;AACI;AACJ;AACE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI;AACJ;;;;AAIM;AACN;;;;AAIQ;AACR;AACA;AACA;AACA;;AAEA;;;;AAIE;AACA;AACElC;AACA;AACJ;AACEA;AACA;AACF;;AAEA;AACA;AACA;AACA;;AAEE;;;;;AAKF;;AAEA;AACA;;AAEE;AACA;AACA;AACF;;AAEA;AACA;AACA;AACA;AACA;;;AAGI;;AAEE;;;AAGE;AACA;;AAER;AACA;AACI;AACJ;;;AAGE;AACA;AACF;;AAEA;AACA;;AAEE;;;AAGE;AACJ;AACE;AACF;AAEA;;AAEE;AACA;;;AAGE;AACJ;AACI;AACA;AACJ;AACE;AACF;;AAGE;;AAEA;AACF;;AAEA;;AAEE;AACF;;AAGE;AACF;;;;;;;;;;;;AC/RE;AACE;AACAoC;;AAEEzsC;AACN;AACIt8B;;AAEJ;;;;AAIA;AACA;AACE;AACA;AACAA;AACA;AACA;AACA;AACE;;;AAGF;AACE2f;AACAqpD;;;;AAIF;AACEC;AACAC;;;AAGF;AACElpE;;AAEF;AACE;AACA;AACE;AACA;AACN;AACI;AACE;AACA;AACN;;AAEE;;;AAGA;AACE0pC;AACAA;AACA;;AAEJ;AACIA;AACAA;AACJ;AACEA;AACAA;AACA;AACAA;AACA;AACEA;AACAA;AACAA;AACA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;;AAEJ;AACAy/B;;;;;;;;;ACnFA;AACA;AAA4CxgE;;AAA6C4R;AAAkCnT;AAAciN;AAAkBqL;AAAoBC;AAAgB;AAAE;AAAUwC;AAAiB;AAAG;AAAW;;AAC3M;;AAA0F;AACzH;;AAAoG;;;AAA+G;AAAyC;AAAsE;;AAAqD;AACvX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI/a;AACAwhD;;AAEJ;;AAEE;;;AAGF;AACA;AACA;;AAEMwgB;AACAA;AACAA;AACAlmD;AACN;AACA;AACA;;AAEA;AACA;AACEjjB;AACF;AACA;AACE;;AAEI;AACEijB;AACA;AACR;AACMkmD;;;AAGN;;AAEA;;;;AAIEziD;;AAEF;AACA;AACI;;AAEE;AACN;AACI;;AAEJ;AACI;AACJ;AACA;AACA;AACA;AACM;;AAEI;AACEktC;AACZ;AACY3wC;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACI;AACA;AACA;;AAEJ;AACA;AACA;;;;AAIA;;AAEA;AACI;AACA;AACJ;;AAEE;;;AAGF;AACA;AACA;AACE;;AAEI;;AAEE;AACR;AACMA;AACN;AACA;AACA;AACA;AACE;AACA;AACE9b;AACAuY;AACJ;AACIvY;AACAuY;AACJ;AACIvY;AACAuY;AACJ;AACIvY;AACAuY;AACJ;AACIvY;AACAuY;AACJ;AACIvY;;AAEE;AACE2hD;AACAA;AACAA;AACA7lC;AACR;AACQ6lC;AACAA;AACR;;AAEIppC;AACD;AACDopC;AACAp1B;AACE;AACE;AACN;AACA;;AAEQo1B;AACAA;AACAA;;AAER;AACMA;AACA;AACN;AACI;;AAEEA;AACAA;AACAA;AACA7lC;AACN;AACI6lC;AACJ;AACErf;AACA;;AAEF2/B;;;;;;;;;ACjLA;;;AAA6G;;;AAAyD;AAAO;;;AAAqC;;AAAqD;AAAA;;AACtO;;AAAsC/sC;AAAkB;;;AAAwGgtC;AAAyE;;AAAwBA;;;AAA4F;;AAAK;AACnY;AAA2C;;AAAoE;;;AAAkL;;AAAsC;AAAY;;AAClT;AAA6C;AAAuDloE;;AAAyG;AAAoKmZ;AAAmF;AAAE;AAAG;AAAc;AACxf;AAA4C5R;;AAA6C4R;AAAkCnT;AAAciN;AAAkBqL;AAAoBC;AAAgB;AAAE;AAAUwC;AAAiB;AAAG;AAAW;;AAC3M;;AAA0F;AACzH;;AAAoG;;;AAA+G;AAAyC;AAAsE;;AAAqD;;AAEvX;AACE;;AAEE4mC;;AAEF;AACEwgB;;AAEJ;AACA;;;;AAIMC;AACA7iD;AACN;;;AAGI;AACJ;;;;AAIQ;;;AAGA;AACEsiD;;AAEAtiD;AACV;AACU6iD;AACV;;AAEQP;AACR;AACA;AACI;AACJ;AACE;AACF;AACAQ;;;;;;;;;AC5BAjgC;;AAEA;AACA;AACA;;;;AAIA;AACA;;AAEE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEE;AACF;;;AAGA;;AAEA;;AAEA;AACA;AACE5I;AACF;AACEA;AACF;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA8oC;AACA;AACA;AACA;AACA;AACA;AACE;;AAEF;AACA;AACA;AACA;AACE;AACF;AACA;AACE5B;AACAx0D;;AAEF;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACE;AACA;;AAEF;AACA;AACE;;AAEF;AACA;AACA;AACE;;;;;;;;;AASF;AACA;AACA;AACA;;;AAGA;AACA;;;;;;;AAOA;AACE;;AAEF;AACE;;AAEF;;;AAGA;AACA;AACA;AACE;;AAEF;;;AAGA;;;;;;;AAOI;AACJ;AACA;;AAEEw0D;;;AAGF;AACA;AACE;;;AAGF;;AAEE;AACE;AACA;AACJ;AACE3S;AACF;;AAEA;AACA;AACA;AACE9gD;AACAnW;AACE;AACE;AACN;AACI;;AAEFF;AACF;AACA;AACI;AACE;AACN;;AAEA;AACA;AACI;AACJ;AACA;AACA0qE;AACAA;;;;;AAKA;AACA;AACA;AACA;;AAEE;AACA;AACA;AACE;AACExoB;AACA;;AAEEA;AACR;AACMypB;AACN;AACA;AACIA;AACJ;;;;AAIA;AACAjB;;;;AAIE9nC;AACA;;;AAGEgpC;AACJ;AACI;;AAEA;AACE1C;AACN;;AAEQryB;AACR;AACM;;AAEN;AACQqyB;AACR;AACQ;AACR;;AAEQ;;;AAGR;;AAEA;AACA;AACA;;AAEM2C;AACN;AACA;;AAEA;AACA;AACA;AACE;AACF;;AAEE;;AAEEngC;AACJ;AACA;;AAEI;AACA;AACJ;AACEmgC;AACF;AACA;AACE;AACA;AACE3B;AACJ;AACE;AACF;AACAQ;AACE;;;AAGF;AACAA;;AAEE;AACA;AACF;;;AAGA;;;;;;AAMA;AACE;AACA;AACA;AACA;;;AAGF;;;;AAIA;AACIvkD;AACJ;AACA;AACA;AACIA;;;;;;AAMAA;AACJ;AACE;AACF;;AAEA;AACA;AACA;AACE;AACA;;AAEF;;AAEA;AACA;AACE;AACA;AACF;AACE;;AAEE;AACJ;;AAEA;;AAEA;AACAukD;AACE9nC;AACAzc;AACA;;;;AAIF;AACA;AACA;AACE;;AAEE;AACA;AACJ;AACEA;;AAEF;AACE;;AAEE;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACE;AACAyc;;AAEF;AACE;AACEkpC;AACAlpC;AACJ;;AAEA;AACA;AACE;AACEkpC;AACAlpC;;;;;AAKJ;;AAEA;AACI;;AAEJ;AACA;AACI;AACJ;AACE;AACA;;;AAGEzc;AACJ;;;AAGA;AACE;AACF;AACA;;;AAGA;;AAEA;;AAEE;;AAEF;;;;;AAKI;AACEsI;;AAEN;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEI;;;AAGJ;AACA;AACA;;AAEA;AACA;AACA;;AAEE;;;AAGA;AACEmU;;AAEA3gC;AACJ;AACA;;AAEE;AACA2gC;AACA;AACE8I;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACEjd;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;AACE;;AAEAid;AACA;AACJ;AACM;AACN;;AAEA;;AAEA;AACA;AACA;AACA;AACAg/B;;;;;AAKE;;AAEE;;AAEE;AACF;;AAEE;AACF;AACEj8C;AACA;AACN;;;;AAIE;AACA;AACAs9C;AACA;;;AAGI;;AAEE3E;AACR;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACE;AACA2E;;;;AAIF;AACIA;AACAA;AACAA;AACAA;AACAA;AACAlpC;AACAA;AACAA;AACAmpC;;AAEJ;AACA;AACA;AACA;AACA;AACI;AACJ;AACEnpC;;;AAGE;AACAD;;AAEJ;AACA;AACA;AACA;AACM;AACEA;;AAER;;AAEA;AACA;;AAEA;AACA;;AAEIA;AACAk2B;AACAiT;AACA;AACJ;;AAEA;AACEE;;AAEF;;AAEIF;AACAjT;AACJ;AACEiT;;;AAGEA;AACAjT;AACJ;AACEiT;;;AAGElpC;AACJ;;AAEA;AACEkpC;;AAEF;AACE;;;AAGF;AACE;;;;AAIE;AACAnpC;AACA;AACA;;;AAGJ;;AAEA;AACA8nC;AACE;AACA;AACEwB;;;AAGJ;AACE;;AAEF;AACE;AACF;;AAEI;;AAEJ;;;;;AAKI;AACJ;;AAEA;;;AAGA;AACI;AACA;;;;;AAKEA;AACN;AACI;AACJ;;AAEA;;AAEE;;;AAGA;;AAEA;;;AAGF;AACA;;AAEE;AACA;;AAEF;AACA;;;AAGA;;AAEA;;AAEMz9C;;;;;;AAMN;AACQxsB;AACR;AACA;AACA;AACE;;;;AAIA;;AAEF;AACA;AACA;AACA;AACA;AACA;AACIA;AACJ;AACE;;AAEFyoE;AACE;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACIzoE;AACJ;AACE;;;AAGA;;;AAGF;AACA;;;AAGA;;;AAGA;AACA;;;AAGEmF;AACF;;AAEA;AACA;AACAsjE;AACE;AACA;;AAEF;AACA;AACA;AACIj8C;AACAgnC;AACJ;;AAEE;;AAEF;AACE;;;AAGF;AACA;AACA;AACE7yB;AACA;AACE8I;AACJ;;AAEEA;;AAEA;AACF;AACAg/B;;AAEE;;AAEE;AACA;AACJ;AACE;AACA;;;AAGA;AACA9nC;;AAEF;;AAEA;AACA;AACA;AACA8nC;;AAEE;;AAEAh/B;;;;;AAKF;AACIm9B;AACJ;AACEn9B;;AAEE;;AAEJ;AACI;AACA;;AAEEktB;;AAEN;AACA;;AAEA;AACA;AACE;AACE;;;;;;AAMJ;AACA;;AAEA;AACE;;AAEF;;AAEA;AACA;AACE;AACEh2B;AACA;AACEg2B;;AAEN;;AAEE;;AAEF;;;;AAIA;;;AAGA;;AAEA;AACA;AACA;AACEviD;AACAnW;AACE;AACJ;AACA;;AAEA;AACA;AACA;AACEmW;AACAnW;;AAEF;AACA;;AAEA;AACA;AACA;AACEmW;AACAnW;AACE;;AAEFF;;AAEI;AACN;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACEqW;AACAnW;AACE;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACE;AACA;;AAEF;;AAEIuuB;AACJ;AACA;AACIuuB;AACJ;AACE;AACF;;AAEE;AACApa;AACA;;;AAGF;AACA;AACA;;;AAGA;;;;AAII8I;;AAEJ;AACA;AACM;;;AAGN;AACA;AACA;AACA;AACA;AACEg/B;;;AAGF;AACI;;AAEJ;AACA;AACE;;AAEF;AACE;AACF;;;;;;;;;ACj8BAr/B;AACA;;;;;AAKA;AACAo/B;AACA;AACE;;AAEA;;;AAGF;;;;AAIA;AACI;;AAEF;;;AAGE;AACJ;AACA;;;AAGEX;;AAEEqC;AACAC;AACAC;AACAC;AACAC;AACAC;;;AAGJ;AACE;;AAEF;AACA;AACA;AACE;AACA;AACE;AACA;AACJ;;AAEA;AACE;AACF;;;AAGE;AACE;AACE5hB;AACN;AACA;AACIA;AACJ;AACA;;AAEE;AACA;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE7+C;;;AAGA;;;;AAIA;AACE;;AAEJ;;;AAGA;AACA;AACA;AACA0gE;AACE;;;AAGE;AACJ;AACA;AACA;;AAEA;;;AAGE3C;;AAEF;;AAEA;;;AAGA;AACIp+B;;AAEJ;AACA;AACA;;;AAGE;AACF;;;;;;;;;AClKAH;AACA;AACA5/B;;;AAGE8gE;AACF;;AAEE1gE;;;;;;;;;;AC9BF;;;AAGE;AACE;AACAg/D;AACA/oE;;AAEJ;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEEA;;AAEA0pC;AACEqG;AACJ;;;AAGIk5B;AACAtpD;;AAEA;AACAowB;AACA/vC;AACJ;;;AAGI;AACA;AACA0qE;;AAEJ;;AAEI;;;AAGJ;;AAEElnC;AACF;AACA;AACE;AACF;;AAEE;AACA;AACA;AACF;;;AAGImnC;AACJ;AACE;AACA;AACA;AACE;AACJ;AACE;;;AAGE;;AAEE;AACA;AACA;AACAC;;AAEN;AACA;AACE;AACF;AACAC;;;;;;;;;;;ACnFEvtD;;AAEAA;AACF;AACEnD;AACAA;;AAEAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACF;;;;;;;;;;ACfQswD;;AAER;;;AAGI1qE;AAAeqH;AAAWiN;AAAmBsL;AAAgBD;AAAkB;AAChF;AACH;;AAEA;AACA;;AAEE;AACE;AACEyzC;AACA5lC;;AAEN;AAEI;AACJ;AACMA;AACN;AAEI;AACE4lC;AACN;AAEI;;AAEJ;;AAEA;;AAEE;;AAIA;;AAEF;AAEE;AACF;;AAEA;AACA;;;AAGI;AACE;AACN;AAEI;;;AAKA;;AAEJ;AACA;AAEE2X;AAEA;AACF;;;AAG2CvB;AAAkBwB;;;AAI3D;;AAEF;AAEE;AACF;;AAGAC;AACAA;;;;;;;;;;;AClFAthC;;;;;;;;;ACEA;AAA2C;;AAAoE;;;AAAkL;;AAAsC;AAAY;;AAClT;AAA6C;AAAuDtoC;;AAAyG;AAAoKmZ;AAAmF;AAAE;AAAG;AAAc;AACxf;AAA4C5R;;AAA6C4R;AAAkCnT;AAAciN;AAAkBqL;AAAoBC;AAAgB;AAAE;AAAUwC;AAAiB;AAAG;AAAW;AAC1O;AAAkD;AAA0C;AAA2D;AAAA;AACvJ;AAA4C;AAAyC;AAA2BskD;;;AAA+IlsD;AAA4E;AAAA;AAC3U;;AAAkMA;AAAkDoF;AAAe;AAAK;AAAmB;;AAC5P;;AAA0F;AACzH;;AAAoG;;;AAA+G;AAAyC;AAAsE;;AAAqD;;;;;;AAMvX;AACEg3C;AACF;;;AAGI+P;;;;AAIJ;;AAEI/9D;AACAvB;AACE;AACEpB;AACA2gB;;AAEF;;;AAGN;AACA;AACIhe;AACAvB;AACE;AACEpB;;;;;;AAMR;AACA;AACI2C;AACAvB;AACE;AACA;;;AAGA;AACN;AACA;AACIuB;AACAvB;AACE;;AAEN;AACA;AACIuB;AACAvB;AACE;AACA;AACA;AACA;AACA;AACN;AACA;AACIuB;AACAvB;AACE;;AAEA;;AAEA;;AAEEhG;;AAER;AACM;AACN;;AAEA;AACA;AACIuH;AACAvB;AACE;;AAEN;AACQ4zC;AACA;;AAER;AACQA;AACR;AACA;AACQA;AACR;AACM;AACN;AACA;AACIryC;AACAvB;AACE;AACN;;AAEA;AACA;AACIuB;AACAvB;AACE;;AAEA;;AAEA;AACE;AACA;;AAEA+c;;AAEE;AACE;;AAEZ;;;AAGA;AACU;AACV;AACQ;AACR;;AAEM;AACN;;AAEA;AACA;AACIxb;AACAvB;AACE;AACA;;AAEA+zC;AACAh3B;AACA;AACE;AACA;AACAwiD;AACAxiD;;AAEE;AACE;;AAEZ;;;AAGA;AACU;AACV;AACQ;AACR;;AAEM;AACN;;AAEA;AACA;AACIxb;AACAvB;AACE;AACN;AACQ4hB;AACR;AACQ49C;AACR;AACA;AACA;AACE;AACF;;;;;;;;;;ACpLA;AACA;;;;;AAKI;;;AAGE;;;AAGE;;AAER;AACA;AACI;AACJ;;AAEA;AACA;;;AAGI;AACJ;;AAEA;;AAEI;AACJ;;AAEI;AACE;;;AAGEC;;AAER;AACQ5mE;AACR;;AAEMA;;AAEN;AACMA;AACN;AACA;AACE;AACF;AACA;AACE6mE;;AAEF;;;;AAIE1hE;AACF;;;AAGI;AACA;AACA;AACA;AACJ;;AAEI;AACA;AACA;AACA;AACA;AACA;AACA;AACJ;AACA;AACA;AACEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACA;;AAEF;AACA2hE;AACEC;AACAC;AACAC;;;;;;;;;;;;AC1FF;;AAEIC;AACJ;AAEE;AACE;AACE;AACN;AACM;AACN;AACA;;AAGIpnE;;AAEJ;AACA;AAEEqnE;AACAA;AAEAhzB;AACF;;AAEA;AACA;AACE;AACE;;;;AAKJ;AACM;AACN;AACM;AACN;AACA;AACI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACC;AACD;;AAEA;AACA;AACE;AACExzB;AACJ;;AAGI;AACJ;;AAEA;AACA;AAEAymD;;;;AAIA;AACE;;AAEEC;;AAEJ;AACIA;AACJ;AAEE;AACA;AACF;AACIC;AACJ;;AAEIA;AACJ;AAEEA;AACA;;AAEFF;AACAA;AACE;AACF;AACAA;AACAA;AACE;AACF;AACAA;AACAA;AACAA;AACAA;AACAA;;;AAGAA;;;;;;;;;;;AC9GA;AACE;AACF;;;;AAII;AACE;AACA;AACN;AACI;AACJ;;AAEA;;AAEA;AACA56C;AACE+6C;;;;;;;;;;ACOF/9B;;AAUA;AACA;;;;;;AAMIm+B;;AAEJ;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEE;AACF;;;AAGA;AACA;AACA;;AAEA;;;;;;;;;AASA;AACAC;;AAEA;AACEC;AACAx0D;;AAEF;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACE;AACA;;AAEF;AACA;AACA;AACE;;AAEF;;;AAGA;;AAEA;;AAEA;;AAEA;;;AAGA;;;AAGA;AACA;AACA;AACE;AACA;;AAEF;AACA;AACA;AACE;;AAEF;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACE;AACEy0D;;;AAGJ;;;AAGA;;;;;AAKA;AACA;;;AAGA;AACA;;;AAGA;;;AAGA;AACE;;AAEF;AACE;;AAEF;;;AAGA;AACA;AACE;AACF;;AAEE;;AAEA;AACE91D;;AAEJ;AACE;;AAEF;;;;AAIQ;AACR;AACA;AACG;AACH;;AAEA;AACA;AACA;;;;AAII7K;;AAEE;AACA;AACN;AACA;AACA;AACE4gE;;;AAGF;;AAEEF;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACE;AACA;;;AAGF;;AAEE;AACE;AACA;AACA;AACA;AACJ;AACE3S;AACF;;AAEA;AACA8S;AACEf;;AAEF;AACE;AACF;AACEA;AACAjnE;AACF;;AAEA;AACA;AACA;;AAEE;;AAEEioE;;AAEAA;AACJ;AACE;AACEhB;AACAjnE;AACA;AACJ;AACE;AACF;;AAEE;;;;AAIE40C;AACJ;AACE;AACE9qC;AACAm2C;AACJ;AACE;AACA;;;AAGElF;AACJ;AACE;;AAEFitB;AACE;;AAEFA;AACE;;;;AAIF;;;AAGA;;;AAGE;AACA;;;AAGF;AACA;AACA;AACE5zD;AACAnW;;AAEF;AACA;AACA;AACE;;AAEF;AACE;AACF;;AAEA;AACA;AACA;AACEmW;AACAnW;AACE;AACJ;AACA;;AAEA;AACA;AACA;AACA;;;;AAIMiqE;AACAjoB;AACArL;AACN;AACA;;;;AAIA;AACE;AACA;AACE;;AAEEA;AACAqL;AACAioB;AACAnoE;AACA2mB;;AAEF;AACEyhD;AACN;AACM37C;AACN;;AAEA;AACI47C;AACJ;AACE;AACF;AACA;;;;;AAKE;;AAEF;;;AAGE;AACF;AACA;AACIpoE;AACJ;AACA;;AAEIypC;AACAw9B;AACJ;AACA;AACA;;AAEIx9B;AACAw9B;AACJ;AACA;AACIoB;AACJ;AACA;;;;AAIE77C;;AAEF;AACA;AACE;AACA;AACA;;;AAGA;AACF;;AAEI;AACE87C;AACN;AACI;AACEtoE;AACN;;AAEA;AACA;AACA;;;;AAIE8J;AACAu+D;AACF;;AAEA;AACA;AACA;AACA;;;AAGI5+B;AACJ;AACA;;AAEA;AACA;;AAEE;;AAEF;AACI;AACA;AACA;;;;AAIA;AACE73B;AACA;;AAEA6M;AACN;;AAEI2pD;;AAEJ;AACA;;;;AAIM57C;;AAEN;AACMA;AACN;;AAEA;AACA;AACI;AACE;AACA;AACA;;AAEA47C;;;AAGN;AACA;AACA;AACA;;AAEQ;AACR;AACA;;AAEA;;;AAGA;;AAEEt+D;;AAEFk+D;;AAEE;AACA;AACEl+D;AACA8qC;AACAqL;AACJ;AACIn2C;AACAm2C;AACJ;AACE;;AAEF;;;;AAIA;;AAEA;AACE;AACA;;;AAGF;AACA;AACA;AACE7rC;AACAnW;AACE;AACJ;AACA;;;AAGA;AACA;AACEwrC;;AAEE;AACEw9B;AACN;;AAEIx9B;AACA4+B;AACJ;AACA;AACA;;;;;;AAMA;;AAEM5+B;AACN;AACA;AACA;AACA;AACE;AACA;AACE8+B;AACA;;AAEE9+B;;AAEN;AACA;AACQ;;;AAGR;AACA;AACA;AACA;AACE;AACF;AACA;;AAEE4+B;AACA;AACE;AACJ;;;AAGA;AACA;AACE;;AAEA;AACE;;;;AAIJ;;AAEA;AACE77C;AACF;;AAEA;AACA;AACA;AACEpY;AACAnW;AACE;AACE;AACN;AACI;;AAEFF;AACF;AACA;AACI;AACE;AACN;;AAEA;AACA;AACI;AACJ;AACA;AACAiqE;AACAA;;;;;;;;;;;;;ACjmBA;;;;AAIE;;AAEF;;AAEA7+B;AACA;AACA;AACAq/B;AACA;AACA;AACE;AACA;AACE;;AAEJ;AACA;;;AAGEC;AACAT;;AAEA;;;AAGE;;AAEE;AACN;AACA;AACA;;AAEA;AACA;AACA;AACE5zD;AACAnW;AACE;AACJ;AACA;;AAEA;AACA;AACA;AACEmW;AACAnW;;AAEF;AACA;;AAEA;AACA;AACA;AACEmW;AACAnW;AACE;AACJ;AACA;;AAEA;;AAEA;AACE;;AAEF;AACA;AACE+B;AACF;;;AAGA;;AAEA;AACA;AACA;AACEoU;AACAnW;;AAEI;AACN;;;AAGEF;AACF;AACA;;AAEM;AACN;;AAEA;AACA;AACI;AACA;AACJ;AACA;;;;;;;;;;;ACtGA;;AAEA;AACA;;;;AAIE;AACE;AAAW;AAAY;AAAa;AAAa;AAAc;AAAc;AAAY;AAAa;AAAe;AAAgB;AACnI;AACF;AACE;AACN;;;AAIE;AACA;AACA;AACE;AACE;AACA;AACE;AACF;AACA;AACA;AACA;AACE;AACF;AACA;AACE;AACF;AACA;AACA;AACE;AACF;;;AAGE4qE;AACR;AACA;AACA;;AAEA;AACA;;AAEE;;;AAGF;;AAEA;AACA;AACA;;;AAGE;AACA;;AAEE;;;AAGEC;AACA;AACF;;AAEEA;AACA;AACF;;;AAGEA;AACA;AACF;;;AAGE;AACN;;;;AAIA;AAEAC;AACE;AACA;AACA;;AAEEhhD;AACA;;;AAGJ;AACI1mB;AACJ;;;;AAKA0nE;;AAEA;AACAA;;AAEA;AACAA;AACE;;AAEE;AACJ;;AAEE;;;AAGF;AACA;;AAEE;;AAEF;;AAEA;AACA;AACA;AACA;AACE;AACA;;;;AAIE;AACJ;;AAEED;;;AAGE;AACJ;;AAEEA;;;AAGI;AACN;AACI;AACJ;AACE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI;AACJ;;;;AAIM;AACN;;;;AAIQ;AACR;AACA;AACA;AACA;;AAEA;;;;AAIE;AACA;AACElC;AACA;AACJ;AACEA;AACA;AACF;;AAEA;AACA;AACA;AACA;;AAEE;;;;;AAKF;;AAEA;AACA;;AAEE;AACA;AACA;AACF;;AAEA;AACA;AACA;AACA;AACA;;;AAGI;;AAEE;;;AAGE;AACA;;AAER;AACA;AACI;AACJ;;;AAGE;AACA;AACF;;AAEA;AACA;;AAEE;;;AAGE;AACJ;AACE;AACF;AAEA;;AAEE;AACA;;;AAGE;AACJ;AACI;AACA;AACJ;AACE;AACF;;AAGE;;AAEA;AACF;;AAEA;;AAEE;AACF;;AAGE;AACF;;;;;;;;;;;;AC/RE;AACE;AACAoC;;AAEEzsC;AACN;AACIt8B;;AAEJ;;;;AAIA;AACA;AACE;AACA;AACAA;AACA;AACA;AACA;AACE;;;AAGF;AACE2f;AACAqpD;;;;AAIF;AACEC;AACAC;;;AAGF;AACElpE;;AAEF;AACE;AACA;AACE;AACA;AACN;AACI;AACE;AACA;AACN;;AAEE;;;AAGA;AACE0pC;AACAA;AACA;;AAEJ;AACIA;AACAA;AACJ;AACEA;AACAA;AACA;AACAA;AACA;AACEA;AACAA;AACAA;AACA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;;AAEJ;AACAy/B;;;;;;;;;ACnFA;AACA;AAA4CxgE;;AAA6C4R;AAAkCnT;AAAciN;AAAkBqL;AAAoBC;AAAgB;AAAE;AAAUwC;AAAiB;AAAG;AAAW;;AAC3M;;AAA0F;AACzH;;AAAoG;;;AAA+G;AAAyC;AAAsE;;AAAqD;AACvX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI/a;AACAwhD;;AAEJ;;AAEE;;;AAGF;AACA;AACA;;AAEMwgB;AACAA;AACAA;AACAlmD;AACN;AACA;AACA;;AAEA;AACA;AACEjjB;AACF;AACA;AACE;;AAEI;AACEijB;AACA;AACR;AACMkmD;;;AAGN;;AAEA;;;;AAIEziD;;AAEF;AACA;AACI;;AAEE;AACN;AACI;;AAEJ;AACI;AACJ;AACA;AACA;AACA;AACM;;AAEI;AACEktC;AACZ;AACY3wC;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACI;AACA;AACA;;AAEJ;AACA;AACA;;;;AAIA;;AAEA;AACI;AACA;AACJ;;AAEE;;;AAGF;AACA;AACA;AACE;;AAEI;;AAEE;AACR;AACMA;AACN;AACA;AACA;AACA;AACE;AACA;AACE9b;AACAuY;AACJ;AACIvY;AACAuY;AACJ;AACIvY;AACAuY;AACJ;AACIvY;AACAuY;AACJ;AACIvY;AACAuY;AACJ;AACIvY;;AAEE;AACE2hD;AACAA;AACAA;AACA7lC;AACR;AACQ6lC;AACAA;AACR;;AAEIppC;AACD;AACDopC;AACAp1B;AACE;AACE;AACN;AACA;;AAEQo1B;AACAA;AACAA;;AAER;AACMA;AACA;AACN;AACI;;AAEEA;AACAA;AACAA;AACA7lC;AACN;AACI6lC;AACJ;AACErf;AACA;;AAEF2/B;;;;;;;;;ACjLA;;;AAA6G;;;AAAyD;AAAO;;;AAAqC;;AAAqD;AAAA;;AACtO;;AAAsC/sC;AAAkB;;;AAAwGgtC;AAAyE;;AAAwBA;;;AAA4F;;AAAK;AACnY;AAA2C;;AAAoE;;;AAAkL;;AAAsC;AAAY;;AAClT;AAA6C;AAAuDloE;;AAAyG;AAAoKmZ;AAAmF;AAAE;AAAG;AAAc;AACxf;AAA4C5R;;AAA6C4R;AAAkCnT;AAAciN;AAAkBqL;AAAoBC;AAAgB;AAAE;AAAUwC;AAAiB;AAAG;AAAW;;AAC3M;;AAA0F;AACzH;;AAAoG;;;AAA+G;AAAyC;AAAsE;;AAAqD;;AAEvX;AACE;;AAEE4mC;;AAEF;AACEwgB;;AAEJ;AACA;;;;AAIMC;AACA7iD;AACN;;;AAGI;AACJ;;;;AAIQ;;;AAGA;AACEsiD;;AAEAtiD;AACV;AACU6iD;AACV;;AAEQP;AACR;AACA;AACI;AACJ;AACE;AACF;AACAQ;;;;;;;;;AC5BAjgC;;AAEA;AACA;AACA;;;;AAIA;AACA;;AAEE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEE;AACF;;;AAGA;;AAEA;;AAEA;AACA;AACE5I;AACF;AACEA;AACF;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA8oC;AACA;AACA;AACA;AACA;AACA;AACE;;AAEF;AACA;AACA;AACA;AACE;AACF;AACA;AACE5B;AACAx0D;;AAEF;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACE;AACA;;AAEF;AACA;AACE;;AAEF;AACA;AACA;AACE;;;;;;;;;AASF;AACA;AACA;AACA;;;AAGA;AACA;;;;;;;AAOA;AACE;;AAEF;AACE;;AAEF;;;AAGA;AACA;AACA;AACE;;AAEF;;;AAGA;;;;;;;AAOI;AACJ;AACA;;AAEEw0D;;;AAGF;AACA;AACE;;;AAGF;;AAEE;AACE;AACA;AACJ;AACE3S;AACF;;AAEA;AACA;AACA;AACE9gD;AACAnW;AACE;AACE;AACN;AACI;;AAEFF;AACF;AACA;AACI;AACE;AACN;;AAEA;AACA;AACI;AACJ;AACA;AACA0qE;AACAA;;;;;AAKA;AACA;AACA;AACA;;AAEE;AACA;AACA;AACE;AACExoB;AACA;;AAEEA;AACR;AACMypB;AACN;AACA;AACIA;AACJ;;;;AAIA;AACAjB;;;;AAIE9nC;AACA;;;AAGEgpC;AACJ;AACI;;AAEA;AACE1C;AACN;;AAEQryB;AACR;AACM;;AAEN;AACQqyB;AACR;AACQ;AACR;;AAEQ;;;AAGR;;AAEA;AACA;AACA;;AAEM2C;AACN;AACA;;AAEA;AACA;AACA;AACE;AACF;;AAEE;;AAEEngC;AACJ;AACA;;AAEI;AACA;AACJ;AACEmgC;AACF;AACA;AACE;AACA;AACE3B;AACJ;AACE;AACF;AACAQ;AACE;;;AAGF;AACAA;;AAEE;AACA;AACF;;;AAGA;;;;;;AAMA;AACE;AACA;AACA;AACA;;;AAGF;;;;AAIA;AACIvkD;AACJ;AACA;AACA;AACIA;;;;;;AAMAA;AACJ;AACE;AACF;;AAEA;AACA;AACA;AACE;AACA;;AAEF;;AAEA;AACA;AACE;AACA;AACF;AACE;;AAEE;AACJ;;AAEA;;AAEA;AACAukD;AACE9nC;AACAzc;AACA;;;;AAIF;AACA;AACA;AACE;;AAEE;AACA;AACJ;AACEA;;AAEF;AACE;;AAEE;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACE;AACAyc;;AAEF;AACE;AACEkpC;AACAlpC;AACJ;;AAEA;AACA;AACE;AACEkpC;AACAlpC;;;;;AAKJ;;AAEA;AACI;;AAEJ;AACA;AACI;AACJ;AACE;AACA;;;AAGEzc;AACJ;;;AAGA;AACE;AACF;AACA;;;AAGA;;AAEA;;AAEE;;AAEF;;;;;AAKI;AACEsI;;AAEN;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEI;;;AAGJ;AACA;AACA;;AAEA;AACA;AACA;;AAEE;;;AAGA;AACEmU;;AAEA3gC;AACJ;AACA;;AAEE;AACA2gC;AACA;AACE8I;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACEjd;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;AACE;;AAEAid;AACA;AACJ;AACM;AACN;;AAEA;;AAEA;AACA;AACA;AACA;AACAg/B;;;;;AAKE;;AAEE;;AAEE;AACF;;AAEE;AACF;AACEj8C;AACA;AACN;;;;AAIE;AACA;AACAs9C;AACA;;;AAGI;;AAEE3E;AACR;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACE;AACA2E;;;;AAIF;AACIA;AACAA;AACAA;AACAA;AACAA;AACAlpC;AACAA;AACAA;AACAmpC;;AAEJ;AACA;AACA;AACA;AACA;AACI;AACJ;AACEnpC;;;AAGE;AACAD;;AAEJ;AACA;AACA;AACA;AACM;AACEA;;AAER;;AAEA;AACA;;AAEA;AACA;;AAEIA;AACAk2B;AACAiT;AACA;AACJ;;AAEA;AACEE;;AAEF;;AAEIF;AACAjT;AACJ;AACEiT;;;AAGEA;AACAjT;AACJ;AACEiT;;;AAGElpC;AACJ;;AAEA;AACEkpC;;AAEF;AACE;;;AAGF;AACE;;;;AAIE;AACAnpC;AACA;AACA;;;AAGJ;;AAEA;AACA8nC;AACE;AACA;AACEwB;;;AAGJ;AACE;;AAEF;AACE;AACF;;AAEI;;AAEJ;;;;;AAKI;AACJ;;AAEA;;;AAGA;AACI;AACA;;;;;AAKEA;AACN;AACI;AACJ;;AAEA;;AAEE;;;AAGA;;AAEA;;;AAGF;AACA;;AAEE;AACA;;AAEF;AACA;;;AAGA;;AAEA;;AAEMz9C;;;;;;AAMN;AACQxsB;AACR;AACA;AACA;AACE;;;;AAIA;;AAEF;AACA;AACA;AACA;AACA;AACA;AACIA;AACJ;AACE;;AAEFyoE;AACE;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACIzoE;AACJ;AACE;;;AAGA;;;AAGF;AACA;;;AAGA;;;AAGA;AACA;;;AAGEmF;AACF;;AAEA;AACA;AACAsjE;AACE;AACA;;AAEF;AACA;AACA;AACIj8C;AACAgnC;AACJ;;AAEE;;AAEF;AACE;;;AAGF;AACA;AACA;AACE7yB;AACA;AACE8I;AACJ;;AAEEA;;AAEA;AACF;AACAg/B;;AAEE;;AAEE;AACA;AACJ;AACE;AACA;;;AAGA;AACA9nC;;AAEF;;AAEA;AACA;AACA;AACA8nC;;AAEE;;AAEAh/B;;;;;AAKF;AACIm9B;AACJ;AACEn9B;;AAEE;;AAEJ;AACI;AACA;;AAEEktB;;AAEN;AACA;;AAEA;AACA;AACE;AACE;;;;;;AAMJ;AACA;;AAEA;AACE;;AAEF;;AAEA;AACA;AACE;AACEh2B;AACA;AACEg2B;;AAEN;;AAEE;;AAEF;;;;AAIA;;;AAGA;;AAEA;AACA;AACA;AACEviD;AACAnW;AACE;AACJ;AACA;;AAEA;AACA;AACA;AACEmW;AACAnW;;AAEF;AACA;;AAEA;AACA;AACA;AACEmW;AACAnW;AACE;;AAEFF;;AAEI;AACN;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACEqW;AACAnW;AACE;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACE;AACA;;AAEF;;AAEIuuB;AACJ;AACA;AACIuuB;AACJ;AACE;AACF;;AAEE;AACApa;AACA;;;AAGF;AACA;AACA;;;AAGA;;;;AAII8I;;AAEJ;AACA;AACM;;;AAGN;AACA;AACA;AACA;AACA;AACEg/B;;;AAGF;AACI;;AAEJ;AACA;AACE;;AAEF;AACE;AACF;;;;;;;;;ACj8BAr/B;AACA;;;;;AAKA;AACAo/B;AACA;AACE;;AAEA;;;AAGF;;;;AAIA;AACI;;AAEF;;;AAGE;AACJ;AACA;;;AAGEX;;AAEEqC;AACAC;AACAC;AACAC;AACAC;AACAC;;;AAGJ;AACE;;AAEF;AACA;AACA;AACE;AACA;AACE;AACA;AACJ;;AAEA;AACE;AACF;;;AAGE;AACE;AACE5hB;AACN;AACA;AACIA;AACJ;AACA;;AAEE;AACA;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE7+C;;;AAGA;;;;AAIA;AACE;;AAEJ;;;AAGA;AACA;AACA;AACA0gE;AACE;;;AAGE;AACJ;AACA;AACA;;AAEA;;;AAGE3C;;AAEF;;AAEA;;;AAGA;AACIp+B;;AAEJ;AACA;AACA;;;AAGE;AACF;;;;;;;;;AClKAH;AACA;AACA5/B;;;AAGE8gE;AACF;;AAEE1gE;;;;;;;;;;AC9BF;;;AAGE;AACE;AACAg/D;AACA/oE;;AAEJ;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEEA;;AAEA0pC;AACEqG;AACJ;;;AAGIk5B;AACAtpD;;AAEA;AACAowB;AACA/vC;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CNA;;AAIA;;AAIA;;AAGE;;;AAGF;;;;AAMI;;AAGF;AACF;AAEA;AAEAw3C;AACE;AACF;AAEA+N;;;;;;;;;AChCA;;AAIA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACE;;;;;;AAOI;;AAGEvlD;AACR;AACQA;AACAwlD;AACR;AAEM1yC;AAEA;AACEkC;AACR;AAEMywC;AACN;;;AAIA;AAEAC;;;;;;;;;ACjDA;;AAIA;;AAIA;;AAIA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEAlO;;;AAGA;AAEE;AACF;AAEAmO;;;;;;;;;ACrEA;;AAIA;;AAIA;;AAIA;;AAIA;;AAIA;;AAIA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEAnO;AAEAoO;;AAEI;AACE;AACE;AACR;AAEI;AACE;;AAEE;;AAGJ;AACE;AACN;AACA;AAEAC;;;;;;;;;ACtFA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEArO;;;;AAIE;;AAGEx2C;AACA+1C;AACJ;AAEE;AACE;AACE/2C;AACN;AACA;AAEE;AACF;AAEA8lD;;;;;;;;;AC3CA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAEAtO;;AAGE;;AAEIx3C;AACN;AACA;AAEE;AACF;AAEA+lD;;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AEA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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YC;;AAAMxuE;AAAQE;AAAkbG;AAAkBE;AAAGguE;AAAcC;AAAa;AAAC;;;;;;;;;ACElhtB;AACA;AACA;;AAGE;;AAEE;;AAEJ;AAEAC;AACE;;;;AAIF;AACMp5E;;AAEImwB;AACV;AACUA;AACV;AACQ;;AAER;;AAEA;AACMnwB;AACN;AACMA;AAEIq5E;AACA;;AAIV;AACA;AACMr5E;AACN;AACI;;AAEF;;;;;;;;;;AC7CF01C;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtLGtF;AACJ;AACA;AAEAkpC;AAEAvwE;;;;;;;;;;;;;ACXAwwE;AACE;AAAO;AACP;AAAQ;AACR;AAAO;AACP;AAAO;AACP;AAAO;AACP;AAAU;;;;;;;;;;;ACNZC;;;;;;;;;;;;;;;;ACEA;AACA;AACA;AACA;AAEA;;AAGA;AACE;AACE;AACA;;;AAGJ;AACE;;AAEA;AACE;AACAC;;AAEJ;;AAGA;;AAGE;AACEr8C;;;;AAIFs8C;AACE;;;AAII;AACAC;AACA;;AAIJ;;AAEF;AACF;;AAGAC;;;;;;;;;;ACjDA;;AAGE;AACE;;AAEE;;AAEEC;AACR;AACQC;AACR;AACM;;AAEF;;AAEJ;;AAGAC;;;;;;;;;ACrBA;AACA;;;AAIA;;;;AAKA;;;;;;;AAWE;AACE;AAGJ;AACE;AACE;AAGJ;;AAEI;AAGJ;AACA;;AAGE;AACF;;AAEE;AACF;AAEA;AACE;;AAEA;;AAEE;AACE;AACN;AACI;AACEzzD;AACA;AACN;AACI0zD;AAEA;AACE;AACN;AAEI;AACA;AACE1zD;AACA;AACN;;;AAII0zD;AACEnpC;AACD;AACL;AACE;AACF;;;;AAKE;AACE;AACJ;AACE;AACF;;AAGE;AACE;AACE;AACE;AACR;AACA;AACA;AACI;AACJ;AACA;AAEA;AACE;AAEA;AACA;;AAEF;AACI90C;AACJ;AACIA;AACJ;AACIA;AACJ;;;;AAOA;AACA;AAEE;AACF;;AAGE;AAIA;;;;AAIE;;AAEE;AAGN;AACA;;AAEIo0B;AAAS0H;;AACb;AACE;AACEoiD;AACJ;AAEE;AACF;;;;AAKA;;AAGE;AAEA;AACEC;AACJ;AACE;AACF;;;AAIE;;AAEE;AACE;AACEC;AACR;AACA;AACA;;AAEA;;AAGE;AACA;AAEA;AACA;AAEA;AACF;AAEA;;;AAGA;AACE;;AAEF;AAEE;;AAGA;;;;AAIIC;AACAA;AACN;AACMA;AACN;AACA;AAEE;AACF;AAEA;AACE;AACE;AACJ;AACA;;AAEM;AACAC;;AAEN;AACA;AACA;;AAGEC;;;AAGF;;AACkDzpD;AAAsB;AACpE;;AAEJ;AACI;AACE;AACE;AACR;;AAEQ;AACR;AACA;;;;;;AAYA;AACI;;AAEgB;AAEhB;;AAGF0pD;AACE;;;AAGJ;AACMV;AACN;;;AAKU;;AAIV;AACI;;;;AAII;AACR;AACA;AACI;;AAGFW;AACE;AACE;;;;AAIN;AACM;AACN;AACM;AACN;;;;AAKI;AACE;;;;;AAKN;AACM;AACAC;AACAC;AACA;AACE;AACEA;AACV;AACA;AACA;;AAGEC;;AAEE;AACA;;;;;AAKJ;AACI;AACAC;AACA;;AAEE;AACEA;AACR;AACA;;AAGEC;AACE;AAAehjD;;AACf;;AAOI;AACD;;AAGA;AAEC;AACEijD;AACAA;AACE;;AAIZ;AACYx0D;AACD;AACX;AACUw0D;AACEx0D;AACD;AACX;AACO;AAEH;;AAGFy0D;AACE;;AAEJ;AAEI;;AAGFC;AACE;;;;AAOI;AACA;;AAEIC;;AAEA;;AAIZ;AACA;AAEQ;AACE;;AAIA;;AAKA;AAGV;AACU;AACV;AACU;;AAEA;AACV;;;AAMEC;AACE;AAEA;;AAGFC;AACEC;;;;AAKA;;AAGFC;AACE;AACAD;AACA;AAEA;AACA;AAEA;AACE;AACA9mD;AAQN;;AAGEgnD;AACE;;;;;;;;;;;;;;;;;;;;ACxcJ;AAEA;AACE;;;;AAIF;AACA;AACE;AACF;AAEA;AACE;AAAavtE;;;;AAGXA;AACJ;AAEE;AACE;;AAEA;;AAEE;AACEuL;AACR;AACM;AACN;AACA;;AAGE;AACF;AAEA;AACE;;AAEE;AACEA;;AAEAiiE;AACA;;AAEAjiE;;AAEAiiE;AACA;AACN;;;AAGMA;AACA;AACN;AACI;AACD;AACH;AAEAzuE;AACE;;;;;AAMF;AACM;AACD;;;;;;;;;;;AC1EL;AACA;;;AAIA;AACA;AACA;;;;;;AAMA;;AAEA;AACE;AACF;;AAGE;;AAEE;AACD;AACH;;AAGE;;AAEC;AACH;;;;AAKI0uE;AACJ;AACE;AACF;;AAGE;AACE;;AAEJ;;;AAIA;AAEA;AACE;;;;AAIE;AACJ;;AAEE;;AAEEC;AACJ;AACE;AACF;;;AAIE;;AAEF;AACE;AACF;AAEA;AACE;;AAEF;AACA;AAEA;AACE/gF;;;AAGI;;AAEN;;AAEM;;AAEN;;AAEM;;AAEN;;AAEM;;AAEN;;AAGI;AACJ;AACA;AAEA;;;;;;;AAOM;;AAEN;;;AAGM;;AAEN;;;AAGM;;AAEN;;;AAGM;;AAEN;AACA;;;AAIA;AAEA;AACE;AACA;AACA;AACF;AAEA;AACE;AAKF;;AAEA;AACA;;AAEE;AACEymB;AACJ;AACA;AACA;AACE;AACE;;;AAGI;;AAEJ;AACA;;;AAGI;;AAER;AACA;;AAEA;AACA;;AAEI;AACJ;AACE;AACE;AACJ;;AAEI;AACJ;AACE;AACF;AAEA;;AAEI;AACJ;;AAEA;AACI;AACJ;AACA;AAEA;AACE;AACA;AACE;;AAEA;AACJ;AACI;AACJ;AACA;AAEA;;AAEE;AACE;AACA;AACA;AACE;AACA;AACD;AACD;;AAEJ;;;;;;;;AASA;AAEA;AACEplB;;;AAGE;;AAEE;AACN;AACM;;AAEA;AACN;AACA;AACE;AACF;AAEA;AACE;AACA;AAEI;;AAGN;;;AAIE;AACE8b;AACJ;AACE;AACF;AAEA;AACE6jE;AACAA;;AAEAA;;;AAGF;AACG;AACD;AACF;AAEA;AACE;;AAEA;AACF;;;AASA;;AAEA;AACA;;;AAGE;AACE;AACE;;;AAGA;AACF;AACE;;AAEA;AACF;AACE;AACN;;AAEI;AACJ;;AAEA;AAEA;;AAKA;AAEA;AACE;AACE;AACE;AAMN;AACI;AACA;AACE;AACA;;AAEN;AACQ;AACR;AACK;AAED;;AAEI;;AAEC;AACT;AACQ;;AAEC;AACT;AACA;;;AAGQhlD;AACEqa;AACD;AACD;AACE;AACD;AACT;AACM;AACN;;AAEA;;;AAKE;AACEvvC;AACJ;AAEE;AACF;AAEA;;AAEI;AACA;AACEm6E;AACN;;AAEA;AACA;AAEE;AACF;;AAGE;;AAIF;AACA;;;AAKA;AACEn6E;AACAm6E;;;AAIE;AACD;AACD;;;;;;AAMF;AACE;AACEx9C;AACJ;AAEExsB;;AAEA;AACEwsB;AACA;;AAEJ;AACA;;;AAKE;AACEy9C;AACAC;;AAEJ;AACA;AACA;AACM;AACA;AACA;AACN;;AAEA;AACG;AACD;AACEhrC;AACJ;AACE;AACF;;AAGE;;AAEA;AACA;AACEirC;AACJ;AACE;AACF;AAEAC;AACEv6E;AACAm6E;;;;;AAKF;AACAI;AACAA;;;AAGEC;;;AAGF;;;AAGA;;AAEEC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;;;AAGF;AACA;AACA;;AAEEC;AACAC;AACAC;;;;AAIF;AACAhB;AAEAA;AACAA;AACAA;AACAA;AACAA;AACAA;AAEAA;AACE;AACA;AACE/7E;AACJ;;AAEIwB;AACA;;AAEE;AACN;;AAEI;;AAEJ;AACA;AACI;AACEq4E;AACN;AACMA;AACN;AACIloE;AACA3R;AACJ;;;AAGA;;AAEI;AACE;AACEA;AACR;AACA;AACA;;AAGI;;;AAGJ;AACI;;;AAIJ;;AAEI;AACD;AACD;;AAEI;AACN;;AAIA;AACA;;AAEA;AAEA;AACE;;;;AAIF;AAEA;AACE;AACA;;;AAGI;AACE;AACR;;AAEA;AACM;AACA;AACEg9E;AACR;AACQA;AACR;AACMrrE;AACA+oE;AACN;AACA;AACE;;AAEC;;;AAGD;AACA;AACEhgF;AACA;AACAuiF;AACA32D;;AAEJ;AACE;AACF;AAEA;AACE42D;;AAEEC;AACAC;AACE;AACE;AACA;;;AAGAjtD;AACA;;AAER;;AAEEktD;;AAEEF;AACAC;AACE;AACE;AACA;AACA;;AAEAjtD;AACA;;AAER;;AAEEmtD;;AAEEH;AACAC;AACE;AACA;AACE;AACD;AACP;;AAEEG;;AAEEJ;AACAC;AACE;;AAGN;AAEA;;AAEEI;AACEC;AACAN;AACAC;;;AAGE;AACAjtD;AACA;AACN;;AAEEutD;;AAEEP;AACAC;AACE;AAGI;AACD;AACT;;AAEEO;;AAEER;AACAC;AACE;;AAIG;AACT;;AAEEQ;AACEH;AACAN;AACAC;;;AAGEjtD;AACA;AACN;;AAEE0tD;AACEJ;AACAN;AACAC;AACE;AACE;AACA;;;AAGC;;AAED;;AAER;;AAEEU;AACEL;AACAN;;AAEE;AACN;;AAEEY;;AAEEZ;AACAC;;;;;AAOJ;;AAEEY;;AAEEb;AACAC;AACE;AACN;;AAEEa;;AAEEd;AACAC;;AAEFc;AACET;AACAN;AACAC;;AAEFe;AACEV;AACAN;AACAC;;AAEFgB;AACEX;AACAN;AACAC;AACE;AACA;AACA;AACE;AACE;AACE92D;AACZ;AACA;AACU;AACEA;AACZ;AACA;AACU;AACEA;AACZ;;AAEUA;AACV;AACQ;;AAER;;AAEE+3D;AACEZ;AACAN;AACAC;AACE;AACA;AACE;AACR;AACM;AACA;AACE;;AAEE;AACV;AAEQ;;AAEI92D;AACZ;AACA;;AAEYA;AACZ;AACA;;AAEYA;AACZ;AACA;AACUA;AACV;AACQ;;AAER;;AAEEg4D;AACEb;AACAN;AACAC;AACE;AACA;AACA;AACEj/C;AACA;;AAER;AACA;AACM;AACE;AACR;AACM;AACA;AACE;;AAEE;AACV;AAEQ;;AAEI7X;AACZ;AACA;;AAEYA;AACZ;AACA;;AAEYA;AACZ;AACA;AACUA;AACV;AACQ;;AAER;;AAEEi4D;AACEd;AACAN;AACAC;AACE;AACA;AACA;AACEJ;AACR;AACQA;AACR;AACMrrE;AACA;AACA;AACE;;AAEE;AACV;AAEQ;;AAEI2U;AACZ;AACA;;AAEYA;AACZ;AACA;;AAEYA;AACZ;AACA;AACUA;AACV;AACQ;;AAER;;AAEEk4D;;AAEErB;AACAC;;AAEFqB;AACEhB;AACAN;AACAC;;AAEFsB;AACEjB;AACAN;AACAC;;AAEE;;;AAGA;AACE;AACR;;;;AAIUuB;AACV;AACQ;AAIA3+E;;AAEE;AACE23B;AACZ;AACU;;AAEV;AACS;AACT;AACM;AACN;;AAEEinD;AACEnB;AACAN;AACAC;AACE;AACA;AACA;AACA;AACA;;AAEN;AACM;;AAEN;;AAGU;AACA;AACD;AAEC;AACD;AACT;;AAEEyB;AACEpB;AACAN;AACAC;AACE;;AAKG;AACT;;AAEE0B;AACErB;AACAN;AACAC;;AAEE;AACA;;AAEE;AACA;AACR;AACM;AACN;;AAEE2B;AACEtB;AACAN;AACAC;AACE;;AAII;AACD;AACT;;AAEE4B;AACEvB;AACAN;AACAC;;;AAKK;AACT;;AAEE6B;AACExB;AACAN;AACAC;AACE;;AAEA;AACA;;AAII;AACD;AACT;;AAEE8B;AACEzB;AACAN;;;AAGJ;;AAEEgC;AACE1B;AACAN;;;AAGJ;;AAEEiC;;AAEEjC;AACAC;AACE;AACA;;;AAKN;AACM;AACN;;AAEEiC;;AAEElC;AACAC;;AAEFkC;;AAEEnC;AACAC;;AAEFmC;;AAEEpC;AACAC;;AAEFoC;AACE/B;AACAN;AACAC;;AAEJ;;AAEEqC;AACEhC;AACAN;AACAC;AACE;AACA;AAEI;AAKD;AAEC;AACD;AACH;AACN;;AAEEsC;AACEjC;AACAN;;;AAGJ;;AAEEwC;AACElC;AACAN;;;AAGJ;;AAEEyC;AACEnC;AACAN;AACAC;AACE;;;AAGA;AACA;AACE1iF;AACR;;;AAGA;;AAEA;AACQ+7B;AACA;AACE/7B;AACV;AACU;AACV;AACU;AAGV;AACA;;AAEA;;AAEEmlF;AACEpC;AACAN;AACA2C;AACA1C;AACE;AACN;;AAEE2C;;AAEE5C;AACA2C;AACA1C;AACE;AACN;;AAEEvlD;AACE4lD;AACAN;AACAC;AACE;AACN;;AAEE4C;AACEvC;AACAN;AACAC;AACE;AAQA;AACN;;AAEE6C;AACExC;AACAN;AACAC;;;AAKJ;AACQ;AACR;AACA;AACA;AACA;;AAEA;AAAA;AAEC;AACC;AACE;AACArB;AACEhgF;;AAEAmkF;AACAC;;AAEFC;AAEArE;AACA;AACE;;;AAIE;AACA;AACEA;AACV;AACA;AACA;AACA;;;AAIG;AACH;AAEAsE;;;;;;;;;;;;;;AC/sCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;;;;;;;;;;AAUA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;;;;;;;AAOA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;;AAIA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;;AAGA;AACA;AACA;;;;;;;;AAQA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;;;;;;AAQA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524],"debugId":"d8009203-2429-47e6-a0c5-d14b77158759"}