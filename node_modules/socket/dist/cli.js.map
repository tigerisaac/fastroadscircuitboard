{"version":3,"file":"cli.js","sources":["../src/commands/analytics/fetch-org-analytics.mts","../src/commands/analytics/fetch-repo-analytics.mts","../src/commands/analytics/output-analytics.mts","../src/commands/analytics/handle-analytics.mts","../src/commands/analytics/cmd-analytics.mts","../src/commands/audit-log/fetch-audit-log.mts","../src/commands/audit-log/output-audit-log.mts","../src/commands/audit-log/handle-audit-log.mts","../src/commands/audit-log/cmd-audit-log.mts","../src/commands/cdxgen/run-cyclonedx.mts","../src/commands/cdxgen/cmd-cdxgen.mts","../src/commands/ci/fetch-default-org-slug.mts","../src/commands/scan/fetch-create-org-full-scan.mts","../src/commands/scan/fetch-supported-scan-file-names.mts","../src/commands/scan/fetch-report-data.mts","../src/commands/scan/generate-report.mts","../src/commands/scan/output-scan-report.mts","../src/commands/scan/handle-scan-report.mts","../src/commands/scan/output-create-new-scan.mts","../src/commands/scan/handle-create-new-scan.mts","../src/commands/ci/handle-ci.mts","../src/commands/ci/cmd-ci.mts","../src/commands/config/discover-config-value.mts","../src/commands/config/output-config-auto.mts","../src/commands/config/handle-config-auto.mts","../src/commands/config/cmd-config-auto.mts","../src/commands/config/output-config-get.mts","../src/commands/config/handle-config-get.mts","../src/commands/config/cmd-config-get.mts","../src/commands/config/output-config-list.mts","../src/commands/config/cmd-config-list.mts","../src/commands/config/output-config-set.mts","../src/commands/config/handle-config-set.mts","../src/commands/config/cmd-config-set.mts","../src/commands/config/output-config-unset.mts","../src/commands/config/handle-config-unset.mts","../src/commands/config/cmd-config-unset.mts","../src/commands/config/cmd-config.mts","../src/commands/dependencies/fetch-dependencies.mts","../src/commands/dependencies/output-dependencies.mts","../src/commands/dependencies/handle-dependencies.mts","../src/commands/dependencies/cmd-dependencies.mts","../src/commands/diff-scan/fetch-diff-scan.mts","../src/commands/diff-scan/output-diff-scan.mts","../src/commands/diff-scan/handle-diff-scan.mts","../src/commands/diff-scan/cmd-diff-scan-get.mts","../src/commands/diff-scan/cmd-diff-scan.mts","../src/commands/fix/git.mts","../src/commands/fix/open-pr.mts","../src/commands/fix/shared.mts","../src/commands/fix/npm-fix.mts","../src/commands/fix/pnpm-fix.mts","../src/commands/fix/run-fix.mts","../src/commands/fix/cmd-fix.mts","../src/commands/info/fetch-package-info.mts","../src/commands/info/output-package-info.mts","../src/commands/info/handle-package-info.mts","../src/commands/info/cmd-info.mts","../src/commands/login/apply-login.mts","../src/commands/login/attempt-login.mts","../src/commands/login/cmd-login.mts","../src/commands/logout/apply-logout.mts","../src/commands/logout/attempt-logout.mts","../src/commands/logout/cmd-logout.mts","../src/commands/manifest/convert-conda-to-requirements.mts","../src/commands/manifest/output-requirements.mts","../src/commands/manifest/handle-manifest-conda.mts","../src/commands/manifest/cmd-manifest-conda.mts","../src/commands/manifest/convert_gradle_to_maven.mts","../src/commands/manifest/cmd-manifest-gradle.mts","../src/commands/manifest/convert_sbt_to_maven.mts","../src/commands/manifest/cmd-manifest-scala.mts","../src/commands/manifest/cmd-manifest-auto.mts","../src/commands/manifest/cmd-manifest-kotlin.mts","../src/commands/manifest/cmd-manifest.mts","../src/commands/npm/wrap-npm.mts","../src/commands/npm/cmd-npm.mts","../src/commands/npx/wrap-npx.mts","../src/commands/npx/cmd-npx.mts","../src/commands/oops/cmd-oops.mts","../src/commands/optimize/deps-includes-by-agent.mts","../src/commands/optimize/get-dependency-entries.mts","../src/commands/optimize/get-overrides-by-agent.mts","../src/commands/optimize/lockfile-includes-by-agent.mts","../src/commands/optimize/ls-by-agent.mts","../src/commands/optimize/shared.mts","../src/commands/optimize/update-manifest-by-agent.mts","../src/commands/optimize/add-overrides.mts","../src/commands/optimize/update-lockfile.mts","../src/commands/optimize/apply-optimization.mts","../src/commands/optimize/cmd-optimize.mts","../src/commands/organization/fetch-organization-list.mts","../src/commands/organization/output-organization-list.mts","../src/commands/organization/handle-organization-list.mts","../src/commands/organization/cmd-organization-list.mts","../src/commands/organization/fetch-license-policy.mts","../src/commands/organization/output-license-policy.mts","../src/commands/organization/handle-license-policy.mts","../src/commands/organization/cmd-organization-policy-license.mts","../src/commands/organization/fetch-security-policy.mts","../src/commands/organization/output-security-policy.mts","../src/commands/organization/handle-security-policy.mts","../src/commands/organization/cmd-organization-policy-security.mts","../src/commands/organization/cmd-organization-policy.mts","../src/commands/organization/fetch-quota.mts","../src/commands/organization/output-quota.mts","../src/commands/organization/handle-quota.mts","../src/commands/organization/cmd-organization-quota.mts","../src/commands/organization/cmd-organization.mts","../src/commands/package/fetch-purl-deep-score.mts","../src/commands/package/output-purl-score.mts","../src/commands/package/handle-purl-deep-score.mts","../src/commands/package/parse-package-specifiers.mts","../src/commands/package/cmd-package-score.mts","../src/commands/package/fetch-purls-shallow-score.mts","../src/commands/package/output-purls-shallow-score.mts","../src/commands/package/handle-purls-shallow-score.mts","../src/commands/package/cmd-package-shallow.mts","../src/commands/package/cmd-package.mts","../src/commands/raw-npm/run-raw-npm.mts","../src/commands/raw-npm/cmd-raw-npm.mts","../src/commands/raw-npx/run-raw-npx.mts","../src/commands/raw-npx/cmd-raw-npx.mts","../src/commands/report/cmd-report-create.mts","../src/commands/report/cmd-report-view.mts","../src/commands/report/cmd-report.mts","../src/commands/repos/fetch-create-repo.mts","../src/commands/repos/output-create-repo.mts","../src/commands/repos/handle-create-repo.mts","../src/commands/repos/cmd-repos-create.mts","../src/commands/repos/fetch-delete-repo.mts","../src/commands/repos/output-delete-repo.mts","../src/commands/repos/handle-delete-repo.mts","../src/commands/repos/cmd-repos-del.mts","../src/commands/repos/fetch-list-repos.mts","../src/commands/repos/output-list-repos.mts","../src/commands/repos/handle-list-repos.mts","../src/commands/repos/cmd-repos-list.mts","../src/commands/repos/fetch-update-repo.mts","../src/commands/repos/output-update-repo.mts","../src/commands/repos/handle-update-repo.mts","../src/commands/repos/cmd-repos-update.mts","../src/commands/repos/fetch-view-repo.mts","../src/commands/repos/output-view-repo.mts","../src/commands/repos/handle-view-repo.mts","../src/commands/repos/cmd-repos-view.mts","../src/commands/repos/cmd-repos.mts","../src/commands/scan/suggest_target.mts","../src/commands/scan/cmd-scan-create.mts","../src/commands/scan/fetch-delete-org-full-scan.mts","../src/commands/scan/output-delete-scan.mts","../src/commands/scan/handle-delete-scan.mts","../src/commands/scan/cmd-scan-del.mts","../src/commands/scan/fetch-diff-scan.mts","../src/commands/scan/output-diff-scan.mts","../src/commands/scan/handle-diff-scan.mts","../src/commands/scan/cmd-scan-diff.mts","../src/commands/scan/fetch-list-scans.mts","../src/commands/scan/output-list-scans.mts","../src/commands/scan/handle-list-scans.mts","../src/commands/scan/cmd-scan-list.mts","../src/commands/scan/fetch-scan-metadata.mts","../src/commands/scan/output-scan-metadata.mts","../src/commands/scan/handle-scan-metadata.mts","../src/commands/scan/cmd-scan-metadata.mts","../src/commands/scan/cmd-scan-report.mts","../src/commands/scan/fetch-scan.mts","../src/commands/scan/output-scan-view.mts","../src/commands/scan/handle-scan-view.mts","../src/commands/scan/stream-scan.mts","../src/commands/scan/cmd-scan-view.mts","../src/commands/scan/cmd-scan.mts","../src/commands/threat-feed/fetch-threat-feed.mts","../src/commands/threat-feed/output-threat-feed.mts","../src/commands/threat-feed/handle-threat-feed.mts","../src/commands/threat-feed/cmd-threat-feed.mts","../src/commands/wrapper/add-socket-wrapper.mts","../src/commands/wrapper/check-socket-wrapper-setup.mts","../src/commands/wrapper/postinstall-wrapper.mts","../src/commands/wrapper/remove-socket-wrapper.mts","../src/commands/wrapper/cmd-wrapper.mts","../src/cli.mts"],"sourcesContent":["import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchOrgAnalyticsData(\n  time: number\n): Promise<CResult<SocketSdkReturnType<'getOrgAnalytics'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgAnalytics(time.toString()),\n    'analytics data'\n  )\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchRepoAnalyticsData(\n  repo: string,\n  time: number\n): Promise<CResult<SocketSdkReturnType<'getRepoAnalytics'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getRepoAnalytics(repo, time.toString()),\n    'analytics data'\n  )\n}\n","import fs from 'node:fs/promises'\nimport { createRequire } from 'node:module'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mdTableStringNumber } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\nimport type { Widgets } from 'blessed' // Note: Widgets does not seem to actually work as code :'(\nimport type { grid as ContribGrid } from 'blessed-contrib'\n\nconst require = createRequire(import.meta.url)\n\nconst METRICS = [\n  'total_critical_alerts',\n  'total_high_alerts',\n  'total_medium_alerts',\n  'total_low_alerts',\n  'total_critical_added',\n  'total_medium_added',\n  'total_low_added',\n  'total_high_added',\n  'total_critical_prevented',\n  'total_high_prevented',\n  'total_medium_prevented',\n  'total_low_prevented'\n] as const\n\n// Note: This maps `new Date(date).getMonth()` to English three letters\nconst Months = [\n  'Jan',\n  'Feb',\n  'Mar',\n  'Apr',\n  'May',\n  'Jun',\n  'Jul',\n  'Aug',\n  'Sep',\n  'Oct',\n  'Nov',\n  'Dec'\n] as const\n\nexport async function outputAnalytics(\n  result: CResult<\n    | SocketSdkReturnType<'getOrgAnalytics'>['data']\n    | SocketSdkReturnType<'getRepoAnalytics'>['data']\n  >,\n  {\n    filePath,\n    outputKind,\n    repo,\n    scope,\n    time\n  }: {\n    scope: string\n    time: number\n    repo: string\n    outputKind: OutputKind\n    filePath: string\n  }\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(result))\n      return\n    }\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'json') {\n    const serialized = serializeResultJson(result)\n\n    if (filePath) {\n      try {\n        await fs.writeFile(filePath, serialized, 'utf8')\n        logger.error(`Data successfully written to ${filePath}`)\n      } catch (e) {\n        process.exitCode = 1\n        logger.log(\n          serializeResultJson({\n            ok: false,\n            message: 'File Write Failure',\n            cause: 'There was an error trying to write the json to disk'\n          })\n        )\n      }\n    } else {\n      logger.log(serialized)\n    }\n\n    return\n  }\n\n  const fdata =\n    scope === 'org' ? formatDataOrg(result.data) : formatDataRepo(result.data)\n\n  if (outputKind === 'markdown') {\n    const serialized = renderMarkdown(fdata, time, repo)\n\n    // TODO: do we want to write to file even if there was an error...?\n    if (filePath) {\n      try {\n        await fs.writeFile(filePath, serialized, 'utf8')\n        logger.log(`Data successfully written to ${filePath}`)\n      } catch (e) {\n        logger.error(e)\n      }\n    } else {\n      logger.log(serialized)\n    }\n  } else {\n    displayAnalyticsScreen(fdata)\n  }\n}\n\nexport interface FormattedData {\n  top_five_alert_types: Record<string, number>\n  total_critical_alerts: Record<string, number>\n  total_high_alerts: Record<string, number>\n  total_medium_alerts: Record<string, number>\n  total_low_alerts: Record<string, number>\n  total_critical_added: Record<string, number>\n  total_medium_added: Record<string, number>\n  total_low_added: Record<string, number>\n  total_high_added: Record<string, number>\n  total_critical_prevented: Record<string, number>\n  total_high_prevented: Record<string, number>\n  total_medium_prevented: Record<string, number>\n  total_low_prevented: Record<string, number>\n}\n\nexport function renderMarkdown(\n  data: FormattedData,\n  days: number,\n  repoSlug: string\n): string {\n  return (\n    `\n# Socket Alert Analytics\n\nThese are the Socket.dev analytics for the ${repoSlug ? `${repoSlug} repo` : 'org'} of the past ${days} days\n\n${[\n  [\n    'Total critical alerts',\n    mdTableStringNumber('Date', 'Counts', data['total_critical_alerts'])\n  ],\n  [\n    'Total high alerts',\n    mdTableStringNumber('Date', 'Counts', data['total_high_alerts'])\n  ],\n  [\n    'Total critical alerts added to the main branch',\n    mdTableStringNumber('Date', 'Counts', data['total_critical_added'])\n  ],\n  [\n    'Total high alerts added to the main branch',\n    mdTableStringNumber('Date', 'Counts', data['total_high_added'])\n  ],\n  [\n    'Total critical alerts prevented from the main branch',\n    mdTableStringNumber('Date', 'Counts', data['total_critical_prevented'])\n  ],\n  [\n    'Total high alerts prevented from the main branch',\n    mdTableStringNumber('Date', 'Counts', data['total_high_prevented'])\n  ],\n  [\n    'Total medium alerts prevented from the main branch',\n    mdTableStringNumber('Date', 'Counts', data['total_medium_prevented'])\n  ],\n  [\n    'Total low alerts prevented from the main branch',\n    mdTableStringNumber('Date', 'Counts', data['total_low_prevented'])\n  ]\n]\n  .map(([title, table]) =>\n    `\n## ${title}\n\n${table}\n`.trim()\n  )\n  .join('\\n\\n')}\n\n## Top 5 alert types\n\n${mdTableStringNumber('Name', 'Counts', data['top_five_alert_types'])}\n`.trim() + '\\n'\n  )\n}\n\nfunction displayAnalyticsScreen(data: FormattedData): void {\n  const ScreenWidget = require('blessed/lib/widgets/screen.js')\n  // Lazily access constants.blessedOptions.\n  const screen: Widgets.Screen = new ScreenWidget({\n    ...constants.blessedOptions\n  })\n  const GridLayout = require('blessed-contrib/lib/layout/grid.js')\n  const grid = new GridLayout({ rows: 5, cols: 4, screen })\n\n  renderLineCharts(\n    grid,\n    screen,\n    'Total critical alerts',\n    [0, 0, 1, 2],\n    data['total_critical_alerts']\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total high alerts',\n    [0, 2, 1, 2],\n    data['total_high_alerts']\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total critical alerts added to the main branch',\n    [1, 0, 1, 2],\n    data['total_critical_added']\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total high alerts added to the main branch',\n    [1, 2, 1, 2],\n    data['total_high_added']\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total critical alerts prevented from the main branch',\n    [2, 0, 1, 2],\n    data['total_critical_prevented']\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total high alerts prevented from the main branch',\n    [2, 2, 1, 2],\n    data['total_high_prevented']\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total medium alerts prevented from the main branch',\n    [3, 0, 1, 2],\n    data['total_medium_prevented']\n  )\n  renderLineCharts(\n    grid,\n    screen,\n    'Total low alerts prevented from the main branch',\n    [3, 2, 1, 2],\n    data['total_low_prevented']\n  )\n\n  const BarChart = require('blessed-contrib/lib/widget/charts/bar.js')\n  const bar = grid.set(4, 0, 1, 2, BarChart, {\n    label: 'Top 5 alert types',\n    barWidth: 10,\n    barSpacing: 17,\n    xOffset: 0,\n    maxHeight: 9,\n    barBgColor: 'magenta'\n  })\n\n  screen.append(bar) //must append before setting data\n\n  bar.setData({\n    titles: Object.keys(data.top_five_alert_types),\n    data: Object.values(data.top_five_alert_types)\n  })\n\n  screen.render()\n  // eslint-disable-next-line n/no-process-exit\n  screen.key(['escape', 'q', 'C-c'], () => process.exit(0))\n}\n\nexport function formatDataRepo(\n  data: SocketSdkReturnType<'getRepoAnalytics'>['data']\n): FormattedData {\n  const sortedTopFiveAlerts: Record<string, number> = {}\n  const totalTopAlerts: Record<string, number> = {}\n\n  const formattedData = {} as Omit<FormattedData, 'top_five_alert_types'>\n  for (const metric of METRICS) {\n    formattedData[metric] = {}\n  }\n\n  for (const entry of data) {\n    const topFiveAlertTypes = entry['top_five_alert_types']\n    for (const type of Object.keys(topFiveAlertTypes)) {\n      const count = topFiveAlertTypes[type] ?? 0\n      if (!totalTopAlerts[type]) {\n        totalTopAlerts[type] = count\n      } else if (count > (totalTopAlerts[type] ?? 0)) {\n        totalTopAlerts[type] = count\n      }\n    }\n  }\n  for (const entry of data) {\n    for (const metric of METRICS) {\n      formattedData[metric]![formatDate(entry['created_at'])] = entry[metric]\n    }\n  }\n\n  const topFiveAlertEntries = Object.entries(totalTopAlerts)\n    .sort(([_keya, a], [_keyb, b]) => b - a)\n    .slice(0, 5)\n  for (const [key, value] of topFiveAlertEntries) {\n    sortedTopFiveAlerts[key] = value\n  }\n\n  return {\n    ...formattedData,\n    top_five_alert_types: sortedTopFiveAlerts\n  }\n}\n\nexport function formatDataOrg(\n  data: SocketSdkReturnType<'getOrgAnalytics'>['data']\n): FormattedData {\n  const sortedTopFiveAlerts: Record<string, number> = {}\n  const totalTopAlerts: Record<string, number> = {}\n\n  const formattedData = {} as Omit<FormattedData, 'top_five_alert_types'>\n  for (const metric of METRICS) {\n    formattedData[metric] = {}\n  }\n\n  for (const entry of data) {\n    const topFiveAlertTypes = entry['top_five_alert_types']\n    for (const type of Object.keys(topFiveAlertTypes)) {\n      const count = topFiveAlertTypes[type] ?? 0\n      if (!totalTopAlerts[type]) {\n        totalTopAlerts[type] = count\n      } else {\n        totalTopAlerts[type] += count\n      }\n    }\n  }\n\n  for (const metric of METRICS) {\n    const formatted = formattedData[metric]\n    for (const entry of data) {\n      const date = formatDate(entry['created_at'])\n      if (!formatted[date]) {\n        formatted[date] = entry[metric]!\n      } else {\n        formatted[date] += entry[metric]!\n      }\n    }\n  }\n\n  const topFiveAlertEntries = Object.entries(totalTopAlerts)\n    .sort(([_keya, a], [_keyb, b]) => b - a)\n    .slice(0, 5)\n  for (const [key, value] of topFiveAlertEntries) {\n    sortedTopFiveAlerts[key] = value\n  }\n\n  return {\n    ...formattedData,\n    top_five_alert_types: sortedTopFiveAlerts\n  }\n}\n\nfunction formatDate(date: string): string {\n  return `${Months[new Date(date).getMonth()]} ${new Date(date).getDate()}`\n}\n\nfunction renderLineCharts(\n  grid: ContribGrid,\n  screen: Widgets.Screen,\n  title: string,\n  coords: number[],\n  data: Record<string, number>\n): void {\n  const LineChart = require('blessed-contrib/lib/widget/charts/line.js')\n  const line = grid.set(...coords, LineChart, {\n    style: { line: 'cyan', text: 'cyan', baseline: 'black' },\n    xLabelPadding: 0,\n    xPadding: 0,\n    xOffset: 0,\n    wholeNumbersOnly: true,\n    legend: {\n      width: 1\n    },\n    label: title\n  })\n\n  screen.append(line)\n\n  const lineData = {\n    x: Object.keys(data),\n    y: Object.values(data)\n  }\n\n  line.setData([lineData])\n}\n","import { fetchOrgAnalyticsData } from './fetch-org-analytics.mts'\nimport { fetchRepoAnalyticsData } from './fetch-repo-analytics.mts'\nimport { outputAnalytics } from './output-analytics.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function handleAnalytics({\n  filePath,\n  outputKind,\n  repo,\n  scope,\n  time\n}: {\n  scope: string\n  time: number\n  repo: string\n  outputKind: OutputKind\n  filePath: string\n}) {\n  let result: CResult<\n    | SocketSdkReturnType<'getOrgAnalytics'>['data']\n    | SocketSdkReturnType<'getRepoAnalytics'>['data']\n  >\n  if (scope === 'org') {\n    result = await fetchOrgAnalyticsData(time)\n  } else if (repo) {\n    result = await fetchRepoAnalyticsData(repo, time)\n  } else {\n    result = {\n      ok: false,\n      message: 'Missing repository name in command'\n    }\n  }\n  if (result.ok && !result.data.length) {\n    result = {\n      ok: true,\n      message: `The analytics data for this ${scope === 'org' ? 'organization' : 'repository'} is not yet available.`,\n      data: []\n    }\n  }\n\n  await outputAnalytics(result, {\n    filePath,\n    outputKind,\n    repo,\n    scope,\n    time\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleAnalytics } from './handle-analytics.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'analytics',\n  description: `Look up analytics data`,\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    file: {\n      type: 'string',\n      shortFlag: 'f',\n      description:\n        'Filepath to save output. Only valid with --json/--markdown. Defaults to stdout.'\n    },\n    repo: {\n      type: 'string',\n      shortFlag: 'r',\n      default: '',\n      description: 'Name of the repository. Only valid when scope=repo'\n    },\n    scope: {\n      type: 'string',\n      shortFlag: 's',\n      default: 'org',\n      description:\n        \"Scope of the analytics data - either 'org' or 'repo', default: org\"\n    },\n    time: {\n      type: 'number',\n      shortFlag: 't',\n      default: 30,\n      description: 'Time filter - either 7, 30 or 90, default: 30'\n    }\n  },\n  help: (command, { flags }) =>\n    `\n    Usage\n      $ ${command} ${isTestingV1() ? '[ org | repo <reponame>] [time]' : '--scope=<scope> --time=<time filter>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: report:write\n\n    ${isTestingV1() ? '' : 'Default parameters are set to show the organization-level analytics over the'}\n    ${isTestingV1() ? '' : 'last 30 days.'}\n\n    ${isTestingV1() ? 'The scope is either org or repo level, defaults to org.' : ''}\n\n    ${isTestingV1() ? 'When scope is repo, a repo slug must be given as well.' : ''}\n\n    ${isTestingV1() ? 'The time argument must be number 7, 30, or 90 and defaults to 30.' : ''}\n\n    Options\n      ${getFlagListOutput(flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? 'org 7' : '--scope=org --time=7'}\n      $ ${command} ${isTestingV1() ? 'repo test-repo 30' : '--scope=org --time=30'}\n      $ ${command} ${isTestingV1() ? '90' : '--scope=repo --repo=test-repo --time=30'}\n  `\n      // Drop consecutive empty lines. Temporarily necessary to deal with v1 prep.\n      .replace(/\\n(?: *\\n)+/g, '\\n\\n')\n}\n\nexport const cmdAnalytics = {\n  description: config.description,\n  hidden: config.hidden,\n  run: run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { file, json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  // In v1 mode support:\n  // - []        (no args)\n  // - ['org']\n  // - ['org', '30']\n  // - ['repo', 'name']\n  // - ['repo', 'name', '30']\n  // - ['30']\n  // Validate final values in the next step\n  let scope = 'org'\n  let time = isTestingV1() ? '30' : 30\n  let repoName = ''\n  if (isTestingV1()) {\n    if (cli.input[0] === 'org') {\n      if (cli.input[1]) {\n        time = cli.input[1]\n      }\n    } else if (cli.input[0] === 'repo') {\n      scope = 'repo'\n      if (cli.input[1]) {\n        repoName = cli.input[1]\n      }\n      if (cli.input[2]) {\n        time = cli.input[2]\n      }\n    } else if (cli.input[0]) {\n      time = cli.input[0]\n    }\n  } else {\n    if (cli.flags['scope']) {\n      scope = String(cli.flags['scope'] || '')\n    }\n    if (scope === 'repo') {\n      repoName = String(cli.flags['repo'] || '')\n    }\n    if (cli.flags['time']) {\n      time = Number(cli.flags['time'] || 30)\n    }\n  }\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      // In v1 this can't go wrong anymore since the unknown value goes to time\n      nook: !isTestingV1(),\n      test: scope === 'org' || scope === 'repo',\n      message: 'Scope must be \"repo\" or \"org\"',\n      pass: 'ok',\n      fail: 'bad'\n    },\n    {\n      nook: true,\n      // Before v1 there were no args, only flags\n      test: isTestingV1() || cli.input.length === 0,\n      message: 'This command does not accept any arguments (use flags instead)',\n      pass: 'ok',\n      fail: `bad`\n    },\n    {\n      nook: true,\n      test: scope === 'org' || !!repoName,\n      message: isTestingV1()\n        ? 'When scope=repo, repo name should be the second argument'\n        : 'When scope=repo, repo name should be set through --repo',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test:\n        scope === 'org' ||\n        !isTestingV1() ||\n        (repoName !== '7' && repoName !== '30' && repoName !== '90'),\n      message: 'When scope is repo, the second arg should be repo, not time',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      test: isTestingV1()\n        ? time === '7' || time === '30' || time === '90'\n        : time === 7 || time === 30 || time === 90,\n      message: 'The time filter must either be 7, 30 or 90',\n      pass: 'ok',\n      fail: isTestingV1()\n        ? 'invalid range set, see --help for command arg details.'\n        : 'bad'\n    },\n    {\n      nook: true,\n      test: !file || !!json || !!markdown,\n      message:\n        'The `--file` flag is only valid when using `--json` or `--markdown`',\n      pass: 'ok',\n      fail: 'bad'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  return await handleAnalytics({\n    scope,\n    time:\n      time === '90' || time === 90 ? 90 : time === '30' || time === 30 ? 30 : 7,\n    repo: repoName,\n    outputKind,\n    filePath: String(file || '')\n  })\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchAuditLog({\n  logType,\n  orgSlug,\n  outputKind,\n  page,\n  perPage\n}: {\n  outputKind: OutputKind\n  orgSlug: string\n  page: number\n  perPage: number\n  logType: string\n}): Promise<CResult<SocketSdkReturnType<'getAuditLogEvents'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getAuditLogEvents(orgSlug, {\n      // I'm not sure this is used at all.\n      outputJson: String(outputKind === 'json'),\n      // I'm not sure this is used at all.\n      outputMarkdown: String(outputKind === 'markdown'),\n      orgSlug,\n      type: logType,\n      page: String(page),\n      per_page: String(perPage)\n    }),\n    `audit log for ${orgSlug}`\n  )\n}\n","import { debugLog, isDebug } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mdTable } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nconst { REDACTED } = constants\n\nexport async function outputAuditLog(\n  auditLogs: CResult<SocketSdkReturnType<'getAuditLogEvents'>['data']>,\n  {\n    logType,\n    orgSlug,\n    outputKind,\n    page,\n    perPage\n  }: {\n    outputKind: OutputKind\n    orgSlug: string\n    page: number\n    perPage: number\n    logType: string\n  }\n): Promise<void> {\n  if (!auditLogs.ok) {\n    process.exitCode = auditLogs.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(\n      await outputAsJson(auditLogs, {\n        logType,\n        orgSlug,\n        page,\n        perPage\n      })\n    )\n  } else if (outputKind !== 'markdown' && !auditLogs.ok) {\n    logger.fail(failMsgWithBadge(auditLogs.message, auditLogs.cause))\n  } else {\n    logger.log(\n      await outputAsMarkdown(auditLogs, {\n        logType,\n        orgSlug,\n        page,\n        perPage\n      })\n    )\n  }\n}\n\nexport async function outputAsJson(\n  auditLogs: CResult<SocketSdkReturnType<'getAuditLogEvents'>['data']>,\n  {\n    logType,\n    orgSlug,\n    page,\n    perPage\n  }: {\n    orgSlug: string\n    page: number\n    perPage: number\n    logType: string\n  }\n): Promise<string> {\n  if (!auditLogs.ok) {\n    return serializeResultJson(auditLogs)\n  }\n\n  return serializeResultJson({\n    ok: true,\n    data: {\n      desc: 'Audit logs for given query',\n      // Lazily access constants.ENV.VITEST.\n      generated: constants.ENV.VITEST ? REDACTED : new Date().toISOString(),\n      org: orgSlug,\n      logType,\n      page,\n      nextPage: auditLogs.data.nextPage,\n      perPage,\n      logs: auditLogs.data.results.map(log => {\n        // Note: The subset is pretty arbitrary\n        const {\n          created_at,\n          event_id,\n          ip_address,\n          type,\n          user_agent,\n          user_email\n        } = log\n        return {\n          event_id,\n          created_at,\n          ip_address,\n          type,\n          user_agent,\n          user_email\n        }\n      })\n    }\n  })\n}\n\nexport async function outputAsMarkdown(\n  auditLogs: CResult<SocketSdkReturnType<'getAuditLogEvents'>['data']>,\n  {\n    logType,\n    orgSlug,\n    page,\n    perPage\n  }: {\n    orgSlug: string\n    page: number\n    perPage: number\n    logType: string\n  }\n): Promise<string> {\n  if (!auditLogs.ok) {\n    return `\n# Socket Audit Logs\n\nThere was a problem fetching the audit logs:\n\n> ${auditLogs.message}\n${\n  auditLogs.cause\n    ? '>\\n' +\n      (\n        auditLogs.cause\n          .split('\\n')\n          .map(s => `> ${s}\\n`)\n          .join('') ?? ''\n      )\n    : ''\n}\nParameters:\n\n- org: ${orgSlug}\n- type filter: ${logType || '(none)'}\n- page: ${page}\n- per page: ${perPage}\n`\n  }\n\n  try {\n    const table = mdTable<any>(auditLogs.data.results, [\n      'event_id',\n      'created_at',\n      'type',\n      'user_email',\n      'ip_address',\n      'user_agent'\n    ])\n\n    return `\n# Socket Audit Logs\n\nThese are the Socket.dev audit logs as per requested query.\n- org: ${orgSlug}\n- type filter: ${logType || '(none)'}\n- page: ${page}\n- next page: ${auditLogs.data.nextPage}\n- per page: ${perPage}\n- generated: ${constants.ENV.VITEST ? REDACTED : new Date().toISOString()}\n\n${table}\n`\n  } catch (e) {\n    process.exitCode = 1\n    logger.fail(\n      'There was a problem converting the logs to Markdown, please try the `--json` flag'\n    )\n    if (isDebug()) {\n      debugLog('Error:\\n', e)\n    }\n    // logger.error(e)\n    return ''\n  }\n}\n","import { fetchAuditLog } from './fetch-audit-log.mts'\nimport { outputAuditLog } from './output-audit-log.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleAuditLog({\n  logType,\n  orgSlug,\n  outputKind,\n  page,\n  perPage\n}: {\n  outputKind: OutputKind\n  orgSlug: string\n  page: number\n  perPage: number\n  logType: string\n}): Promise<void> {\n  const auditLogs = await fetchAuditLog({\n    orgSlug,\n    outputKind,\n    page,\n    perPage,\n    logType\n  })\n\n  await outputAuditLog(auditLogs, {\n    logType,\n    orgSlug,\n    outputKind,\n    page,\n    perPage\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleAuditLog } from './handle-audit-log.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'audit-log',\n  description: 'Look up the audit log for an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    },\n    type: {\n      type: 'string',\n      shortFlag: 't',\n      default: '',\n      description: 'Type of log event'\n    },\n    perPage: {\n      type: 'number',\n      shortFlag: 'pp',\n      default: 30,\n      description: 'Results per page - default is 30'\n    },\n    page: {\n      type: 'number',\n      shortFlag: 'p',\n      default: 1,\n      description: 'Page number - default is 1'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} ${isTestingV1() ? '<repo>' : '<org slug>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: audit-log:list\n\n    This feature requires an Enterprise Plan. To learn more about getting access\n    to this feature and many more, please visit https://socket.dev/pricing\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? '' : 'FakeOrg'}\n  `\n}\n\nexport const cmdAuditLog = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const {\n    dryRun,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag,\n    page,\n    perPage,\n    type\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n  const logType = String(type || '')\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleAuditLog({\n    orgSlug,\n    outputKind,\n    page: Number(page || 0),\n    perPage: Number(perPage || 0),\n    logType: logType.charAt(0).toUpperCase() + logType.slice(1)\n  })\n}\n","import { existsSync, promises as fs } from 'node:fs'\nimport path from 'node:path'\n\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport shadowBin from '../../shadow/npm/bin.mts'\n\nconst { NPM, NPX, PACKAGE_LOCK_JSON, PNPM, YARN, YARN_LOCK } = constants\n\nconst nodejsPlatformTypes = new Set([\n  'javascript',\n  'js',\n  'nodejs',\n  NPM,\n  PNPM,\n  'ts',\n  'tsx',\n  'typescript'\n])\n\nexport async function runCycloneDX(yargvWithYes: any) {\n  let cleanupPackageLock = false\n  const { yes, ...yargv } = { __proto__: null, ...yargvWithYes } as any\n  const yesArgs = yes ? ['--yes'] : []\n  if (\n    yargv.type !== YARN &&\n    nodejsPlatformTypes.has(yargv.type) &&\n    existsSync(`./${YARN_LOCK}`)\n  ) {\n    if (existsSync(`./${PACKAGE_LOCK_JSON}`)) {\n      yargv.type = NPM\n    } else {\n      // Use synp to create a package-lock.json from the yarn.lock,\n      // based on the node_modules folder, for a more accurate SBOM.\n      try {\n        await shadowBin(NPX, [\n          ...yesArgs,\n          // Lazily access constants.ENV.INLINED_SYNP_VERSION.\n          `synp@${constants.ENV.INLINED_SYNP_VERSION}`,\n          '--source-file',\n          `./${YARN_LOCK}`\n        ])\n        yargv.type = NPM\n        cleanupPackageLock = true\n      } catch {}\n    }\n  }\n  await shadowBin(NPX, [\n    ...yesArgs,\n    // Lazily access constants.ENV.INLINED_CYCLONEDX_CDXGEN_VERSION.\n    `@cyclonedx/cdxgen@${constants.ENV.INLINED_CYCLONEDX_CDXGEN_VERSION}`,\n    ...argvToArray(yargv)\n  ])\n  if (cleanupPackageLock) {\n    try {\n      await fs.rm(`./${PACKAGE_LOCK_JSON}`)\n    } catch {}\n  }\n  const fullOutputPath = path.join(process.cwd(), yargv.output)\n  if (existsSync(fullOutputPath)) {\n    logger.log(colors.cyanBright(`${yargv.output} created!`))\n  }\n}\n\nfunction argvToArray(argv: {\n  [key: string]: boolean | null | number | string | Array<string | number>\n}): string[] {\n  if (argv['help']) {\n    return ['--help']\n  }\n  const result = []\n  for (const { 0: key, 1: value } of Object.entries(argv)) {\n    if (key === '_' || key === '--') {\n      continue\n    }\n    if (key === 'babel' || key === 'install-deps' || key === 'validate') {\n      // cdxgen documents no-babel, no-install-deps, and no-validate flags so\n      // use them when relevant.\n      result.push(`--${value ? key : `no-${key}`}`)\n    } else if (value === true) {\n      result.push(`--${key}`)\n    } else if (typeof value === 'string') {\n      result.push(`--${key}`, String(value))\n    } else if (Array.isArray(value)) {\n      result.push(`--${key}`, ...value.map(String))\n    }\n  }\n  if (argv['--']) {\n    result.push('--', ...(argv as any)['--'])\n  }\n  return result\n}\n","import terminalLink from 'terminal-link'\nimport yargsParse from 'yargs-parser'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { pluralize } from '@socketsecurity/registry/lib/words'\n\nimport { runCycloneDX } from './run-cyclonedx.mts'\nimport constants from '../../constants.mts'\nimport { isHelpFlag } from '../../utils/cmd.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\n// TODO: Convert yargs to meow.\nconst toLower = (arg: string) => arg.toLowerCase()\nconst arrayToLower = (arg: string[]) => arg.map(toLower)\n\n// npx @cyclonedx/cdxgen@11.2.7 --help\n//\n// Options:\n//   -o, --output                 Output file. Default bom.json                                       [default: \"bom.json\"]\n//   -t, --type                   Project type. Please refer to https://cyclonedx.github.io/cdxgen/#/PROJECT_TYPES for supp\n//                                orted languages/platforms.                                                        [array]\n//       --exclude-type           Project types to exclude. Please refer to https://cyclonedx.github.io/cdxgen/#/PROJECT_TY\n//                                PES for supported languages/platforms.\n//   -r, --recurse                Recurse mode suitable for mono-repos. Defaults to true. Pass --no-recurse to disable.\n//                                                                                                [boolean] [default: true]\n//   -p, --print                  Print the SBOM as a table with tree.                                            [boolean]\n//   -c, --resolve-class          Resolve class names for packages. jars only for now.                            [boolean]\n//       --deep                   Perform deep searches for components. Useful while scanning C/C++ apps, live OS and oci i\n//                                mages.                                                                          [boolean]\n//       --server-url             Dependency track url. Eg: https://deptrack.cyclonedx.io\n//       --skip-dt-tls-check      Skip TLS certificate check when calling Dependency-Track.      [boolean] [default: false]\n//       --api-key                Dependency track api key\n//       --project-group          Dependency track project group\n//       --project-name           Dependency track project name. Default use the directory name\n//       --project-version        Dependency track project version                                   [string] [default: \"\"]\n//       --project-id             Dependency track project id. Either provide the id or the project name and version togeth\n//                                er                                                                               [string]\n//       --parent-project-id      Dependency track parent project id                                               [string]\n//       --required-only          Include only the packages with required scope on the SBOM. Would set compositions.aggrega\n//                                te to incomplete unless --no-auto-compositions is passed.                       [boolean]\n//       --fail-on-error          Fail if any dependency extractor fails.                                         [boolean]\n//       --no-babel               Do not use babel to perform usage analysis for JavaScript/TypeScript projects.  [boolean]\n//       --generate-key-and-sign  Generate an RSA public/private key pair and then sign the generated SBOM using JSON Web S\n//                                ignatures.                                                                      [boolean]\n//       --server                 Run cdxgen as a server                                                          [boolean]\n//       --server-host            Listen address                                                     [default: \"127.0.0.1\"]\n//       --server-port            Listen port                                                             [default: \"9090\"]\n//       --install-deps           Install dependencies automatically for some projects. Defaults to true but disabled for c\n//                                ontainers and oci scans. Use --no-install-deps to disable this feature.\n//                                                                                                [boolean] [default: true]\n//       --validate               Validate the generated SBOM using json schema. Defaults to true. Pass --no-validate to di\n//                                sable.                                                          [boolean] [default: true]\n//       --evidence               Generate SBOM with evidence for supported languages.           [boolean] [default: false]\n//       --spec-version           CycloneDX Specification version to use. Defaults to 1.6\n//                                                                         [number] [choices: 1.4, 1.5, 1.6] [default: 1.6]\n//       --filter                 Filter components containing this word in purl or component.properties.value. Multiple va\n//                                lues allowed.                                                                     [array]\n//       --only                   Include components only containing this word in purl. Useful to generate BOM with first p\n//                                arty components alone. Multiple values allowed.                                   [array]\n//       --author                 The person(s) who created the BOM. Set this value if you're intending the modify the BOM\n//                                and claim authorship.                               [array] [default: \"OWASP Foundation\"]\n//       --profile                BOM profile to use for generation. Default generic.\n//   [choices: \"appsec\", \"research\", \"operational\", \"threat-modeling\", \"license-compliance\", \"generic\", \"machine-learning\",\n//                                                        \"ml\", \"deep-learning\", \"ml-deep\", \"ml-tiny\"] [default: \"generic\"]\n//       --exclude                Additional glob pattern(s) to ignore                                              [array]\n//       --include-formulation    Generate formulation section with git metadata and build tools. Defaults to false.\n//                                                                                               [boolean] [default: false]\n//       --include-crypto         Include crypto libraries as components.                        [boolean] [default: false]\n//       --standard               The list of standards which may consist of regulations, industry or organizational-specif\n//                                ic standards, maturity models, best practices, or any other requirements which can be eva\n//                                luated against or attested to.\n//   [array] [choices: \"asvs-5.0\", \"asvs-4.0.3\", \"bsimm-v13\", \"masvs-2.0.0\", \"nist_ssdf-1.1\", \"pcissc-secure-slc-1.1\", \"scv\n//                                                                                          s-1.0.0\", \"ssaf-DRAFT-2023-11\"]\n//       --json-pretty            Pretty-print the generated BOM json.                           [boolean] [default: false]\n//       --min-confidence         Minimum confidence needed for the identity of a component from 0 - 1, where 1 is 100% con\n//                                fidence.                                                            [number] [default: 0]\n//       --technique              Analysis technique to use\n//   [array] [choices: \"auto\", \"source-code-analysis\", \"binary-analysis\", \"manifest-analysis\", \"hash-comparison\", \"instrume\n//                                                                                                    ntation\", \"filename\"]\n//       --auto-compositions      Automatically set compositions when the BOM was filtered. Defaults to true\n//                                                                                                [boolean] [default: true]\n//   -h, --help                   Show help                                                                       [boolean]\n//   -v, --version                Show version number                                                             [boolean]\n\n// isSecureMode defined at:\n// https://github.com/CycloneDX/cdxgen/blob/v11.2.7/lib/helpers/utils.js#L66\n// const isSecureMode =\n//   ['true', '1'].includes(process.env?.CDXGEN_SECURE_MODE) ||\n//   process.env?.NODE_OPTIONS?.includes('--permission')\n\n// Yargs CDXGEN configuration defined at:\n// https://github.com/CycloneDX/cdxgen/blob/v11.2.7/bin/cdxgen.js#L64\nconst yargsConfig = {\n  configuration: {\n    'camel-case-expansion': false,\n    'greedy-arrays': false,\n    'parse-numbers': false,\n    'populate--': true,\n    'short-option-groups': false,\n    'strip-aliased': true,\n    'unknown-options-as-args': true\n  },\n  coerce: {\n    'exclude-type': arrayToLower,\n    'feature-flags': arrayToLower,\n    filter: arrayToLower,\n    only: arrayToLower,\n    profile: toLower,\n    standard: arrayToLower,\n    technique: arrayToLower,\n    type: arrayToLower\n  },\n  default: {\n    //author: ['OWASP Foundation'],\n    //'auto-compositions': true,\n    //babel: true,\n    //banner: false, // hidden\n    //'deps-slices-file': 'deps.slices.json', // hidden\n    //evidence: false,\n    //'exclude-type': [],\n    //'export-proto': true, // hidden\n    //'fail-on-error': isSecureMode,\n    //'feature-flags': [], // hidden\n    //'include-crypto': false,\n    //'include-formulation': false,\n    //'install-deps': !isSecureMode\n    //lifecycle: 'build', // hidden\n    //'min-confidence': '0',\n    //output: 'bom.json',\n    //profile: 'generic',\n    //'project-version': '',\n    //'proto-bin-file': 'bom.cdx', // hidden\n    //recurse: true,\n    //'skip-dt-tls-check': false,\n    //'semantics-slices-file': 'semantics.slices.json',\n    //'server-host': '127.0.0.1',\n    //'server-port': '9090',\n    //'spec-version': '1.6',\n    type: ['js']\n    //validate: true,\n  },\n  alias: {\n    help: ['h'],\n    output: ['o'],\n    print: ['p'],\n    recurse: ['r'],\n    'resolve-class': ['c'],\n    type: ['t'],\n    version: ['v'],\n    yes: ['y']\n  },\n  array: [\n    { key: 'author', type: 'string' },\n    { key: 'exclude', type: 'string' },\n    { key: 'exclude-type', type: 'string' },\n    { key: 'feature-flags', type: 'string' }, // hidden\n    { key: 'filter', type: 'string' },\n    { key: 'only', type: 'string' },\n    { key: 'standard', type: 'string' },\n    { key: 'technique', type: 'string' },\n    { key: 'type', type: 'string' }\n  ],\n  boolean: [\n    'auto-compositions',\n    'babel',\n    'banner', // hidden\n    'deep',\n    'evidence',\n    'export-proto', // hidden\n    'fail-on-error',\n    'generate-key-and-sign',\n    'help',\n    'include-crypto',\n    'include-formulation',\n    'install-deps',\n    'json-pretty',\n    'print',\n    'recurse',\n    'required-only',\n    'resolve-class',\n    'skip-dt-tls-check',\n    'server',\n    'validate',\n    'version',\n    // The --yes flag and -y alias map to the corresponding flag and alias of npx.\n    // https://docs.npmjs.com/cli/v7/commands/npx#compatibility-with-older-npx-versions\n    'yes'\n  ],\n  string: [\n    'api-key',\n    'data-flow-slices-file', // hidden\n    'deps-slices-file', // hidden\n    'evinse-output', // hidden\n    'lifecycle',\n    'min-confidence', // number\n    'openapi-spec-file', // hidden\n    'output',\n    'parent-project-id',\n    'profile',\n    'project-group',\n    'project-name',\n    'project-version',\n    'project-id',\n    'proto-bin-file', // hidden\n    'reachables-slices-file', // hidden\n    'semantics-slices-file', // hidden\n    'server-host',\n    'server-port',\n    'server-url',\n    'spec-version', // number\n    'usages-slices-file' // hidden\n  ]\n}\n\nconst config: CliCommandConfig = {\n  commandName: 'cdxgen',\n  description: 'Create an SBOM with CycloneDX generator (cdxgen)',\n  hidden: false,\n  // Stub out flags and help.\n  // TODO: Convert yargs to meow.\n  flags: {},\n  help: () => ''\n}\n\nexport const cmdCdxgen = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    allowUnknownFlags: true,\n    // Don't let meow take over --help.\n    argv: argv.filter(a => !isHelpFlag(a)),\n    config,\n    importMeta,\n    parentName\n  })\n\n  // TODO: Convert yargs to meow.\n  const yargv = {\n    ...yargsParse(argv as string[], yargsConfig)\n  } as any\n\n  const unknown: string[] = yargv._\n  const { length: unknownLength } = unknown\n  if (unknownLength) {\n    // Use exit status of 2 to indicate incorrect usage, generally invalid\n    // options or missing arguments.\n    // https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html\n    process.exitCode = 2\n    logger.fail(\n      `Unknown ${pluralize('argument', unknownLength)}: ${yargv._.join(', ')}`\n    )\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  // Make 'lifecycle' default to 'pre-build', which also sets 'install-deps' to `false`,\n  // to avoid arbitrary code execution on the cdxgen scan.\n  // https://github.com/CycloneDX/cdxgen/issues/1328\n  if (yargv.lifecycle === undefined) {\n    yargv.lifecycle = 'pre-build'\n    yargv['install-deps'] = false\n    logger.info(\n      `Socket set cdxgen --lifecycle to \"${yargv.lifecycle}\" to avoid arbitrary code execution on this scan.\\n  Pass \"--lifecycle build\" to generate a BOM consisting of information obtained during the build process.\\n  See cdxgen ${terminalLink(\n        'BOM lifecycles documentation',\n        'https://cyclonedx.github.io/cdxgen/#/ADVANCED?id=bom-lifecycles'\n      )} for more details.`\n    )\n  }\n\n  if (yargv.output === undefined) {\n    yargv.output = 'socket-cdx.json'\n  }\n\n  await runCycloneDX(yargv)\n}\n","import { debugLog } from '@socketsecurity/registry/lib/debug'\n\nimport { handleApiCall } from '../../utils/api.mts'\nimport { getConfigValueOrUndef } from '../../utils/config.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\n\n// Use the config defaultOrg when set, otherwise discover from remote\nexport async function getDefaultOrgSlug(): Promise<CResult<string>> {\n  const defaultOrgResult = getConfigValueOrUndef('defaultOrg')\n\n  if (defaultOrgResult) {\n    debugLog(`Using default org: ${defaultOrgResult}`)\n    return { ok: true, data: defaultOrgResult }\n  }\n\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  const result = await handleApiCall(\n    sockSdk.getOrganizations(),\n    'list of organizations'\n  )\n\n  if (!result.ok) {\n    return result\n  }\n\n  const orgs = result.data.organizations\n  const keys = Object.keys(orgs)\n\n  if (!keys[0]) {\n    return {\n      ok: false,\n      message: 'Failed to establish identity',\n      data: `API did not return any organization associated with the current API token. Unable to continue.`\n    }\n  }\n\n  const slug = (keys[0] in orgs && orgs?.[keys[0]]?.name) ?? undefined\n\n  if (!slug) {\n    return {\n      ok: false,\n      message: 'Failed to establish identity',\n      data: `Was unable to determine the default organization for the current API token. Unable to continue.`\n    }\n  }\n\n  debugLog(`Resolved org to: ${slug}`)\n  return {\n    ok: true,\n    message: 'Retrieved default org from server',\n    data: slug\n  }\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchCreateOrgFullScan(\n  packagePaths: string[],\n  orgSlug: string,\n  defaultBranch: boolean,\n  pendingHead: boolean,\n  tmp: boolean,\n  cwd: string,\n  {\n    branchName,\n    commitHash,\n    commitMessage,\n    committers,\n    pullRequest,\n    repoName\n  }: {\n    branchName: string\n    commitHash: string\n    commitMessage: string\n    committers: string\n    pullRequest: number\n    repoName: string\n  }\n): Promise<CResult<SocketSdkReturnType<'CreateOrgFullScan'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.createOrgFullScan(\n      orgSlug,\n      {\n        ...(branchName ? { branch: branchName } : {}),\n        ...(commitHash ? { commit_hash: commitHash } : {}),\n        ...(commitMessage ? { commit_message: commitMessage } : {}),\n        ...(committers ? { committers } : {}),\n        make_default_branch: String(defaultBranch),\n        ...(pullRequest ? { pull_request: String(pullRequest) } : {}),\n        repo: repoName || 'socket-default-repository', // mandatory, this is server default for repo\n        set_as_pending_head: String(pendingHead),\n        tmp: String(tmp)\n      },\n      packagePaths,\n      cwd\n    ),\n    'to create a scan'\n  )\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchSupportedScanFileNames(): Promise<\n  CResult<SocketSdkReturnType<'getReportSupportedFiles'>['data']>\n> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getReportSupportedFiles(),\n    'supported scan file types'\n  )\n}\n","import { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { handleApiCallNoSpinner, queryApiSafeText } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\nimport type { components } from '@socketsecurity/sdk/types/api'\n\n/**\n * This fetches all the relevant pieces of data to generate a report, given a\n * full scan ID.\n */\nexport async function fetchReportData(\n  orgSlug: string,\n  scanId: string,\n  includeLicensePolicy: boolean\n): Promise<\n  CResult<{\n    scan: Array<components['schemas']['SocketArtifact']>\n    securityPolicy: SocketSdkReturnType<'getOrgSecurityPolicy'>['data']\n  }>\n> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  let scanStatus = 'requested..'\n  let policyStatus = 'requested..'\n  let finishedFetching = false\n\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n\n  function updateScan(desc: string) {\n    scanStatus = desc\n    updateProgress()\n  }\n\n  function updatePolicy(desc: string) {\n    policyStatus = desc\n    updateProgress()\n  }\n\n  function updateProgress() {\n    if (finishedFetching) {\n      spinner.stop()\n      logger.error(\n        `Scan result: ${scanStatus}. Security policy: ${policyStatus}.`\n      )\n    } else {\n      spinner.start(\n        `Scan result: ${scanStatus}. Security policy: ${policyStatus}.`\n      )\n    }\n  }\n\n  async function fetchScanResult(): Promise<\n    CResult<Array<components['schemas']['SocketArtifact']>>\n  > {\n    const result = await queryApiSafeText(\n      `orgs/${orgSlug}/full-scans/${encodeURIComponent(scanId)}${includeLicensePolicy ? '?include_license_details=true' : ''}`\n    )\n\n    updateScan(`response received`)\n\n    if (!result.ok) {\n      return result\n    }\n\n    const jsonsString = result.data\n\n    // This is nd-json; each line is a json object\n    const lines = jsonsString.split('\\n').filter(Boolean)\n    let ok = true\n    const data = lines.map(line => {\n      try {\n        return JSON.parse(line)\n      } catch {\n        ok = false\n        debugLog('ndjson failed to parse the following line:')\n        debugLog(line)\n        return\n      }\n    }) as unknown as Array<components['schemas']['SocketArtifact']>\n\n    if (ok) {\n      updateScan(`success`)\n      return { ok: true, data }\n    }\n\n    updateScan(`received invalid JSON response`)\n\n    return {\n      ok: false,\n      message: 'Invalid API response',\n      cause:\n        'The API responded with at least one line that was not valid JSON. Please report if this persists.'\n    }\n  }\n\n  async function fetchSecurityPolicy(): Promise<\n    CResult<SocketSdkReturnType<'getOrgSecurityPolicy'>['data']>\n  > {\n    const result = await handleApiCallNoSpinner(\n      sockSdk.getOrgSecurityPolicy(orgSlug),\n      'GetOrgSecurityPolicy'\n    )\n\n    updatePolicy('received policy')\n\n    return result\n  }\n\n  updateProgress()\n\n  const [scan, securityPolicy]: [\n    CResult<Array<components['schemas']['SocketArtifact']>>,\n    CResult<SocketSdkReturnType<'getOrgSecurityPolicy'>['data']>\n  ] = await Promise.all([\n    fetchScanResult().catch(e => {\n      updateScan(`failure; unknown blocking problem occurred`)\n      return {\n        ok: false as const,\n        message: 'Unexpected API problem',\n        cause: `We encountered an unexpected problem while requesting the Scan from the API: ${e?.message || '(no error message found)'}${e?.cause ? ` (cause: ${e.cause})` : ''}`\n      }\n    }),\n    fetchSecurityPolicy().catch(e => {\n      updatePolicy(`failure; unknown blocking problem occurred`)\n      return {\n        ok: false as const,\n        message: 'Unexpected API problem',\n        cause: `We encountered an unexpected problem while requesting the policy from the API: ${e?.message || '(no error message found)'}${e?.cause ? ` (cause: ${e.cause})` : ''}`\n      }\n    })\n  ]).finally(() => {\n    finishedFetching = true\n    updateProgress()\n  })\n\n  if (!scan.ok) {\n    return scan\n  }\n  if (!securityPolicy.ok) {\n    return securityPolicy\n  }\n\n  if (!Array.isArray(scan.data)) {\n    return {\n      ok: false,\n      message: 'Failed to fetch',\n      cause: 'Was unable to fetch scan result, bailing'\n    }\n  }\n\n  return {\n    ok: true,\n    data: {\n      scan: scan.data satisfies Array<components['schemas']['SocketArtifact']>,\n      securityPolicy: securityPolicy.data\n    }\n  }\n}\n","import { getSocketDevPackageOverviewUrlFromPurl } from '../../utils/socket-url.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { Spinner } from '@socketsecurity/registry/lib/spinner'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\nimport type { components } from '@socketsecurity/sdk/types/api'\n\ntype AlertAction = 'defer' | 'ignore' | 'monitor' | 'error' | 'warn'\ntype AlertKey = string\n\ntype FileMap = Map<string, ReportLeafNode | Map<AlertKey, ReportLeafNode>>\ntype VersionMap = Map<string, ReportLeafNode | FileMap>\ntype PackageMap = Map<string, ReportLeafNode | VersionMap>\ntype EcoMap = Map<string, ReportLeafNode | PackageMap>\nexport type ViolationsMap = Map<string, EcoMap>\n\nexport interface ShortScanReport {\n  healthy: boolean\n}\nexport interface ScanReport {\n  orgSlug: string\n  scanId: string\n  options: { fold: string; reportLevel: string }\n  healthy: boolean\n  alerts: ViolationsMap\n}\n\nexport type ReportLeafNode = {\n  type: string\n  policy: 'defer' | 'ignore' | 'monitor' | 'warn' | 'error'\n  url: string\n  manifest: string[]\n}\n\n// Note: The returned cresult will only be ok:false when the generation\n//       failed. It won't reflect the healthy state.\nexport function generateReport(\n  scan: Array<components['schemas']['SocketArtifact']>,\n  securityPolicy: SocketSdkReturnType<'getOrgSecurityPolicy'>['data'],\n  {\n    fold,\n    orgSlug,\n    reportLevel,\n    scanId,\n    short,\n    spinner\n  }: {\n    fold: 'pkg' | 'version' | 'file' | 'none'\n    orgSlug: string\n    reportLevel: 'defer' | 'ignore' | 'monitor' | 'warn' | 'error'\n    scanId: string\n    short?: boolean | undefined\n    spinner?: Spinner | undefined\n  }\n): CResult<ScanReport | { healthy: boolean }> {\n  const now = Date.now()\n\n  spinner?.start('Generating report...')\n\n  // Create an object that includes:\n  //   healthy: boolean\n  //   worst violation level;\n  //   per eco\n  //     per package\n  //       per version\n  //         per offending file\n  //           reported issue -> policy action\n\n  // In the context of a report;\n  // - the alert.severity is irrelevant\n  // - the securityPolicyDefault is irrelevant\n  // - the report defaults to healthy:true with no alerts\n  // - the appearance of an alert will trigger the policy action;\n  //   - error: healthy will end up as false, add alerts to report\n  //   - warn: healthy unchanged, add alerts to report\n  //   - monitor/ignore: no action\n  //   - defer: unknown (no action)\n\n  // Note: the server will emit alerts for license policy violations but\n  //       those are only included if you set the flag when requesting the scan\n  //       data. The alerts map to a single security policy key that determines\n  //       what to do with any violation, regardless of the concrete license.\n  //       That rule is called \"License Policy Violation\".\n  // The license policy part is implicitly handled here. Either they are\n  // included and may show up, or they are not and won't show up.\n\n  const violations = new Map()\n\n  let healthy = true\n\n  const securityRules = securityPolicy.securityPolicyRules\n  if (securityRules) {\n    // Note: reportLevel: error > warn > monitor > ignore > defer\n    scan.forEach(artifact => {\n      const {\n        alerts,\n        name: pkgName = '<unknown>',\n        type: ecosystem,\n        version = '<unknown>'\n      } = artifact\n\n      alerts?.forEach(\n        (\n          alert: NonNullable<\n            components['schemas']['SocketArtifact']['alerts']\n          >[number]\n        ) => {\n          const alertName = alert.type as keyof typeof securityRules // => policy[type]\n          const action = securityRules[alertName]?.action || ''\n          switch (action) {\n            case 'error': {\n              healthy = false\n              if (!short) {\n                addAlert(\n                  artifact,\n                  violations,\n                  fold,\n                  ecosystem,\n                  pkgName,\n                  version,\n                  alert,\n                  action\n                )\n              }\n              break\n            }\n            case 'warn': {\n              if (!short && reportLevel !== 'error') {\n                addAlert(\n                  artifact,\n                  violations,\n                  fold,\n                  ecosystem,\n                  pkgName,\n                  version,\n                  alert,\n                  action\n                )\n              }\n              break\n            }\n            case 'monitor': {\n              if (!short && reportLevel !== 'warn' && reportLevel !== 'error') {\n                addAlert(\n                  artifact,\n                  violations,\n                  fold,\n                  ecosystem,\n                  pkgName,\n                  version,\n                  alert,\n                  action\n                )\n              }\n              break\n            }\n\n            case 'ignore': {\n              if (\n                !short &&\n                reportLevel !== 'warn' &&\n                reportLevel !== 'error' &&\n                reportLevel !== 'monitor'\n              ) {\n                addAlert(\n                  artifact,\n                  violations,\n                  fold,\n                  ecosystem,\n                  pkgName,\n                  version,\n                  alert,\n                  action\n                )\n              }\n              break\n            }\n\n            case 'defer': {\n              // Not sure but ignore for now. Defer to later ;)\n              if (!short && reportLevel === 'defer') {\n                addAlert(\n                  artifact,\n                  violations,\n                  fold,\n                  ecosystem,\n                  pkgName,\n                  version,\n                  alert,\n                  action\n                )\n              }\n              break\n            }\n\n            default: {\n              // This value was not emitted from the api at the time of writing.\n            }\n          }\n        }\n      )\n    })\n  }\n\n  spinner?.successAndStop(`Generated reported in ${Date.now() - now} ms`)\n\n  if (short) {\n    return {\n      ok: true,\n      data: { healthy }\n    }\n  }\n\n  const report = {\n    healthy,\n    orgSlug,\n    scanId,\n    options: { fold, reportLevel },\n    alerts: violations\n  }\n\n  if (!healthy) {\n    return {\n      ok: true,\n      message:\n        'The report contains at least one alert that violates the policies set by your organization',\n      data: report\n    }\n  }\n\n  return {\n    ok: true,\n    data: report\n  }\n}\n\nfunction createLeaf(\n  art: components['schemas']['SocketArtifact'],\n  alert: NonNullable<components['schemas']['SocketArtifact']['alerts']>[number],\n  policyAction: AlertAction\n): ReportLeafNode {\n  const leaf: ReportLeafNode = {\n    type: alert.type,\n    policy: policyAction,\n    url: getSocketDevPackageOverviewUrlFromPurl(art),\n    manifest: art.manifestFiles?.map(obj => obj.file) ?? []\n  }\n  return leaf\n}\n\nfunction addAlert(\n  art: components['schemas']['SocketArtifact'],\n  violations: ViolationsMap,\n  foldSetting: 'pkg' | 'version' | 'file' | 'none',\n  ecosystem: string,\n  pkgName: string,\n  version: string,\n  alert: NonNullable<components['schemas']['SocketArtifact']['alerts']>[number],\n  policyAction: AlertAction\n): void {\n  if (!violations.has(ecosystem)) {\n    violations.set(ecosystem, new Map())\n  }\n  const ecomap: EcoMap = violations.get(ecosystem)!\n  if (foldSetting === 'pkg') {\n    const existing = ecomap.get(pkgName) as ReportLeafNode | undefined\n    if (!existing || isStricterPolicy(existing.policy, policyAction)) {\n      ecomap.set(pkgName, createLeaf(art, alert, policyAction))\n    }\n  } else {\n    if (!ecomap.has(pkgName)) {\n      ecomap.set(pkgName, new Map())\n    }\n    const pkgmap = ecomap.get(pkgName) as PackageMap\n    if (foldSetting === 'version') {\n      const existing = pkgmap.get(version) as ReportLeafNode | undefined\n      if (!existing || isStricterPolicy(existing.policy, policyAction)) {\n        pkgmap.set(version, createLeaf(art, alert, policyAction))\n      }\n    } else {\n      if (!pkgmap.has(version)) {\n        pkgmap.set(version, new Map())\n      }\n      const file = alert.file || '<unknown>'\n      const vermap = pkgmap.get(version) as VersionMap\n\n      if (foldSetting === 'file') {\n        const existing = vermap.get(file) as ReportLeafNode | undefined\n        if (!existing || isStricterPolicy(existing.policy, policyAction)) {\n          vermap.set(file, createLeaf(art, alert, policyAction))\n        }\n      } else {\n        if (!vermap.has(file)) {\n          vermap.set(file, new Map())\n        }\n        const key = `${alert.type} at ${alert.start}:${alert.end}`\n        const filemap: FileMap = vermap.get(file) as FileMap\n        const existing = filemap.get(key) as ReportLeafNode | undefined\n        if (!existing || isStricterPolicy(existing.policy, policyAction)) {\n          filemap.set(key, createLeaf(art, alert, policyAction))\n        }\n      }\n    }\n  }\n}\n\nfunction isStricterPolicy(\n  was: 'error' | 'warn' | 'monitor' | 'ignore' | 'defer',\n  is: 'error' | 'warn' | 'monitor' | 'ignore' | 'defer'\n): boolean {\n  // error > warn > monitor > ignore > defer > {unknown}\n  if (was === 'error') {\n    return false\n  }\n  if (is === 'error') {\n    return true\n  }\n  if (was === 'warn') {\n    return false\n  }\n  if (is === 'warn') {\n    return false\n  }\n  if (was === 'monitor') {\n    return false\n  }\n  if (is === 'monitor') {\n    return false\n  }\n  if (was === 'ignore') {\n    return false\n  }\n  if (is === 'ignore') {\n    return false\n  }\n  if (was === 'defer') {\n    return false\n  }\n  if (is === 'defer') {\n    return false\n  }\n  // unreachable?\n  return false\n}\n","import fs from 'node:fs/promises'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { generateReport } from './generate-report.mts'\nimport constants from '../../constants.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mapToObject } from '../../utils/map-to-object.mts'\nimport { mdTable } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\nimport { walkNestedMap } from '../../utils/walk-nested-map.mts'\n\nimport type { ReportLeafNode, ScanReport } from './generate-report.mts'\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\nimport type { components } from '@socketsecurity/sdk/types/api'\n\nexport async function outputScanReport(\n  result: CResult<{\n    scan: Array<components['schemas']['SocketArtifact']>\n    securityPolicy: SocketSdkReturnType<'getOrgSecurityPolicy'>['data']\n  }>,\n  {\n    filePath,\n    fold,\n    includeLicensePolicy,\n    orgSlug,\n    outputKind,\n    reportLevel,\n    scanId,\n    short\n  }: {\n    orgSlug: string\n    scanId: string\n    includeLicensePolicy: boolean\n    outputKind: OutputKind\n    filePath: string\n    fold: 'pkg' | 'version' | 'file' | 'none'\n    reportLevel: 'defer' | 'ignore' | 'monitor' | 'warn' | 'error'\n    short: boolean\n  }\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(result))\n      return\n    }\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const scanReport = generateReport(\n    result.data.scan,\n    result.data.securityPolicy,\n    {\n      orgSlug,\n      scanId,\n      fold,\n      reportLevel,\n      short,\n      // Lazily access constants.spinner.\n      spinner: constants.spinner\n    }\n  )\n\n  if (!scanReport.ok) {\n    // Note: this means generation failed, it does not reflect the healthy state\n    process.exitCode = scanReport.code ?? 1\n\n    // If report generation somehow failed then .data should not be set.\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(scanReport))\n      return\n    }\n    logger.fail(failMsgWithBadge(scanReport.message, scanReport.cause))\n    return\n  }\n\n  // I don't think we emit the default error message with banner for an unhealhty report, do we?\n  // if (!scanReport.data.healhty) {\n  //   logger.fail(failMsgWithBadge(scanReport.message, scanReport.cause))\n  //   return\n  // }\n\n  if (\n    outputKind === 'json' ||\n    (outputKind === 'text' && filePath && filePath.endsWith('.json'))\n  ) {\n    const json = short\n      ? serializeResultJson(scanReport)\n      : toJsonReport(scanReport.data as ScanReport, includeLicensePolicy)\n\n    if (filePath && filePath !== '-') {\n      logger.log('Writing json report to', filePath)\n      return await fs.writeFile(filePath, json)\n    }\n\n    logger.log(json)\n    return\n  }\n\n  if (outputKind === 'markdown' || (filePath && filePath.endsWith('.md'))) {\n    const md = short\n      ? `healthy = ${scanReport.data.healthy}`\n      : toMarkdownReport(\n          scanReport.data as ScanReport, // not short so must be regular report\n          includeLicensePolicy\n        )\n\n    if (filePath && filePath !== '-') {\n      logger.log('Writing markdown report to', filePath)\n      return await fs.writeFile(filePath, md)\n    }\n\n    logger.log(md)\n    logger.log('')\n    return\n  }\n\n  if (short) {\n    logger.log(scanReport.data.healthy ? 'OK' : 'ERR')\n  } else {\n    logger.dir(scanReport.data, { depth: null })\n  }\n}\n\nexport function toJsonReport(\n  report: ScanReport,\n  includeLicensePolicy?: boolean | undefined\n): string {\n  const obj = mapToObject(report.alerts)\n\n  const newReport = {\n    includeLicensePolicy,\n    ...report,\n    alerts: obj\n  }\n\n  return serializeResultJson({\n    ok: true,\n    data: newReport\n  })\n}\n\nexport function toMarkdownReport(\n  report: ScanReport,\n  includeLicensePolicy?: boolean | undefined\n): string {\n  const flatData = Array.from(walkNestedMap(report.alerts)).map(\n    ({ keys, value }: { keys: string[]; value: ReportLeafNode }) => {\n      const { manifest, policy, type, url } = value\n      return {\n        'Alert Type': type,\n        Package: keys[1] || '<unknown>',\n        'Introduced by': keys[2] || '<unknown>',\n        url,\n        'Manifest file': manifest.join(', '),\n        Policy: policy\n      }\n    }\n  )\n\n  const md =\n    `\n# Scan Policy Report\n\nThis report tells you whether the results of a Socket scan results violate the\nsecurity${includeLicensePolicy ? ' or license' : ''} policy set by your organization.\n\n## Health status\n\n${\n  report.healthy\n    ? `The scan *PASSES* all requirements set by your security${includeLicensePolicy ? ' and license' : ''} policy.`\n    : 'The scan *VIOLATES* one or more policies set to the \"error\" level.'\n}\n\n## Settings\n\nConfiguration used to generate this report:\n\n- Organization: ${report.orgSlug}\n- Scan ID: ${report.scanId}\n- Alert folding: ${report.options.fold === 'none' ? 'none' : `up to ${report.options.fold}`}\n- Minimal policy level for alert to be included in report: ${report.options.reportLevel === 'defer' ? 'everything' : report.options.reportLevel}\n- Include license alerts: ${includeLicensePolicy ? 'yes' : 'no'}\n\n## Alerts\n\n${\n  report.alerts.size\n    ? `All the alerts from the scan with a policy set to at least \"${report.options.reportLevel}\".`\n    : `The scan contained no alerts with a policy set to at least \"${report.options.reportLevel}\".`\n}\n\n${\n  !report.alerts.size\n    ? ''\n    : mdTable(flatData, [\n        'Policy',\n        'Alert Type',\n        'Package',\n        'Introduced by',\n        'url',\n        'Manifest file'\n      ])\n}\n  `.trim() + '\\n'\n\n  return md\n}\n","import { fetchReportData } from './fetch-report-data.mts'\nimport { outputScanReport } from './output-scan-report.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleScanReport({\n  filePath,\n  fold,\n  includeLicensePolicy,\n  orgSlug,\n  outputKind,\n  reportLevel,\n  scanId,\n  short\n}: {\n  orgSlug: string\n  scanId: string\n  includeLicensePolicy: boolean\n  outputKind: OutputKind\n  filePath: string\n  fold: 'pkg' | 'version' | 'file' | 'none'\n  reportLevel: 'defer' | 'ignore' | 'monitor' | 'warn' | 'error'\n  short: boolean\n}): Promise<void> {\n  const result = await fetchReportData(orgSlug, scanId, includeLicensePolicy)\n\n  await outputScanReport(result, {\n    filePath,\n    fold,\n    scanId: scanId,\n    includeLicensePolicy,\n    orgSlug,\n    outputKind,\n    reportLevel,\n    short\n  })\n}\n","import open from 'open'\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { confirm } from '@socketsecurity/registry/lib/prompts'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputCreateNewScan(\n  result: CResult<SocketSdkReturnType<'CreateOrgFullScan'>['data']>,\n  outputKind: OutputKind,\n  interactive: boolean\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (!result.data.id) {\n    logger.fail('Did not receive a scan ID from the API...')\n    process.exitCode = 1\n  }\n\n  if (outputKind === 'markdown') {\n    logger.log('# Create New Scan')\n    logger.log('')\n    if (result.data.id) {\n      logger.log(\n        `A [new Scan](${result.data.html_report_url}) was created with ID: ${result.data.id}`\n      )\n      logger.log('')\n    } else {\n      logger.log(\n        `The server did not return a Scan ID while trying to create a new Scan. This could be an indication something went wrong.`\n      )\n    }\n    logger.log('')\n    return\n  }\n\n  const link = colors.underline(colors.cyan(`${result.data.html_report_url}`))\n  logger.log(`Available at: ${link}`)\n\n  if (\n    interactive &&\n    (await confirm({\n      message: 'Would you like to open it in your browser?',\n      default: false\n    }))\n  ) {\n    await open(`${result.data.html_report_url}`)\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { fetchCreateOrgFullScan } from './fetch-create-org-full-scan.mts'\nimport { fetchSupportedScanFileNames } from './fetch-supported-scan-file-names.mts'\nimport { handleScanReport } from './handle-scan-report.mts'\nimport { outputCreateNewScan } from './output-create-new-scan.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getPackageFilesForScan } from '../../utils/path-resolve.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleCreateNewScan({\n  branchName,\n  commitHash,\n  commitMessage,\n  committers,\n  cwd,\n  defaultBranch,\n  interactive,\n  orgSlug,\n  outputKind,\n  pendingHead,\n  pullRequest,\n  readOnly,\n  repoName,\n  report,\n  targets,\n  tmp\n}: {\n  branchName: string\n  commitHash: string\n  commitMessage: string\n  committers: string\n  cwd: string\n  defaultBranch: boolean\n  interactive: boolean\n  orgSlug: string\n  pendingHead: boolean\n  pullRequest: number\n  outputKind: OutputKind\n  readOnly: boolean\n  repoName: string\n  report: boolean\n  targets: string[]\n  tmp: boolean\n}): Promise<void> {\n  const supportedFileNames = await fetchSupportedScanFileNames()\n  if (!supportedFileNames.ok) {\n    await outputCreateNewScan(supportedFileNames, outputKind, interactive)\n    return\n  }\n\n  const packagePaths = await getPackageFilesForScan(\n    cwd,\n    targets,\n    supportedFileNames.data\n  )\n\n  const wasValidInput = checkCommandInput(outputKind, {\n    nook: true,\n    test: packagePaths.length > 0,\n    pass: 'ok',\n    fail: 'found no eligible files to scan',\n    message:\n      'TARGET (file/dir) must contain matching / supported file types for a scan'\n  })\n  if (!wasValidInput) {\n    return\n  }\n\n  if (readOnly) {\n    logger.log('[ReadOnly] Bailing now')\n    return\n  }\n\n  const data = await fetchCreateOrgFullScan(\n    packagePaths,\n    orgSlug,\n    defaultBranch,\n    pendingHead,\n    tmp,\n    cwd,\n    {\n      commitHash,\n      commitMessage,\n      committers,\n      pullRequest,\n      repoName,\n      branchName\n    }\n  )\n\n  if (data.ok && report) {\n    if (data.data?.id) {\n      await handleScanReport({\n        filePath: '-',\n        fold: 'version',\n        includeLicensePolicy: true,\n        orgSlug,\n        outputKind,\n        reportLevel: 'error',\n        scanId: data.data.id,\n        short: false\n      })\n    } else {\n      await outputCreateNewScan(\n        {\n          ok: false,\n          message: 'Missing Scan ID',\n          cause: 'Server did not respond with a scan ID',\n          data: data.data\n        },\n        outputKind,\n        interactive\n      )\n    }\n  } else {\n    await outputCreateNewScan(data, outputKind, interactive)\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { getDefaultOrgSlug } from './fetch-default-org-slug.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\nimport { handleCreateNewScan } from '../scan/handle-create-new-scan.mts'\n\nexport async function handleCI(): Promise<void> {\n  // ci: {\n  //   description: 'Alias for \"report create --view --strict\"',\n  //     argv: ['report', 'create', '--view', '--strict']\n  // }\n  const result = await getDefaultOrgSlug()\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n    // Always assume json mode\n    logger.log(serializeResultJson(result))\n    return\n  }\n\n  // TODO: does it make sense to discover the commit details from local git?\n  // TODO: does it makes sense to use custom branch/repo names here? probably socket.yml, right\n  await handleCreateNewScan({\n    branchName: 'socket-default-branch',\n    commitMessage: '',\n    commitHash: '',\n    committers: '',\n    cwd: process.cwd(),\n    defaultBranch: false,\n    interactive: false,\n    orgSlug: result.data,\n    outputKind: 'json',\n    pendingHead: true, // when true, requires branch name set, tmp false\n    pullRequest: 0,\n    repoName: 'socket-default-repository',\n    readOnly: false,\n    report: true,\n    targets: ['.'],\n    tmp: false // don't set when pendingHead is true\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleCI } from './handle-ci.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'ci',\n  description:\n    'Create a new scan and report whether it passes your security policy',\n  hidden: true,\n  flags: {\n    ...commonFlags\n  },\n  help: (parentName, _config) => `\n    Usage\n      $ ${parentName}\n\n    This command is intended to use in CI runs to allow automated systems to\n    accept or reject a current build. When the scan does not pass your security\n    policy, the exit code will be non-zero.\n\n    It will use the default org for the set API token.\n  `\n}\n\nexport const cmdCI = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleCI()\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { supportedConfigKeys } from '../../utils/config.mts'\nimport { hasDefaultToken, setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function discoverConfigValue(\n  key: string\n): Promise<CResult<unknown>> {\n  // This will have to be a specific implementation per key because certain\n  // keys should request information from particular API endpoints while\n  // others should simply return their default value, like endpoint URL.\n\n  if (!supportedConfigKeys.has(key as keyof LocalConfig)) {\n    return {\n      ok: false,\n      message: 'Auto discover failed',\n      cause: 'Requested key is not a valid config key.'\n    }\n  }\n\n  if (key === 'apiBaseUrl') {\n    // Return the default value\n    return {\n      ok: false,\n      message: 'Auto discover failed',\n      cause:\n        \"If you're unsure about the base endpoint URL then simply unset it.\"\n    }\n  }\n\n  if (key === 'apiProxy') {\n    // I don't think we can auto-discover this with any order of reliability..?\n    return {\n      ok: false,\n      message: 'Auto discover failed',\n      cause:\n        'When uncertain, unset this key. Otherwise ask your network administrator'\n    }\n  }\n\n  if (key === 'apiToken') {\n    return {\n      ok: false,\n      message: 'Auto discover failed',\n      cause:\n        'You can find/create your API token in your Socket dashboard > settings > API tokens.\\nYou should then use `socket login` to login instead of this command.'\n    }\n  }\n\n  if (key === 'defaultOrg') {\n    const hasApiToken = hasDefaultToken()\n    if (!hasApiToken) {\n      return {\n        ok: false,\n        message: 'Auto discover failed',\n        cause: 'No API token set, must have a token to resolve its default org.'\n      }\n    }\n\n    const org = await getDefaultOrgFromToken()\n    if (!org?.length) {\n      return {\n        ok: false,\n        message: 'Auto discover failed',\n        cause: 'Was unable to determine default org for the current API token.'\n      }\n    }\n\n    if (Array.isArray(org)) {\n      return {\n        ok: true,\n        data: org,\n        message: 'These are the orgs that the current API token can access.'\n      }\n    }\n\n    return {\n      ok: true,\n      data: org,\n      message: 'This is the org that belongs to the current API token.'\n    }\n  }\n\n  if (key === 'enforcedOrgs') {\n    const hasApiToken = hasDefaultToken()\n    if (!hasApiToken) {\n      return {\n        ok: false,\n        message: 'Auto discover failed',\n        cause: 'No API token set, must have a token to resolve orgs to enforce.'\n      }\n    }\n\n    const orgs = await getEnforceableOrgsFromToken()\n    if (!orgs?.length) {\n      return {\n        ok: false,\n        message: 'Auto discover failed',\n        cause:\n          'Was unable to determine any orgs to enforce for the current API token.'\n      }\n    }\n\n    return {\n      ok: true,\n      data: orgs,\n      message: 'These are the orgs whose security policy you can enforce.'\n    }\n  }\n\n  if (key === 'test') {\n    return {\n      ok: false,\n      message: 'Auto discover failed',\n      cause: 'congrats, you found the test key'\n    }\n  }\n\n  // Mostly to please TS, because we're not telling it `key` is keyof LocalConfig\n  return {\n    ok: false,\n    message: 'Auto discover failed',\n    cause: 'unreachable?'\n  }\n}\n\nasync function getDefaultOrgFromToken(): Promise<\n  string[] | string | undefined\n> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return undefined\n  }\n  const sockSdk = sockSdkResult.data\n\n  const result = await handleApiCall(\n    sockSdk.getOrganizations(),\n    'list of organizations'\n  )\n\n  if (result.ok) {\n    const arr = Array.from(Object.values(result.data.organizations)).map(\n      ({ slug }) => slug\n    )\n    if (arr.length === 0) {\n      return undefined\n    }\n    if (arr.length === 1) {\n      return arr[0]\n    }\n    return arr\n  }\n\n  return undefined\n}\n\nasync function getEnforceableOrgsFromToken(): Promise<string[] | undefined> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return undefined\n  }\n  const sockSdk = sockSdkResult.data\n\n  const result = await handleApiCall(\n    sockSdk.getOrganizations(),\n    'list of organizations'\n  )\n\n  if (result.ok) {\n    const arr = Array.from(Object.values(result.data.organizations)).map(\n      ({ slug }) => slug\n    )\n    if (arr.length === 0) {\n      return undefined\n    }\n    return arr\n  }\n\n  return undefined\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\nimport { select } from '@socketsecurity/registry/lib/prompts'\n\nimport { isReadOnlyConfig, updateConfigValue } from '../../utils/config.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function outputConfigAuto(\n  key: keyof LocalConfig,\n  result: CResult<unknown>,\n  outputKind: OutputKind\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    logger.log(`# Auto discover config value`)\n    logger.log('')\n    logger.log(\n      `Attempted to automatically discover the value for config key: \"${key}\"`\n    )\n    logger.log('')\n    if (result.ok) {\n      logger.log(`The discovered value is: \"${result.data}\"`)\n      if (result.message) {\n        logger.log('')\n        logger.log(result.message)\n      }\n    }\n    logger.log('')\n  } else {\n    if (result.message) {\n      logger.log(result.message)\n      logger.log('')\n    }\n    logger.log(`- ${key}: ${result.data}`)\n    logger.log('')\n\n    if (isReadOnlyConfig()) {\n      logger.log(\n        '(Unable to persist this value because the config is in read-only mode, meaning it was overridden through env or flag.)'\n      )\n    } else if (key === 'defaultOrg') {\n      const proceed = await select<string>({\n        message:\n          'Would you like to update the default org in local config to this value?',\n        choices: (Array.isArray(result.data) ? result.data : [result.data])\n          .map(slug => ({\n            name: 'Yes [' + slug + ']',\n            value: slug,\n            description: `Use \"${slug}\" as the default organization`\n          }))\n          .concat({\n            name: 'No',\n            value: '',\n            description: 'Do not use any of these organizations'\n          })\n      })\n      if (proceed) {\n        logger.log(`Setting defaultOrg to \"${proceed}\"...`)\n        const updateResult = updateConfigValue('defaultOrg', proceed)\n        if (updateResult.ok) {\n          logger.log(\n            `OK. Updated defaultOrg to \"${proceed}\".\\nYou should no longer need to add the org to commands that normally require it.`\n          )\n        } else {\n          logger.log(failMsgWithBadge(updateResult.message, updateResult.cause))\n        }\n      } else {\n        logger.log('OK. No changes made.')\n      }\n    } else if (key === 'enforcedOrgs') {\n      const proceed = await select<string>({\n        message:\n          'Would you like to update the enforced orgs in local config to this value?',\n        choices: (Array.isArray(result.data) ? result.data : [result.data])\n          .map(slug => ({\n            name: 'Yes [' + slug + ']',\n            value: slug,\n            description: `Enforce the security policy of \"${slug}\" on this machine`\n          }))\n          .concat({\n            name: 'No',\n            value: '',\n            description: 'Do not use any of these organizations'\n          })\n      })\n      if (proceed) {\n        logger.log(`Setting enforcedOrgs key to \"${proceed}\"...`)\n        const updateResult = updateConfigValue('defaultOrg', proceed)\n        if (updateResult.ok) {\n          logger.log(`OK. Updated enforcedOrgs to \"${proceed}\".`)\n        } else {\n          logger.log(failMsgWithBadge(updateResult.message, updateResult.cause))\n        }\n      } else {\n        logger.log('OK. No changes made.')\n      }\n    }\n  }\n}\n","import { discoverConfigValue } from './discover-config-value.mts'\nimport { outputConfigAuto } from './output-config-auto.mts'\n\nimport type { OutputKind } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function handleConfigAuto({\n  key,\n  outputKind\n}: {\n  key: keyof LocalConfig\n  outputKind: OutputKind\n}) {\n  const result = await discoverConfigValue(key)\n\n  await outputConfigAuto(key, result, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleConfigAuto } from './handle-config-auto.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { supportedConfigKeys } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { LocalConfig } from '../../utils/config.mts'\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'auto',\n  description: 'Automatically discover and set the correct value config item',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <org slug>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Attempt to automatically discover the correct value for a certain config key.\n\n    For certain keys it will request the value from server, for others it will\n    reset the value to the default. For some keys this has no effect.\n\n    Keys:\n\n${Array.from(supportedConfigKeys.entries())\n  .map(([key, desc]) => `     - ${key} -- ${desc}`)\n  .join('\\n')}\n\n    Examples\n      $ ${command} auto defaultOrg\n  `\n}\n\nexport const cmdConfigAuto = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [key = ''] = cli.input\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: supportedConfigKeys.has(key as keyof LocalConfig) && key !== 'test',\n      message: 'Config key should be the first arg',\n      pass: 'ok',\n      fail: key ? 'invalid config key' : 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleConfigAuto({\n    key: key as keyof LocalConfig,\n    outputKind\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { isReadOnlyConfig } from '../../utils/config.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function outputConfigGet(\n  key: keyof LocalConfig,\n  result: CResult<LocalConfig[keyof LocalConfig]>,\n  outputKind: OutputKind\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const readOnly = isReadOnlyConfig()\n\n  if (outputKind === 'markdown') {\n    logger.log(`# Config Value`)\n    logger.log('')\n    logger.log(`Config key '${key}' has value '${result.data}`)\n    if (readOnly) {\n      logger.log('')\n      logger.log(\n        'Note: the config is in read-only mode, meaning at least one key was temporarily\\n      overridden from an env var or command flag.'\n      )\n    }\n  } else {\n    logger.log(`${key}: ${result.data}`)\n    if (readOnly) {\n      logger.log('')\n      logger.log(\n        'Note: the config is in read-only mode, meaning at least one key was temporarily overridden from an env var or command flag.'\n      )\n    }\n  }\n}\n","import { outputConfigGet } from './output-config-get.mts'\nimport { getConfigValue } from '../../utils/config.mts'\n\nimport type { OutputKind } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function handleConfigGet({\n  key,\n  outputKind\n}: {\n  key: keyof LocalConfig\n  outputKind: OutputKind\n}) {\n  const result = getConfigValue(key)\n\n  await outputConfigGet(key, result, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleConfigGet } from './handle-config-get.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { supportedConfigKeys } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { LocalConfig } from '../../utils/config.mts'\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'get',\n  description: 'Get the value of a local CLI config item',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <org slug>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Keys:\n\n${Array.from(supportedConfigKeys.entries())\n  .map(([key, desc]) => `     - ${key} -- ${desc}`)\n  .join('\\n')}\n\n    Examples\n      $ ${command} FakeOrg --repoName=test-repo\n  `\n}\n\nexport const cmdConfigGet = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [key = ''] = cli.input\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: supportedConfigKeys.has(key as keyof LocalConfig) || key === 'test',\n      message: 'Config key should be the first arg',\n      pass: 'ok',\n      fail: key ? 'invalid config key' : 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleConfigGet({\n    key: key as keyof LocalConfig,\n    outputKind\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport {\n  getConfigValue,\n  isReadOnlyConfig,\n  sensitiveConfigKeys,\n  supportedConfigKeys\n} from '../../utils/config.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function outputConfigList({\n  full,\n  outputKind\n}: {\n  full: boolean\n  outputKind: OutputKind\n}) {\n  const readOnly = isReadOnlyConfig()\n  if (outputKind === 'json') {\n    let failed = false\n    const obj: Record<string, unknown> = {}\n    for (const key of supportedConfigKeys.keys()) {\n      const result = getConfigValue(key)\n      let value = result.data\n      if (!result.ok) {\n        value = `Failed to retrieve: ${result.message}`\n        failed = true\n      } else if (!full && sensitiveConfigKeys.has(key)) {\n        value = '********'\n      }\n      if (full || value !== undefined) {\n        obj[key as any] = value ?? '<none>'\n      }\n    }\n    if (failed) {\n      process.exitCode = 1\n    }\n    logger.log(\n      serializeResultJson(\n        failed\n          ? {\n              ok: false,\n              message: 'At least one config key failed to be fetched...',\n              data: JSON.stringify({\n                full,\n                config: obj,\n                readOnly\n              })\n            }\n          : {\n              ok: true,\n              data: {\n                full,\n                config: obj,\n                readOnly\n              }\n            }\n      )\n    )\n  } else {\n    const maxWidth = Array.from(supportedConfigKeys.keys()).reduce(\n      (a, b) => Math.max(a, b.length),\n      0\n    )\n\n    logger.log('# Local CLI Config')\n    logger.log('')\n    logger.log(`This is the local CLI config (full=${!!full}):`)\n    logger.log('')\n    for (const key of supportedConfigKeys.keys()) {\n      const result = getConfigValue(key)\n      if (!result.ok) {\n        logger.log(`- ${key}: failed to read: ${result.message}`)\n      } else {\n        let value = result.data\n        if (!full && sensitiveConfigKeys.has(key)) {\n          value = '********'\n        }\n        if (full || value !== undefined) {\n          logger.log(\n            `- ${key}:${' '.repeat(Math.max(0, maxWidth - key.length + 3))} ${Array.isArray(value) ? value.join(', ') || '<none>' : (value ?? '<none>')}`\n          )\n        }\n      }\n    }\n    if (readOnly) {\n      logger.log('')\n      logger.log(\n        'Note: the config is in read-only mode, meaning at least one key was temporarily\\n      overridden from an env var or command flag.'\n      )\n    }\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { outputConfigList } from './output-config-list.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { supportedConfigKeys } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'list',\n  description: 'Show all local CLI config items and their values',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    full: {\n      type: 'boolean',\n      default: false,\n      description: 'Show full tokens in plaintext (unsafe)'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <org slug>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Keys:\n\n${Array.from(supportedConfigKeys.entries())\n  .map(([key, desc]) => `     - ${key} -- ${desc}`)\n  .join('\\n')}\n\n    Examples\n      $ ${command} FakeOrg --repoName=test-repo\n  `\n}\n\nexport const cmdConfigList = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { full, json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const wasValidInput = checkCommandInput(outputKind, {\n    nook: true,\n    test: !json || !markdown,\n    message:\n      'The `--json` and `--markdown` flags can not be used at the same time',\n    pass: 'ok',\n    fail: 'bad'\n  })\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await outputConfigList({\n    full: !!full,\n    outputKind\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\n\nexport async function outputConfigSet(\n  result: CResult<undefined | string>,\n  outputKind: OutputKind\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    logger.log(`# Update config`)\n    logger.log('')\n    logger.log(result.message)\n    if (result.data) {\n      logger.log('')\n      logger.log(result.data)\n    }\n  } else {\n    logger.log(`OK`)\n    logger.log(result.message)\n    if (result.data) {\n      logger.log('')\n      logger.log(result.data)\n    }\n  }\n}\n","import { outputConfigSet } from './output-config-set.mts'\nimport { updateConfigValue } from '../../utils/config.mts'\n\nimport type { OutputKind } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function handleConfigSet({\n  key,\n  outputKind,\n  value\n}: {\n  key: keyof LocalConfig\n  outputKind: OutputKind\n  value: string\n}) {\n  const result = updateConfigValue(key, value)\n\n  await outputConfigSet(result, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleConfigSet } from './handle-config-set.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { supportedConfigKeys } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { LocalConfig } from '../../utils/config.mts'\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'set',\n  description: 'Update the value of a local CLI config item',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <key> <value>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    This is a crude way of updating the local configuration for this CLI tool.\n\n    Note that updating a value here is nothing more than updating a key/value\n    store entry. No validation is happening. The server may reject your config.\n\n    Keys:\n\n${Array.from(supportedConfigKeys.entries())\n  .map(([key, desc]) => `     - ${key} -- ${desc}`)\n  .join('\\n')}\n\n    Examples\n      $ ${command} apiProxy https://example.com\n  `\n}\n\nexport const cmdConfigSet = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [key = '', ...rest] = cli.input\n  const value = rest.join(' ')\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: key === 'test' || supportedConfigKeys.has(key as keyof LocalConfig),\n      message: 'Config key should be the first arg',\n      pass: 'ok',\n      fail: key ? 'invalid config key' : 'missing'\n    },\n    {\n      test: !!value, // This is a string, empty string is not ok\n      message:\n        'Key value should be the remaining args (use `unset` to unset a value)',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleConfigSet({\n    key: key as keyof LocalConfig,\n    outputKind,\n    value\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\n\nexport async function outputConfigUnset(\n  updateResult: CResult<undefined | string>,\n  outputKind: OutputKind\n) {\n  if (!updateResult.ok) {\n    process.exitCode = updateResult.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(updateResult))\n    return\n  }\n  if (!updateResult.ok) {\n    logger.fail(failMsgWithBadge(updateResult.message, updateResult.cause))\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    logger.log(`# Update config`)\n    logger.log('')\n    logger.log(updateResult.message)\n    if (updateResult.data) {\n      logger.log('')\n      logger.log(updateResult.data)\n    }\n  } else {\n    logger.log(`OK`)\n    logger.log(updateResult.message)\n    if (updateResult.data) {\n      logger.log('')\n      logger.log(updateResult.data)\n    }\n  }\n}\n","import { outputConfigUnset } from './output-config-unset.mts'\nimport { updateConfigValue } from '../../utils/config.mts'\n\nimport type { OutputKind } from '../../types.mts'\nimport type { LocalConfig } from '../../utils/config.mts'\n\nexport async function handleConfigUnset({\n  key,\n  outputKind\n}: {\n  key: keyof LocalConfig\n  outputKind: OutputKind\n}) {\n  const updateResult = updateConfigValue(key, undefined)\n\n  await outputConfigUnset(updateResult, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleConfigUnset } from './handle-config-unset.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { supportedConfigKeys } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { LocalConfig } from '../../utils/config.mts'\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'unset',\n  description: 'Clear the value of a local CLI config item',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <org slug>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Keys:\n\n${Array.from(supportedConfigKeys.entries())\n  .map(([key, desc]) => `     - ${key} -- ${desc}`)\n  .join('\\n')}\n\n    Examples\n      $ ${command} FakeOrg --repoName=test-repo\n  `\n}\n\nexport const cmdConfigUnset = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [key = ''] = cli.input\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: key === 'test' || supportedConfigKeys.has(key as keyof LocalConfig),\n      message: 'Config key should be the first arg',\n      pass: 'ok',\n      fail: key ? 'invalid config key' : 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleConfigUnset({\n    key: key as keyof LocalConfig,\n    outputKind\n  })\n}\n","import { cmdConfigAuto } from './cmd-config-auto.mts'\nimport { cmdConfigGet } from './cmd-config-get.mts'\nimport { cmdConfigList } from './cmd-config-list.mts'\nimport { cmdConfigSet } from './cmd-config-set.mts'\nimport { cmdConfigUnset } from './cmd-config-unset.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Commands related to the local CLI configuration'\n\nexport const cmdConfig: CliSubcommand = {\n  description,\n  hidden: true, // [beta]\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        auto: cmdConfigAuto,\n        get: cmdConfigGet,\n        list: cmdConfigList,\n        set: cmdConfigSet,\n        unset: cmdConfigUnset\n      },\n      {\n        argv,\n        description,\n        importMeta,\n        name: `${parentName} config`\n      }\n    )\n  }\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchDependencies({\n  limit,\n  offset\n}: {\n  limit: number\n  offset: number\n}): Promise<CResult<SocketSdkReturnType<'searchDependencies'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.searchDependencies({ limit, offset }),\n    'organization dependencies'\n  )\n}\n","// @ts-ignore\nimport chalkTable from 'chalk-table'\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputDependencies(\n  result: CResult<SocketSdkReturnType<'searchDependencies'>['data']>,\n  {\n    limit,\n    offset,\n    outputKind\n  }: {\n    limit: number\n    offset: number\n    outputKind: OutputKind\n  }\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.log(\n    'Request details: Offset:',\n    offset,\n    ', limit:',\n    limit,\n    ', is there more data after this?',\n    result.data.end ? 'no' : 'yes'\n  )\n\n  const options = {\n    columns: [\n      { field: 'namespace', name: colors.cyan('Namespace') },\n      { field: 'name', name: colors.cyan('Name') },\n      { field: 'version', name: colors.cyan('Version') },\n      { field: 'repository', name: colors.cyan('Repository') },\n      { field: 'branch', name: colors.cyan('Branch') },\n      { field: 'type', name: colors.cyan('Type') },\n      { field: 'direct', name: colors.cyan('Direct') }\n    ]\n  }\n\n  logger.log(chalkTable(options, result.data.rows))\n}\n","import { fetchDependencies } from './fetch-dependencies.mts'\nimport { outputDependencies } from './output-dependencies.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleDependencies({\n  limit,\n  offset,\n  outputKind\n}: {\n  limit: number\n  offset: number\n  outputKind: OutputKind\n}): Promise<void> {\n  const result = await fetchDependencies({ limit, offset })\n\n  await outputDependencies(result, { limit, offset, outputKind })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleDependencies } from './handle-dependencies.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'dependencies',\n  description:\n    'Search for any dependency that is being used in your organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    limit: {\n      type: 'number',\n      shortFlag: 'l',\n      default: 50,\n      description: 'Maximum number of dependencies returned'\n    },\n    offset: {\n      type: 'number',\n      shortFlag: 'o',\n      default: 0,\n      description: 'Page number'\n    },\n    ...outputFlags\n  },\n  help: (command, config) => `\n    Usage\n      ${command}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: none (does need token with access to target org)\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      ${command} --limit 20 --offset 10\n  `\n}\n\nexport const cmdScanCreate = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { json, limit, markdown, offset } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleDependencies({\n    limit: Number(limit || 0) || 0,\n    offset: Number(offset || 0) || 0,\n    outputKind\n  })\n}\n","import { queryApiSafeJson } from '../../utils/api.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchDiffScan({\n  after,\n  before,\n  orgSlug\n}: {\n  after: string\n  before: string\n  orgSlug: string\n}): Promise<CResult<SocketSdkReturnType<'GetOrgDiffScan'>['data']>> {\n  return await queryApiSafeJson<SocketSdkReturnType<'GetOrgDiffScan'>['data']>(\n    `orgs/${orgSlug}/full-scans/diff?before=${encodeURIComponent(before)}&after=${encodeURIComponent(after)}`,\n    'a scan diff'\n  )\n}\n","import fs from 'node:fs'\nimport util from 'node:util'\n\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputDiffScan(\n  result: CResult<SocketSdkReturnType<'GetOrgDiffScan'>['data']>,\n  {\n    depth,\n    file,\n    outputKind\n  }: {\n    depth: number\n    file: string\n    outputKind: OutputKind\n  }\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(result))\n      return\n    }\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const dashboardUrl = result.data.diff_report_url\n  const dashboardMessage = dashboardUrl\n    ? `\\n View this diff scan in the Socket dashboard: ${colors.cyan(dashboardUrl)}`\n    : ''\n\n  // When forcing json, or dumping to file, serialize to string such that it\n  // won't get truncated. The only way to dump the full raw JSON to stdout is\n  // to use `--json --file -` (the dash is a standard notation for stdout)\n  if (outputKind === 'json' || file) {\n    const json = serializeResultJson(result)\n\n    if (file && file !== '-') {\n      logger.log(`Writing json to \\`${file}\\``)\n      fs.writeFile(file, JSON.stringify(result, null, 2), err => {\n        if (err) {\n          logger.fail(`Writing to \\`${file}\\` failed...`)\n          logger.error(err)\n        } else {\n          logger.log(`Data successfully written to \\`${file}\\``)\n        }\n        logger.error(dashboardMessage)\n      })\n    } else {\n      // TODO: expose different method for writing to stderr when simply dodging stdout\n      logger.error(`\\n Diff scan result: \\n`)\n      logger.log(json)\n      logger.error(dashboardMessage)\n    }\n\n    return\n  }\n\n  // In this case neither the --json nor the --file flag was passed\n  // Dump the JSON to CLI and let NodeJS deal with truncation\n\n  logger.log('Diff scan result:')\n  logger.log(\n    util.inspect(result, {\n      showHidden: false,\n      depth: depth > 0 ? depth : null,\n      colors: true,\n      maxArrayLength: null\n    })\n  )\n  logger.log(\n    `\\n 📝 To display the detailed report in the terminal, use the --json flag \\n`\n  )\n  logger.log(dashboardMessage)\n}\n","import { fetchDiffScan } from './fetch-diff-scan.mts'\nimport { outputDiffScan } from './output-diff-scan.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleDiffScan({\n  after,\n  before,\n  depth,\n  file,\n  orgSlug,\n  outputKind\n}: {\n  after: string\n  before: string\n  depth: number\n  file: string\n  orgSlug: string\n  outputKind: OutputKind\n}): Promise<void> {\n  const data = await fetchDiffScan({\n    after,\n    before,\n    orgSlug\n  })\n\n  await outputDiffScan(data, {\n    depth,\n    file,\n    outputKind\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleDiffScan } from './handle-diff-scan.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getConfigValueOrUndef, isTestingV1 } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'get',\n  description: 'Get a diff scan for an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    after: {\n      type: 'string',\n      shortFlag: 'a',\n      default: '',\n      description: 'The scan ID of the head scan'\n    },\n    before: {\n      type: 'string',\n      shortFlag: 'b',\n      default: '',\n      description: 'The scan ID of the base scan'\n    },\n    depth: {\n      type: 'number',\n      default: 2,\n      description:\n        'Max depth of JSON to display before truncating, use zero for no limit (without --json/--file)'\n    },\n    json: {\n      type: 'boolean',\n      shortFlag: 'j',\n      default: false,\n      description:\n        'Output result as json. This can be big. Use --file to store it to disk without truncation.'\n    },\n    file: {\n      type: 'string',\n      shortFlag: 'f',\n      default: '',\n      description:\n        'Path to a local file where the output should be saved. Use `-` to force stdout.'\n    }\n  },\n  help: (command, config) =>\n    isTestingV1()\n      ? 'This command will be removed in v1'\n      : `\n    Note: This command is deprecated, to be dropped in the next major bump.\n          Please see \\`socket scan diff\\`\n\n    Usage\n      $ ${command} <org slug> --before=<before> --after=<after>\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:list\n\n    This command displays the package changes between two scans. The full output\n    can be pretty large depending on the size of your repo and time range. It is\n    best stored to disk to be further analyzed by other tools.\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} FakeCorp --before=aaa0aa0a-aaaa-0000-0a0a-0000000a00a0 --after=aaa1aa1a-aaaa-1111-1a1a-1111111a11a1\n  `\n}\n\nexport const cmdDiffScanGet = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { after, before, depth, file, json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const defaultOrgSlugResult = getConfigValueOrUndef('defaultOrg')\n  const orgSlug = defaultOrgSlugResult || cli.input[0] || ''\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: !!(before && after),\n      message:\n        'Specify a before and after scan ID.\\nThe args are expecting a full `aaa0aa0a-aaaa-0000-0a0a-0000000a00a0` scan ID.',\n      pass: 'ok',\n      fail:\n        !before && !after\n          ? 'missing before and after'\n          : !before\n            ? 'missing before'\n            : 'missing after'\n    },\n    {\n      test: !!orgSlug,\n      nook: true,\n      message: 'Org name as the first argument',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  logger.fail(\n    'Warning: this command is deprecated in favor of `socket scan diff` and will be removed in the next major bump.'\n  )\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleDiffScan({\n    before: String(before || ''),\n    after: String(after || ''),\n    depth: Number(depth),\n    orgSlug,\n    outputKind,\n    file: String(file || '')\n  })\n}\n","import { cmdDiffScanGet } from './cmd-diff-scan-get.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Diff scans related commands'\n\nexport const cmdDiffScan: CliSubcommand = {\n  description,\n  // Hidden because it was broken all this time (nobody could be using it)\n  // and we're not sure if it's useful to anyone in its current state.\n  // Until we do, we'll hide this to keep the help tidier.\n  // And later, we may simply move this under `scan`, anyways.\n  hidden: true,\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        get: cmdDiffScanGet\n      },\n      {\n        argv,\n        description,\n        importMeta,\n        name: parentName + ' diff-scan'\n      }\n    )\n  }\n}\n","import path from 'node:path'\n\nimport { PackageURL } from '@socketregistry/packageurl-js'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { normalizePath } from '@socketsecurity/registry/lib/path'\nimport { escapeRegExp } from '@socketsecurity/registry/lib/regexps'\nimport { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\nimport {\n  getPkgFullNameFromPurlObj,\n  getSocketDevPackageOverviewUrlFromPurl\n} from '../../utils/socket-url.mts'\n\nfunction formatBranchName(str: string): string {\n  return str\n    .replace(/[-_.\\\\/]+/g, '-')\n    .replace(/[^-a-zA-Z0-9]+/g, '')\n    .replace(/^-+|-+$/g, '')\n}\n\nexport function getBaseGitBranch() {\n  // Lazily access constants.ENV.GITHUB_REF_NAME.\n  return (\n    constants.ENV.GITHUB_REF_NAME ||\n    // GitHub defaults to branch name \"main\"\n    // https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-branches#about-the-default-branch\n    'main'\n  )\n}\n\nexport function getSocketBranchName(\n  purl: string,\n  newVersion: string,\n  workspaceName?: string | undefined\n): string {\n  const purlObj = PackageURL.fromString(purl)\n  const maybeWorkspaceName = workspaceName\n    ? `${formatBranchName(workspaceName)}-`\n    : ''\n  const maybeNamespace = purlObj.namespace\n    ? `${formatBranchName(purlObj.namespace)}-`\n    : ''\n  const fullName = `${maybeWorkspaceName}${maybeNamespace}${formatBranchName(purlObj.name)}`\n  return `socket/${fullName}-${formatBranchName(newVersion)}`\n}\n\nexport function getSocketPrTitlePattern(\n  purl: string,\n  workspaceName?: string | undefined\n): RegExp {\n  const purlObj = PackageURL.fromString(purl)\n  const pkgFullName = getPkgFullNameFromPurlObj(purlObj)\n  const workspaceDetails = workspaceName\n    ? ` in ${escapeRegExp(workspaceName)}`\n    : ''\n  return new RegExp(\n    `Bump ${escapeRegExp(pkgFullName)} from ${escapeRegExp(purlObj.version!)} to \\\\S+${workspaceDetails}`\n  )\n}\n\nexport function getSocketPullRequestTitle(\n  purl: string,\n  newVersion: string,\n  workspaceName?: string | undefined\n): string {\n  const purlObj = PackageURL.fromString(purl)\n  const pkgFullName = getPkgFullNameFromPurlObj(purlObj)\n  const workspaceDetails = workspaceName ? ` in ${workspaceName}` : ''\n  return `Bump ${pkgFullName} from ${purlObj.version} to ${newVersion}${workspaceDetails}`\n}\n\nexport function getSocketPullRequestBody(\n  purl: string,\n  newVersion: string,\n  workspaceName?: string | undefined\n): string {\n  const purlObj = PackageURL.fromString(purl)\n  const pkgFullName = getPkgFullNameFromPurlObj(purlObj)\n  const workspaceDetails = workspaceName ? ` in ${workspaceName}` : ''\n  return `Bump [${pkgFullName}](${getSocketDevPackageOverviewUrlFromPurl(purlObj)}) from ${purlObj.version} to ${newVersion}${workspaceDetails}.`\n}\n\nexport function getSocketCommitMessage(\n  purl: string,\n  newVersion: string,\n  workspaceName?: string | undefined\n): string {\n  const purlObj = PackageURL.fromString(purl)\n  const pkgFullName = getPkgFullNameFromPurlObj(purlObj)\n  const workspaceDetails = workspaceName ? ` in ${workspaceName}` : ''\n  return `socket: Bump ${pkgFullName} from ${purlObj.version} to ${newVersion}${workspaceDetails}`\n}\n\nexport async function gitCreateAndPushBranchIfNeeded(\n  branch: string,\n  commitMsg: string,\n  cwd = process.cwd()\n): Promise<boolean> {\n  if (await gitRemoteBranchExists(branch, cwd)) {\n    logger.warn(`Branch \"${branch}\" already exists remotely, skipping push.`)\n    return true\n  }\n  const moddedFilepaths = (await gitUnstagedModifiedFiles(cwd)).filter(p => {\n    const basename = path.basename(p)\n    return (\n      basename === 'package.json' ||\n      basename === 'package-lock.json' ||\n      basename === 'pnpm-lock.yaml'\n    )\n  })\n  if (!moddedFilepaths.length) {\n    logger.warn('Nothing to commit, skipping push.')\n    return false\n  }\n  await spawn('git', ['checkout', '-b', branch], { cwd })\n  await spawn('git', ['add', ...moddedFilepaths], { cwd })\n  await spawn('git', ['commit', '-m', commitMsg], { cwd })\n  try {\n    await spawn('git', ['push', '--set-upstream', 'origin', branch], { cwd })\n    return true\n  } catch {}\n  logger.warn(`Push failed for \"${branch}\", trying force-push`)\n  try {\n    await spawn(\n      'git',\n      ['push', '--force', '--set-upstream', 'origin', branch],\n      { cwd }\n    )\n    return true\n  } catch {}\n  logger.warn(`Force-push failed for \"${branch}\"`)\n  return false\n}\n\nexport async function gitResetAndClean(\n  branch = 'HEAD',\n  cwd = process.cwd()\n): Promise<void> {\n  // Discards tracked changes.\n  await gitResetHard(branch, cwd)\n  // Deletes all untracked files and directories.\n  await gitCleanFdx(cwd)\n}\n\nexport async function gitResetHard(\n  branch = 'HEAD',\n  cwd = process.cwd()\n): Promise<void> {\n  await spawn('git', ['reset', '--hard', branch], { cwd })\n}\n\nexport async function gitCleanFdx(cwd = process.cwd()): Promise<void> {\n  await spawn('git', ['clean', '-fdx'], { cwd })\n}\n\nexport async function gitRemoteBranchExists(\n  branch: string,\n  cwd = process.cwd()\n): Promise<boolean> {\n  try {\n    const { stdout } = await spawn(\n      'git',\n      ['ls-remote', '--heads', 'origin', branch],\n      { cwd }\n    )\n    return stdout.trim().length > 0\n  } catch {\n    return false\n  }\n}\n\nasync function gitUnstagedModifiedFiles(\n  cwd = process.cwd()\n): Promise<string[]> {\n  const { stdout } = await spawn('git', ['diff', '--name-only'], { cwd })\n  const rawFiles = stdout?.trim().split('\\n') ?? []\n  return rawFiles.map(relPath => normalizePath(relPath))\n}\n","import { existsSync, promises as fs, statSync } from 'node:fs'\nimport path from 'node:path'\n\nimport {\n  GraphqlResponseError,\n  graphql as OctokitGraphql\n} from '@octokit/graphql'\nimport { RequestError } from '@octokit/request-error'\nimport { Octokit } from '@octokit/rest'\nimport semver from 'semver'\n\nimport { readJson, writeJson } from '@socketsecurity/registry/lib/fs'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport {\n  getSocketPrTitlePattern,\n  getSocketPullRequestBody,\n  getSocketPullRequestTitle\n} from './git.mts'\nimport constants from '../../constants.mts'\n\nimport type { components } from '@octokit/openapi-types'\nimport type { OctokitResponse } from '@octokit/types'\nimport type { JsonContent } from '@socketsecurity/registry/lib/fs'\n\nlet _octokit: Octokit | undefined\nfunction getOctokit() {\n  if (_octokit === undefined) {\n    _octokit = new Octokit({\n      // Lazily access constants.ENV.SOCKET_SECURITY_GITHUB_PAT.\n      auth: constants.ENV.SOCKET_SECURITY_GITHUB_PAT\n    })\n  }\n  return _octokit\n}\n\nlet _octokitGraphql: typeof OctokitGraphql | undefined\nexport function getOctokitGraphql() {\n  if (!_octokitGraphql) {\n    _octokitGraphql = OctokitGraphql.defaults({\n      headers: {\n        // Lazily access constants.ENV.SOCKET_SECURITY_GITHUB_PAT.\n        authorization: `token ${constants.ENV.SOCKET_SECURITY_GITHUB_PAT}`\n      }\n    })\n  }\n  return _octokitGraphql\n}\n\nexport async function cacheFetch<T>(\n  key: string,\n  fetcher: () => Promise<T>,\n  ttlMs?: number | undefined\n): Promise<T> {\n  // Optionally disable cache.\n  if (constants.ENV.DISABLE_GITHUB_CACHE) {\n    return await fetcher()\n  }\n  let data = (await readCache(key, ttlMs)) as T\n  if (!data) {\n    data = await fetcher()\n    await writeCache(key, data as JsonContent)\n  }\n  return data\n}\n\nasync function readCache(\n  key: string,\n  // 5 minute in milliseconds time to live (TTL).\n  ttlMs = 5 * 60 * 1000\n): Promise<JsonContent | null> {\n  // Lazily access constants.rootPath.\n  const cachePath = path.join(constants.rootPath, '.cache/github')\n  const cacheJsonPath = path.join(cachePath, `${key}.json`)\n  try {\n    const stat = statSync(cacheJsonPath)\n    const isExpired = Date.now() - stat.mtimeMs > ttlMs\n    if (!isExpired) {\n      return await readJson(cacheJsonPath)\n    }\n  } catch {}\n  return null\n}\n\nasync function writeCache(key: string, data: JsonContent): Promise<void> {\n  // Lazily access constants.rootPath.\n  const cachePath = path.join(constants.rootPath, '.cache/github')\n  const cacheJsonPath = path.join(cachePath, `${key}.json`)\n  if (!existsSync(cachePath)) {\n    await fs.mkdir(cachePath, { recursive: true })\n  }\n  await writeJson(cacheJsonPath, data as JsonContent)\n}\n\nexport type Pr = components['schemas']['pull-request']\n\nexport type CleanupPrsOptions = {\n  workspaceName?: string | undefined\n}\n\nexport async function cleanupOpenPrs(\n  owner: string,\n  repo: string,\n  purl: string,\n  newVersion: string,\n  options?: CleanupPrsOptions | undefined\n) {\n  const { workspaceName } = { __proto__: null, ...options } as CleanupPrsOptions\n  const octokit = getOctokit()\n  const octokitGraphql = getOctokitGraphql()\n  const titlePattern = getSocketPrTitlePattern(purl, workspaceName)\n\n  type PrMatch = {\n    apiType: 'graphql' | 'rest'\n    cacheKey: string\n    data: any\n    entry: any\n    index: number\n    parent: any[]\n    props: any\n  }\n  type GqlPrNode = {\n    baseRefName: string\n    headRefName: string\n    mergeable: string\n    number: number\n    title: string\n  }\n\n  const prMatches: PrMatch[] = []\n  try {\n    // Optimistically fetch only the first 50 open PRs using GraphQL to minimize\n    // API quota usage. Fallback to REST if no matching PRs are found.\n    const gqlCacheKey = `${repo}-pr-graphql-snapshot`\n    const gqlResp = await cacheFetch(gqlCacheKey, () =>\n      octokitGraphql(\n        `\n          query($owner: String!, $repo: String!) {\n            repository(owner: $owner, name: $repo) {\n              pullRequests(first: 50, states: OPEN, orderBy: {field: CREATED_AT, direction: DESC}) {\n                nodes {\n                  number\n                  title\n                  mergeStateStatus\n                  headRefName\n                  baseRefName\n                }\n              }\n            }\n          }\n          `,\n        { owner, repo }\n      )\n    )\n    const nodes: GqlPrNode[] = (gqlResp as any)?.repository?.pullRequests?.nodes\n    if (nodes) {\n      for (let i = 0, { length } = nodes; i < length; i += 1) {\n        const node = nodes[i]!\n        if (titlePattern.test(node.title)) {\n          prMatches.push({\n            apiType: 'graphql',\n            cacheKey: gqlCacheKey,\n            data: gqlResp,\n            entry: node,\n            index: i,\n            parent: nodes,\n            props: node\n          })\n        }\n      }\n    }\n  } catch {}\n\n  // Fallback to REST if GraphQL found no matching PRs.\n  let allOpenPrs: Pr[] | undefined\n  if (!prMatches.length) {\n    const cacheKey = `${repo}-open-prs`\n    try {\n      allOpenPrs = await cacheFetch(\n        cacheKey,\n        async () =>\n          (await octokit.paginate(octokit.pulls.list, {\n            owner,\n            repo,\n            state: 'open',\n            per_page: 100\n          })) as Pr[]\n      )\n    } catch {}\n    if (allOpenPrs) {\n      for (let i = 0, { length } = allOpenPrs; i < length; i += 1) {\n        const pr = allOpenPrs[i]!\n        if (titlePattern.test(pr.title)) {\n          prMatches.push({\n            apiType: 'rest',\n            cacheKey,\n            data: allOpenPrs,\n            entry: pr,\n            index: i,\n            parent: allOpenPrs,\n            props: {\n              baseRefName: pr.base.ref,\n              headRefName: pr.head.ref,\n              // Upper cased mergeable_state is equivalent to mergeStateStatus.\n              // https://docs.github.com/en/rest/pulls/pulls?apiVersion=2022-11-28#get-a-pull-request\n              mergeStateStatus:\n                pr.mergeable_state?.toUpperCase?.() ?? 'UNKNOWN',\n              number: pr.number,\n              title: pr.title\n            }\n          })\n        }\n      }\n    }\n  }\n\n  if (!prMatches.length) {\n    return\n  }\n\n  const cachesToSave = new Map<string, JsonContent>()\n\n  await Promise.allSettled(\n    prMatches.map(async match => {\n      const { props } = match\n      const versionText = /(?<= to )\\S+/.exec(props.title)?.[0]\n      const { number: prNumber } = props\n      const prVersion = semver.coerce(versionText)\n      // Close older PRs.\n      if (prVersion && semver.lt(prVersion, newVersion)) {\n        try {\n          await octokit.pulls.update({\n            owner,\n            repo,\n            pull_number: prNumber,\n            state: 'closed'\n          })\n          logger.info(`Closed PR #${prNumber} for older version ${prVersion}`)\n          // Remove entry from parent object.\n          match.parent.splice(match.index, 1)\n          // Mark cache to be saved.\n          cachesToSave.set(match.cacheKey, match.data)\n        } catch (e) {\n          logger.warn(\n            `Failed to close PR #${prNumber}: ${(e as Error).message}`\n          )\n          return\n        }\n      }\n      // Update stale PRs.\n      // https://docs.github.com/en/graphql/reference/enums#mergestatestatus\n      if (props.mergeStateStatus === 'BEHIND') {\n        try {\n          await octokit.repos.merge({\n            owner,\n            repo,\n            base: props.headRefName,\n            head: props.baseRefName\n          })\n          logger.info(`Updated stale PR #${prNumber}`)\n          // Update entry entry.\n          if (match.apiType === 'graphql') {\n            match.entry.mergeStateStatus = 'CLEAN'\n          } else if (match.apiType === 'rest') {\n            match.entry.mergeable_state = 'clean'\n          }\n          // Mark cache to be saved.\n          cachesToSave.set(match.cacheKey, match.data)\n        } catch (e) {\n          const message = (e as Error)?.message ?? 'Unknown error'\n          logger.warn(`Failed to update PR #${prNumber}: ${message}`)\n        }\n      }\n    })\n  )\n\n  if (cachesToSave.size) {\n    await Promise.allSettled(\n      [...cachesToSave].map(({ 0: key, 1: data }) => writeCache(key, data))\n    )\n  }\n}\n\nexport async function enablePrAutoMerge({\n  node_id: prId,\n  number: prNumber\n}: Pr): Promise<boolean> {\n  const octokitGraphql = getOctokitGraphql()\n  let error: unknown\n  try {\n    const response = await octokitGraphql(\n      `\n      mutation EnableAutoMerge($pullRequestId: ID!) {\n        enablePullRequestAutoMerge(input: {\n          pullRequestId: $pullRequestId,\n          mergeMethod: SQUASH\n        }) {\n          pullRequest {\n            number\n          }\n        }\n      }`,\n      { pullRequestId: prId }\n    )\n    const respPrNumber = (response as any)?.enablePullRequestAutoMerge\n      ?.pullRequest?.number\n    if (respPrNumber) {\n      logger.info(`Auto-merge enabled for PR #${respPrNumber}`)\n      return true\n    }\n  } catch (e) {\n    error = e\n  }\n  let message = `Failed to enable auto-merge for PR #${prNumber}`\n  if (error instanceof GraphqlResponseError && error.errors) {\n    const details = error.errors\n      .map(({ message }) => ` - ${message.trim()}`)\n      .join('\\n')\n    message += `:\\n${details}`\n  }\n  logger.error(message)\n  return false\n}\n\nexport type GitHubRepoInfo = {\n  owner: string\n  repo: string\n}\n\nexport function getGitHubEnvRepoInfo(): GitHubRepoInfo {\n  // Lazily access constants.ENV.GITHUB_REPOSITORY.\n  const ownerSlashRepo = constants.ENV.GITHUB_REPOSITORY\n  const slashIndex = ownerSlashRepo.indexOf('/')\n  if (slashIndex === -1) {\n    throw new Error('Missing GITHUB_REPOSITORY environment variable')\n  }\n  return {\n    owner: ownerSlashRepo.slice(0, slashIndex),\n    repo: ownerSlashRepo.slice(slashIndex + 1)\n  }\n}\n\nexport type OpenPrOptions = {\n  baseBranch?: string | undefined\n  cwd?: string | undefined\n  workspaceName?: string | undefined\n}\n\nexport async function openPr(\n  owner: string,\n  repo: string,\n  branch: string,\n  purl: string,\n  newVersion: string,\n  options?: OpenPrOptions | undefined\n): Promise<OctokitResponse<Pr> | null> {\n  const {\n    baseBranch = 'main',\n    cwd = process.cwd(),\n    workspaceName\n  } = {\n    __proto__: null,\n    ...options\n  } as OpenPrOptions\n  // Lazily access constants.ENV.GITHUB_ACTIONS.\n  if (constants.ENV.GITHUB_ACTIONS) {\n    // Lazily access constants.ENV.SOCKET_SECURITY_GITHUB_PAT.\n    const pat = constants.ENV.SOCKET_SECURITY_GITHUB_PAT\n    if (!pat) {\n      throw new Error('Missing SOCKET_SECURITY_GITHUB_PAT environment variable')\n    }\n    const url = `https://x-access-token:${pat}@github.com/${owner}/${repo}`\n    await spawn('git', ['remote', 'set-url', 'origin', url], {\n      cwd\n    })\n    const octokit = getOctokit()\n    try {\n      return await octokit.pulls.create({\n        owner,\n        repo,\n        title: getSocketPullRequestTitle(purl, newVersion, workspaceName),\n        head: branch,\n        base: baseBranch,\n        body: getSocketPullRequestBody(purl, newVersion, workspaceName)\n      })\n    } catch (e) {\n      let message = `Failed to open pull request`\n      if (e instanceof RequestError) {\n        const restErrors = (e.response?.data as any)?.['errors']\n        if (Array.isArray(restErrors)) {\n          const details = restErrors\n            .map(\n              restErr =>\n                `- ${restErr.message?.trim() ?? `${restErr.resource}.${restErr.field} (${restErr.code})`}`\n            )\n            .join('\\n')\n          message += `:\\n${details}`\n        }\n      }\n      logger.error(message)\n      return null\n    }\n  }\n  throw new Error('Missing GITHUB_ACTIONS environment variable')\n}\n\nexport async function prExistForBranch(\n  owner: string,\n  repo: string,\n  branch: string\n): Promise<boolean> {\n  const octokit = getOctokit()\n  try {\n    const { data: prs } = await octokit.pulls.list({\n      owner,\n      repo,\n      head: `${owner}:${branch}`,\n      state: 'open',\n      per_page: 1\n    })\n    return prs.length > 0\n  } catch {}\n  return false\n}\n","import type { FixOptions, NormalizedFixOptions } from './types.mts'\nimport type { GetAlertsMapFromPurlsOptions } from '../../utils/alerts-map.mts'\nimport type { Remap } from '@socketsecurity/registry/lib/objects'\n\nexport const CMD_NAME = 'socket fix'\n\nexport function getAlertMapOptions(options: GetAlertsMapFromPurlsOptions = {}) {\n  return {\n    __proto__: null,\n    consolidate: true,\n    nothrow: true,\n    ...options,\n    include: {\n      __proto__: null,\n      existing: true,\n      unfixable: false,\n      upgradable: false,\n      ...options?.include\n    }\n  } as Remap<\n    Omit<GetAlertsMapFromPurlsOptions, 'include' | 'overrides' | 'spinner'> & {\n      include: Exclude<GetAlertsMapFromPurlsOptions['include'], undefined>\n    }\n  >\n}\n\nexport function normalizeFixOptions(\n  options_: FixOptions\n): NormalizedFixOptions {\n  const options = {\n    __proto__: null,\n    ...options_\n  } as FixOptions\n  if (typeof options.autopilot !== 'boolean') {\n    options.autopilot = false\n  }\n  if (typeof options.autoMerge !== 'boolean') {\n    options.autoMerge = !!options.autopilot\n  }\n  if (typeof options.cwd !== 'string') {\n    options.cwd = process.cwd()\n  }\n  const limit =\n    typeof options.limit === 'number'\n      ? options.limit\n      : parseInt(`${options.limit || ''}`, 10)\n\n  options.limit = Number.isNaN(limit) ? Infinity : limit\n\n  options.purls = Array.isArray(options.purls)\n    ? options.purls.flatMap(p => p.split(/, */))\n    : []\n\n  if (typeof options.rangeStyle !== 'string') {\n    options.rangeStyle = 'preserve'\n  }\n  if (typeof options.test !== 'boolean') {\n    options.test = !!options.autopilot || !!options.testScript\n  }\n  if (typeof options.testScript !== 'string') {\n    options.testScript = 'test'\n  }\n  return options as NormalizedFixOptions\n}\n","import path from 'node:path'\n\nimport { getManifestData } from '@socketsecurity/registry'\nimport { arrayUnique } from '@socketsecurity/registry/lib/arrays'\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { runScript } from '@socketsecurity/registry/lib/npm'\nimport {\n  fetchPackagePackument,\n  readPackageJson\n} from '@socketsecurity/registry/lib/packages'\n\nimport {\n  getBaseGitBranch,\n  getSocketBranchName,\n  getSocketCommitMessage,\n  gitCreateAndPushBranchIfNeeded,\n  gitResetAndClean\n} from './git.mts'\nimport {\n  cleanupOpenPrs,\n  enablePrAutoMerge,\n  getGitHubEnvRepoInfo,\n  openPr,\n  prExistForBranch\n} from './open-pr.mts'\nimport { getAlertMapOptions } from './shared.mts'\nimport constants from '../../constants.mts'\nimport {\n  Arborist,\n  SAFE_ARBORIST_REIFY_OPTIONS_OVERRIDES,\n  SafeArborist\n} from '../../shadow/npm/arborist/lib/arborist/index.mts'\nimport {\n  findBestPatchVersion,\n  findPackageNode,\n  findPackageNodes,\n  getAlertsMapFromArborist,\n  updateNode,\n  updatePackageJsonFromNode\n} from '../../shadow/npm/arborist-helpers.mts'\nimport { getAlertsMapFromPurls } from '../../utils/alerts-map.mts'\nimport { removeNodeModules } from '../../utils/fs.mts'\nimport { globWorkspace } from '../../utils/glob.mts'\nimport { applyRange } from '../../utils/semver.mts'\nimport { getCveInfoByAlertsMap } from '../../utils/socket-package-alert.mts'\nimport { idToPurl } from '../../utils/spec.mts'\n\nimport type { NormalizedFixOptions } from './types.mts'\nimport type { SafeNode } from '../../shadow/npm/arborist/lib/node.mts'\nimport type { EnvDetails } from '../../utils/package-environment.mts'\nimport type { PackageJson } from '@socketsecurity/registry/lib/packages'\n\nconst { DRY_RUN_NOT_SAVING, NPM } = constants\n\ntype InstallOptions = {\n  cwd?: string | undefined\n}\n\nasync function install(\n  idealTree: SafeNode,\n  options: InstallOptions\n): Promise<void> {\n  const { cwd = process.cwd() } = {\n    __proto__: null,\n    ...options\n  } as InstallOptions\n  const arb = new Arborist({ path: cwd })\n  arb.idealTree = idealTree\n  await arb.reify()\n}\n\nexport async function npmFix(\n  pkgEnvDetails: EnvDetails,\n  {\n    autoMerge,\n    cwd,\n    dryRun,\n    limit,\n    purls,\n    rangeStyle,\n    test,\n    testScript\n  }: NormalizedFixOptions\n) {\n  if (dryRun) {\n    logger.log(DRY_RUN_NOT_SAVING)\n    return\n  }\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n\n  spinner?.start()\n\n  const { pkgPath: rootPath } = pkgEnvDetails\n  const arb = new SafeArborist({\n    path: rootPath,\n    ...SAFE_ARBORIST_REIFY_OPTIONS_OVERRIDES\n  })\n  // Calling arb.reify() creates the arb.diff object and nulls-out arb.idealTree.\n  await arb.reify()\n\n  const alertsMap = purls.length\n    ? await getAlertsMapFromPurls(purls, getAlertMapOptions({ limit }))\n    : await getAlertsMapFromArborist(arb, getAlertMapOptions({ limit }))\n\n  const infoByPkg = getCveInfoByAlertsMap(alertsMap, { limit })\n  if (!infoByPkg) {\n    spinner?.stop()\n    logger.info('No fixable vulnerabilities found.')\n    return\n  }\n\n  // Lazily access constants.ENV.CI.\n  const isCi = constants.ENV.CI\n  const baseBranch = isCi ? getBaseGitBranch() : ''\n  const workspacePkgJsonPaths = await globWorkspace(\n    pkgEnvDetails.agent,\n    rootPath\n  )\n  const pkgJsonPaths = [\n    ...workspacePkgJsonPaths,\n    // Process the workspace root last since it will add an override to package.json.\n    pkgEnvDetails.editablePkgJson.filename!\n  ]\n\n  let count = 0\n  infoByPkgLoop: for (const { 0: name, 1: infos } of infoByPkg) {\n    debugLog(`Processing vulnerable package: ${name}`)\n\n    if (getManifestData(NPM, name)) {\n      spinner?.info(`Socket Optimize package for ${name} exists, skipping`)\n      continue\n    }\n    if (!infos.length) {\n      debugLog(`No vuln info found for ${name}`)\n      continue\n    }\n    // eslint-disable-next-line no-await-in-loop\n    const packument = await fetchPackagePackument(name)\n    if (!packument) {\n      debugLog(`No packument found for ${name}`)\n      continue\n    }\n\n    const availableVersions = Object.keys(packument.versions)\n    const fixedSpecs = new Set<string>()\n\n    for (const pkgJsonPath of pkgJsonPaths) {\n      const pkgPath = path.dirname(pkgJsonPath)\n      const isWorkspaceRoot =\n        pkgJsonPath === pkgEnvDetails.editablePkgJson.filename\n      const workspaceName = isWorkspaceRoot\n        ? 'root'\n        : path.relative(rootPath, pkgPath)\n\n      debugLog(`Checking workspace: ${workspaceName}`)\n\n      arb.idealTree = null\n      // eslint-disable-next-line no-await-in-loop\n      await arb.buildIdealTree()\n\n      const oldVersions = arrayUnique(\n        findPackageNodes(arb.idealTree!, name)\n          .map(n => n.target?.version ?? n.version)\n          .filter(Boolean)\n      )\n      if (!oldVersions.length) {\n        debugLog(`Lockfile entries not found for ${name}`)\n        continue\n      }\n\n      // Always re-read the editable package.json to avoid stale mutations\n      // across iterations.\n      // eslint-disable-next-line no-await-in-loop\n      const editablePkgJson = await readPackageJson(pkgJsonPath, {\n        editable: true\n      })\n\n      for (const oldVersion of oldVersions) {\n        const oldId = `${name}@${oldVersion}`\n        const oldPurl = idToPurl(oldId)\n\n        const node = findPackageNode(arb.idealTree!, name, oldVersion)\n        if (!node) {\n          debugLog(`Arborist node not found, skipping ${oldId}`)\n          continue\n        }\n\n        for (const {\n          firstPatchedVersionIdentifier,\n          vulnerableVersionRange\n        } of infos) {\n          const newVersion = findBestPatchVersion(\n            node,\n            availableVersions,\n            vulnerableVersionRange,\n            firstPatchedVersionIdentifier\n          )\n          const newVersionPackument = newVersion\n            ? packument.versions[newVersion]\n            : undefined\n\n          if (!(newVersion && newVersionPackument)) {\n            debugLog(\n              `No suitable update. ${oldId} needs >=${firstPatchedVersionIdentifier}, skipping`\n            )\n            continue\n          }\n\n          const newVersionRange = applyRange(oldVersion, newVersion, rangeStyle)\n          const newId = `${name}@${newVersionRange}`\n          const newSpecKey = `${workspaceName}:${newId}`\n\n          if (fixedSpecs.has(newSpecKey)) {\n            debugLog(`Already fixed ${newId} in ${workspaceName}, skipping`)\n            continue\n          }\n\n          const revertData = {\n            ...(editablePkgJson.content.dependencies && {\n              dependencies: { ...editablePkgJson.content.dependencies }\n            }),\n            ...(editablePkgJson.content.optionalDependencies && {\n              optionalDependencies: {\n                ...editablePkgJson.content.optionalDependencies\n              }\n            }),\n            ...(editablePkgJson.content.peerDependencies && {\n              peerDependencies: { ...editablePkgJson.content.peerDependencies }\n            })\n          } as PackageJson\n\n          updateNode(node, newVersion, newVersionPackument)\n          updatePackageJsonFromNode(\n            editablePkgJson,\n            arb.idealTree!,\n            node,\n            newVersion,\n            rangeStyle\n          )\n          // eslint-disable-next-line no-await-in-loop\n          if (!(await editablePkgJson.save({ ignoreWhitespace: true }))) {\n            debugLog(`Nothing changed for ${workspaceName}, skipping install`)\n            // Reset things just in case.\n            if (isCi) {\n              // eslint-disable-next-line no-await-in-loop\n              await gitResetAndClean(baseBranch, cwd)\n            }\n            continue\n          }\n\n          spinner?.info(`Installing ${newId} in ${workspaceName}`)\n\n          let error\n          let errored = false\n          try {\n            // eslint-disable-next-line no-await-in-loop\n            await install(arb.idealTree!, { cwd })\n            if (test) {\n              spinner?.info(`Testing ${newId} in ${workspaceName}`)\n              // eslint-disable-next-line no-await-in-loop\n              await runScript(testScript, [], { spinner, stdio: 'ignore' })\n            }\n            fixedSpecs.add(newSpecKey)\n            spinner?.successAndStop(`Fixed ${name} in ${workspaceName}`)\n            spinner?.start()\n          } catch (e) {\n            errored = true\n            error = e\n          }\n\n          if (!errored && isCi) {\n            const branch = getSocketBranchName(\n              oldPurl,\n              newVersion,\n              workspaceName\n            )\n            try {\n              const { owner, repo } = getGitHubEnvRepoInfo()\n              if (\n                // eslint-disable-next-line no-await-in-loop\n                (await prExistForBranch(owner, repo, branch)) ||\n                // eslint-disable-next-line no-await-in-loop\n                !(await gitCreateAndPushBranchIfNeeded(\n                  branch,\n                  getSocketCommitMessage(oldPurl, newVersion, workspaceName),\n                  cwd\n                ))\n              ) {\n                continue\n              }\n              // eslint-disable-next-line no-await-in-loop\n              await cleanupOpenPrs(owner, repo, oldPurl, newVersion, {\n                workspaceName\n              })\n              // eslint-disable-next-line no-await-in-loop\n              const prResponse = await openPr(\n                owner,\n                repo,\n                branch,\n                oldPurl,\n                newVersion,\n                {\n                  baseBranch,\n                  cwd,\n                  workspaceName\n                }\n              )\n              if (prResponse) {\n                const { data } = prResponse\n                spinner?.info(`Opened PR #${data.number}.`)\n                if (autoMerge) {\n                  // eslint-disable-next-line no-await-in-loop\n                  await enablePrAutoMerge(data)\n                }\n              }\n            } catch (e) {\n              error = e\n              errored = true\n            }\n          }\n\n          if (isCi) {\n            // eslint-disable-next-line no-await-in-loop\n            await gitResetAndClean(baseBranch, cwd)\n            // eslint-disable-next-line no-await-in-loop\n            await install(arb.idealTree!, { cwd })\n          }\n          if (errored) {\n            if (!isCi) {\n              editablePkgJson.update(revertData)\n              // eslint-disable-next-line no-await-in-loop\n              await Promise.all([\n                removeNodeModules(cwd),\n                editablePkgJson.save({ ignoreWhitespace: true })\n              ])\n              // eslint-disable-next-line no-await-in-loop\n              await install(arb.idealTree!, { cwd })\n            }\n            spinner?.failAndStop(\n              `Update failed for ${oldId} in ${workspaceName}`,\n              error\n            )\n          }\n          if (++count >= limit) {\n            break infoByPkgLoop\n          }\n        }\n      }\n    }\n  }\n\n  spinner?.stop()\n}\n","import path from 'node:path'\n\nimport { readWantedLockfile } from '@pnpm/lockfile.fs'\n\nimport { getManifestData } from '@socketsecurity/registry'\nimport { arrayUnique } from '@socketsecurity/registry/lib/arrays'\nimport { debugLog, isDebug } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { runScript } from '@socketsecurity/registry/lib/npm'\nimport {\n  fetchPackagePackument,\n  readPackageJson\n} from '@socketsecurity/registry/lib/packages'\n\nimport {\n  getBaseGitBranch,\n  getSocketBranchName,\n  getSocketCommitMessage,\n  gitCreateAndPushBranchIfNeeded,\n  gitResetAndClean\n} from './git.mts'\nimport {\n  cleanupOpenPrs,\n  enablePrAutoMerge,\n  getGitHubEnvRepoInfo,\n  openPr,\n  prExistForBranch\n} from './open-pr.mts'\nimport { getAlertMapOptions } from './shared.mts'\nimport constants from '../../constants.mts'\nimport {\n  SAFE_ARBORIST_REIFY_OPTIONS_OVERRIDES,\n  SafeArborist\n} from '../../shadow/npm/arborist/lib/arborist/index.mts'\nimport {\n  findBestPatchVersion,\n  findPackageNode,\n  findPackageNodes,\n  updatePackageJsonFromNode\n} from '../../shadow/npm/arborist-helpers.mts'\nimport { runAgentInstall } from '../../utils/agent.mts'\nimport {\n  getAlertsMapFromPnpmLockfile,\n  getAlertsMapFromPurls\n} from '../../utils/alerts-map.mts'\nimport { removeNodeModules } from '../../utils/fs.mts'\nimport { globWorkspace } from '../../utils/glob.mts'\nimport { parsePnpmLockfileVersion } from '../../utils/pnpm.mts'\nimport { applyRange } from '../../utils/semver.mts'\nimport { getCveInfoByAlertsMap } from '../../utils/socket-package-alert.mts'\nimport { idToPurl } from '../../utils/spec.mts'\n\nimport type { NormalizedFixOptions } from './types.mts'\nimport type { SafeNode } from '../../shadow/npm/arborist/lib/node.mts'\nimport type { StringKeyValueObject } from '../../types.mts'\nimport type { EnvDetails } from '../../utils/package-environment.mts'\nimport type { LockfileObject } from '@pnpm/lockfile.fs'\nimport type { PackageJson } from '@socketsecurity/registry/lib/packages'\nimport type { Spinner } from '@socketsecurity/registry/lib/spinner'\n\nconst { DRY_RUN_NOT_SAVING, NPM, OVERRIDES, PNPM } = constants\n\nasync function getActualTree(cwd: string = process.cwd()): Promise<SafeNode> {\n  const arb = new SafeArborist({\n    path: cwd,\n    ...SAFE_ARBORIST_REIFY_OPTIONS_OVERRIDES\n  })\n  return await arb.loadActual()\n}\n\ntype InstallOptions = {\n  args?: string[] | undefined\n  cwd?: string | undefined\n  spinner?: Spinner | undefined\n}\n\nasync function install(\n  pkgEnvDetails: EnvDetails,\n  options: InstallOptions\n): Promise<SafeNode> {\n  const { args, cwd, spinner } = {\n    __proto__: null,\n    ...options\n  } as InstallOptions\n  await runAgentInstall(pkgEnvDetails, {\n    args: [...(args ?? []), '--no-frozen-lockfile'],\n    spinner,\n    stdio: isDebug() ? 'inherit' : 'ignore'\n  })\n  return await getActualTree(cwd)\n}\n\nasync function readLockfile(pkgPath: string): Promise<LockfileObject | null> {\n  return await readWantedLockfile(pkgPath, {\n    ignoreIncompatible: false\n  })\n}\n\nexport async function pnpmFix(\n  pkgEnvDetails: EnvDetails,\n  {\n    autoMerge,\n    cwd,\n    dryRun,\n    limit,\n    purls,\n    rangeStyle,\n    test,\n    testScript\n  }: NormalizedFixOptions\n) {\n  if (dryRun) {\n    logger.log(DRY_RUN_NOT_SAVING)\n    return\n  }\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n  const { pkgPath: rootPath } = pkgEnvDetails\n\n  spinner?.start()\n\n  let lockfile = await readLockfile(rootPath)\n\n  // If pnpm-lock.yaml does NOT exist then install with pnpm to create it.\n  if (!lockfile) {\n    await install(pkgEnvDetails, { cwd, spinner })\n    lockfile = await readLockfile(rootPath)\n  }\n  // Update pnpm-lock.yaml if its version is older than what the installed pnpm\n  // produces.\n  if (\n    lockfile &&\n    pkgEnvDetails.agentVersion.major >= 10 &&\n    parsePnpmLockfileVersion(lockfile.lockfileVersion).major <= 6\n  ) {\n    await install(pkgEnvDetails, { args: ['--lockfile-only'], cwd, spinner })\n    lockfile = await readLockfile(rootPath)\n  }\n  // Exit early if pnpm-lock.yaml is not found.\n  if (!lockfile) {\n    spinner?.stop()\n    logger.error('Required pnpm-lock.yaml not found.')\n    return\n  }\n\n  const alertsMap = purls.length\n    ? await getAlertsMapFromPurls(purls, getAlertMapOptions({ limit }))\n    : await getAlertsMapFromPnpmLockfile(\n        lockfile,\n        getAlertMapOptions({ limit })\n      )\n\n  const infoByPkg = getCveInfoByAlertsMap(alertsMap, { limit })\n  if (!infoByPkg) {\n    spinner?.stop()\n    logger.info('No fixable vulnerabilities found.')\n    return\n  }\n\n  // Lazily access constants.ENV.CI.\n  const isCi = constants.ENV.CI\n  const baseBranch = isCi ? getBaseGitBranch() : ''\n  const workspacePkgJsonPaths = await globWorkspace(\n    pkgEnvDetails.agent,\n    rootPath\n  )\n  const pkgJsonPaths = [\n    ...workspacePkgJsonPaths,\n    // Process the workspace root last since it will add an override to package.json.\n    pkgEnvDetails.editablePkgJson.filename!\n  ]\n\n  let count = 0\n  infoByPkgLoop: for (const { 0: name, 1: infos } of infoByPkg) {\n    debugLog(`Processing vulnerable package: ${name}`)\n\n    if (getManifestData(NPM, name)) {\n      spinner?.info(`Socket Optimize package for ${name} exists, skipping`)\n      continue\n    }\n    if (!infos.length) {\n      debugLog(`No vuln info found for ${name}`)\n      continue\n    }\n    // eslint-disable-next-line no-await-in-loop\n    const packument = await fetchPackagePackument(name)\n    if (!packument) {\n      debugLog(`No packument found for ${name}`)\n      continue\n    }\n\n    const availableVersions = Object.keys(packument.versions)\n    const fixedSpecs = new Set<string>()\n\n    for (const pkgJsonPath of pkgJsonPaths) {\n      const pkgPath = path.dirname(pkgJsonPath)\n      const isWorkspaceRoot =\n        pkgJsonPath === pkgEnvDetails.editablePkgJson.filename\n      const workspaceName = isWorkspaceRoot\n        ? 'root'\n        : path.relative(rootPath, pkgPath)\n\n      debugLog(`Checking workspace: ${workspaceName}`)\n\n      // eslint-disable-next-line no-await-in-loop\n      let actualTree = await getActualTree(cwd)\n\n      const oldVersions = arrayUnique(\n        findPackageNodes(actualTree, name)\n          .map(n => n.target?.version ?? n.version)\n          .filter(Boolean)\n      )\n      if (!oldVersions.length) {\n        debugLog(`Lockfile entries not found for ${name}`)\n        continue\n      }\n\n      // Always re-read the editable package.json to avoid stale mutations\n      // across iterations.\n      // eslint-disable-next-line no-await-in-loop\n      const editablePkgJson = await readPackageJson(pkgJsonPath, {\n        editable: true\n      })\n      // Get current overrides for revert logic\n      const oldPnpmSection = editablePkgJson.content[PNPM] as\n        | StringKeyValueObject\n        | undefined\n      const oldOverrides = oldPnpmSection?.[OVERRIDES] as\n        | Record<string, string>\n        | undefined\n\n      for (const oldVersion of oldVersions) {\n        const oldId = `${name}@${oldVersion}`\n        const oldPurl = idToPurl(oldId)\n\n        const node = findPackageNode(actualTree, name, oldVersion)\n        if (!node) {\n          debugLog(`Arborist node not found, skipping ${oldId}`)\n          continue\n        }\n\n        for (const {\n          firstPatchedVersionIdentifier,\n          vulnerableVersionRange\n        } of infos) {\n          const newVersion = findBestPatchVersion(\n            node,\n            availableVersions,\n            vulnerableVersionRange,\n            firstPatchedVersionIdentifier\n          )\n          const newVersionPackument = newVersion\n            ? packument.versions[newVersion]\n            : undefined\n\n          if (!(newVersion && newVersionPackument)) {\n            debugLog(\n              `No suitable update. ${oldId} needs >=${firstPatchedVersionIdentifier}, skipping`\n            )\n            continue\n          }\n\n          const overrideKey = `${name}@${vulnerableVersionRange}`\n          const newVersionRange = applyRange(\n            oldOverrides?.[overrideKey] ?? oldVersion,\n            newVersion,\n            rangeStyle\n          )\n          const newId = `${name}@${newVersionRange}`\n          const newSpecKey = `${workspaceName}:${newId}`\n\n          if (fixedSpecs.has(newSpecKey)) {\n            debugLog(`Already fixed ${newId} in ${workspaceName}, skipping`)\n            continue\n          }\n\n          const updateData = isWorkspaceRoot\n            ? ({\n                [PNPM]: {\n                  ...oldPnpmSection,\n                  [OVERRIDES]: {\n                    ...oldOverrides,\n                    [overrideKey]: newVersionRange\n                  }\n                }\n              } as PackageJson)\n            : undefined\n\n          const revertData = {\n            ...(isWorkspaceRoot\n              ? {\n                  [PNPM]: {\n                    ...oldPnpmSection,\n                    [OVERRIDES]:\n                      oldOverrides && Object.keys(oldOverrides).length > 1\n                        ? {\n                            ...oldOverrides,\n                            [overrideKey]: undefined\n                          }\n                        : undefined\n                  }\n                }\n              : {}),\n            ...(editablePkgJson.content.dependencies && {\n              dependencies: { ...editablePkgJson.content.dependencies }\n            }),\n            ...(editablePkgJson.content.optionalDependencies && {\n              optionalDependencies: {\n                ...editablePkgJson.content.optionalDependencies\n              }\n            }),\n            ...(editablePkgJson.content.peerDependencies && {\n              peerDependencies: { ...editablePkgJson.content.peerDependencies }\n            })\n          } as PackageJson\n\n          if (updateData) {\n            editablePkgJson.update(updateData)\n          }\n          updatePackageJsonFromNode(\n            editablePkgJson,\n            actualTree,\n            node,\n            newVersion,\n            rangeStyle\n          )\n          // eslint-disable-next-line no-await-in-loop\n          if (!(await editablePkgJson.save({ ignoreWhitespace: true }))) {\n            debugLog(`Nothing changed for ${workspaceName}, skipping install`)\n            // Reset things just in case.\n            if (isCi) {\n              // eslint-disable-next-line no-await-in-loop\n              await gitResetAndClean(baseBranch, cwd)\n            }\n            continue\n          }\n\n          spinner?.info(`Installing ${newId} in ${workspaceName}`)\n\n          let error\n          let errored = false\n          try {\n            // eslint-disable-next-line no-await-in-loop\n            actualTree = await install(pkgEnvDetails, { cwd, spinner })\n            if (test) {\n              spinner?.info(`Testing ${newId} in ${workspaceName}`)\n              // eslint-disable-next-line no-await-in-loop\n              await runScript(testScript, [], { spinner, stdio: 'ignore' })\n            }\n            fixedSpecs.add(newSpecKey)\n            spinner?.successAndStop(`Fixed ${name} in ${workspaceName}`)\n            spinner?.start()\n          } catch (e) {\n            error = e\n            errored = true\n          }\n\n          if (!errored && isCi) {\n            const branch = getSocketBranchName(\n              oldPurl,\n              newVersion,\n              workspaceName\n            )\n            try {\n              const { owner, repo } = getGitHubEnvRepoInfo()\n              if (\n                // eslint-disable-next-line no-await-in-loop\n                (await prExistForBranch(owner, repo, branch)) ||\n                // eslint-disable-next-line no-await-in-loop\n                !(await gitCreateAndPushBranchIfNeeded(\n                  branch,\n                  getSocketCommitMessage(oldPurl, newVersion, workspaceName),\n                  cwd\n                ))\n              ) {\n                continue\n              }\n              // eslint-disable-next-line no-await-in-loop\n              await cleanupOpenPrs(owner, repo, oldPurl, newVersion, {\n                workspaceName\n              })\n              // eslint-disable-next-line no-await-in-loop\n              const prResponse = await openPr(\n                owner,\n                repo,\n                branch,\n                oldPurl,\n                newVersion,\n                {\n                  baseBranch,\n                  cwd,\n                  workspaceName\n                }\n              )\n              if (prResponse) {\n                const { data } = prResponse\n                spinner?.info(`Opened PR #${data.number}.`)\n                if (autoMerge) {\n                  // eslint-disable-next-line no-await-in-loop\n                  await enablePrAutoMerge(data)\n                }\n              }\n            } catch (e) {\n              error = e\n              errored = true\n            }\n          }\n\n          if (isCi) {\n            // eslint-disable-next-line no-await-in-loop\n            await gitResetAndClean(baseBranch, cwd)\n            // eslint-disable-next-line no-await-in-loop\n            actualTree = await install(pkgEnvDetails, { cwd, spinner })\n          }\n          if (errored) {\n            if (!isCi) {\n              editablePkgJson.update(revertData)\n              // eslint-disable-next-line no-await-in-loop\n              await Promise.all([\n                removeNodeModules(cwd),\n                editablePkgJson.save({ ignoreWhitespace: true })\n              ])\n              // eslint-disable-next-line no-await-in-loop\n              actualTree = await install(pkgEnvDetails, { cwd, spinner })\n            }\n            spinner?.failAndStop(\n              `Update failed for ${oldId} in ${workspaceName}`,\n              error\n            )\n          }\n          if (++count >= limit) {\n            break infoByPkgLoop\n          }\n        }\n      }\n    }\n  }\n\n  spinner?.stop()\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { npmFix } from './npm-fix.mts'\nimport { pnpmFix } from './pnpm-fix.mts'\nimport { CMD_NAME, normalizeFixOptions } from './shared.mts'\nimport constants from '../../constants.mts'\nimport { detectAndValidatePackageEnvironment } from '../../utils/package-environment.mts'\n\nimport type { FixOptions } from './types.mts'\n\nconst { NPM, PNPM } = constants\n\nexport async function runFix(options_: FixOptions) {\n  const options = normalizeFixOptions(options_)\n  const pkgEnvDetails = await detectAndValidatePackageEnvironment(options.cwd, {\n    cmdName: CMD_NAME,\n    logger\n  })\n  if (!pkgEnvDetails) {\n    return\n  }\n  logger.info(`Fixing packages for ${pkgEnvDetails.agent}`)\n  const { agent } = pkgEnvDetails\n  if (agent === NPM) {\n    await npmFix(pkgEnvDetails, options)\n  } else if (agent === PNPM) {\n    await pnpmFix(pkgEnvDetails, options)\n  }\n}\n","import terminalLink from 'terminal-link'\n\nimport { joinOr } from '@socketsecurity/registry/lib/arrays'\n\nimport { runFix } from './run-fix.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { RangeStyles } from '../../utils/semver.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\nimport type { RangeStyle } from '../../utils/semver.mts'\n\nconst config: CliCommandConfig = {\n  commandName: 'fix',\n  description: 'Update dependencies with \"fixable\" Socket alerts',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    autoMerge: {\n      type: 'boolean',\n      default: false,\n      description: `Enable auto-merge for pull requests that Socket opens.\\n                        See ${terminalLink(\n        'GitHub documentation',\n        'https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-auto-merge-for-pull-requests-in-your-repository'\n      )} for managing auto-merge for pull requests in your repository.`\n    },\n    autopilot: {\n      type: 'boolean',\n      default: false,\n      description: `Shorthand for --autoMerge --test`\n    },\n    limit: {\n      type: 'number',\n      default: Infinity,\n      description: 'The number of fixes to attempt at a time'\n    },\n    purl: {\n      type: 'string',\n      default: [],\n      description: `Provide a list of ${terminalLink(\n        'package URLs',\n        'https://github.com/package-url/purl-spec?tab=readme-ov-file#purl'\n      )} (PURLs) to fix, as either a comma separated value or as multiple flags,\\n                        instead of querying the Socket API`,\n      isMultiple: true,\n      shortFlag: 'p'\n    },\n    rangeStyle: {\n      type: 'string',\n      default: 'preserve',\n      description: `\n                        Define how updated dependency versions should be written in package.json.\n                        Available styles:\n                          * caret - Use ^ range for compatible updates (e.g. ^1.2.3)\n                          * gt - Use > to allow any newer version (e.g. >1.2.3)\n                          * gte - Use >= to allow any newer version (e.g. >=1.2.3)\n                          * lt - Use < to allow only lower versions (e.g. <1.2.3)\n                          * lte - Use <= to allow only lower versions (e.g. <=1.2.3)\n                          * pin - Use the exact version (e.g. 1.2.3)\n                          * preserve - Retain the existing version range style as-is\n                          * tilde - Use ~ range for patch/minor updates (e.g. ~1.2.3)\n      `.trim()\n    },\n    test: {\n      type: 'boolean',\n      default: false,\n      description: 'Verify the fix by running unit tests'\n    },\n    testScript: {\n      type: 'string',\n      default: 'test',\n      description: 'The test script to run for each fix attempt'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n  `\n}\n\nexport const cmdFix = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n\n  const wasValidInput = checkCommandInput(outputKind, {\n    test: RangeStyles.includes(cli.flags['rangeStyle'] as string),\n    message: `Expecting range style of ${joinOr(RangeStyles)}`,\n    pass: 'ok',\n    fail: 'missing'\n  })\n  if (!wasValidInput) {\n    return\n  }\n\n  await runFix({\n    autoMerge: Boolean(cli.flags['autoMerge']),\n    autopilot: Boolean(cli.flags['autopilot']),\n    limit: Number(cli.flags['limit']),\n    dryRun: Boolean(cli.flags['dryRun']),\n    purls: Array.isArray(cli.flags['purl']) ? cli.flags['purl'] : [],\n    rangeStyle: (cli.flags['rangeStyle'] ?? undefined) as\n      | RangeStyle\n      | undefined,\n    test: Boolean(cli.flags['test']),\n    testScript: cli.flags['testScript'] as string | undefined\n  })\n}\n","import { getSeverityCount } from '../../utils/alert/severity.mts'\nimport {\n  handleApiCall,\n  handleUnsuccessfulApiResponse\n} from '../../utils/api.mts'\nimport { getPublicToken, setupSdk } from '../../utils/sdk.mts'\n\nimport type { PackageData } from './handle-package-info.mts'\n\nexport async function fetchPackageInfo(\n  pkgName: string,\n  pkgVersion: string,\n  includeAllIssues: boolean\n): Promise<void | PackageData> {\n  const sockSdkResult = await setupSdk(getPublicToken())\n  if (!sockSdkResult.ok) {\n    throw new Error('Was unable to setup sdk. Run `socket login` first.')\n  }\n  const sockSdk = sockSdkResult.data\n\n  const result = await handleApiCall(\n    sockSdk.getIssuesByNPMPackage(pkgName, pkgVersion),\n    'package issues'\n  )\n  const scoreResult = await handleApiCall(\n    sockSdk.getScoreByNPMPackage(pkgName, pkgVersion),\n    'package score'\n  )\n\n  if (!result.ok) {\n    handleUnsuccessfulApiResponse(\n      'getIssuesByNPMPackage',\n      result.message,\n      result.cause ?? '',\n      (result.data as any)?.code ?? 0\n    )\n  }\n\n  if (!scoreResult.ok) {\n    handleUnsuccessfulApiResponse(\n      'getScoreByNPMPackage',\n      scoreResult.message,\n      scoreResult.cause ?? '',\n      (scoreResult.data as any)?.code ?? 0\n    )\n  }\n\n  const severityCount = getSeverityCount(\n    result.data,\n    includeAllIssues ? undefined : 'high'\n  )\n\n  return {\n    data: result.data,\n    severityCount,\n    score: scoreResult.data\n  }\n}\n","import colors from 'yoctocolors-cjs'\n\nimport constants from '@socketsecurity/registry/lib/constants'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { hasKeys } from '@socketsecurity/registry/lib/objects'\n\nimport {\n  ALERT_SEVERITY,\n  formatSeverityCount\n} from '../../utils/alert/severity.mts'\nimport { ColorOrMarkdown } from '../../utils/color-or-markdown.mts'\nimport {\n  getSocketDevAlertUrl,\n  getSocketDevPackageOverviewUrl\n} from '../../utils/socket-url.mts'\n\nimport type { PackageData } from './handle-package-info.mts'\nimport type { OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nconst { NPM } = constants\n\nfunction formatScore(score: number): string {\n  if (score > 80) {\n    return colors.green(`${score}`)\n  } else if (score < 80 && score > 60) {\n    return colors.yellow(`${score}`)\n  }\n  return colors.red(`${score}`)\n}\n\nfunction outputPackageIssuesDetails(\n  packageData: SocketSdkReturnType<'getIssuesByNPMPackage'>['data'],\n  outputMarkdown: boolean\n) {\n  const issueDetails = packageData.filter(\n    d =>\n      d.value?.severity === ALERT_SEVERITY.critical ||\n      d.value?.severity === ALERT_SEVERITY.high\n  )\n  const uniqueIssueDetails = issueDetails.reduce((acc, issue) => {\n    const { type } = issue\n    if (type) {\n      const details = acc.get(type)\n      if (details) {\n        details.count += 1\n      } else {\n        acc.set(type, {\n          label: issue.value?.label ?? '',\n          count: 1\n        })\n      }\n    }\n    return acc\n  }, new Map<string, { count: number; label: string }>())\n  const format = new ColorOrMarkdown(outputMarkdown)\n  for (const [type, details] of uniqueIssueDetails.entries()) {\n    const issueWithLink = format.hyperlink(\n      details.label,\n      getSocketDevAlertUrl(type),\n      { fallbackToUrl: true }\n    )\n    if (details.count === 1) {\n      logger.log(`- ${issueWithLink}`)\n    } else {\n      logger.log(`- ${issueWithLink}: ${details.count}`)\n    }\n  }\n}\n\nexport function outputPackageInfo(\n  { data, score, severityCount }: PackageData,\n  {\n    commandName,\n    outputKind,\n    pkgName,\n    pkgVersion\n  }: {\n    commandName: string\n    outputKind: OutputKind\n    pkgName: string\n    pkgVersion: string\n    includeAllIssues?: boolean | undefined\n  }\n): void {\n  if (outputKind === 'json') {\n    logger.log(JSON.stringify(data, undefined, 2))\n    return\n  }\n  if (outputKind === 'markdown') {\n    logger.log(\n      `\n# Package report for ${pkgName}\n\nPackage report card:\n    `.trim()\n    )\n  } else {\n    logger.log(`Package report card for ${pkgName}:`)\n  }\n  const scoreResult = {\n    'Supply Chain Risk': Math.floor(score.supplyChainRisk.score * 100),\n    Maintenance: Math.floor(score.maintenance.score * 100),\n    Quality: Math.floor(score.quality.score * 100),\n    Vulnerabilities: Math.floor(score.vulnerability.score * 100),\n    License: Math.floor(score.license.score * 100)\n  }\n  logger.log('\\n')\n  Object.entries(scoreResult).map(score =>\n    logger.log(`- ${score[0]}: ${formatScore(score[1])}`)\n  )\n  logger.log('\\n')\n  if (hasKeys(severityCount)) {\n    if (outputKind === 'markdown') {\n      logger.log('# Issues\\n')\n    }\n    logger.log(\n      `Package has these issues: ${formatSeverityCount(severityCount)}\\n`\n    )\n    outputPackageIssuesDetails(data, outputKind === 'markdown')\n  } else {\n    logger.log('Package has no issues')\n  }\n\n  const format = new ColorOrMarkdown(outputKind === 'markdown')\n  const url = getSocketDevPackageOverviewUrl(NPM, pkgName, pkgVersion)\n\n  logger.log('\\n')\n  if (pkgVersion === 'latest') {\n    logger.log(\n      `Detailed info on socket.dev: ${format.hyperlink(`${pkgName}`, url, { fallbackToUrl: true })}`\n    )\n  } else {\n    logger.log(\n      `Detailed info on socket.dev: ${format.hyperlink(`${pkgName} v${pkgVersion}`, url, { fallbackToUrl: true })}`\n    )\n  }\n  if (outputKind !== 'markdown') {\n    logger.log(\n      colors.dim(\n        `\\nOr rerun ${colors.italic(commandName)} using the ${colors.italic('--json')} flag to get full JSON output`\n      )\n    )\n  } else {\n    logger.log('')\n  }\n}\n","import { hasKeys } from '@socketsecurity/registry/lib/objects'\n\nimport { fetchPackageInfo } from './fetch-package-info.mts'\nimport { outputPackageInfo } from './output-package-info.mts'\n\nimport type { OutputKind } from '../../types.mts'\nimport type { SocketSdkAlert } from '../../utils/alert/severity.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport interface PackageData {\n  data: SocketSdkReturnType<'getIssuesByNPMPackage'>['data']\n  severityCount: Record<SocketSdkAlert['severity'], number>\n  score: SocketSdkReturnType<'getScoreByNPMPackage'>['data']\n}\n\nexport async function handlePackageInfo({\n  commandName,\n  includeAllIssues,\n  outputKind,\n  pkgName,\n  pkgVersion,\n  strict\n}: {\n  commandName: string\n  includeAllIssues: boolean\n  outputKind: OutputKind\n  pkgName: string\n  pkgVersion: string\n  strict: boolean\n}) {\n  const packageData = await fetchPackageInfo(\n    pkgName,\n    pkgVersion,\n    includeAllIssues\n  )\n\n  if (packageData) {\n    outputPackageInfo(packageData, {\n      commandName,\n      includeAllIssues,\n      outputKind,\n      pkgName,\n      pkgVersion\n    })\n\n    if (strict && hasKeys(packageData.severityCount)) {\n      // Let NodeJS exit gracefully but with exit(1)\n      process.exitCode = 1\n    }\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handlePackageInfo } from './handle-package-info.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags, validationFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'info',\n  description: 'Look up info regarding a package',\n  hidden: true, // Deprecated\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    ...validationFlags\n  },\n  help: (command, config) =>\n    isTestingV1()\n      ? 'This command will be removed in v1'\n      : `\n    Usage\n      $ ${command} <name>\n\n    Note: this command will be deprecated in favor of \\`socket package score\\` soon\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} webtorrent\n      $ ${command} webtorrent@1.9.1\n  `\n}\n\nexport const cmdInfo = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { all, json, markdown, strict } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [rawPkgName = ''] = cli.input\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: !!rawPkgName,\n      message: 'Expecting a package name',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: cli.input.length === 1,\n      message: 'Can only accept one package at a time',\n      pass: 'ok',\n      fail: 'got ' + cli.input.length\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  const versionSeparator = rawPkgName.lastIndexOf('@')\n  const pkgName =\n    versionSeparator < 1 ? rawPkgName : rawPkgName.slice(0, versionSeparator)\n  const pkgVersion =\n    versionSeparator < 1 ? 'latest' : rawPkgName.slice(versionSeparator + 1)\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handlePackageInfo({\n    commandName: `${parentName} ${config.commandName}`,\n    includeAllIssues: Boolean(all),\n    outputKind,\n    pkgName,\n    pkgVersion,\n    strict: Boolean(strict)\n  })\n}\n","import { updateConfigValue } from '../../utils/config.mts'\n\nexport function applyLogin(\n  apiToken: string,\n  enforcedOrgs: string[],\n  apiBaseUrl: string | undefined,\n  apiProxy: string | undefined\n) {\n  updateConfigValue('enforcedOrgs', enforcedOrgs)\n  updateConfigValue('apiToken', apiToken)\n  updateConfigValue('apiBaseUrl', apiBaseUrl)\n  updateConfigValue('apiProxy', apiProxy)\n}\n","import terminalLink from 'terminal-link'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { confirm, password, select } from '@socketsecurity/registry/lib/prompts'\n\nimport { applyLogin } from './apply-login.mts'\nimport constants from '../../constants.mts'\nimport { handleApiCall } from '../../utils/api.mts'\nimport { getConfigValueOrUndef, isReadOnlyConfig } from '../../utils/config.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { Choice, Separator } from '@socketsecurity/registry/lib/prompts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\ntype OrgChoice = Choice<string>\ntype OrgChoices = Array<Separator | OrgChoice>\nconst { SOCKET_PUBLIC_API_TOKEN } = constants\n\nexport async function attemptLogin(\n  apiBaseUrl: string | undefined,\n  apiProxy: string | undefined\n) {\n  apiBaseUrl ??= getConfigValueOrUndef('apiBaseUrl') ?? undefined\n  apiProxy ??= getConfigValueOrUndef('apiProxy') ?? undefined\n  const apiToken =\n    (await password({\n      message: `Enter your ${terminalLink(\n        'Socket.dev API key',\n        'https://docs.socket.dev/docs/api-keys'\n      )} (leave blank for a public key)`\n    })) || SOCKET_PUBLIC_API_TOKEN\n\n  const sdk = await setupSdk(apiToken, apiBaseUrl, apiProxy)\n  if (!sdk.ok) {\n    process.exitCode = 1\n    logger.fail(failMsgWithBadge(sdk.message, sdk.cause))\n    return\n  }\n\n  const result = await handleApiCall(\n    sdk.data.getOrganizations(),\n    'token verification'\n  )\n\n  if (!result.ok) {\n    process.exitCode = 1\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.success('API key verified')\n\n  const orgs: SocketSdkReturnType<'getOrganizations'>['data'] = result.data\n\n  const enforcedChoices: OrgChoices = Object.values(orgs.organizations)\n    .filter(org => org?.plan === 'enterprise')\n    .map(org => ({\n      name: org.name ?? 'undefined',\n      value: org.id\n    }))\n\n  let enforcedOrgs: string[] = []\n  if (enforcedChoices.length > 1) {\n    const id = (await select({\n      message:\n        \"Which organization's policies should Socket enforce system-wide?\",\n      choices: enforcedChoices.concat({\n        name: 'None',\n        value: '',\n        description: 'Pick \"None\" if this is a personal device'\n      })\n    })) as string | null\n    if (id) {\n      enforcedOrgs = [id]\n    }\n  } else if (enforcedChoices.length) {\n    if (\n      await confirm({\n        message: `Should Socket enforce ${(enforcedChoices[0] as OrgChoice)?.name}'s security policies system-wide?`,\n        default: true\n      })\n    ) {\n      const existing = enforcedChoices[0] as OrgChoice\n      if (existing) {\n        enforcedOrgs = [existing.value]\n      }\n    }\n  }\n\n  const previousPersistedToken = getConfigValueOrUndef('apiToken')\n  try {\n    applyLogin(apiToken, enforcedOrgs, apiBaseUrl, apiProxy)\n    logger.success(\n      `API credentials ${previousPersistedToken === apiToken ? 'refreshed' : previousPersistedToken ? 'updated' : 'set'}`\n    )\n    if (isReadOnlyConfig()) {\n      logger.log('')\n      logger.warn(\n        'Note: config is in read-only mode, at least one key was overridden through flag/env, so the login was not persisted!'\n      )\n    }\n  } catch {\n    process.exitCode = 1\n    logger.fail(`API login failed`)\n  }\n}\n","import isInteractive from '@socketregistry/is-interactive/index.cjs'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { attemptLogin } from './attempt-login.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { InputError } from '../../utils/errors.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'login',\n  description: 'Socket API login',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    apiBaseUrl: {\n      type: 'string',\n      description: 'API server to connect to for login'\n    },\n    apiProxy: {\n      type: 'string',\n      description: 'Proxy to use when making connection to API server'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}\n\n    API Token Requirements\n      - Quota: 1 unit\n\n    Logs into the Socket API by prompting for an API key\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}\n      $ ${command} --api-proxy=http://localhost:1234\n  `\n}\n\nexport const cmdLogin = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const apiBaseUrl = cli.flags['apiBaseUrl'] as string | undefined\n  const apiProxy = cli.flags['apiProxy'] as string | undefined\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  if (!isInteractive()) {\n    throw new InputError(\n      'Cannot prompt for credentials in a non-interactive shell'\n    )\n  }\n\n  await attemptLogin(apiBaseUrl, apiProxy)\n}\n","import { updateConfigValue } from '../../utils/config.mts'\n\nexport function applyLogout() {\n  updateConfigValue('apiToken', null)\n  updateConfigValue('apiBaseUrl', null)\n  updateConfigValue('apiProxy', null)\n  updateConfigValue('enforcedOrgs', null)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { applyLogout } from './apply-logout.mts'\nimport { isReadOnlyConfig } from '../../utils/config.mts'\n\nexport function attemptLogout() {\n  try {\n    applyLogout()\n    logger.success('Successfully logged out')\n    if (isReadOnlyConfig()) {\n      logger.log('')\n      logger.warn(\n        'Note: config is in read-only mode, at least one key was overridden through flag/env, so the logout was not persisted!'\n      )\n    }\n  } catch {\n    logger.fail('Failed to complete logout steps')\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { attemptLogout } from './attempt-logout.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'logout',\n  description: 'Socket API logout',\n  hidden: false,\n  flags: {\n    ...commonFlags\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}\n\n    Logs out of the Socket API and clears all Socket credentials from disk\n  `\n}\n\nexport const cmdLogout = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  attemptLogout()\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport type { CResult } from '../../types.mts'\n\nexport async function convertCondaToRequirements(\n  target: string,\n  cwd: string,\n  verbose: boolean\n): Promise<CResult<{ contents: string; pip: string }>> {\n  let contents: string\n  if (target === '-') {\n    if (verbose) {\n      logger.error(`[VERBOSE] reading input from stdin`)\n    }\n\n    const buf: string[] = []\n    contents = await new Promise((resolve, reject) => {\n      process.stdin.on('data', chunk => {\n        const input = chunk.toString()\n        buf.push(input)\n      })\n      process.stdin.on('end', () => {\n        resolve(buf.join(''))\n      })\n      process.stdin.on('error', e => {\n        if (verbose) {\n          logger.error('Unexpected error while reading from stdin:', e)\n        }\n        reject(e)\n      })\n      process.stdin.on('close', () => {\n        if (buf.length === 0) {\n          if (verbose) {\n            logger.error('stdin closed explicitly without data received')\n          }\n          reject(new Error('No data received from stdin'))\n        } else {\n          if (verbose) {\n            logger.error(\n              'warning: stdin closed explicitly with some data received'\n            )\n          }\n          resolve(buf.join(''))\n        }\n      })\n    })\n\n    if (!contents) {\n      return {\n        ok: false,\n        message: 'Manifest Generation Failed',\n        cause: 'No data received from stdin'\n      }\n    }\n  } else {\n    const f = path.resolve(cwd, target)\n\n    if (verbose) {\n      logger.error(`[VERBOSE] target file: ${f}`)\n    }\n\n    if (!fs.existsSync(f)) {\n      return {\n        ok: false,\n        message: 'Manifest Generation Failed',\n        cause: `Input file not found at ${f}`\n      }\n    }\n\n    contents = fs.readFileSync(target, 'utf8')\n\n    if (!contents) {\n      return {\n        ok: false,\n        message: 'Manifest Generation Failed',\n        cause: 'File is empty'\n      }\n    }\n  }\n\n  return {\n    ok: true,\n    data: {\n      contents,\n      pip: convertCondaToRequirementsFromInput(contents)\n    }\n  }\n}\n\n// Just extract the first pip block, if one exists at all.\nexport function convertCondaToRequirementsFromInput(input: string): string {\n  const keeping: string[] = []\n  let collecting = false\n  let delim = '-'\n  let indent = ''\n  input.split('\\n').some(line => {\n    if (!line) {\n      // Ignore empty lines\n      return\n    }\n    if (collecting) {\n      if (line.startsWith('#')) {\n        // Ignore comment lines (keep?)\n        return\n      }\n      if (line.startsWith(delim)) {\n        // In this case we have a line with the same indentation as the\n        // `- pip:` line, so we have reached the end of the pip block.\n        return true // the end\n      } else {\n        if (!indent) {\n          // Store the indentation of the block\n          if (line.trim().startsWith('-')) {\n            indent = line.split('-')[0] + '-'\n            if (indent.length <= delim.length) {\n              // The first line after the `pip:` line does not indent further\n              // than that so the block is empty?\n              return true\n            }\n          }\n        }\n        if (line.startsWith(indent)) {\n          keeping.push(line.slice(indent.length).trim())\n        } else {\n          // Unexpected input. bail.\n          return true\n        }\n      }\n    } else {\n      // Note: the line may end with a line comment so don't === it.\n      if (line.trim().startsWith('- pip:')) {\n        delim = line.split('-')[0] + '-'\n        collecting = true\n      }\n    }\n  })\n\n  return keeping.join('\\n')\n}\n","import fs from 'node:fs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\n\nexport async function outputRequirements(\n  result: CResult<{ contents: string; pip: string }>,\n  outputKind: OutputKind,\n  out: string\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(result))\n      return\n    }\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'json') {\n    const json = serializeResultJson(result)\n\n    if (out === '-') {\n      logger.log(json)\n    } else {\n      fs.writeFileSync(out, json, 'utf8')\n    }\n\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    const arr = []\n    arr.push('# Converted Conda file')\n    arr.push('')\n    arr.push(\n      'This is the Conda `environment.yml` file converted to python `requirements.txt`:'\n    )\n    arr.push('')\n    arr.push('```file=requirements.txt')\n    arr.push(result.data.pip)\n    arr.push('```')\n    arr.push('')\n    const md = arr.join('\\n')\n\n    if (out === '-') {\n      logger.log(md)\n    } else {\n      fs.writeFileSync(out, md, 'utf8')\n    }\n    return\n  }\n\n  if (out === '-') {\n    logger.log(result.data.pip)\n    logger.log('')\n  } else {\n    fs.writeFileSync(out, result.data.pip, 'utf8')\n  }\n}\n","import { convertCondaToRequirements } from './convert-conda-to-requirements.mts'\nimport { outputRequirements } from './output-requirements.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleManifestConda(\n  target: string,\n  out: string,\n  outputKind: OutputKind,\n  cwd: string,\n  verbose: boolean\n): Promise<void> {\n  const data = await convertCondaToRequirements(target, cwd, verbose)\n\n  await outputRequirements(data, outputKind, out)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleManifestConda } from './handle-manifest-conda.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'conda',\n  description:\n    '[beta] Convert a Conda environment.yml file to a python requirements.txt',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    cwd: {\n      type: 'string',\n      description: 'Set the cwd, defaults to process.cwd()'\n    },\n    out: {\n      type: 'string',\n      default: '-',\n      description: 'Output target (use `-` or omit to print to stdout)'\n    },\n    verbose: {\n      type: 'boolean',\n      description: 'Print debug messages'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} FILE\n\n    Warning: While we don't support Conda necessarily, this tool extracts the pip\n             block from an environment.yml and outputs it as a requirements.txt\n             which you can scan as if it were a pypi package.\n\n    USE AT YOUR OWN RISK\n\n    Note: FILE can be a dash (-) to indicate stdin. This way you can pipe the\n          contents of a file to have it processed.\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n\n      $ ${command} ./environment.yml\n  `\n}\n\nexport const cmdManifestConda = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const {\n    cwd = process.cwd(),\n    json = false,\n    markdown = false,\n    out = '-',\n    verbose = false\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n\n  const [target = ''] = cli.input\n\n  if (verbose) {\n    logger.group('- ', parentName, config.commandName, ':')\n    logger.group('- flags:', cli.flags)\n    logger.groupEnd()\n    logger.log('- target:', target)\n    logger.log('- output:', out)\n    logger.groupEnd()\n  }\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: !!target,\n      message: 'The FILE arg is required',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: cli.input.length <= 1,\n      message: 'Can only accept one DIR (make sure to escape spaces!)',\n      pass: 'ok',\n      fail: 'received ' + cli.input.length\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  logger.error(\n    'Warning: This will approximate your Conda dependencies using PyPI. We do not yet officially support Conda. Use at your own risk.'\n  )\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleManifestConda(\n    target,\n    String(out || ''),\n    json ? 'json' : markdown ? 'markdown' : 'text',\n    String(cwd),\n    Boolean(verbose)\n  )\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nimport colors from 'yoctocolors-cjs'\n\nimport { isDebug } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\n\nexport async function convertGradleToMaven(\n  target: string,\n  bin: string,\n  cwd: string,\n  verbose: boolean,\n  gradleOpts: string[]\n) {\n  // TODO: impl json/md\n  if (verbose) {\n    logger.log('[VERBOSE] Resolving:', [cwd, bin])\n  }\n  const rbin = path.resolve(cwd, bin)\n  if (verbose) {\n    logger.log('[VERBOSE] Resolving:', [cwd, target])\n  }\n  const rtarget = path.resolve(cwd, target)\n\n  const binExists = fs.existsSync(rbin)\n\n  const targetExists = fs.existsSync(rtarget)\n\n  logger.group('gradle2maven:')\n  if (verbose || isDebug()) {\n    logger.log(\n      `[VERBOSE] - Absolute bin path: \\`${rbin}\\` (${binExists ? 'found' : colors.red('not found!')})`\n    )\n    logger.log(\n      `[VERBOSE] - Absolute target path: \\`${rtarget}\\` (${targetExists ? 'found' : colors.red('not found!')})`\n    )\n  } else {\n    logger.log(`- executing: \\`${rbin}\\``)\n    if (!binExists) {\n      logger.warn(\n        'Warning: It appears the executable could not be found at this location. An error might be printed later because of that.'\n      )\n    }\n    logger.log(`- src dir: \\`${rtarget}\\``)\n    if (!targetExists) {\n      logger.warn(\n        'Warning: It appears the src dir could not be found at this location. An error might be printed later because of that.'\n      )\n    }\n  }\n  logger.groupEnd()\n\n  try {\n    // Run gradlew with the init script we provide which should yield zero or more\n    // pom files. We have to figure out where to store those pom files such that\n    // we can upload them and predict them through the GitHub API. We could do a\n    // .socket folder. We could do a socket.pom.gz with all the poms, although\n    // I'd prefer something plain-text if it is to be committed.\n\n    // Note: init.gradle will be exported by .config/rollup.dist.config.mjs\n    const initLocation = path.join(constants.distPath, 'init.gradle')\n    const commandArgs = ['--init-script', initLocation, ...gradleOpts, 'pom']\n\n    if (verbose) {\n      logger.log('[VERBOSE] Executing:', [bin], ', args:', commandArgs)\n    }\n\n    logger.log(\n      `Converting gradle to maven from \\`${bin}\\` on \\`${target}\\` ...`\n    )\n    const output = await execGradleWithSpinner(rbin, commandArgs, rtarget, cwd)\n\n    if (verbose) {\n      logger.group('[VERBOSE] gradle stdout:')\n      logger.log(output)\n      logger.groupEnd()\n    }\n    if (output.code !== 0) {\n      process.exitCode = 1\n      logger.fail(`Gradle exited with exit code ${output.code}`)\n      // (In verbose mode, stderr was printed above, no need to repeat it)\n      if (!verbose) {\n        logger.group('stderr:')\n        logger.error(output.stderr)\n        logger.groupEnd()\n      }\n      return\n    }\n    logger.success('Executed gradle successfully')\n    logger.log('Reported exports:')\n    output.stdout.replace(\n      /^POM file copied to: (.*)/gm,\n      (_all: string, fn: string) => {\n        logger.log('- ', fn)\n        return fn\n      }\n    )\n    logger.log('')\n    logger.log(\n      'Next step is to generate a Scan by running the `socket scan create` command on the same directory'\n    )\n  } catch (e) {\n    process.exitCode = 1\n    logger.fail(\n      'There was an unexpected error while generating manifests' +\n        (verbose ? '' : '  (use --verbose for details)')\n    )\n    if (verbose) {\n      logger.group('[VERBOSE] error:')\n      logger.log(e)\n      logger.groupEnd()\n    }\n  }\n}\n\nasync function execGradleWithSpinner(\n  bin: string,\n  commandArgs: string[],\n  target: string,\n  cwd: string\n): Promise<{ code: number; stdout: string; stderr: string }> {\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n\n  let pass = false\n  try {\n    spinner.start(\n      `Running gradlew... (this can take a while, it depends on how long gradlew has to run)`\n    )\n    const output = await spawn(bin, commandArgs, {\n      // We can pipe the output through to have the user see the result\n      // of running gradlew, but then we can't (easily) gather the output\n      // to discover the generated files... probably a flag we should allow?\n      // stdio: isDebug() ? 'inherit' : undefined,\n      cwd: target || cwd\n    })\n    pass = true\n    const { code, stderr, stdout } = output\n    return { code, stdout, stderr }\n  } finally {\n    if (pass) {\n      spinner.successAndStop('Completed gradlew execution')\n    } else {\n      spinner.failAndStop('There was an error while trying to run gradlew.')\n    }\n  }\n}\n","import path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { convertGradleToMaven } from './convert_gradle_to_maven.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'gradle',\n  description:\n    '[beta] Use Gradle to generate a manifest file (`pom.xml`) for a Gradle/Java/Kotlin/etc project',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    bin: {\n      type: 'string',\n      description: 'Location of gradlew binary to use, default: CWD/gradlew'\n    },\n    cwd: {\n      type: 'string',\n      description: 'Set the cwd, defaults to process.cwd()'\n    },\n    gradleOpts: {\n      type: 'string',\n      default: '',\n      description:\n        'Additional options to pass on to ./gradlew, see `./gradlew --help`'\n    },\n    task: {\n      type: 'string',\n      default: 'all',\n      description: 'Task to target. By default targets all'\n    },\n    verbose: {\n      type: 'boolean',\n      description: 'Print debug messages'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [--bin=path/to/gradle/binary] [--out=path/to/result] DIR\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Uses gradle, preferably through your local project \\`gradlew\\`, to generate a\n    \\`pom.xml\\` file for each task. If you have no \\`gradlew\\` you can try the\n    global \\`gradle\\` binary but that may not work (hard to predict).\n\n    The \\`pom.xml\\` is a manifest file similar to \\`package.json\\` for npm or\n    or requirements.txt for PyPi), but specifically for Maven, which is Java's\n    dependency repository. Languages like Kotlin and Scala piggy back on it too.\n\n    There are some caveats with the gradle to \\`pom.xml\\` conversion:\n\n    - each task will generate its own xml file and by default it generates one xml\n      for every task.\n\n    - it's possible certain features don't translate well into the xml. If you\n      think something is missing that could be supported please reach out.\n\n    - it works with your \\`gradlew\\` from your repo and local settings and config\n\n    Support is beta. Please report issues or give us feedback on what's missing.\n\n    Examples\n\n      $ ${command} .\n      $ ${command} --bin=../gradlew .\n  `\n}\n\nexport const cmdManifestGradle = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const verbose = Boolean(cli.flags['verbose'])\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n\n  if (verbose) {\n    logger.group('- ', parentName, config.commandName, ':')\n    logger.group('- flags:', cli.flags)\n    logger.groupEnd()\n    logger.log('- input:', cli.input)\n    logger.groupEnd()\n  }\n\n  const [target = ''] = cli.input\n\n  // TODO: I'm not sure it's feasible to parse source file from stdin. We could\n  //       try, store contents in a file in some folder, target that folder... what\n  //       would the file name be?\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: !!target && target !== '-',\n      message: 'The DIR arg is required',\n      pass: 'ok',\n      fail: target === '-' ? 'stdin is not supported' : 'missing'\n    },\n    {\n      nook: true,\n      test: cli.input.length <= 1,\n      message: 'Can only accept one DIR (make sure to escape spaces!)',\n      pass: 'ok',\n      fail: 'received ' + cli.input.length\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  const { bin = path.join(target, 'gradlew'), cwd = process.cwd() } = cli.flags\n\n  if (verbose) {\n    logger.group()\n    logger.log('- target:', target)\n    logger.log('- gradle bin:', bin)\n    logger.groupEnd()\n  }\n\n  let gradleOpts: string[] = []\n  if (cli.flags['gradleOpts']) {\n    gradleOpts = (cli.flags['gradleOpts'] as string)\n      .split(' ')\n      .map(s => s.trim())\n      .filter(Boolean)\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await convertGradleToMaven(\n    target,\n    String(bin),\n    String(cwd),\n    verbose,\n    gradleOpts\n  )\n}\n","import path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\nimport { safeReadFile } from '../../utils/fs.mts'\n\nexport async function convertSbtToMaven(\n  target: string,\n  bin: string,\n  out: string,\n  verbose: boolean,\n  sbtOpts: string[]\n) {\n  // TODO: impl json/md\n\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n  const rbin = path.resolve(bin)\n  const rtarget = path.resolve(target)\n\n  if (verbose) {\n    logger.group('sbt2maven:')\n    logger.log(`[VERBOSE] - Absolute bin path: \\`${rbin}\\``)\n    logger.log(`[VERBOSE] - Absolute target path: \\`${rtarget}\\``)\n    // logger.log(`[VERBOSE] - Absolute out path: \\`${rout}\\``)\n    logger.groupEnd()\n  } else {\n    logger.group('sbt2maven:')\n    logger.log(`- executing: \\`${bin}\\``)\n    logger.log(`- src dir: \\`${target}\\``)\n    // logger.log(`- dst dir: \\`${out}\\``)\n    logger.groupEnd()\n  }\n\n  try {\n    spinner.start(`Converting sbt to maven from \\`${bin}\\` on \\`${target}\\`...`)\n\n    // Run sbt with the init script we provide which should yield zero or more\n    // pom files. We have to figure out where to store those pom files such that\n    // we can upload them and predict them through the GitHub API. We could do a\n    // .socket folder. We could do a socket.pom.gz with all the poms, although\n    // I'd prefer something plain-text if it is to be committed.\n    const output = await spawn(bin, ['makePom'].concat(sbtOpts), {\n      cwd: target || '.'\n    })\n\n    spinner.stop()\n\n    if (verbose) {\n      logger.group('[VERBOSE] sbt stdout:')\n      logger.log(output)\n      logger.groupEnd()\n    }\n    if (output.stderr) {\n      process.exitCode = 1\n      logger.fail('There were errors while running sbt')\n      // (In verbose mode, stderr was printed above, no need to repeat it)\n      if (!verbose) {\n        logger.group('[VERBOSE] stderr:')\n        logger.error(output.stderr)\n        logger.groupEnd()\n      }\n      return\n    }\n    const poms: string[] = []\n    output.stdout.replace(/Wrote (.*?.pom)\\n/g, (_all: string, fn: string) => {\n      poms.push(fn)\n      return fn\n    })\n    if (!poms.length) {\n      process.exitCode = 1\n      logger.fail(\n        'There were no errors from sbt but it seems to not have generated any poms either'\n      )\n      return\n    }\n    // Move the pom file to ...? initial cwd? loc will be an absolute path, or dump to stdout\n    // TODO: what to do with multiple output files? Do we want to dump them to stdout? Raw or with separators or ?\n    // TODO: maybe we can add an option to target a specific file to dump to stdout\n    if (out === '-' && poms.length === 1) {\n      logger.log('Result:\\n```')\n      logger.log(await safeReadFile(poms[0]!))\n      logger.log('```')\n      logger.success(`OK`)\n    } else if (out === '-') {\n      process.exitCode = 1\n      logger.fail(\n        'Requested out target was stdout but there are multiple generated files'\n      )\n      poms.forEach(fn => logger.error('-', fn))\n      logger.error('Exiting now...')\n      return\n    } else {\n      // if (verbose) {\n      //   logger.log(\n      //     `Moving manifest file from \\`${loc.replace(/^\\/home\\/[^/]*?\\//, '~/')}\\` to \\`${out}\\``\n      //   )\n      // } else {\n      //   logger.log('Moving output pom file')\n      // }\n      // TODO: do we prefer fs-extra? renaming can be gnarly on windows and fs-extra's version is better\n      // await renamep(loc, out)\n      logger.success(`Generated ${poms.length} pom files`)\n      poms.forEach(fn => logger.log('-', fn))\n      logger.success(`OK`)\n    }\n  } catch (e) {\n    process.exitCode = 1\n    spinner.stop()\n    logger.fail(\n      'There was an unexpected error while running this' +\n        (verbose ? '' : ' (use --verbose for details)')\n    )\n    if (verbose) {\n      logger.group('[VERBOSE] error:')\n      logger.log(e)\n      logger.groupEnd()\n    }\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { convertSbtToMaven } from './convert_sbt_to_maven.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'scala',\n  description:\n    \"[beta] Generate a manifest file (`pom.xml`) from Scala's `build.sbt` file\",\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    bin: {\n      type: 'string',\n      default: 'sbt',\n      description: 'Location of sbt binary to use'\n    },\n    cwd: {\n      type: 'string',\n      description: 'Set the cwd, defaults to process.cwd()'\n    },\n    out: {\n      type: 'string',\n      default: './socket.pom.xml',\n      description:\n        'Path of output file; where to store the resulting manifest, see also --stdout'\n    },\n    stdout: {\n      type: 'boolean',\n      description: 'Print resulting pom.xml to stdout (supersedes --out)'\n    },\n    sbtOpts: {\n      type: 'string',\n      default: '',\n      description: 'Additional options to pass on to sbt, as per `sbt --help`'\n    },\n    verbose: {\n      type: 'boolean',\n      description: 'Print debug messages'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [--bin=path/to/sbt/binary] [--out=path/to/result] FILE|DIR\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Uses \\`sbt makePom\\` to generate a \\`pom.xml\\` from your \\`build.sbt\\` file.\n    This xml file is the dependency manifest (like a package.json\n    for Node.js or requirements.txt for PyPi), but specifically for Scala.\n\n    There are some caveats with \\`build.sbt\\` to \\`pom.xml\\` conversion:\n\n    - the xml is exported as socket.pom.xml as to not confuse existing build tools\n      but it will first hit your /target/sbt<version> folder (as a different name)\n\n    - the pom.xml format (standard by Scala) does not support certain sbt features\n      - \\`excludeAll()\\`, \\`dependencyOverrides\\`, \\`force()\\`, \\`relativePath\\`\n      - For details: https://www.scala-sbt.org/1.x/docs/Library-Management.html\n\n    - it uses your sbt settings and local configuration verbatim\n\n    - it can only export one target per run, so if you have multiple targets like\n      development and production, you must run them separately.\n\n    You can optionally configure the path to the \\`sbt\\` bin to invoke.\n\n    Support is beta. Please report issues or give us feedback on what's missing.\n\n    This is only for SBT. If your Scala setup uses gradle, please see the help\n    sections for \\`socket manifest gradle\\` or \\`socket cdxgen\\`.\n\n    Examples\n\n      $ ${command} ./build.sbt\n      $ ${command} --bin=/usr/bin/sbt ./build.sbt\n  `\n}\n\nexport const cmdManifestScala = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const verbose = Boolean(cli.flags['verbose'])\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n\n  if (verbose) {\n    logger.group('- ', parentName, config.commandName, ':')\n    logger.group('- flags:', cli.flags)\n    logger.groupEnd()\n    logger.log('- input:', cli.input)\n    logger.groupEnd()\n  }\n\n  const [target = ''] = cli.input\n\n  // TODO: I'm not sure it's feasible to parse source file from stdin. We could\n  //       try, store contents in a file in some folder, target that folder... what\n  //       would the file name be?\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: !!target && target !== '-',\n      message: 'The DIR arg is required',\n      pass: 'ok',\n      fail: target === '-' ? 'stdin is not supported' : 'missing'\n    },\n    {\n      nook: true,\n      test: cli.input.length <= 1,\n      message: 'Can only accept one DIR (make sure to escape spaces!)',\n      pass: 'ok',\n      fail: 'received ' + cli.input.length\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  let bin: string = 'sbt'\n  if (cli.flags['bin']) {\n    bin = cli.flags['bin'] as string\n  }\n\n  let out: string = './socket.pom.xml'\n  if (cli.flags['out']) {\n    out = cli.flags['out'] as string\n  }\n  if (cli.flags['stdout']) {\n    out = '-'\n  }\n\n  if (verbose) {\n    logger.group()\n    logger.log('- target:', target)\n    logger.log('- gradle bin:', bin)\n    logger.log('- out:', out)\n    logger.groupEnd()\n  }\n\n  let sbtOpts: string[] = []\n  if (cli.flags['sbtOpts']) {\n    sbtOpts = (cli.flags['sbtOpts'] as string)\n      .split(' ')\n      .map(s => s.trim())\n      .filter(Boolean)\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await convertSbtToMaven(target, bin, out, verbose, sbtOpts)\n}\n","import { existsSync } from 'node:fs'\nimport path from 'node:path'\n\nimport meow from 'meow'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { cmdManifestConda } from './cmd-manifest-conda.mts'\nimport { cmdManifestGradle } from './cmd-manifest-gradle.mts'\nimport { cmdManifestScala } from './cmd-manifest-scala.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'auto',\n  description: 'Auto-detect build and attempt to generate manifest file',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    cwd: {\n      type: 'string',\n      description: 'Set the cwd, defaults to process.cwd()'\n    },\n    verbose: {\n      type: 'boolean',\n      default: false,\n      description: 'Enable debug output, may help when running into errors'\n    }\n    // TODO: support output flags\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Tries to figure out what language your current repo uses. If it finds a\n    supported case then it will try to generate the manifest file for that\n    language with the default or detected settings.\n  `\n}\n\nexport const cmdManifestAuto = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n  const verbose = !!cli.flags['verbose']\n  const cwd = (cli.flags['cwd'] as string) ?? process.cwd()\n  // TODO: impl json/md\n\n  if (verbose) {\n    logger.group('- ', parentName, config.commandName, ':')\n    logger.group('- flags:', cli.flags)\n    logger.groupEnd()\n    logger.log('- input:', cli.input)\n    logger.log('- cwd:', cwd)\n    logger.groupEnd()\n  }\n\n  const subArgs = []\n  if (verbose) {\n    subArgs.push('--verbose')\n  }\n\n  const dir = cwd\n\n  if (existsSync(path.join(dir, 'build.sbt'))) {\n    logger.log('Detected a Scala sbt build, running default Scala generator...')\n    if (cwd) {\n      subArgs.push('--cwd', cwd)\n    }\n    subArgs.push(dir)\n    if (cli.flags['dryRun']) {\n      logger.log(DRY_RUN_BAILING_NOW)\n      return\n    }\n    await cmdManifestScala.run(subArgs, importMeta, { parentName })\n    return\n  }\n\n  if (existsSync(path.join(dir, 'gradlew'))) {\n    logger.log('Detected a gradle build, running default gradle generator...')\n    if (cwd) {\n      // This command takes the cwd as first arg.\n      subArgs.push(cwd)\n    }\n    if (cli.flags['dryRun']) {\n      logger.log(DRY_RUN_BAILING_NOW)\n      return\n    }\n    await cmdManifestGradle.run(subArgs, importMeta, { parentName })\n    return\n  }\n\n  const envyml = path.join(dir, 'environment.yml')\n  const hasEnvyml = existsSync(envyml)\n  const envyaml = path.join(dir, 'environment.yaml')\n  const hasEnvyaml = !hasEnvyml && existsSync(envyaml)\n  if (hasEnvyml || hasEnvyaml) {\n    logger.log(\n      'Detected an environment.yml file, running default Conda generator...'\n    )\n    // This command takes the TARGET as first arg.\n    subArgs.push(hasEnvyml ? envyml : hasEnvyaml ? envyaml : '')\n    if (cli.flags['dryRun']) {\n      logger.log(DRY_RUN_BAILING_NOW)\n      return\n    }\n    await cmdManifestConda.run(subArgs, importMeta, { parentName })\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  // Show new help screen and exit.\n  meow(\n    `\n    $ ${parentName} ${config.commandName}\n\n    Unfortunately this script did not discover a supported language in the\n    current folder.\n\n    - Make sure this script would work with your target build\n    - Make sure to run it from the correct folder\n    - Make sure the necessary build tools are available (\\`PATH\\`)\n\n    If that doesn't work, see \\`${parentName} <lang> --help\\` for config details for\n    your target language.\n  `,\n    {\n      argv: [],\n      description: config.description,\n      importMeta\n    }\n  ).showHelp()\n}\n","import path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { convertGradleToMaven } from './convert_gradle_to_maven.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\n// TODO: we may want to dedupe some pieces for all gradle languages. I think it\n//       makes sense to have separate commands for them and I think it makes\n//       sense for the help panels to note the requested language, rather than\n//       `socket manifest kotlin` to print help screens with `gradle` as the\n//       command. Room for improvement.\nconst config: CliCommandConfig = {\n  commandName: 'kotlin',\n  description:\n    '[beta] Use Gradle to generate a manifest file (`pom.xml`) for a Kotlin project',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    bin: {\n      type: 'string',\n      description: 'Location of gradlew binary to use, default: CWD/gradlew'\n    },\n    cwd: {\n      type: 'string',\n      description: 'Set the cwd, defaults to process.cwd()'\n    },\n    gradleOpts: {\n      type: 'string',\n      default: '',\n      description:\n        'Additional options to pass on to ./gradlew, see `./gradlew --help`'\n    },\n    task: {\n      type: 'string',\n      default: 'all',\n      description: 'Task to target. By default targets all'\n    },\n    verbose: {\n      type: 'boolean',\n      description: 'Print debug messages'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} [--bin=path/to/gradle/binary] [--out=path/to/result] DIR\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Uses gradle, preferably through your local project \\`gradlew\\`, to generate a\n    \\`pom.xml\\` file for each task. If you have no \\`gradlew\\` you can try the\n    global \\`gradle\\` binary but that may not work (hard to predict).\n\n    The \\`pom.xml\\` is a manifest file similar to \\`package.json\\` for npm or\n    or requirements.txt for PyPi), but specifically for Maven, which is Java's\n    dependency repository. Languages like Kotlin and Scala piggy back on it too.\n\n    There are some caveats with the gradle to \\`pom.xml\\` conversion:\n\n    - each task will generate its own xml file and by default it generates one xml\n      for every task. (This may be a good thing!)\n\n    - it's possible certain features don't translate well into the xml. If you\n      think something is missing that could be supported please reach out.\n\n    - it works with your \\`gradlew\\` from your repo and local settings and config\n\n    Support is beta. Please report issues or give us feedback on what's missing.\n\n    Examples\n\n      $ ${command} .\n      $ ${command} --bin=../gradlew .\n  `\n}\n\nexport const cmdManifestKotlin = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const verbose = Boolean(cli.flags['verbose'])\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n\n  if (verbose) {\n    logger.group('- ', parentName, config.commandName, ':')\n    logger.group('- flags:', cli.flags)\n    logger.groupEnd()\n    logger.log('- input:', cli.input)\n    logger.groupEnd()\n  }\n\n  const [target = ''] = cli.input\n\n  // TODO: I'm not sure it's feasible to parse source file from stdin. We could\n  //       try, store contents in a file in some folder, target that folder... what\n  //       would the file name be?\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: !!target && target !== '-',\n      message: 'The DIR arg is required',\n      pass: 'ok',\n      fail: target === '-' ? 'stdin is not supported' : 'missing'\n    },\n    {\n      nook: true,\n      test: cli.input.length <= 1,\n      message: 'Can only accept one DIR (make sure to escape spaces!)',\n      pass: 'ok',\n      fail: 'received ' + cli.input.length\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  const { bin = path.join(target, 'gradlew'), cwd = process.cwd() } = cli.flags\n\n  if (verbose) {\n    logger.group()\n    logger.log('- target:', target)\n    logger.log('- gradle bin:', bin)\n    logger.groupEnd()\n  }\n\n  let gradleOpts: string[] = []\n  if (cli.flags['gradleOpts']) {\n    gradleOpts = (cli.flags['gradleOpts'] as string)\n      .split(' ')\n      .map(s => s.trim())\n      .filter(Boolean)\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await convertGradleToMaven(\n    target,\n    String(bin),\n    String(cwd),\n    verbose,\n    gradleOpts\n  )\n}\n","import { cmdManifestAuto } from './cmd-manifest-auto.mts'\nimport { cmdManifestConda } from './cmd-manifest-conda.mts'\nimport { cmdManifestGradle } from './cmd-manifest-gradle.mts'\nimport { cmdManifestKotlin } from './cmd-manifest-kotlin.mts'\nimport { cmdManifestScala } from './cmd-manifest-scala.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst config: CliCommandConfig = {\n  commandName: 'manifest',\n  description: 'Generate a dependency manifest for given file or dir',\n  hidden: false,\n  flags: {\n    ...commonFlags\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <language> <target>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Generates a declarative dependency manifest (like a package.json for Node.JS\n    or requirements.txt for PyPi), but for certain supported ecosystems\n    where it's common to use a dynamic manifest, like Scala's sbt.\n\n    Only certain languages are supported and there may be language specific\n    configurations available. See \\`manifest <language> --help\\` for usage details\n    per language.\n\n    Currently supported language: scala [beta], gradle [beta], kotlin (through\n    gradle) [beta].\n\n    Examples\n\n      $ ${command} scala .\n\n    To have it auto-detect and attempt to run:\n\n      $ ${command} yolo\n  `\n}\n\nexport const cmdManifest = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  await meowWithSubcommands(\n    {\n      auto: cmdManifestAuto,\n      conda: cmdManifestConda,\n      scala: cmdManifestScala,\n      gradle: cmdManifestGradle,\n      kotlin: cmdManifestKotlin\n    },\n    {\n      argv,\n      aliases: {\n        yolo: {\n          description: config.description,\n          hidden: true,\n          argv: ['auto']\n        }\n      },\n      description: config.description,\n      importMeta,\n      flags: config.flags,\n      name: `${parentName} ${config.commandName}`\n    }\n  )\n}\n","import { createRequire } from 'node:module'\n\nimport constants from '../../constants.mts'\n\nconst require = createRequire(import.meta.url)\n\nconst { NPM } = constants\n\nexport async function wrapNpm(argv: readonly string[]) {\n  // Lazily access constants.distShadowNpmBinPath.\n  const shadowBin = require(constants.distShadowNpmBinPath)\n  await shadowBin(NPM, argv)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { wrapNpm } from './wrap-npm.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW, NPM } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'npm',\n  description: `${NPM} wrapper functionality`,\n  hidden: false,\n  flags: {\n    ...commonFlags\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}\n  `\n}\n\nexport const cmdNpm = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    allowUnknownFlags: true,\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await wrapNpm(argv)\n}\n","import { createRequire } from 'node:module'\n\nimport constants from '../../constants.mts'\n\nconst require = createRequire(import.meta.url)\n\nconst { NPX } = constants\n\nexport async function wrapNpx(argv: readonly string[]) {\n  // Lazily access constants.distShadowNpmBinPath.\n  const shadowBin = require(constants.distShadowNpmBinPath)\n  await shadowBin(NPX, argv)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { wrapNpx } from './wrap-npx.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW, NPX } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'npx',\n  description: `${NPX} wrapper functionality`,\n  hidden: false,\n  flags: {\n    ...commonFlags\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}\n  `\n}\n\nexport const cmdNpx = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    allowUnknownFlags: true,\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await wrapNpx(argv)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'oops',\n  description: 'Trigger an intentional error (for development)',\n  hidden: true,\n  flags: {\n    ...commonFlags,\n    ...outputFlags\n  },\n  help: (parentName, config) => `\n    Usage\n      $ ${parentName} ${config.commandName}\n\n    Don't run me.\n  `\n}\n\nexport const cmdOops = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { json, markdown } = cli.flags\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  if (json) {\n    process.exitCode = 1\n    logger.log(\n      serializeResultJson({\n        ok: false,\n        message: 'Oops',\n        cause: 'This error was intentionally left blank'\n      })\n    )\n  }\n\n  if (markdown) {\n    process.exitCode = 1\n    logger.fail(\n      failMsgWithBadge('Oops', 'This error was intentionally left blank')\n    )\n    return\n  }\n\n  throw new Error('This error was intentionally left blank')\n}\n","import constants from '../../constants.mts'\n\nimport type { Agent } from '../../utils/package-environment.mts'\n\ntype AgentDepsIncludesFn = (stdout: string, name: string) => boolean\n\nconst { BUN, NPM, PNPM, VLT, YARN_BERRY, YARN_CLASSIC } = constants\n\nfunction matchLsCmdViewHumanStdout(stdout: string, name: string) {\n  return stdout.includes(` ${name}@`)\n}\n\nfunction matchQueryCmdStdout(stdout: string, name: string) {\n  return stdout.includes(`\"${name}\"`)\n}\n\nexport const depsIncludesByAgent = new Map<Agent, AgentDepsIncludesFn>([\n  [BUN, matchLsCmdViewHumanStdout],\n  [NPM, matchQueryCmdStdout],\n  [PNPM, matchQueryCmdStdout],\n  [VLT, matchQueryCmdStdout],\n  [YARN_BERRY, matchLsCmdViewHumanStdout],\n  [YARN_CLASSIC, matchLsCmdViewHumanStdout]\n])\n","import type { EnvDetails } from '../../utils/package-environment.mts'\n\nexport function getDependencyEntries(pkgEnvDetails: EnvDetails) {\n  const {\n    dependencies,\n    devDependencies,\n    optionalDependencies,\n    peerDependencies\n  } = pkgEnvDetails.editablePkgJson.content\n  return [\n    [\n      'dependencies',\n      dependencies ? { __proto__: null, ...dependencies } : undefined\n    ],\n    [\n      'devDependencies',\n      devDependencies ? { __proto__: null, ...devDependencies } : undefined\n    ],\n    [\n      'peerDependencies',\n      peerDependencies ? { __proto__: null, ...peerDependencies } : undefined\n    ],\n    [\n      'optionalDependencies',\n      optionalDependencies\n        ? { __proto__: null, ...optionalDependencies }\n        : undefined\n    ]\n  ].filter(({ 1: o }) => o) as Array<[string, NonNullable<typeof dependencies>]>\n}\n","import constants from '../../constants.mts'\n\nimport type { NpmOverrides, Overrides, PnpmOrYarnOverrides } from './types.mts'\nimport type { Agent, EnvDetails } from '../../utils/package-environment.mts'\n\nconst {\n  BUN,\n  NPM,\n  OVERRIDES,\n  PNPM,\n  RESOLUTIONS,\n  VLT,\n  YARN_BERRY,\n  YARN_CLASSIC\n} = constants\n\nfunction getOverridesDataBun(pkgEnvDetails: EnvDetails) {\n  const overrides =\n    pkgEnvDetails.editablePkgJson.content?.[RESOLUTIONS] ??\n    ({} as PnpmOrYarnOverrides)\n  return { type: YARN_BERRY, overrides }\n}\n\n// npm overrides documentation:\n// https://docs.npmjs.com/cli/v10/configuring-npm/package-json#overrides\nfunction getOverridesDataNpm(pkgEnvDetails: EnvDetails) {\n  const overrides =\n    pkgEnvDetails.editablePkgJson.content?.[OVERRIDES] ?? ({} as NpmOverrides)\n  return { type: NPM, overrides }\n}\n\n// pnpm overrides documentation:\n// https://pnpm.io/package_json#pnpmoverrides\nfunction getOverridesDataPnpm(pkgEnvDetails: EnvDetails) {\n  const overrides =\n    (pkgEnvDetails.editablePkgJson.content as any)?.[PNPM]?.[OVERRIDES] ??\n    ({} as PnpmOrYarnOverrides)\n  return { type: PNPM, overrides }\n}\n\nfunction getOverridesDataVlt(pkgEnvDetails: EnvDetails) {\n  const overrides =\n    pkgEnvDetails.editablePkgJson.content?.[OVERRIDES] ?? ({} as NpmOverrides)\n  return { type: VLT, overrides }\n}\n\n// Yarn resolutions documentation:\n// https://yarnpkg.com/configuration/manifest#resolutions\nfunction getOverridesDataYarn(pkgEnvDetails: EnvDetails) {\n  const overrides =\n    pkgEnvDetails.editablePkgJson.content?.[RESOLUTIONS] ??\n    ({} as PnpmOrYarnOverrides)\n  return { type: YARN_BERRY, overrides }\n}\n\n// Yarn resolutions documentation:\n// https://classic.yarnpkg.com/en/docs/selective-version-resolutions\nfunction getOverridesDataYarnClassic(pkgEnvDetails: EnvDetails) {\n  const overrides =\n    pkgEnvDetails.editablePkgJson.content?.[RESOLUTIONS] ??\n    ({} as PnpmOrYarnOverrides)\n  return { type: YARN_CLASSIC, overrides }\n}\n\nexport type GetOverrides = (pkgEnvDetails: EnvDetails) => GetOverridesResult\n\nexport type GetOverridesResult = { type: Agent; overrides: Overrides }\n\nexport const overridesDataByAgent = new Map<Agent, GetOverrides>([\n  [BUN, getOverridesDataBun],\n  [NPM, getOverridesDataNpm],\n  [PNPM, getOverridesDataPnpm],\n  [VLT, getOverridesDataVlt],\n  [YARN_BERRY, getOverridesDataYarn],\n  [YARN_CLASSIC, getOverridesDataYarnClassic]\n] as ReadonlyArray<[Agent, GetOverrides]>)\n","import { escapeRegExp } from '@socketsecurity/registry/lib/regexps'\n\nimport constants from '../../constants.mts'\n\nimport type { Agent } from '../../utils/package-environment.mts'\n\nexport type AgentLockIncludesFn = (\n  lockSrc: string,\n  name: string,\n  ext?: string | undefined\n) => boolean\n\nconst { BUN, LOCK_EXT, NPM, PNPM, VLT, YARN_BERRY, YARN_CLASSIC } = constants\n\nfunction includesNpm(lockSrc: string, name: string) {\n  // Detects the package name in the following cases:\n  //   \"name\":\n  return lockSrc.includes(`\"${name}\":`)\n}\n\nfunction includesBun(lockSrc: string, name: string, lockName?: string) {\n  // This is a bit counterintuitive. When lockName ends with a .lockb\n  // we treat it as a yarn.lock. When lockName ends with a .lock we\n  // treat it as a package-lock.json. The bun.lock format is not identical\n  // package-lock.json, however it close enough for npmLockIncludes to work.\n  const lockfileScanner = lockName?.endsWith(LOCK_EXT)\n    ? includesNpm\n    : includesYarn\n  return lockfileScanner(lockSrc, name)\n}\n\nfunction includesPnpm(lockSrc: string, name: string) {\n  const escapedName = escapeRegExp(name)\n  return new RegExp(\n    // Detects the package name in the following cases:\n    //   /name/\n    //   'name'\n    //   name:\n    //   name@\n    `(?<=^\\\\s*)(?:(['/])${escapedName}\\\\1|${escapedName}(?=[:@]))`,\n    'm'\n  ).test(lockSrc)\n}\n\nfunction includesVlt(lockSrc: string, name: string) {\n  // Detects the package name in the following cases:\n  //   \"name\"\n  return lockSrc.includes(`\"${name}\"`)\n}\n\nfunction includesYarn(lockSrc: string, name: string) {\n  const escapedName = escapeRegExp(name)\n  return new RegExp(\n    // Detects the package name in the following cases:\n    //   \"name@\n    //   , \"name@\n    //   name@\n    //   , name@\n    `(?<=(?:^\\\\s*|,\\\\s*)\"?)${escapedName}(?=@)`,\n    'm'\n  ).test(lockSrc)\n}\n\nexport const lockfileIncludesByAgent = new Map<Agent, AgentLockIncludesFn>([\n  [BUN, includesBun],\n  [NPM, includesNpm],\n  [PNPM, includesPnpm],\n  [VLT, includesVlt],\n  [YARN_BERRY, includesYarn],\n  [YARN_CLASSIC, includesYarn]\n])\n","import { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\n\nimport type { Agent, EnvDetails } from '../../utils/package-environment.mts'\n\nconst { BUN, NPM, PNPM, VLT, YARN_BERRY, YARN_CLASSIC } = constants\n\nfunction cleanupQueryStdout(stdout: string): string {\n  if (stdout === '') {\n    return ''\n  }\n  let pkgs\n  try {\n    pkgs = JSON.parse(stdout)\n  } catch {}\n  if (!Array.isArray(pkgs)) {\n    return ''\n  }\n  const names = new Set<string>()\n  for (const { _id, name, pkgid } of pkgs) {\n    // `npm query` results may not have a \"name\" property, in which case we\n    // fallback to \"_id\" and then \"pkgid\".\n    // `vlt ls --view json` results always have a \"name\" property.\n    const fallback = _id ?? pkgid ?? ''\n    const resolvedName = name ?? fallback.slice(0, fallback.indexOf('@', 1))\n    // Add package names, except for those under the `@types` scope as those\n    // are known to only be dev dependencies.\n    if (resolvedName && !resolvedName.startsWith('@types/')) {\n      names.add(resolvedName)\n    }\n  }\n  return JSON.stringify([...names], null, 2)\n}\n\nfunction parsableToQueryStdout(stdout: string) {\n  if (stdout === '') {\n    return ''\n  }\n  // Convert the parsable stdout into a json array of unique names.\n  // The matchAll regexp looks for a forward (posix) or backward (win32) slash\n  // and matches one or more non-slashes until the newline.\n  const names = new Set(stdout.matchAll(/(?<=[/\\\\])[^/\\\\]+(?=\\n)/g))\n  return JSON.stringify([...names], null, 2)\n}\n\nasync function npmQuery(npmExecPath: string, cwd: string): Promise<string> {\n  let stdout = ''\n  try {\n    stdout = (\n      await spawn(npmExecPath, ['query', ':not(.dev)'], {\n        cwd,\n        // Lazily access constants.WIN32.\n        shell: constants.WIN32\n      })\n    ).stdout\n  } catch {}\n  return cleanupQueryStdout(stdout)\n}\n\nasync function lsBun(pkgEnvDetails: EnvDetails, cwd: string): Promise<string> {\n  try {\n    // Bun does not support filtering by production packages yet.\n    // https://github.com/oven-sh/bun/issues/8283\n    return (\n      await spawn(pkgEnvDetails.agentExecPath, ['pm', 'ls', '--all'], {\n        cwd,\n        // Lazily access constants.WIN32.\n        shell: constants.WIN32\n      })\n    ).stdout\n  } catch {}\n  return ''\n}\n\nasync function lsNpm(pkgEnvDetails: EnvDetails, cwd: string): Promise<string> {\n  return await npmQuery(pkgEnvDetails.agentExecPath, cwd)\n}\n\nasync function lsPnpm(\n  pkgEnvDetails: EnvDetails,\n  cwd: string,\n  options?: AgentListDepsOptions | undefined\n): Promise<string> {\n  const npmExecPath = options?.npmExecPath\n  if (npmExecPath && npmExecPath !== NPM) {\n    const result = await npmQuery(npmExecPath, cwd)\n    if (result) {\n      return result\n    }\n  }\n  let stdout = ''\n  try {\n    stdout = (\n      await spawn(\n        pkgEnvDetails.agentExecPath,\n        // Pnpm uses the alternative spelling of parsable.\n        // https://en.wiktionary.org/wiki/parsable\n        ['ls', '--parseable', '--prod', '--depth', 'Infinity'],\n        {\n          cwd,\n          // Lazily access constants.WIN32.\n          shell: constants.WIN32\n        }\n      )\n    ).stdout\n  } catch {}\n  return parsableToQueryStdout(stdout)\n}\n\nasync function lsVlt(pkgEnvDetails: EnvDetails, cwd: string): Promise<string> {\n  let stdout = ''\n  try {\n    // See https://docs.vlt.sh/cli/commands/list#options.\n    stdout = (\n      await spawn(\n        pkgEnvDetails.agentExecPath,\n        ['ls', '--view', 'human', ':not(.dev)'],\n        {\n          cwd,\n          // Lazily access constants.WIN32.\n          shell: constants.WIN32\n        }\n      )\n    ).stdout\n  } catch {}\n  return cleanupQueryStdout(stdout)\n}\n\nasync function lsYarnBerry(\n  pkgEnvDetails: EnvDetails,\n  cwd: string\n): Promise<string> {\n  try {\n    return (\n      // Yarn Berry does not support filtering by production packages yet.\n      // https://github.com/yarnpkg/berry/issues/5117\n      (\n        await spawn(\n          pkgEnvDetails.agentExecPath,\n          ['info', '--recursive', '--name-only'],\n          {\n            cwd,\n            // Lazily access constants.WIN32.\n            shell: constants.WIN32\n          }\n        )\n      ).stdout.trim()\n    )\n  } catch {}\n  return ''\n}\n\nasync function lsYarnClassic(\n  pkgEnvDetails: EnvDetails,\n  cwd: string\n): Promise<string> {\n  try {\n    // However, Yarn Classic does support it.\n    // https://github.com/yarnpkg/yarn/releases/tag/v1.0.0\n    // > Fix: Excludes dev dependencies from the yarn list output when the\n    //   environment is production\n    return (\n      await spawn(pkgEnvDetails.agentExecPath, ['list', '--prod'], {\n        cwd,\n        // Lazily access constants.WIN32.\n        shell: constants.WIN32\n      })\n    ).stdout.trim()\n  } catch {}\n  return ''\n}\n\nexport type AgentListDepsOptions = { npmExecPath?: string }\n\nexport type AgentListDepsFn = (\n  pkgEnvDetails: EnvDetails,\n  cwd: string,\n  options?: AgentListDepsOptions | undefined\n) => Promise<string>\n\nexport const lsByAgent = new Map<Agent, AgentListDepsFn>([\n  [BUN, lsBun],\n  [NPM, lsNpm],\n  [PNPM, lsPnpm],\n  [VLT, lsVlt],\n  [YARN_BERRY, lsYarnBerry],\n  [YARN_CLASSIC, lsYarnClassic]\n])\n","export const CMD_NAME = 'socket optimize'\n","import { hasKeys, isObject } from '@socketsecurity/registry/lib/objects'\n\nimport constants from '../../constants.mts'\n\nimport type { Overrides } from './types.mts'\nimport type { Agent, EnvDetails } from '../../utils/package-environment.mts'\nimport type { EditablePackageJson } from '@socketsecurity/registry/lib/packages'\n\nconst {\n  BUN,\n  NPM,\n  OVERRIDES,\n  PNPM,\n  RESOLUTIONS,\n  VLT,\n  YARN_BERRY,\n  YARN_CLASSIC\n} = constants\n\nconst depFields = [\n  'dependencies',\n  'devDependencies',\n  'peerDependencies',\n  'peerDependenciesMeta',\n  'optionalDependencies',\n  'bundleDependencies'\n]\n\nfunction getEntryIndexes(\n  entries: Array<[string | symbol, any]>,\n  keys: Array<string | symbol>\n): number[] {\n  return keys\n    .map(n => entries.findIndex(p => p[0] === n))\n    .filter(n => n !== -1)\n    .sort((a, b) => a - b)\n}\n\nfunction getLowestEntryIndex(\n  entries: Array<[string | symbol, any]>,\n  keys: Array<string | symbol>\n) {\n  return getEntryIndexes(entries, keys)?.[0] ?? -1\n}\n\nfunction getHighestEntryIndex(\n  entries: Array<[string | symbol, any]>,\n  keys: Array<string | symbol>\n) {\n  return getEntryIndexes(entries, keys).at(-1) ?? -1\n}\n\nfunction updatePkgJsonField(\n  editablePkgJson: EditablePackageJson,\n  field: string,\n  value: any\n) {\n  const oldValue = editablePkgJson.content[field]\n  if (oldValue) {\n    // The field already exists so we simply update the field value.\n    if (field === PNPM) {\n      const isPnpmObj = isObject(oldValue)\n      if (hasKeys(value)) {\n        editablePkgJson.update({\n          [field]: {\n            ...(isPnpmObj ? oldValue : {}),\n            overrides: {\n              ...(isPnpmObj ? (oldValue as any)[OVERRIDES] : {}),\n              ...value\n            }\n          }\n        })\n      } else {\n        // Properties with undefined values are omitted when saved as JSON.\n        editablePkgJson.update(\n          (hasKeys(oldValue)\n            ? {\n                [field]: {\n                  ...(isPnpmObj ? oldValue : {}),\n                  overrides: undefined\n                }\n              }\n            : { [field]: undefined }) as typeof editablePkgJson.content\n        )\n      }\n    } else if (field === OVERRIDES || field === RESOLUTIONS) {\n      // Properties with undefined values are omitted when saved as JSON.\n      editablePkgJson.update({\n        [field]: hasKeys(value) ? value : undefined\n      } as typeof editablePkgJson.content)\n    } else {\n      editablePkgJson.update({ [field]: value })\n    }\n    return\n  }\n  if (\n    (field === OVERRIDES || field === PNPM || field === RESOLUTIONS) &&\n    !hasKeys(value)\n  ) {\n    return\n  }\n  // Since the field doesn't exist we want to insert it into the package.json\n  // in a place that makes sense, e.g. close to the \"dependencies\" field. If\n  // we can't find a place to insert the field we'll add it to the bottom.\n  const entries = Object.entries(editablePkgJson.content)\n  let insertIndex = -1\n  let isPlacingHigher = false\n  if (field === OVERRIDES) {\n    insertIndex = getLowestEntryIndex(entries, [RESOLUTIONS])\n    if (insertIndex === -1) {\n      isPlacingHigher = true\n      insertIndex = getHighestEntryIndex(entries, [...depFields, PNPM])\n    }\n  } else if (field === RESOLUTIONS) {\n    isPlacingHigher = true\n    insertIndex = getHighestEntryIndex(entries, [...depFields, OVERRIDES, PNPM])\n  } else if (field === PNPM) {\n    insertIndex = getLowestEntryIndex(entries, [OVERRIDES, RESOLUTIONS])\n    if (insertIndex === -1) {\n      isPlacingHigher = true\n      insertIndex = getHighestEntryIndex(entries, depFields)\n    }\n  }\n  if (insertIndex === -1) {\n    insertIndex = getLowestEntryIndex(entries, ['engines', 'files'])\n  }\n  if (insertIndex === -1) {\n    isPlacingHigher = true\n    insertIndex = getHighestEntryIndex(entries, ['exports', 'imports', 'main'])\n  }\n  if (insertIndex === -1) {\n    insertIndex = entries.length\n  } else if (isPlacingHigher) {\n    insertIndex += 1\n  }\n  entries.splice(insertIndex, 0, [\n    field,\n    field === PNPM ? { [OVERRIDES]: value } : value\n  ])\n  editablePkgJson.fromJSON(\n    `${JSON.stringify(Object.fromEntries(entries), null, 2)}\\n`\n  )\n}\n\nfunction updateOverridesField(pkgEnvDetails: EnvDetails, overrides: Overrides) {\n  updatePkgJsonField(pkgEnvDetails.editablePkgJson, OVERRIDES, overrides)\n}\n\nfunction updateResolutionsField(\n  pkgEnvDetails: EnvDetails,\n  overrides: Overrides\n) {\n  updatePkgJsonField(pkgEnvDetails.editablePkgJson, RESOLUTIONS, overrides)\n}\n\nfunction updatePnpmField(pkgEnvDetails: EnvDetails, overrides: Overrides) {\n  updatePkgJsonField(pkgEnvDetails.editablePkgJson, PNPM, overrides)\n}\n\nexport type AgentModifyManifestFn = (\n  pkgEnvDetails: EnvDetails,\n  overrides: Overrides\n) => void\n\nexport const updateManifestByAgent = new Map<Agent, AgentModifyManifestFn>([\n  [BUN, updateResolutionsField],\n  [NPM, updateOverridesField],\n  [PNPM, updatePnpmField],\n  [VLT, updateOverridesField],\n  [YARN_BERRY, updateResolutionsField],\n  [YARN_CLASSIC, updateResolutionsField]\n])\n","import path from 'node:path'\n\nimport npa from 'npm-package-arg'\nimport semver from 'semver'\n\nimport { getManifestData } from '@socketsecurity/registry'\nimport { hasOwn, toSortedObject } from '@socketsecurity/registry/lib/objects'\nimport { fetchPackageManifest } from '@socketsecurity/registry/lib/packages'\nimport { pEach } from '@socketsecurity/registry/lib/promises'\nimport { Spinner } from '@socketsecurity/registry/lib/spinner'\n\nimport { depsIncludesByAgent } from './deps-includes-by-agent.mts'\nimport { getDependencyEntries } from './get-dependency-entries.mts'\nimport { overridesDataByAgent } from './get-overrides-by-agent.mts'\nimport { lockfileIncludesByAgent } from './lockfile-includes-by-agent.mts'\nimport { lsByAgent } from './ls-by-agent.mts'\nimport { CMD_NAME } from './shared.mts'\nimport { updateManifestByAgent } from './update-manifest-by-agent.mts'\nimport constants from '../../constants.mts'\nimport { cmdPrefixMessage } from '../../utils/cmd.mts'\nimport { globWorkspace } from '../../utils/glob.mts'\n\nimport type { GetOverridesResult } from './get-overrides-by-agent.mts'\nimport type { AgentLockIncludesFn } from './lockfile-includes-by-agent.mts'\nimport type { EnvDetails } from '../../utils/package-environment.mts'\nimport type { Logger } from '@socketsecurity/registry/lib/logger'\nimport type { PackageJson } from '@socketsecurity/registry/lib/packages'\n\ntype AddOverridesOptions = {\n  logger?: Logger | undefined\n  pin?: boolean | undefined\n  prod?: boolean | undefined\n  spinner?: Spinner | undefined\n  state?: AddOverridesState | undefined\n}\ntype AddOverridesState = {\n  added: Set<string>\n  addedInWorkspaces: Set<string>\n  updated: Set<string>\n  updatedInWorkspaces: Set<string>\n  warnedPnpmWorkspaceRequiresNpm: boolean\n}\n\nconst { NPM, PNPM, YARN_CLASSIC } = constants\n\nconst manifestNpmOverrides = getManifestData(NPM)\n\nexport async function addOverrides(\n  pkgEnvDetails: EnvDetails,\n  pkgPath: string,\n  options?: AddOverridesOptions | undefined\n): Promise<AddOverridesState> {\n  const {\n    agent,\n    lockName,\n    lockSrc,\n    npmExecPath,\n    pkgPath: rootPath\n  } = pkgEnvDetails\n  const {\n    logger,\n    pin,\n    prod,\n    spinner,\n    state = {\n      added: new Set(),\n      addedInWorkspaces: new Set(),\n      updated: new Set(),\n      updatedInWorkspaces: new Set(),\n      warnedPnpmWorkspaceRequiresNpm: false\n    }\n  } = { __proto__: null, ...options } as AddOverridesOptions\n  const workspacePkgJsonPaths = await globWorkspace(agent, pkgPath)\n  const isWorkspace = workspacePkgJsonPaths.length > 0\n  const isWorkspaceRoot = pkgPath === rootPath\n  const isLockScanned = isWorkspaceRoot && !prod\n  const workspaceName = isWorkspaceRoot\n    ? 'root'\n    : path.relative(rootPath, pkgPath)\n  if (\n    isWorkspace &&\n    agent === PNPM &&\n    // npmExecPath will === the agent name IF it CANNOT be resolved.\n    npmExecPath === NPM &&\n    !state.warnedPnpmWorkspaceRequiresNpm\n  ) {\n    state.warnedPnpmWorkspaceRequiresNpm = true\n    logger?.warn(\n      cmdPrefixMessage(\n        CMD_NAME,\n        `${agent} workspace support requires \\`npm ls\\`, falling back to \\`${agent} list\\``\n      )\n    )\n  }\n\n  const overridesDataObjects = [] as GetOverridesResult[]\n  if (isWorkspace || pkgEnvDetails.editablePkgJson.content['private']) {\n    overridesDataObjects.push(overridesDataByAgent.get(agent)!(pkgEnvDetails))\n  } else {\n    overridesDataObjects.push(\n      overridesDataByAgent.get(NPM)!(pkgEnvDetails),\n      overridesDataByAgent.get(YARN_CLASSIC)!(pkgEnvDetails)\n    )\n  }\n\n  spinner?.setText(`Adding overrides to ${workspaceName}...`)\n\n  const depAliasMap = new Map<string, string>()\n  const depEntries = getDependencyEntries(pkgEnvDetails)\n\n  const manifestEntries = manifestNpmOverrides.filter(({ 1: data }) =>\n    semver.satisfies(\n      // Roughly check Node range as semver.coerce will strip leading\n      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).\n      semver.coerce(data.engines.node)!,\n      pkgEnvDetails.pkgRequirements.node\n    )\n  )\n\n  // Chunk package names to process them in parallel 3 at a time.\n  await pEach(manifestEntries, 3, async ({ 1: data }) => {\n    const { name: sockRegPkgName, package: origPkgName, version } = data\n    const major = semver.major(version)\n    const sockOverridePrefix = `${NPM}:${sockRegPkgName}@`\n    const sockOverrideSpec = `${sockOverridePrefix}${pin ? version : `^${major}`}`\n    for (const { 1: depObj } of depEntries) {\n      const sockSpec = hasOwn(depObj, sockRegPkgName)\n        ? depObj[sockRegPkgName]\n        : undefined\n      if (sockSpec) {\n        depAliasMap.set(sockRegPkgName, sockSpec)\n      }\n      const origSpec = hasOwn(depObj, origPkgName)\n        ? depObj[origPkgName]\n        : undefined\n      if (origSpec) {\n        let thisSpec = origSpec\n        // Add package aliases for direct dependencies to avoid npm EOVERRIDE\n        // errors...\n        // https://docs.npmjs.com/cli/v8/using-npm/package-spec#aliases\n        if (\n          // ...if the spec doesn't start with a valid Socket override.\n          !(\n            thisSpec.startsWith(sockOverridePrefix) &&\n            // Check the validity of the spec by passing it through npa and\n            // seeing if it will coerce to a version.\n            semver.coerce(npa(thisSpec).rawSpec)?.version\n          )\n        ) {\n          thisSpec = sockOverrideSpec\n          depObj[origPkgName] = thisSpec\n          state.added.add(sockRegPkgName)\n          if (!isWorkspaceRoot) {\n            state.addedInWorkspaces.add(workspaceName)\n          }\n        }\n        depAliasMap.set(origPkgName, thisSpec)\n      }\n    }\n    if (isWorkspaceRoot) {\n      // The AgentDepsIncludesFn and AgentLockIncludesFn types overlap in their\n      // first two parameters. AgentLockIncludesFn accepts an optional third\n      // parameter which AgentDepsIncludesFn will ignore so we cast thingScanner\n      // as an AgentLockIncludesFn type.\n      const thingScanner = (\n        isLockScanned\n          ? lockfileIncludesByAgent.get(agent)\n          : depsIncludesByAgent.get(agent)\n      ) as AgentLockIncludesFn\n      const thingToScan = isLockScanned\n        ? lockSrc\n        : await lsByAgent.get(agent)!(pkgEnvDetails, pkgPath, { npmExecPath })\n      // Chunk package names to process them in parallel 3 at a time.\n      await pEach(overridesDataObjects, 3, async ({ overrides, type }) => {\n        const overrideExists = hasOwn(overrides, origPkgName)\n        if (\n          overrideExists ||\n          thingScanner(thingToScan, origPkgName, lockName)\n        ) {\n          const oldSpec = overrideExists ? overrides[origPkgName]! : undefined\n          const origDepAlias = depAliasMap.get(origPkgName)\n          const sockRegDepAlias = depAliasMap.get(sockRegPkgName)\n          const depAlias = sockRegDepAlias ?? origDepAlias\n          let newSpec = sockOverrideSpec\n          if (type === NPM && depAlias) {\n            // With npm one may not set an override for a package that one directly\n            // depends on unless both the dependency and the override itself share\n            // the exact same spec. To make this limitation easier to deal with,\n            // overrides may also be defined as a reference to a spec for a direct\n            // dependency by prefixing the name of the package to match the version\n            // of with a $.\n            // https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides\n            newSpec = `$${sockRegDepAlias ? sockRegPkgName : origPkgName}`\n          } else if (typeof oldSpec === 'string') {\n            const thisSpec = oldSpec.startsWith('$')\n              ? depAlias || newSpec\n              : oldSpec || newSpec\n            if (thisSpec.startsWith(sockOverridePrefix)) {\n              if (\n                pin &&\n                semver.major(\n                  // Check the validity of the spec by passing it through npa\n                  // and seeing if it will coerce to a version. semver.coerce\n                  // will strip leading v's, carets (^), comparators (<,<=,>,>=,=),\n                  // and tildes (~). If not coerced to a valid version then\n                  // default to the manifest entry version.\n                  semver.coerce(npa(thisSpec).rawSpec)?.version ?? version\n                ) !== major\n              ) {\n                const otherVersion = (await fetchPackageManifest(thisSpec))\n                  ?.version\n                if (otherVersion && otherVersion !== version) {\n                  newSpec = `${sockOverridePrefix}${pin ? otherVersion : `^${semver.major(otherVersion)}`}`\n                }\n              }\n            } else {\n              newSpec = oldSpec\n            }\n          }\n          if (newSpec !== oldSpec) {\n            overrides[origPkgName] = newSpec\n            const addedOrUpdated = overrideExists ? 'updated' : 'added'\n            state[addedOrUpdated].add(sockRegPkgName)\n          }\n        }\n      })\n    }\n  })\n\n  if (isWorkspace) {\n    // Chunk package names to process them in parallel 3 at a time.\n    await pEach(workspacePkgJsonPaths, 3, async workspacePkgJsonPath => {\n      const otherState = await addOverrides(\n        pkgEnvDetails,\n        path.dirname(workspacePkgJsonPath),\n        {\n          logger,\n          pin,\n          prod,\n          spinner\n        }\n      )\n      for (const key of [\n        'added',\n        'addedInWorkspaces',\n        'updated',\n        'updatedInWorkspaces'\n      ] satisfies\n        // Here we're just telling TS that we're looping over key names\n        // of the type and that they're all Set<string> props. This allows\n        // us to do the SetA.add(setB.get) pump type-safe without casts.\n        Array<\n          keyof Pick<\n            AddOverridesState,\n            'added' | 'addedInWorkspaces' | 'updated' | 'updatedInWorkspaces'\n          >\n        >) {\n        for (const value of otherState[key]) {\n          state[key].add(value)\n        }\n      }\n    })\n  }\n\n  if (state.added.size > 0 || state.updated.size > 0) {\n    pkgEnvDetails.editablePkgJson.update(\n      Object.fromEntries(depEntries) as PackageJson\n    )\n    for (const { overrides, type } of overridesDataObjects) {\n      updateManifestByAgent.get(type)!(pkgEnvDetails, toSortedObject(overrides))\n    }\n    await pkgEnvDetails.editablePkgJson.save()\n  }\n\n  return state\n}\n","import { Spinner } from '@socketsecurity/registry/lib/spinner'\n\nimport constants from '../../constants.mts'\nimport { runAgentInstall } from '../../utils/agent.mts'\nimport { cmdPrefixMessage } from '../../utils/cmd.mts'\n\nimport type { EnvDetails } from '../../utils/package-environment.mts'\nimport type { Logger } from '@socketsecurity/registry/lib/logger'\n\nconst { NPM_BUGGY_OVERRIDES_PATCHED_VERSION } = constants\n\nexport type UpdateLockfileOptions = {\n  cmdName?: string | undefined\n  logger?: Logger | undefined\n  spinner?: Spinner | undefined\n}\n\nexport async function updateLockfile(\n  pkgEnvDetails: EnvDetails,\n  options: UpdateLockfileOptions\n) {\n  const {\n    cmdName = '',\n    logger,\n    spinner\n  } = {\n    __proto__: null,\n    ...options\n  } as UpdateLockfileOptions\n  const isSpinning = !!spinner?.['isSpinning']\n  if (!isSpinning) {\n    spinner?.start()\n  }\n  spinner?.setText(`Updating ${pkgEnvDetails.lockName}...`)\n  try {\n    await runAgentInstall(pkgEnvDetails, { spinner })\n    if (pkgEnvDetails.features.npmBuggyOverrides) {\n      spinner?.stop()\n      logger?.log(\n        `💡 Re-run ${cmdName ? `${cmdName} ` : ''}whenever ${pkgEnvDetails.lockName} changes.\\n   This can be skipped for ${pkgEnvDetails.agent} >=${NPM_BUGGY_OVERRIDES_PATCHED_VERSION}.`\n      )\n    }\n  } catch (e) {\n    spinner?.stop()\n    logger?.fail(\n      cmdPrefixMessage(\n        cmdName,\n        `${pkgEnvDetails.agent} install failed to update ${pkgEnvDetails.lockName}`\n      )\n    )\n    logger?.error(e)\n  }\n  if (isSpinning) {\n    spinner?.start()\n  } else {\n    spinner?.stop()\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\nimport { pluralize } from '@socketsecurity/registry/lib/words'\n\nimport { addOverrides } from './add-overrides.mts'\nimport { CMD_NAME } from './shared.mts'\nimport { updateLockfile } from './update-lockfile.mts'\nimport constants from '../../constants.mts'\nimport { detectAndValidatePackageEnvironment } from '../../utils/package-environment.mts'\n\nfunction createActionMessage(\n  verb: string,\n  overrideCount: number,\n  workspaceCount: number\n): string {\n  return `${verb} ${overrideCount} Socket.dev optimized ${pluralize('override', overrideCount)}${workspaceCount ? ` in ${workspaceCount} ${pluralize('workspace', workspaceCount)}` : ''}`\n}\n\nexport async function applyOptimization(\n  cwd: string,\n  pin: boolean,\n  prod: boolean\n) {\n  const pkgEnvDetails = await detectAndValidatePackageEnvironment(cwd, {\n    cmdName: CMD_NAME,\n    logger,\n    prod\n  })\n  if (!pkgEnvDetails) {\n    return\n  }\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n\n  spinner.start('Socket optimizing...')\n\n  const state = await addOverrides(pkgEnvDetails, pkgEnvDetails.pkgPath, {\n    logger,\n    pin,\n    prod,\n    spinner\n  })\n\n  const addedCount = state.added.size\n  const updatedCount = state.updated.size\n  const pkgJsonChanged = addedCount > 0 || updatedCount > 0\n\n  if (pkgJsonChanged || pkgEnvDetails.features.npmBuggyOverrides) {\n    await updateLockfile(pkgEnvDetails, { cmdName: CMD_NAME, logger, spinner })\n  }\n\n  spinner.stop()\n\n  if (pkgJsonChanged) {\n    if (updatedCount > 0) {\n      logger?.log(\n        `${createActionMessage('Updated', updatedCount, state.updatedInWorkspaces.size)}${addedCount ? '.' : '🚀'}`\n      )\n    }\n    if (addedCount > 0) {\n      logger?.log(\n        `${createActionMessage('Added', addedCount, state.addedInWorkspaces.size)} 🚀`\n      )\n    }\n  } else {\n    logger?.log('Congratulations! Already Socket.dev optimized 🎉')\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { applyOptimization } from './apply-optimization.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'optimize',\n  description: 'Optimize dependencies with @socketregistry overrides',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    pin: {\n      type: 'boolean',\n      default: false,\n      description: 'Pin overrides to their latest version'\n    },\n    prod: {\n      type: 'boolean',\n      default: false,\n      description: 'Only add overrides for production dependencies'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}\n      $ ${command} --pin\n  `\n}\n\nexport const cmdOptimize = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  // TODO: impl json/md\n\n  const cwd = process.cwd()\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await applyOptimization(\n    cwd,\n    Boolean(cli.flags['pin']),\n    Boolean(cli.flags['prod'])\n  )\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchOrganization(): Promise<\n  CResult<SocketSdkReturnType<'getOrganizations'>['data']>\n> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(sockSdk.getOrganizations(), 'organization list')\n}\n","import colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { getVisibleTokenPrefix } from '../../utils/sdk.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputOrganizationList(\n  result: CResult<SocketSdkReturnType<'getOrganizations'>['data']>,\n  outputKind: OutputKind = 'text'\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const organizations = Object.values(result.data.organizations)\n  const visibleTokenPrefix = getVisibleTokenPrefix()\n\n  switch (outputKind) {\n    case 'markdown': {\n      // | Syntax      | Description |\n      // | ----------- | ----------- |\n      // | Header      | Title       |\n      // | Paragraph   | Text        |\n      let mw1 = 4\n      let mw2 = 2\n      let mw3 = 4\n      for (const o of organizations) {\n        mw1 = Math.max(mw1, o.name?.length ?? 0)\n        mw2 = Math.max(mw2, o.id.length)\n        mw3 = Math.max(mw3, o.plan.length)\n      }\n      logger.log('# Organizations\\n')\n      logger.log(\n        `List of organizations associated with your API key, starting with: ${colors.italic(visibleTokenPrefix)}\\n`\n      )\n      logger.log(\n        `| Name${' '.repeat(mw1 - 4)} | ID${' '.repeat(mw2 - 2)} | Plan${' '.repeat(mw3 - 4)} |`\n      )\n      logger.log(\n        `| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} | ${'-'.repeat(mw3)} |`\n      )\n      for (const o of organizations) {\n        logger.log(\n          `| ${(o.name || '').padEnd(mw1, ' ')} | ${(o.id || '').padEnd(mw2, ' ')} | ${(o.plan || '').padEnd(mw3, ' ')} |`\n        )\n      }\n      logger.log(\n        `| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} | ${'-'.repeat(mw3)} |`\n      )\n      return\n    }\n    default: {\n      logger.log(\n        `List of organizations associated with your API key, starting with: ${colors.italic(visibleTokenPrefix)}\\n`\n      )\n      // Just dump\n      for (const o of organizations) {\n        logger.log(\n          `- Name: ${colors.bold(o.name ?? 'undefined')}, ID: ${colors.bold(o.id)}, Plan: ${colors.bold(o.plan)}`\n        )\n      }\n    }\n  }\n}\n","import { fetchOrganization } from './fetch-organization-list.mts'\nimport { outputOrganizationList } from './output-organization-list.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleOrganizationList(\n  outputKind: OutputKind = 'text'\n): Promise<void> {\n  const data = await fetchOrganization()\n\n  await outputOrganizationList(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleOrganizationList } from './handle-organization-list.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'list',\n  description: 'List organizations associated with the API key used',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: none (does need a token)\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n  `\n}\n\nexport const cmdOrganizationList = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleOrganizationList(outputKind)\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchLicensePolicy(\n  orgSlug: string\n): Promise<CResult<SocketSdkReturnType<'getOrgLicensePolicy'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgLicensePolicy(orgSlug),\n    'organization license policy'\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mdTableOfPairs } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputLicensePolicy(\n  result: CResult<SocketSdkReturnType<'getOrgLicensePolicy'>['data']>,\n  outputKind: OutputKind\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.error('Use --json to get the full result')\n  logger.log('# License policy')\n  logger.log('')\n  logger.log('This is the license policy for your organization:')\n  logger.log('')\n  const rules = result.data['license_policy']!\n  const entries = rules ? Object.entries(rules) : []\n  const mapped: Array<[string, string]> = entries.map(\n    ([key, value]) =>\n      [key, (value as any)?.['allowed'] ? ' yes' : ' no'] as const\n  )\n  mapped.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))\n  logger.log(mdTableOfPairs(mapped, ['License Name', 'Allowed']))\n  logger.log('')\n}\n","import { fetchLicensePolicy } from './fetch-license-policy.mts'\nimport { outputLicensePolicy } from './output-license-policy.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleLicensePolicy(\n  orgSlug: string,\n  outputKind: OutputKind\n): Promise<void> {\n  const data = await fetchLicensePolicy(orgSlug)\n\n  await outputLicensePolicy(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleLicensePolicy } from './handle-license-policy.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\n// TODO: secret toplevel alias `socket license policy`?\nconst config: CliCommandConfig = {\n  commandName: 'license',\n  description: 'Retrieve the license policy of an organization',\n  hidden: true,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    }\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: license-policy:read\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Your API token will need the \\`license-policy:read\\` permission otherwise\n    the request will fail with an authentication error.\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' mycorp'}\n      $ ${command}${isTestingV1() ? '' : ' mycorp'} --json\n  `\n}\n\nexport const cmdOrganizationPolicyLicense = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleLicensePolicy(orgSlug, outputKind)\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchSecurityPolicy(\n  orgSlug: string\n): Promise<CResult<SocketSdkReturnType<'getOrgSecurityPolicy'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgSecurityPolicy(orgSlug),\n    'organization security policy'\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mdTableOfPairs } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputSecurityPolicy(\n  result: CResult<SocketSdkReturnType<'getOrgSecurityPolicy'>['data']>,\n  outputKind: OutputKind\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.log('# Security policy')\n  logger.log('')\n  logger.log(\n    `The default security policy setting is: \"${result.data.securityPolicyDefault}\"`\n  )\n  logger.log('')\n  logger.log(\n    'These are the security policies per setting for your organization:'\n  )\n  logger.log('')\n  const rules = result.data.securityPolicyRules\n  const entries: Array<\n    [string, { action: 'defer' | 'error' | 'warn' | 'monitor' | 'ignore' }]\n  > = rules ? Object.entries(rules) : []\n  const mapped: Array<[string, string]> = entries.map(([key, value]) => [\n    key,\n    value.action\n  ])\n  mapped.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))\n  logger.log(mdTableOfPairs(mapped, ['name', 'action']))\n  logger.log('')\n}\n","import { fetchSecurityPolicy } from './fetch-security-policy.mts'\nimport { outputSecurityPolicy } from './output-security-policy.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleSecurityPolicy(\n  orgSlug: string,\n  outputKind: OutputKind\n): Promise<void> {\n  const data = await fetchSecurityPolicy(orgSlug)\n\n  await outputSecurityPolicy(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleSecurityPolicy } from './handle-security-policy.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\n// TODO: secret toplevel alias `socket security policy`?\nconst config: CliCommandConfig = {\n  commandName: 'security',\n  description: 'Retrieve the security policy of an organization',\n  hidden: true,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    }\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: security-policy:read\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Your API token will need the \\`security-policy:read\\` permission otherwise\n    the request will fail with an authentication error.\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' mycorp'}\n      $ ${command}${isTestingV1() ? '' : ' mycorp'} --json\n  `\n}\n\nexport const cmdOrganizationPolicyPolicy = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: 'Org name as the first argument',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleSecurityPolicy(orgSlug, outputKind)\n}\n","import { cmdOrganizationPolicyLicense } from './cmd-organization-policy-license.mts'\nimport { cmdOrganizationPolicyPolicy } from './cmd-organization-policy-security.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Organization policy details'\n\nexport const cmdOrganizationPolicy: CliSubcommand = {\n  description,\n  // Hidden because it was broken all this time (nobody could be using it)\n  // and we're not sure if it's useful to anyone in its current state.\n  // Until we do, we'll hide this to keep the help tidier.\n  // And later, we may simply move this under `scan`, anyways.\n  hidden: true,\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        security: cmdOrganizationPolicyPolicy,\n        license: cmdOrganizationPolicyLicense\n      },\n      {\n        argv,\n        description,\n        defaultSub: 'list', // Backwards compat\n        importMeta,\n        name: parentName + ' policy'\n      }\n    )\n  }\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchQuota(): Promise<\n  CResult<SocketSdkReturnType<'getQuota'>['data']>\n> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(sockSdk.getQuota(), 'token quota')\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputQuota(\n  result: CResult<SocketSdkReturnType<'getQuota'>['data']>,\n  outputKind: OutputKind = 'text'\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    logger.log('# Quota')\n    logger.log('')\n    logger.log(`Quota left on the current API token: ${result.data.quota}`)\n    logger.log('')\n    return\n  }\n\n  logger.log(`Quota left on the current API token: ${result.data.quota}`)\n  logger.log('')\n}\n","import { fetchQuota } from './fetch-quota.mts'\nimport { outputQuota } from './output-quota.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleQuota(\n  outputKind: OutputKind = 'text'\n): Promise<void> {\n  const data = await fetchQuota()\n\n  await outputQuota(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleQuota } from './handle-quota.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'quota',\n  description: 'List organizations associated with the API key used',\n  hidden: true,\n  flags: {\n    ...commonFlags,\n    ...outputFlags\n  },\n  help: (command, _config) => `\n    Usage\n      $ ${command}\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n  `\n}\n\nexport const cmdOrganizationQuota = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const json = Boolean(cli.flags['json'])\n  const markdown = Boolean(cli.flags['markdown'])\n  const outputKind = getOutputKind(json, markdown)\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleQuota(outputKind)\n}\n","import { cmdOrganizationList } from './cmd-organization-list.mts'\nimport { cmdOrganizationPolicy } from './cmd-organization-policy.mts'\nimport { cmdOrganizationQuota } from './cmd-organization-quota.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Account details'\n\nexport const cmdOrganization: CliSubcommand = {\n  description,\n  // Hidden because it was broken all this time (nobody could be using it)\n  // and we're not sure if it's useful to anyone in its current state.\n  // Until we do, we'll hide this to keep the help tidier.\n  // And later, we may simply move this under `scan`, anyways.\n  hidden: true,\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        list: cmdOrganizationList,\n        quota: cmdOrganizationQuota,\n        policy: cmdOrganizationPolicy\n      },\n      {\n        argv,\n        description,\n        defaultSub: 'list', // Backwards compat\n        importMeta,\n        name: parentName + ' organization'\n      }\n    )\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { queryApiSafeJson } from '../../utils/api.mts'\n\nimport type { CResult } from '../../types.mts'\n\nexport interface PurlDataResponse {\n  purl: string\n  self: {\n    purl: string\n    score: {\n      license: number\n      maintenance: number\n      overall: number\n      quality: number\n      supplyChain: number\n      vulnerability: number\n    }\n    capabilities: string[]\n    alerts: Array<{\n      name: string\n      severity: string\n      category: string\n      example: string\n    }>\n  }\n  transitively: {\n    dependencyCount: number\n    func: string\n    score: {\n      license: number\n      maintenance: number\n      overall: number\n      quality: number\n      supplyChain: number\n      vulnerability: number\n    }\n    lowest: {\n      license: string\n      maintenance: string\n      overall: string\n      quality: string\n      supplyChain: string\n      vulnerability: string\n    }\n    capabilities: string[]\n    alerts: Array<{\n      name: string\n      severity: string\n      category: string\n      example: string\n    }>\n  }\n}\n\nexport async function fetchPurlDeepScore(\n  purl: string\n): Promise<CResult<PurlDataResponse>> {\n  logger.error(`Requesting deep score data for this purl: ${purl}`)\n\n  return await queryApiSafeJson<PurlDataResponse>(\n    `purl/score/${encodeURIComponent(purl)}`,\n    'the deep package scores'\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mdTable } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { PurlDataResponse } from './fetch-purl-deep-score.mts'\nimport type { CResult, OutputKind } from '../../types.mts'\n\nexport async function outputPurlScore(\n  purl: string,\n  result: CResult<PurlDataResponse>,\n  outputKind: OutputKind\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    const {\n      purl: requestedPurl,\n      self: {\n        alerts: selfAlerts,\n        capabilities: selfCaps,\n        purl,\n        score: selfScore\n      },\n      transitively: {\n        alerts,\n        capabilities,\n        dependencyCount,\n        func,\n        lowest,\n        score\n      }\n    } = result.data\n\n    logger.error(`Score report for \"${requestedPurl}\" (\"${purl}\"):\\n`)\n    logger.log('# Complete Package Score')\n    logger.log('')\n    if (dependencyCount) {\n      logger.log(\n        `This is a Socket report for the package *\"${purl}\"* and its *${dependencyCount}* direct/transitive dependencies.`\n      )\n    } else {\n      logger.log(\n        `This is a Socket report for the package *\"${purl}\"*. It has *no dependencies*.`\n      )\n    }\n    logger.log('')\n    if (dependencyCount) {\n      logger.log(\n        `It will show you the shallow score for just the package itself and a deep score for all the transitives combined. Additionally you can see which capabilities were found and the top alerts as well as a package that was responsible for it.`\n      )\n    } else {\n      logger.log(\n        `It will show you the shallow score for the package itself, which capabilities were found, and its top alerts.`\n      )\n      logger.log('')\n      logger.log(\n        'Since it has no dependencies, the shallow score is also the deep score.'\n      )\n    }\n    logger.log('')\n    if (dependencyCount) {\n      // This doesn't make much sense if there are no dependencies. Better to omit it.\n      logger.log(\n        'The report should give you a good insight into the status of this package.'\n      )\n      logger.log('')\n      logger.log('## Package itself')\n      logger.log('')\n      logger.log(\n        'Here are results for the package itself (excluding data from dependencies).'\n      )\n    } else {\n      logger.log('## Report')\n      logger.log('')\n      logger.log(\n        'The report should give you a good insight into the status of this package.'\n      )\n    }\n    logger.log('')\n    logger.log('### Shallow Score')\n    logger.log('')\n    logger.log('This score is just for the package itself:')\n    logger.log('')\n    logger.log('- Overall: ' + selfScore.overall)\n    logger.log('- Maintenance: ' + selfScore.maintenance)\n    logger.log('- Quality: ' + selfScore.quality)\n    logger.log('- Supply Chain: ' + selfScore.supplyChain)\n    logger.log('- Vulnerability: ' + selfScore.vulnerability)\n    logger.log('- License: ' + selfScore.license)\n    logger.log('')\n    logger.log('### Capabilities')\n    logger.log('')\n    if (selfCaps.length) {\n      logger.log('These are the capabilities detected in the package itself:')\n      logger.log('')\n      selfCaps.forEach(cap => {\n        logger.log(`- ${cap}`)\n      })\n    } else {\n      logger.log('No capabilities were found in the package.')\n    }\n    logger.log('')\n    logger.log('### Alerts for this package')\n    logger.log('')\n    if (selfAlerts.length) {\n      if (dependencyCount) {\n        logger.log('These are the alerts found for the package itself:')\n      } else {\n        logger.log('These are the alerts found for this package:')\n      }\n      logger.log('')\n      logger.log(\n        mdTable(selfAlerts, ['severity', 'name'], ['Severity', 'Alert Name'])\n      )\n    } else {\n      logger.log('There are currently no alerts for this package.')\n    }\n    logger.log('')\n    if (dependencyCount) {\n      logger.log('## Transitive Package Results')\n      logger.log('')\n      logger.log(\n        'Here are results for the package and its direct/transitive dependencies.'\n      )\n      logger.log('')\n      logger.log('### Deep Score')\n      logger.log('')\n      logger.log(\n        'This score represents the package and and its direct/transitive dependencies:'\n      )\n      logger.log(\n        `The function used to calculate the values in aggregate is: *\"${func}\"*`\n      )\n      logger.log('')\n      logger.log('- Overall: ' + score.overall)\n      logger.log('- Maintenance: ' + score.maintenance)\n      logger.log('- Quality: ' + score.quality)\n      logger.log('- Supply Chain: ' + score.supplyChain)\n      logger.log('- Vulnerability: ' + score.vulnerability)\n      logger.log('- License: ' + score.license)\n      logger.log('')\n      logger.log('### Capabilities')\n      logger.log('')\n      logger.log(\n        'These are the packages with the lowest recorded score. If there is more than one with the lowest score, just one is shown here. This may help you figure out the source of low scores.'\n      )\n      logger.log('')\n      logger.log('- Overall: ' + lowest.overall)\n      logger.log('- Maintenance: ' + lowest.maintenance)\n      logger.log('- Quality: ' + lowest.quality)\n      logger.log('- Supply Chain: ' + lowest.supplyChain)\n      logger.log('- Vulnerability: ' + lowest.vulnerability)\n      logger.log('- License: ' + lowest.license)\n      logger.log('')\n      logger.log('### Capabilities')\n      logger.log('')\n      if (capabilities.length) {\n        logger.log(\n          'These are the capabilities detected in at least one package:'\n        )\n        logger.log('')\n        capabilities.forEach(cap => {\n          logger.log(`- ${cap}`)\n        })\n      } else {\n        logger.log(\n          'This package had no capabilities and neither did any of its direct/transitive dependencies.'\n        )\n      }\n      logger.log('')\n      logger.log('### Alerts')\n      logger.log('')\n      if (alerts.length) {\n        logger.log('These are the alerts found:')\n        logger.log('')\n\n        logger.log(\n          mdTable(\n            alerts,\n            ['severity', 'name', 'example'],\n            ['Severity', 'Alert Name', 'Example package reporting it']\n          )\n        )\n      } else {\n        logger.log(\n          'This package had no alerts and neither did any of its direct/transitive dependencies'\n        )\n      }\n      logger.log('')\n    }\n    return\n  }\n\n  logger.log(\n    `Score report for \"${purl}\" (use --json for raw and --markdown for formatted reports):`\n  )\n  logger.log(result.data)\n  logger.log('')\n}\n","import { fetchPurlDeepScore } from './fetch-purl-deep-score.mts'\nimport { outputPurlScore } from './output-purl-score.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handlePurlDeepScore(\n  purl: string,\n  outputKind: OutputKind\n) {\n  const result = await fetchPurlDeepScore(purl)\n\n  await outputPurlScore(purl, result, outputKind)\n}\n","// Either an ecosystem was given or all args must be (namespaced) purls\n// The `pkg:` part is optional here. We'll scan for `eco/name@version`.\n// Not hardcoding the namespace since we don't know what the server accepts.\n// The ecosystem is considered as the first package if it is not an a-z string.\nexport function parsePackageSpecifiers(\n  ecosystem: string,\n  pkgs: string[]\n): { purls: string[]; valid: boolean } {\n  let valid = true\n  const purls = []\n  if (!ecosystem) {\n    valid = false\n  } else if (/^[a-zA-Z]+$/.test(ecosystem)) {\n    for (let i = 0; i < pkgs.length; ++i) {\n      const pkg = pkgs[i] ?? ''\n      if (!pkg) {\n        valid = false\n        break\n      } else if (pkg.startsWith('pkg:')) {\n        // keep\n        purls.push(pkg)\n      } else {\n        purls.push('pkg:' + ecosystem + '/' + pkg)\n      }\n    }\n    if (!purls.length) {\n      valid = false\n    }\n  } else {\n    // Assume ecosystem is a purl, too\n    pkgs.unshift(ecosystem)\n\n    for (let i = 0; i < pkgs.length; ++i) {\n      const pkg = pkgs[i] ?? ''\n      if (!/^(?:pkg:)?[a-zA-Z]+\\/./.test(pkg)) {\n        // At least one purl did not start with `pkg:eco/x` or `eco/x`\n        valid = false\n        break\n      } else if (pkg.startsWith('pkg:')) {\n        purls.push(pkg)\n      } else {\n        purls.push('pkg:' + pkg)\n      }\n    }\n\n    if (!purls.length) {\n      valid = false\n    }\n  }\n\n  return { purls, valid }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handlePurlDeepScore } from './handle-purl-deep-score.mts'\nimport { parsePackageSpecifiers } from './parse-package-specifiers.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'score',\n  description:\n    '[beta] Look up score for one package which reflects all of its transitive dependencies as well',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <<ecosystem> <name> | <purl>>\n\n    API Token Requirements\n      - Quota: 100 units\n      - Permissions: packages:list\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Show deep scoring details for one package. The score will reflect the package\n    itself, any of its dependencies, and any of its transitive dependencies.\n\n    When you want to know whether to trust a package, this is the command to run.\n\n    See also the \\`socket package shallow\\` command, which returns the shallow\n    score for any number of packages. That will not reflect the dependency scores.\n\n    Only a few ecosystems are supported like npm, golang, and maven.\n\n    A \"purl\" is a standard package name formatting: \\`pkg:eco/name@version\\`\n    This command will automatically prepend \"pkg:\" when not present.\n\n    The version is optional but when given should be a direct match.\n\n    Examples\n      $ ${command} npm babel-cli\n      $ ${command} npm babel-cli@1.9.1\n      $ ${command} npm/babel-cli@1.9.1\n      $ ${command} pkg:npm/babel-cli@1.9.1\n  `\n}\n\nexport const cmdPackageScore = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [ecosystem = '', purl] = cli.input\n\n  const hasApiToken = hasDefaultToken()\n\n  const { purls, valid } = parsePackageSpecifiers(ecosystem, purl ? [purl] : [])\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: valid,\n      message: 'First parameter must be an ecosystem or the whole purl',\n      pass: 'ok',\n      fail: 'bad'\n    },\n    {\n      test: purls.length === 1,\n      message: 'Expecting at least one package',\n      pass: 'ok',\n      fail: purls.length === 0 ? 'missing' : 'too many'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handlePurlDeepScore(purls[0] || '', outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchPurlsShallowScore(\n  purls: string[]\n): Promise<CResult<SocketSdkReturnType<'batchPackageFetch'>>> {\n  logger.error(\n    `Requesting shallow score data for ${purls.length} package urls (purl): ${purls.join(', ')}`\n  )\n\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  const result = await handleApiCall(\n    sockSdk.batchPackageFetch(\n      {\n        alerts: 'true'\n      },\n      { components: purls.map(purl => ({ purl })) }\n    ),\n    'looking up package'\n  )\n\n  if (!result.ok) {\n    return result\n  }\n\n  // TODO: seems like there's a bug in the typing since we absolutely have to return the .data here\n  return {\n    ok: true,\n    data: result.data as SocketSdkReturnType<'batchPackageFetch'>\n  }\n}\n","import colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { components } from '@socketsecurity/sdk/types/api'\n\nexport function outputPurlsShallowScore(\n  purls: string[],\n  result: CResult<Array<components['schemas']['SocketArtifact']>>,\n  outputKind: OutputKind\n): void {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  // Make some effort to match the requested data with the response\n\n  const set = new Set()\n  result.data.forEach(data => {\n    set.add('pkg:' + data.type + '/' + data.name + '@' + data.version)\n    set.add('pkg:' + data.type + '/' + data.name)\n  })\n  const missing = purls.filter(purl => {\n    if (set.has(purl)) {\n      return false\n    }\n    if (purl.endsWith('@latest') && set.has(purl.slice(0, -'@latest'.length))) {\n      return false\n    }\n    return true // not found\n  })\n\n  if (outputKind === 'markdown') {\n    logger.log(\n      `\n# Shallow Package Report\n\nThis report contains the response for requesting data on some package url(s).\n\nPlease note: The listed scores are ONLY for the package itself. It does NOT\n             reflect the scores of any dependencies, transitive or otherwise.\n\n${missing.length ? `\\n## Missing response\\n\\nAt least one package had no response or the purl was not canonical:\\n\\n${missing.map(purl => '- ' + purl + '\\n').join('')}` : ''}\n\n${result.data.map(data => '## ' + formatReportCard(data, false)).join('\\n\\n\\n')}\n    `.trim()\n    )\n    return\n  }\n\n  logger.log('\\n' + colors.bold('Shallow Package Score') + '\\n')\n  logger.log(\n    'Please note: The listed scores are ONLY for the package itself. It does NOT\\n' +\n      '             reflect the scores of any dependencies, transitive or otherwise.'\n  )\n\n  if (missing.length) {\n    logger.log(\n      `\\nAt least one package had no response or the purl was not canonical:\\n${missing.map(purl => '\\n- ' + colors.bold(purl)).join('')}`\n    )\n  }\n\n  result.data.forEach(data => {\n    logger.log('\\n')\n    logger.log(formatReportCard(data, true))\n  })\n  logger.log('')\n}\n\nfunction formatReportCard(\n  data: components['schemas']['SocketArtifact'],\n  color: boolean\n): string {\n  const scoreResult = {\n    'Supply Chain Risk': Math.floor((data.score?.supplyChain ?? 0) * 100),\n    Maintenance: Math.floor((data.score?.maintenance ?? 0) * 100),\n    Quality: Math.floor((data.score?.quality ?? 0) * 100),\n    Vulnerabilities: Math.floor((data.score?.vulnerability ?? 0) * 100),\n    License: Math.floor((data.score?.license ?? 0) * 100)\n  }\n  const alertString = getAlertString(data.alerts, !color)\n  const purl = 'pkg:' + data.type + '/' + data.name + '@' + data.version\n\n  return [\n    'Package: ' + (color ? colors.bold(purl) : purl),\n    '',\n    ...Object.entries(scoreResult).map(\n      score =>\n        `- ${score[0]}:`.padEnd(20, ' ') +\n        `  ${formatScore(score[1], !color, true)}`\n    ),\n    alertString\n  ].join('\\n')\n}\n\nfunction formatScore(score: number, noColor = false, pad = false): string {\n  const padded = String(score).padStart(pad ? 3 : 0, ' ')\n  if (noColor) {\n    return padded\n  }\n  if (score >= 80) {\n    return colors.green(padded)\n  }\n  if (score >= 60) {\n    return colors.yellow(padded)\n  }\n  return colors.red(padded)\n}\n\nfunction getAlertString(\n  alerts: Array<components['schemas']['SocketAlert']> | undefined,\n  noColor = false\n) {\n  if (!alerts?.length) {\n    return noColor ? `- Alerts: none!` : `- Alerts: ${colors.green('none')}!`\n  }\n  const bad = alerts\n    .filter(alert => alert.severity !== 'low' && alert.severity !== 'middle')\n    .sort((a, b) => (a.type < b.type ? -1 : a.type > b.type ? 1 : 0))\n  const mid = alerts\n    .filter(alert => alert.severity === 'middle')\n    .sort((a, b) => (a.type < b.type ? -1 : a.type > b.type ? 1 : 0))\n  const low = alerts\n    .filter(alert => alert.severity === 'low')\n    .sort((a, b) => (a.type < b.type ? -1 : a.type > b.type ? 1 : 0))\n\n  // We need to create the no-color string regardless because the actual string\n  // contains a bunch of invisible ANSI chars which would screw up length checks.\n  const colorless = `- Alerts (${bad.length}/${mid.length.toString()}/${low.length}):`\n\n  if (noColor) {\n    return (\n      colorless +\n      ' '.repeat(Math.max(0, 20 - colorless.length)) +\n      '  ' +\n      [\n        bad.map(alert => `[${alert.severity}] ` + alert.type).join(', '),\n        mid.map(alert => `[${alert.severity}] ` + alert.type).join(', '),\n        low.map(alert => `[${alert.severity}] ` + alert.type).join(', ')\n      ]\n        .filter(Boolean)\n        .join(', ')\n    )\n  }\n  return (\n    `- Alerts (${colors.red(bad.length.toString())}/${colors.yellow(mid.length.toString())}/${low.length}):` +\n    ' '.repeat(Math.max(0, 20 - colorless.length)) +\n    '  ' +\n    [\n      bad\n        .map(alert =>\n          colors.red(colors.dim(`[${alert.severity}] `) + alert.type)\n        )\n        .join(', '),\n      mid\n        .map(alert =>\n          colors.yellow(colors.dim(`[${alert.severity}] `) + alert.type)\n        )\n        .join(', '),\n      low\n        .map(alert => colors.dim(`[${alert.severity}] `) + alert.type)\n        .join(', ')\n    ]\n      .filter(Boolean)\n      .join(', ')\n  )\n}\n","import { fetchPurlsShallowScore } from './fetch-purls-shallow-score.mts'\nimport { outputPurlsShallowScore } from './output-purls-shallow-score.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { components } from '@socketsecurity/sdk/types/api'\n\nexport async function handlePurlsShallowScore({\n  outputKind,\n  purls\n}: {\n  outputKind: OutputKind\n  purls: string[]\n}) {\n  const packageData = await fetchPurlsShallowScore(purls)\n\n  outputPurlsShallowScore(\n    purls,\n    packageData as CResult<Array<components['schemas']['SocketArtifact']>>,\n    outputKind\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handlePurlsShallowScore } from './handle-purls-shallow-score.mts'\nimport { parsePackageSpecifiers } from './parse-package-specifiers.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'shallow',\n  description:\n    '[beta] Look up info regarding one or more packages but not their transitives',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <<ecosystem> <name> [<name> ...] | <purl> [<purl> ...]>\n\n    API Token Requirements\n      - Quota: 100 units\n      - Permissions: packages:list\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Show scoring details for one or more packages purely based on their own package.\n    This means that any dependency scores are not reflected by the score. You can\n    use the \\`socket package score <pkg>\\` command to get its full transitive score.\n\n    Only a few ecosystems are supported like npm, golang, and maven.\n\n    A \"purl\" is a standard package name formatting: \\`pkg:eco/name@version\\`\n    This command will automatically prepend \"pkg:\" when not present.\n\n    If the first arg is an ecosystem, remaining args that are not a purl are\n    assumed to be scoped to that ecosystem.\n\n    Examples\n      $ ${command} npm webtorrent\n      $ ${command} npm webtorrent@1.9.1\n      $ ${command} npm/webtorrent@1.9.1\n      $ ${command} pkg:npm/webtorrent@1.9.1\n      $ ${command} maven webtorrent babel\n      $ ${command} npm/webtorrent golang/babel\n      $ ${command} npm npm/webtorrent@1.0.1 babel\n  `\n}\n\nexport const cmdPackageShallow = {\n  description: config.description,\n  hidden: config.hidden,\n  alias: {\n    shallowScore: {\n      description: config.description,\n      hidden: true,\n      argv: []\n    }\n  },\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [ecosystem = '', ...pkgs] = cli.input\n\n  const { purls, valid } = parsePackageSpecifiers(ecosystem, pkgs)\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: valid,\n      message:\n        'First parameter should be an ecosystem or all args must be purls',\n      pass: 'ok',\n      fail: 'bad'\n    },\n    {\n      test: purls.length > 0,\n      message: 'Expecting at least one package',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handlePurlsShallowScore({\n    outputKind,\n    purls\n  })\n}\n","import { cmdPackageScore } from './cmd-package-score.mts'\nimport { cmdPackageShallow } from './cmd-package-shallow.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Commands relating to looking up published packages'\n\nexport const cmdPackage: CliSubcommand = {\n  description,\n  hidden: false,\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        score: cmdPackageScore,\n        shallow: cmdPackageShallow\n      },\n      {\n        aliases: {\n          deep: {\n            description,\n            hidden: true,\n            argv: ['score']\n          }\n        },\n        argv,\n        description,\n        importMeta,\n        name: parentName + ' package'\n      }\n    )\n  }\n}\n","import { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\nimport { getNpmBinPath } from '../../utils/npm-paths.mts'\n\nexport async function runRawNpm(\n  argv: string[] | readonly string[]\n): Promise<void> {\n  const spawnPromise = spawn(getNpmBinPath(), argv as string[], {\n    // Lazily access constants.WIN32.\n    shell: constants.WIN32,\n    stdio: 'inherit'\n  })\n  // See https://nodejs.org/api/all.html#all_child_process_event-exit.\n  spawnPromise.process.on('exit', (code, signalName) => {\n    if (signalName) {\n      process.kill(process.pid, signalName)\n    } else if (code !== null) {\n      // eslint-disable-next-line n/no-process-exit\n      process.exit(code)\n    }\n  })\n  await spawnPromise\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { runRawNpm } from './run-raw-npm.mts'\nimport constants from '../../constants.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW, NPM } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'raw-npm',\n  description: `Temporarily disable the Socket ${NPM} wrapper`,\n  hidden: false,\n  flags: {},\n  help: command => `\n    Usage\n      $ ${command} <command>\n\n    Examples\n      $ ${command} install\n  `\n}\n\nexport const cmdRawNpm = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    allowUnknownFlags: true,\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await runRawNpm(argv)\n}\n","import { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\nimport { getNpxBinPath } from '../../utils/npm-paths.mts'\n\nexport async function runRawNpx(\n  argv: string[] | readonly string[]\n): Promise<void> {\n  const spawnPromise = spawn(getNpxBinPath(), argv as string[], {\n    // Lazily access constants.WIN32.\n    shell: constants.WIN32,\n    stdio: 'inherit'\n  })\n  // See https://nodejs.org/api/all.html#all_child_process_event-exit.\n  spawnPromise.process.on('exit', (code, signalName) => {\n    if (signalName) {\n      process.kill(process.pid, signalName)\n    } else if (code !== null) {\n      // eslint-disable-next-line n/no-process-exit\n      process.exit(code)\n    }\n  })\n  await spawnPromise\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { runRawNpx } from './run-raw-npx.mts'\nimport constants from '../../constants.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW, NPX } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'raw-npx',\n  description: `Temporarily disable the Socket ${NPX} wrapper`,\n  hidden: false,\n  flags: {},\n  help: command => `\n    Usage\n      $ ${command} <command>\n\n    Examples\n      $ ${command} install\n  `\n}\n\nexport const cmdRawNpx = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    allowUnknownFlags: true,\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await runRawNpx(argv)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst config: CliCommandConfig = {\n  commandName: 'create',\n  description: '[Deprecated] Create a project report',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags\n  },\n  help: () => `\n    This command is deprecated in favor of \\`socket scan view\\`.\n    It will be removed in the next major release of the CLI.\n  `\n}\n\nexport const cmdReportCreate = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  logger.fail(\n    'This command has been sunset. Instead, please look at `socket scan create` to create scans and `socket scan report` to view a report of your scans.'\n  )\n\n  process.exitCode = 1\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst config: CliCommandConfig = {\n  commandName: 'view',\n  description: '[Deprecated] View a project report',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags\n  },\n  help: () => `\n    This command is deprecated in favor of \\`socket scan view\\`.\n    It will be removed in the next major release of the CLI.\n  `\n}\n\nexport const cmdReportView = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  logger.fail(\n    'This command has been sunset. Instead, please look at `socket scan create` to create scans and `socket scan report` to view a report of your scans.'\n  )\n\n  process.exitCode = 1\n}\n","import { cmdReportCreate } from './cmd-report-create.mts'\nimport { cmdReportView } from './cmd-report-view.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = '[Deprecated] Project report related commands'\n\nexport const cmdReport: CliSubcommand = {\n  description,\n  hidden: true, // Deprecated in favor of `scan`\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        create: cmdReportCreate,\n        view: cmdReportView\n      },\n      {\n        argv,\n        description,\n        importMeta,\n        name: parentName + ' report'\n      }\n    )\n  }\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchCreateRepo({\n  default_branch,\n  description,\n  homepage,\n  orgSlug,\n  repoName,\n  visibility\n}: {\n  orgSlug: string\n  repoName: string\n  description: string\n  homepage: string\n  default_branch: string\n  visibility: string\n}): Promise<CResult<SocketSdkReturnType<'createOrgRepo'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.createOrgRepo(orgSlug, {\n      name: repoName,\n      description,\n      homepage,\n      default_branch,\n      visibility\n    }),\n    'to create a repository'\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport function outputCreateRepo(\n  result: CResult<SocketSdkReturnType<'createOrgRepo'>['data']>,\n  requestedName: string,\n  outputKind: OutputKind\n): void {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n  const { slug } = result.data\n  logger.success(\n    `OK. Repository created successfully, slug: \\`${slug}\\`${slug !== requestedName ? ' (Warning: slug is not the same as name that was requested!)' : ''}`\n  )\n}\n","import { fetchCreateRepo } from './fetch-create-repo.mts'\nimport { outputCreateRepo } from './output-create-repo.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleCreateRepo(\n  {\n    default_branch,\n    description,\n    homepage,\n    orgSlug,\n    repoName,\n    visibility\n  }: {\n    orgSlug: string\n    repoName: string\n    description: string\n    homepage: string\n    default_branch: string\n    visibility: string\n  },\n  outputKind: OutputKind\n): Promise<void> {\n  const data = await fetchCreateRepo({\n    default_branch,\n    description,\n    homepage,\n    orgSlug,\n    repoName,\n    visibility\n  })\n  outputCreateRepo(data, repoName, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleCreateRepo } from './handle-create-repo.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'create',\n  description: 'Create a repository in an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    defaultBranch: {\n      type: 'string',\n      shortFlag: 'b',\n      default: 'main',\n      description: 'Repository default branch'\n    },\n    homepage: {\n      type: 'string',\n      shortFlag: 'h',\n      default: '',\n      description: 'Repository url'\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    },\n    repoDescription: {\n      type: 'string',\n      shortFlag: 'd',\n      default: '',\n      description: 'Repository description'\n    },\n    repoName: {\n      type: 'string',\n      shortFlag: 'n',\n      default: '',\n      description: 'Repository name'\n    },\n    visibility: {\n      type: 'string',\n      shortFlag: 'v',\n      default: 'private',\n      description: 'Repository visibility (Default Private)'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} ${isTestingV1() ? '<repo>' : '<org slug> --repo-name=<name>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: repo:create\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? 'test-repo' : 'FakeOrg --repoName=test-repo'}\n  `\n}\n\nexport const cmdReposCreate = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const {\n    dryRun,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag,\n    repoName: repoNameFlag\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const repoName = (isTestingV1() ? cli.input[0] : repoNameFlag) || ''\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      test: !!repoName,\n      message: isTestingV1()\n        ? 'Repository name as first argument'\n        : 'Repository name using --repoName',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    },\n    {\n      nook: true,\n      test: !isTestingV1() || !repoNameFlag,\n      message: 'In v1 the first arg should be the repo, not the flag',\n      pass: 'ok',\n      fail: 'received --repo-name flag'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (dryRun) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleCreateRepo(\n    {\n      orgSlug,\n      repoName: String(repoName),\n      description: String(cli.flags['repoDescription'] || ''),\n      homepage: String(cli.flags['homepage'] || ''),\n      default_branch: String(cli.flags['defaultBranch'] || ''),\n      visibility: String(cli.flags['visibility'] || 'private')\n    },\n    outputKind\n  )\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchDeleteRepo(\n  orgSlug: string,\n  repoName: string\n): Promise<CResult<SocketSdkReturnType<'deleteOrgRepo'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.deleteOrgRepo(orgSlug, repoName),\n    'to delete a repository'\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputDeleteRepo(\n  result: CResult<SocketSdkReturnType<'deleteOrgRepo'>['data']>,\n  repoName: string,\n  outputKind: OutputKind\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.success(`OK. Repository \\`${repoName}\\` deleted successfully`)\n}\n","import { fetchDeleteRepo } from './fetch-delete-repo.mts'\nimport { outputDeleteRepo } from './output-delete-repo.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleDeleteRepo(\n  orgSlug: string,\n  repoName: string,\n  outputKind: OutputKind\n) {\n  const data = await fetchDeleteRepo(orgSlug, repoName)\n\n  await outputDeleteRepo(data, repoName, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleDeleteRepo } from './handle-delete-repo.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'del',\n  description: 'Delete a repository in an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} ${isTestingV1() ? '<repo>' : '<org slug> --repo-name=<name>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: repo:delete\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? 'test-repo' : 'FakeOrg test-repo'}\n  `\n}\n\nexport const cmdReposDel = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const repoName =\n    (defaultOrgSlug || isTestingV1() ? cli.input[0] : cli.input[1]) || ''\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      test: !!repoName,\n      message: isTestingV1()\n        ? 'Repository name as first argument'\n        : 'Repository name using --repoName',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (dryRun) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleDeleteRepo(orgSlug, repoName, outputKind)\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchListRepos({\n  direction,\n  orgSlug,\n  page,\n  per_page,\n  sort\n}: {\n  direction: string\n  orgSlug: string\n  page: number\n  per_page: number\n  sort: string\n}): Promise<CResult<SocketSdkReturnType<'getOrgRepoList'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgRepoList(orgSlug, {\n      sort,\n      direction,\n      per_page: String(per_page),\n      page: String(page)\n    }),\n    'list of repositories'\n  )\n}\n","// @ts-ignore\nimport chalkTable from 'chalk-table'\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputListRepos(\n  result: CResult<SocketSdkReturnType<'getOrgRepoList'>['data']>,\n  outputKind: OutputKind\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const options = {\n    columns: [\n      { field: 'id', name: colors.magenta('ID') },\n      { field: 'name', name: colors.magenta('Name') },\n      { field: 'visibility', name: colors.magenta('Visibility') },\n      { field: 'default_branch', name: colors.magenta('Default branch') },\n      { field: 'archived', name: colors.magenta('Archived') }\n    ]\n  }\n\n  logger.log(chalkTable(options, result.data.results))\n}\n","import { fetchListRepos } from './fetch-list-repos.mts'\nimport { outputListRepos } from './output-list-repos.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleListRepos({\n  direction,\n  orgSlug,\n  outputKind,\n  page,\n  per_page,\n  sort\n}: {\n  direction: string\n  orgSlug: string\n  outputKind: OutputKind\n  page: number\n  per_page: number\n  sort: string\n}): Promise<void> {\n  const data = await fetchListRepos({\n    direction,\n    orgSlug,\n    page,\n    per_page,\n    sort\n  })\n\n  await outputListRepos(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleListRepos } from './handle-list-repos.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'list',\n  description: 'List repositories in an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    sort: {\n      type: 'string',\n      shortFlag: 's',\n      default: 'created_at',\n      description: 'Sorting option'\n    },\n    direction: {\n      type: 'string',\n      default: 'desc',\n      description: 'Direction option'\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    },\n    perPage: {\n      type: 'number',\n      shortFlag: 'pp',\n      default: 30,\n      description: 'Number of results per page'\n    },\n    page: {\n      type: 'number',\n      shortFlag: 'p',\n      default: 1,\n      description: 'Page number'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} ${isTestingV1() ? '' : '<org slug>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: repo:list\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? '' : '<org slug>'}\n  `\n}\n\nexport const cmdReposList = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const { dryRun, interactive, org: orgFlag } = cli.flags\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleListRepos({\n    direction: cli.flags['direction'] === 'asc' ? 'asc' : 'desc',\n    orgSlug,\n    outputKind,\n    page: Number(cli.flags['page']) || 1,\n    per_page: Number(cli.flags['perPage']) || 30,\n    sort: String(cli.flags['sort'] || 'created_at')\n  })\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchUpdateRepo({\n  default_branch,\n  description,\n  homepage,\n  orgSlug,\n  repoName,\n  visibility\n}: {\n  orgSlug: string\n  repoName: string\n  description: string\n  homepage: string\n  default_branch: string\n  visibility: string\n}): Promise<CResult<SocketSdkReturnType<'updateOrgRepo'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.updateOrgRepo(orgSlug, repoName, {\n      orgSlug,\n      name: repoName,\n      description,\n      homepage,\n      default_branch,\n      visibility\n    }),\n    'to update a repository'\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputUpdateRepo(\n  result: CResult<SocketSdkReturnType<'updateOrgRepo'>['data']>,\n  repoName: string,\n  outputKind: OutputKind\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.success(`Repository \\`${repoName}\\` updated successfully`)\n}\n","import { fetchUpdateRepo } from './fetch-update-repo.mts'\nimport { outputUpdateRepo } from './output-update-repo.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleUpdateRepo(\n  {\n    default_branch,\n    description,\n    homepage,\n    orgSlug,\n    repoName,\n    visibility\n  }: {\n    orgSlug: string\n    repoName: string\n    description: string\n    homepage: string\n    default_branch: string\n    visibility: string\n  },\n  outputKind: OutputKind\n): Promise<void> {\n  const data = await fetchUpdateRepo({\n    default_branch,\n    description,\n    homepage,\n    orgSlug,\n    repoName,\n    visibility\n  })\n\n  await outputUpdateRepo(data, repoName, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleUpdateRepo } from './handle-update-repo.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'update',\n  description: 'Update a repository in an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    defaultBranch: {\n      type: 'string',\n      shortFlag: 'b',\n      default: 'main',\n      description: 'Repository default branch'\n    },\n    homepage: {\n      type: 'string',\n      shortFlag: 'h',\n      default: '',\n      description: 'Repository url'\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    },\n    repoName: {\n      type: 'string',\n      shortFlag: 'n',\n      default: '',\n      description: 'Repository name'\n    },\n    repoDescription: {\n      type: 'string',\n      shortFlag: 'd',\n      default: '',\n      description: 'Repository description'\n    },\n    visibility: {\n      type: 'string',\n      shortFlag: 'v',\n      default: 'private',\n      description: 'Repository visibility (Default Private)'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} ${isTestingV1() ? '<repo>' : '<org slug> --repo-name=<name>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: repo:update\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? 'test-repo' : 'FakeOrg test-repo'}\n  `\n}\n\nexport const cmdReposUpdate = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const repoNameFlag = cli.flags['repoName']\n  const repoName = (isTestingV1() ? cli.input[0] : repoNameFlag) || ''\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      test: !!repoName,\n      message: isTestingV1()\n        ? 'Repository name as first argument'\n        : 'Repository name using --repoName',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    },\n    {\n      nook: true,\n      test: !isTestingV1() || !repoNameFlag,\n      message: 'In v1 the first arg should be the repo, not the flag',\n      pass: 'ok',\n      fail: 'received --repo-name flag'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleUpdateRepo(\n    {\n      orgSlug,\n      repoName: String(repoName),\n      description: String(cli.flags['repoDescription'] || ''),\n      homepage: String(cli.flags['homepage'] || ''),\n      default_branch: String(cli.flags['defaultBranch'] || ''),\n      visibility: String(cli.flags['visibility'] || 'private')\n    },\n    outputKind\n  )\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchViewRepo(\n  orgSlug: string,\n  repoName: string\n): Promise<CResult<SocketSdkReturnType<'getOrgRepo'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgRepo(orgSlug, repoName),\n    'repository data'\n  )\n}\n","// @ts-ignore\nimport chalkTable from 'chalk-table'\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputViewRepo(\n  result: CResult<SocketSdkReturnType<'createOrgRepo'>['data']>,\n  outputKind: OutputKind\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const options = {\n    columns: [\n      { field: 'id', name: colors.magenta('ID') },\n      { field: 'name', name: colors.magenta('Name') },\n      { field: 'visibility', name: colors.magenta('Visibility') },\n      { field: 'default_branch', name: colors.magenta('Default branch') },\n      { field: 'homepage', name: colors.magenta('Homepage') },\n      { field: 'archived', name: colors.magenta('Archived') },\n      { field: 'created_at', name: colors.magenta('Created at') }\n    ]\n  }\n\n  logger.log(chalkTable(options, [result.data]))\n}\n","import { fetchViewRepo } from './fetch-view-repo.mts'\nimport { outputViewRepo } from './output-view-repo.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleViewRepo(\n  orgSlug: string,\n  repoName: string,\n  outputKind: OutputKind\n): Promise<void> {\n  const data = await fetchViewRepo(orgSlug, repoName)\n\n  await outputViewRepo(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleViewRepo } from './handle-view-repo.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'view',\n  description: 'View repositories in an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    },\n    repoName: {\n      description: 'The repository to check',\n      default: '',\n      type: 'string'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} ${isTestingV1() ? '<repo>' : '<org slug> --repo-name=<name>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: repo:list\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} ${isTestingV1() ? 'test-repo' : 'FakeOrg test-repo'}\n  `\n}\n\nexport const cmdReposView = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const {\n    dryRun,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag,\n    repoName: repoNameFlag\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const repoName = (isTestingV1() ? cli.input[0] : repoNameFlag) || ''\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      test: !!repoName,\n      message: isTestingV1()\n        ? 'Repository name as first argument'\n        : 'Repository name using --repoName',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    },\n    {\n      nook: true,\n      test: !isTestingV1() || !repoNameFlag,\n      message: 'In v1 the first arg should be the repo, not the flag',\n      pass: 'ok',\n      fail: 'received --repo-name flag'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleViewRepo(orgSlug, String(repoName), outputKind)\n}\n","import { cmdReposCreate } from './cmd-repos-create.mts'\nimport { cmdReposDel } from './cmd-repos-del.mts'\nimport { cmdReposList } from './cmd-repos-list.mts'\nimport { cmdReposUpdate } from './cmd-repos-update.mts'\nimport { cmdReposView } from './cmd-repos-view.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Repositories related commands'\n\nexport const cmdRepos: CliSubcommand = {\n  description,\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        create: cmdReposCreate,\n        view: cmdReposView,\n        list: cmdReposList,\n        del: cmdReposDel,\n        update: cmdReposUpdate\n      },\n      {\n        argv,\n        description,\n        importMeta,\n        name: `${parentName} repos`\n      }\n    )\n  }\n}\n","import { select } from '@socketsecurity/registry/lib/prompts'\n\nexport async function suggestTarget(): Promise<string[] | void> {\n  // We could prefill this with sub-dirs of the current\n  // dir ... but is that going to be useful?\n  const proceed = await select<boolean>({\n    message: 'No TARGET given. Do you want to use the current directory?',\n    choices: [\n      {\n        name: 'Yes',\n        value: true,\n        description: 'Target the current directory'\n      },\n      {\n        name: 'No',\n        value: false,\n        description:\n          'Do not use the current directory (this will end in a no-op)'\n      }\n    ]\n  })\n  if (proceed) {\n    return ['.']\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleCreateNewScan } from './handle-create-new-scan.mts'\nimport { suggestOrgSlug } from './suggest-org-slug.mts'\nimport { suggestTarget } from './suggest_target.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'create',\n  description: 'Create a scan',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    branch: {\n      type: 'string',\n      shortFlag: 'b',\n      default: 'socket-default-branch',\n      description: 'Branch name'\n    },\n    commitMessage: {\n      type: 'string',\n      shortFlag: 'm',\n      default: '',\n      description: 'Commit message'\n    },\n    commitHash: {\n      type: 'string',\n      shortFlag: 'ch',\n      default: '',\n      description: 'Commit hash'\n    },\n    committers: {\n      type: 'string',\n      shortFlag: 'c',\n      default: '',\n      description: 'Committers'\n    },\n    cwd: {\n      type: 'string',\n      description: 'working directory, defaults to process.cwd()'\n    },\n    defaultBranch: {\n      type: 'boolean',\n      default: false,\n      description:\n        'Set the default branch of the repository to the branch of this full-scan. Should only need to be done once, for example for the \"main\" or \"master\" branch.'\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    pendingHead: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Designate this full-scan as the latest scan of a given branch. This must be set to have it show up in the dashboard.'\n    },\n    pullRequest: {\n      type: 'number',\n      shortFlag: 'pr',\n      description: 'Commit hash'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    },\n    readOnly: {\n      type: 'boolean',\n      default: false,\n      description:\n        'Similar to --dry-run except it can read from remote, stops before it would create an actual report'\n    },\n    repo: {\n      type: 'string',\n      shortFlag: 'r',\n      default: 'socket-default-repository',\n      description: 'Repository name'\n    },\n    report: {\n      type: 'boolean',\n      default: false,\n      description:\n        'Wait for the scan creation to complete, then basically run `socket scan report` on it'\n    },\n    tmp: {\n      type: 'boolean',\n      shortFlag: 't',\n      default: false,\n      description:\n        'Set the visibility (true/false) of the scan in your dashboard. Can not be used when --pendingHead is set.'\n    }\n  },\n  // TODO: your project's \"socket.yml\" file's \"projectIgnorePaths\"\n  help: (command, config) => `\n    Usage\n      $ ${command} [...options]${isTestingV1() ? '' : ' <org>'} <TARGET> [TARGET...]\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:create\n\n    Uploads the specified \"package.json\" and lock files for JavaScript, Python,\n    Go, Scala, Gradle, and Kotlin dependency manifests.\n    If any folder is specified, the ones found in there recursively are uploaded.\n\n    Supports globbing such as \"**/package.json\", \"**/requirements.txt\", etc.\n\n    Ignores any file specified in your project's \".gitignore\" and also has a\n    sensible set of default ignores from the \"ignore-by-default\" module.\n\n    TARGET should be a FILE or DIR that _must_ be inside the CWD.\n\n    When a FILE is given only that FILE is targeted. Otherwise any eligible\n    files in the given DIR will be considered.\n\n    The --repo and --branch flags tell Socket to associate this Scan with that\n    repo/branch. The names will show up on your dashboard on the Socket website.\n\n    Note: for a first run you probably want to set --defaultBranch to indicate\n          the default branch name, like \"main\" or \"master\".\n\n    Note: --pendingHead is enabled by default and makes a scan show up in your\n          dashboard. You can use \\`--no-pendingHead\\` to have it not show up.\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} .\n      $ ${command} --repo=test-repo --branch=main${isTestingV1() ? '' : ' FakeOrg'} ./package.json\n  `\n}\n\nexport const cmdScanCreate = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const {\n    branch: branchName = 'socket-default-branch',\n    commitHash,\n    commitMessage,\n    committers,\n    cwd: cwdOverride,\n    defaultBranch,\n    dryRun = false,\n    interactive = true,\n    json,\n    markdown,\n    org: orgFlag,\n    pendingHead,\n    pullRequest,\n    readOnly,\n    repo: repoName = 'socket-default-repository',\n    report,\n    tmp\n  } = cli.flags as {\n    branch: string\n    cwd: string\n    commitHash: string\n    commitMessage: string\n    committers: string\n    defaultBranch: boolean\n    dryRun: boolean\n    interactive: boolean\n    json: boolean\n    markdown: boolean\n    org: string\n    pendingHead: boolean\n    pullRequest: number\n    readOnly: boolean\n    repo: string\n    report: boolean\n    tmp: boolean\n  }\n  const outputKind = getOutputKind(json, markdown)\n\n  let [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    interactive,\n    dryRun\n  )\n  if (!defaultOrgSlug) {\n    // Tmp. just for TS. will drop this later.\n    defaultOrgSlug = ''\n  }\n\n  let targets = cli.input.slice(isTestingV1() || defaultOrgSlug ? 0 : 1)\n\n  const cwd =\n    cwdOverride && cwdOverride !== 'process.cwd()'\n      ? String(cwdOverride)\n      : process.cwd()\n\n  // We're going to need an api token to suggest data because those suggestions\n  // must come from data we already know. Don't error on missing api token yet.\n  // If the api-token is not set, ignore it for the sake of suggestions.\n  const hasApiToken = hasDefaultToken()\n\n  // If we updated any inputs then we should print the command line to repeat\n  // the command without requiring user input, as a suggestion.\n  let updatedInput = false\n\n  if (!targets.length && !dryRun && interactive) {\n    const received = await suggestTarget()\n    targets = received ?? []\n    updatedInput = true\n  }\n\n  // If the current cwd is unknown and is used as a repo slug anyways, we will\n  // first need to register the slug before we can use it.\n  // Only do suggestions with an apiToken and when not in dryRun mode\n  if (hasApiToken && !dryRun && interactive) {\n    if (!orgSlug) {\n      const suggestion = await suggestOrgSlug()\n      if (suggestion) {\n        orgSlug = suggestion\n      }\n      updatedInput = true\n    }\n  }\n\n  if (updatedInput && orgSlug && targets?.length) {\n    logger.error(\n      'Note: You can invoke this command next time to skip the interactive questions:'\n    )\n    logger.error('```')\n    logger.error(\n      `    socket scan create [other flags...] ${defaultOrgSlug ? '' : orgSlug} ${targets.join(' ')}`\n    )\n    logger.error('```\\n')\n  }\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !isTestingV1() && !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing'\n    },\n    {\n      test: !!targets.length,\n      message: 'At least one TARGET (e.g. `.` or `./package.json`)',\n      pass: 'ok',\n      fail: 'missing (or perhaps you forgot the org slug?)'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message: 'This command requires an API token for access',\n      pass: 'ok',\n      fail: 'missing (try `socket login`)'\n    },\n    {\n      nook: true,\n      test: !pendingHead || !tmp,\n      message: 'Can not use --pendingHead and --tmp at the same time',\n      pass: 'ok',\n      fail: 'remove at least one flag'\n    },\n    {\n      nook: true,\n      test: !pendingHead || !!branchName,\n      message: 'When --pendingHead is set, --branch is mandatory',\n      pass: 'ok',\n      fail: 'missing branch name'\n    },\n    {\n      nook: true,\n      test: !defaultBranch || !!branchName,\n      message: 'When --defaultBranch is set, --branch is mandatory',\n      pass: 'ok',\n      fail: 'missing branch name'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  // Note exiting earlier to skirt a hidden auth requirement\n  if (dryRun) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleCreateNewScan({\n    branchName: branchName as string,\n    commitHash: (commitHash && String(commitHash)) || '',\n    commitMessage: (commitMessage && String(commitMessage)) || '',\n    committers: (committers && String(committers)) || '',\n    cwd,\n    defaultBranch: Boolean(defaultBranch),\n    interactive: Boolean(interactive),\n    orgSlug,\n    outputKind,\n    pendingHead: Boolean(pendingHead),\n    pullRequest: Number(pullRequest),\n    readOnly: Boolean(readOnly),\n    repoName: repoName,\n    report,\n    targets,\n    tmp: Boolean(tmp)\n  })\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchDeleteOrgFullScan(\n  orgSlug: string,\n  scanId: string\n): Promise<CResult<SocketSdkReturnType<'deleteOrgFullScan'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.deleteOrgFullScan(orgSlug, scanId),\n    'to delete a scan'\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputDeleteScan(\n  result: CResult<SocketSdkReturnType<'deleteOrgFullScan'>['data']>,\n  outputKind: OutputKind\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  logger.success('Scan deleted successfully')\n}\n","import { fetchDeleteOrgFullScan } from './fetch-delete-org-full-scan.mts'\nimport { outputDeleteScan } from './output-delete-scan.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleDeleteScan(\n  orgSlug: string,\n  scanId: string,\n  outputKind: OutputKind\n): Promise<void> {\n  const data = await fetchDeleteOrgFullScan(orgSlug, scanId)\n\n  await outputDeleteScan(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleDeleteScan } from './handle-delete-scan.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'del',\n  description: 'Delete a scan',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'} <scan ID>\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:delete\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0\n  `\n}\n\nexport const cmdScanDel = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const scanId =\n    (isTestingV1() || defaultOrgSlug ? cli.input[0] : cli.input[1]) || ''\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing'\n    },\n    {\n      test: !!scanId,\n      message: 'Scan ID to delete',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleDeleteScan(orgSlug, scanId, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { queryApiSafeJson } from '../../utils/api.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchDiffScan({\n  id1,\n  id2,\n  orgSlug\n}: {\n  id1: string\n  id2: string\n  orgSlug: string\n}): Promise<CResult<SocketSdkReturnType<'GetOrgDiffScan'>['data']>> {\n  logger.error('Scan ID 1:', id1)\n  logger.error('Scan ID 2:', id2)\n  logger.error('Note: this request may take some time if the scans are big')\n\n  return await queryApiSafeJson<SocketSdkReturnType<'GetOrgDiffScan'>['data']>(\n    `orgs/${orgSlug}/full-scans/diff?before=${encodeURIComponent(id1)}&after=${encodeURIComponent(id2)}`,\n    'a scan diff'\n  )\n}\n","import fs from 'node:fs'\nimport util from 'node:util'\n\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nconst SOCKET_SBOM_URL_PREFIX =\n  'https://socket.dev/dashboard/org/SocketDev/sbom/'\n\nexport async function outputDiffScan(\n  result: CResult<SocketSdkReturnType<'GetOrgDiffScan'>['data']>,\n  {\n    depth,\n    file,\n    outputKind\n  }: {\n    depth: number\n    file: string\n    outputKind: OutputKind\n  }\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(result))\n      return\n    }\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const dashboardUrl = result.data.diff_report_url\n  const dashboardMessage = dashboardUrl\n    ? `\\n View this diff scan in the Socket dashboard: ${colors.cyan(dashboardUrl)}`\n    : ''\n\n  // When forcing json, or dumping to file, serialize to string such that it\n  // won't get truncated. The only way to dump the full raw JSON to stdout is\n  // to use `--json --file -` (the dash is a standard notation for stdout)\n  if (outputKind === 'json' || file) {\n    await handleJson(result, file, dashboardMessage)\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    await handleMarkdown(result.data)\n    return\n  }\n\n  // In this case neither the --json nor the --file flag was passed\n  // Dump the JSON to CLI and let NodeJS deal with truncation\n\n  logger.log('Diff scan result:')\n  logger.log(\n    util.inspect(result.data, {\n      showHidden: false,\n      depth: depth > 0 ? depth : null,\n      colors: true,\n      maxArrayLength: null\n    })\n  )\n  logger.error(\n    `\\n 📝 To display the detailed report in the terminal, use the --json flag. For a friendlier report, use the --markdown flag.\\n`\n  )\n  logger.log(dashboardMessage)\n}\n\nasync function handleJson(\n  data: CResult<SocketSdkReturnType<'GetOrgDiffScan'>['data']>,\n  file: string,\n  dashboardMessage: string\n) {\n  const json = serializeResultJson(data)\n\n  if (file && file !== '-') {\n    logger.log(`Writing json to \\`${file}\\``)\n    fs.writeFile(file, json, err => {\n      if (err) {\n        logger.fail(`Writing to \\`${file}\\` failed...`)\n        logger.error(err)\n      } else {\n        logger.log(`Data successfully written to \\`${file}\\``)\n      }\n      logger.error(dashboardMessage)\n    })\n  } else {\n    // TODO: expose different method for writing to stderr when simply dodging stdout\n    logger.error(`\\n Diff scan result: \\n`)\n    logger.log(json)\n    logger.error(dashboardMessage)\n  }\n}\n\nasync function handleMarkdown(\n  data: SocketSdkReturnType<'GetOrgDiffScan'>['data']\n) {\n  logger.log('# Scan diff result')\n  logger.log('')\n  logger.log('This Socket.dev report shows the changes between two scans:')\n  logger.log(\n    `- [${data.before.id}](${SOCKET_SBOM_URL_PREFIX}${data.before.id})`\n  )\n  logger.log(`- [${data.after.id}](${SOCKET_SBOM_URL_PREFIX}${data.after.id})`)\n  logger.log('')\n  logger.log(\n    `You can [view this report in your dashboard](${data.diff_report_url})`\n  )\n  logger.log('')\n  logger.log('## Changes')\n  logger.log('')\n  logger.log(`- directDependenciesChanged: ${data.directDependenciesChanged}`)\n  logger.log(`- Added packages: ${data.artifacts.added.length}`)\n  if (data.artifacts.added.length > 0) {\n    data.artifacts.added.slice(0, 10).forEach(artifact => {\n      logger.log(`  - ${artifact.type} ${artifact.name}@${artifact.version}`)\n    })\n    if (data.artifacts.added.length > 10) {\n      logger.log(`  ... and ${data.artifacts.added.length - 10} more`)\n    }\n  }\n  logger.log(`- Removed packages: ${data.artifacts.removed.length}`)\n  if (data.artifacts.removed.length > 0) {\n    data.artifacts.removed.slice(0, 10).forEach(artifact => {\n      logger.log(`  - ${artifact.type} ${artifact.name}@${artifact.version}`)\n    })\n    if (data.artifacts.removed.length > 10) {\n      logger.log(`  ... and ${data.artifacts.removed.length - 10} more`)\n    }\n  }\n  logger.log(`- Replaced packages: ${data.artifacts.replaced.length}`)\n  if (data.artifacts.replaced.length > 0) {\n    data.artifacts.replaced.slice(0, 10).forEach(artifact => {\n      logger.log(`  - ${artifact.type} ${artifact.name}@${artifact.version}`)\n    })\n    if (data.artifacts.replaced.length > 10) {\n      logger.log(`  ... and ${data.artifacts.replaced.length - 10} more`)\n    }\n  }\n  logger.log(`- Updated packages: ${data.artifacts.updated.length}`)\n  if (data.artifacts.updated.length > 0) {\n    data.artifacts.updated.slice(0, 10).forEach(artifact => {\n      logger.log(`  - ${artifact.type} ${artifact.name}@${artifact.version}`)\n    })\n    if (data.artifacts.updated.length > 10) {\n      logger.log(`  ... and ${data.artifacts.updated.length - 10} more`)\n    }\n  }\n  logger.log(`- Unchanged packages: ${data.artifacts.unchanged.length}`)\n  if (data.artifacts.unchanged.length > 0) {\n    data.artifacts.unchanged.slice(0, 10).forEach(artifact => {\n      logger.log(`  - ${artifact.type} ${artifact.name}@${artifact.version}`)\n    })\n    if (data.artifacts.unchanged.length > 10) {\n      logger.log(`  ... and ${data.artifacts.unchanged.length - 10} more`)\n    }\n  }\n  logger.log('')\n  logger.log(`## Scan ${data.before.id}`)\n  logger.log('')\n  logger.log(\n    'This Scan was considered to be the \"base\" / \"from\" / \"before\" Scan.'\n  )\n  logger.log('')\n  for (const [key, value] of Object.entries(data.before)) {\n    if (key === 'pull_request' && !value) {\n      continue\n    }\n    if (!['id', 'organization_id', 'repository_id'].includes(key)) {\n      logger.group(\n        `- ${key === 'repository_slug' ? 'repo' : key === 'organization_slug' ? 'org' : key}: ${value}`\n      )\n      logger.groupEnd()\n    }\n  }\n  logger.log('')\n  logger.log(`## Scan ${data.after.id}`)\n  logger.log('')\n  logger.log('This Scan was considered to be the \"head\" / \"to\" / \"after\" Scan.')\n  logger.log('')\n  for (const [key, value] of Object.entries(data.after)) {\n    if (key === 'pull_request' && !value) {\n      continue\n    }\n    if (!['id', 'organization_id', 'repository_id'].includes(key)) {\n      logger.group(\n        `- ${key === 'repository_slug' ? 'repo' : key === 'organization_slug' ? 'org' : key}: ${value}`\n      )\n      logger.groupEnd()\n    }\n  }\n  logger.log('')\n}\n","import { fetchDiffScan } from './fetch-diff-scan.mts'\nimport { outputDiffScan } from './output-diff-scan.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleDiffScan({\n  depth,\n  file,\n  id1,\n  id2,\n  orgSlug,\n  outputKind\n}: {\n  depth: number\n  file: string\n  id1: string\n  id2: string\n  orgSlug: string\n  outputKind: OutputKind\n}): Promise<void> {\n  const data = await fetchDiffScan({\n    id1,\n    id2,\n    orgSlug\n  })\n\n  await outputDiffScan(data, {\n    depth,\n    file,\n    outputKind\n  })\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleDiffScan } from './handle-diff-scan.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst SOCKET_SBOM_URL_PREFIX =\n  'https://socket.dev/dashboard/org/SocketDev/sbom/'\n\nconst config: CliCommandConfig = {\n  commandName: 'diff',\n  description: 'See what changed between two Scans',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    depth: {\n      type: 'number',\n      default: 2,\n      description:\n        'Max depth of JSON to display before truncating, use zero for no limit (without --json/--file)'\n    },\n    file: {\n      type: 'string',\n      shortFlag: 'f',\n      default: '',\n      description:\n        'Path to a local file where the output should be saved. Use `-` to force stdout.'\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'} <ID1> <ID2>\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:list\n\n    This command displays the package changes between two scans. The full output\n    can be pretty large depending on the size of your repo and time range. It is\n    best stored to disk (with --json) to be further analyzed by other tools.\n\n    Note: First Scan ID is assumed to be the older ID. This is only relevant for\n          the added/removed list (similar to diffing two files with git).\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} aaa0aa0a-aaaa-0000-0a0a-0000000a00a0 aaa1aa1a-aaaa-1111-1a1a-1111111a11a1\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} aaa0aa0a-aaaa-0000-0a0a-0000000a00a0 aaa1aa1a-aaaa-1111-1a1a-1111111a11a1 --json\n  `\n}\n\nexport const cmdScanDiff = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const {\n    depth,\n    dryRun,\n    file,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  let id1 = cli.input[isTestingV1() || orgSlug ? 0 : 1] || ''\n  let id2 = cli.input[isTestingV1() || orgSlug ? 1 : 2] || ''\n  if (id1.startsWith(SOCKET_SBOM_URL_PREFIX)) {\n    id1 = id1.slice(SOCKET_SBOM_URL_PREFIX.length)\n  }\n  if (id2.startsWith(SOCKET_SBOM_URL_PREFIX)) {\n    id2 = id2.slice(SOCKET_SBOM_URL_PREFIX.length)\n  }\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: !!(id1 && id2),\n      message:\n        'Specify two Scan IDs.\\nA Scan ID looks like `aaa0aa0a-aaaa-0000-0a0a-0000000a00a0`.',\n      pass: 'ok',\n      fail:\n        !id1 && !id2\n          ? 'missing both Scan IDs'\n          : !id2\n            ? 'missing second Scan ID'\n            : 'missing first Scan ID' // Not sure how this can happen but ok.\n    },\n    {\n      test: !!orgSlug,\n      nook: true,\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleDiffScan({\n    id1: String(id1 || ''),\n    id2: String(id2 || ''),\n    depth: Number(depth),\n    orgSlug,\n    outputKind,\n    file: String(file || '')\n  })\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchListScans({\n  branch,\n  direction,\n  from_time,\n  orgSlug,\n  page,\n  per_page,\n  repo,\n  sort\n}: {\n  branch: string\n  direction: string\n  from_time: string\n  orgSlug: string\n  page: number\n  per_page: number\n  repo: string\n  sort: string\n}): Promise<CResult<SocketSdkReturnType<'getOrgFullScanList'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgFullScanList(orgSlug, {\n      ...(branch ? { branch } : {}),\n      ...(repo ? { repo } : {}),\n      sort,\n      direction,\n      per_page: String(per_page),\n      page: String(page),\n      from: from_time\n    }),\n    'list of scans'\n  )\n}\n","// @ts-ignore\nimport chalkTable from 'chalk-table'\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputListScans(\n  result: CResult<SocketSdkReturnType<'getOrgFullScanList'>['data']>,\n  outputKind: OutputKind\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  const options = {\n    columns: [\n      { field: 'id', name: colors.magenta('ID') },\n      { field: 'report_url', name: colors.magenta('Scan URL') },\n      { field: 'repo', name: colors.magenta('Repo') },\n      { field: 'branch', name: colors.magenta('Branch') },\n      { field: 'created_at', name: colors.magenta('Created at') }\n    ]\n  }\n\n  const formattedResults = result.data.results.map(d => {\n    return {\n      id: d.id,\n      report_url: colors.underline(`${d.html_report_url}`),\n      created_at: d.created_at\n        ? new Date(d.created_at).toLocaleDateString('en-us', {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric'\n          })\n        : '',\n      repo: d.repo,\n      branch: d.branch\n    }\n  })\n\n  logger.log(chalkTable(options, formattedResults))\n}\n","import { fetchListScans } from './fetch-list-scans.mts'\nimport { outputListScans } from './output-list-scans.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleListScans({\n  branch,\n  direction,\n  from_time,\n  orgSlug,\n  outputKind,\n  page,\n  per_page,\n  repo,\n  sort\n}: {\n  branch: string\n  direction: string\n  from_time: string\n  orgSlug: string\n  outputKind: OutputKind\n  page: number\n  per_page: number\n  repo: string\n  sort: string\n}): Promise<void> {\n  const data = await fetchListScans({\n    branch,\n    direction,\n    from_time,\n    orgSlug,\n    page,\n    per_page,\n    repo,\n    sort\n  })\n\n  await outputListScans(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleListScans } from './handle-list-scans.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type {\n  CliCommandConfig,\n  CliSubcommand\n} from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'list',\n  description: 'List the scans for an organization',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    branch: {\n      type: 'string',\n      description: 'Filter to show only scans with this branch name'\n    },\n    direction: {\n      type: 'string',\n      shortFlag: 'd',\n      default: 'desc',\n      description: 'Direction option (`desc` or `asc`) - Default is `desc`'\n    },\n    fromTime: {\n      type: 'string',\n      shortFlag: 'f',\n      default: '',\n      description: 'From time - as a unix timestamp'\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    page: {\n      type: 'number',\n      shortFlag: 'p',\n      default: 1,\n      description: 'Page number - Default is 1'\n    },\n    perPage: {\n      type: 'number',\n      shortFlag: 'pp',\n      default: 30,\n      description: 'Results per page - Default is 30'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    },\n    repo: {\n      type: 'string',\n      description: 'Filter to show only scans with this repository name'\n    },\n    sort: {\n      type: 'string',\n      shortFlag: 's',\n      default: 'created_at',\n      description:\n        'Sorting option (`name` or `created_at`) - default is `created_at`'\n    },\n    untilTime: {\n      type: 'string',\n      shortFlag: 'u',\n      default: '',\n      description: 'Until time - as a unix timestamp'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:list\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'}\n  `\n}\n\nexport const cmdScanList: CliSubcommand = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n) {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const {\n    branch,\n    dryRun,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag,\n    repo\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleListScans({\n    branch: branch ? String(branch) : '',\n    direction: String(cli.flags['direction'] || ''),\n    from_time: String(cli.flags['fromTime'] || ''),\n    orgSlug,\n    outputKind,\n    page: Number(cli.flags['page'] || 1),\n    per_page: Number(cli.flags['perPage'] || 30),\n    repo: repo ? String(repo) : '',\n    sort: String(cli.flags['sort'] || '')\n  })\n}\n","import { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function fetchScanMetadata(\n  orgSlug: string,\n  scanId: string\n): Promise<CResult<SocketSdkReturnType<'getOrgFullScanMetadata'>['data']>> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  return await handleApiCall(\n    sockSdk.getOrgFullScanMetadata(orgSlug, scanId),\n    'meta data for a full scan'\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport async function outputScanMetadata(\n  result: CResult<SocketSdkReturnType<'getOrgFullScanMetadata'>['data']>,\n  scanId: string,\n  outputKind: OutputKind\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (outputKind === 'markdown') {\n    logger.log('# Scan meta data\\n')\n  }\n  logger.log(`Scan ID: ${scanId}\\n`)\n  for (const [key, value] of Object.entries(result.data)) {\n    if (\n      [\n        'id',\n        'updated_at',\n        'organization_id',\n        'repository_id',\n        'commit_hash',\n        'html_report_url'\n      ].includes(key)\n    ) {\n      continue\n    }\n    logger.log(`- ${key}:`, value)\n  }\n  if (outputKind === 'markdown') {\n    logger.log(\n      `\\nYou can view this report at: [${result.data.html_report_url}](${result.data.html_report_url})\\n`\n    )\n  } else {\n    logger.log(\n      `\\nYou can view this report at: ${result.data.html_report_url}]\\n`\n    )\n  }\n}\n","import { fetchScanMetadata } from './fetch-scan-metadata.mts'\nimport { outputScanMetadata } from './output-scan-metadata.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleOrgScanMetadata(\n  orgSlug: string,\n  scanId: string,\n  outputKind: OutputKind\n): Promise<void> {\n  const data = await fetchScanMetadata(orgSlug, scanId)\n\n  await outputScanMetadata(data, scanId, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleOrgScanMetadata } from './handle-scan-metadata.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type {\n  CliCommandConfig,\n  CliSubcommand\n} from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'metadata',\n  description: \"Get a scan's metadata\",\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'} <scan ID>\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:list\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0\n  `\n}\n\nexport const cmdScanMetadata: CliSubcommand = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const scanId =\n    (isTestingV1() || defaultOrgSlug ? cli.input[0] : cli.input[1]) || ''\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing'\n    },\n    {\n      test: !!scanId,\n      message: 'Scan ID to inspect as argument',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleOrgScanMetadata(orgSlug, scanId, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleScanReport } from './handle-scan-report.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type {\n  CliCommandConfig,\n  CliSubcommand\n} from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'report',\n  description:\n    'Check whether a scan result passes the organizational policies (security, license)',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    fold: {\n      type: 'string',\n      default: 'none',\n      description: 'Fold reported alerts to some degree'\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    },\n    reportLevel: {\n      type: 'string',\n      default: 'warn',\n      description: 'Which policy level alerts should be reported'\n    },\n    short: {\n      type: 'boolean',\n      default: false,\n      description: 'Report only the healthy status'\n    },\n    license: {\n      type: 'boolean',\n      default: false,\n      description: 'Also report the license policy status. Default: false'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'} <scan ID> [path to output file]\n\n    API Token Requirements\n      - Quota: 2 units\n      - Permissions: full-scans:list security-policy:read\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    By default the result is a nested object that looks like this:\n      \\`{[ecosystem]: {[pkgName]: {[version]: {[file]: {[type:loc]: policy}}}}\\`\n    You can fold this up to given level: 'pkg', 'version', 'file', and 'none'.\n\n    By default only the warn and error policy level alerts are reported. You can\n    override this and request more ('defer' < 'ignore' < 'monitor' < 'warn' < 'error')\n\n    Short responses: JSON: \\`{healthy:bool}\\`, markdown: \\`healthy = bool\\`, text: \\`OK/ERR\\`\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0 --json --fold=version\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0 --license --markdown --short\n  `\n}\n\nexport const cmdScanReport: CliSubcommand = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const {\n    fold = 'none',\n    json,\n    license,\n    markdown,\n    reportLevel = 'warn'\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const { dryRun, interactive, org: orgFlag } = cli.flags\n\n  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const scanId =\n    (isTestingV1() || defaultOrgSlug ? cli.input[0] : cli.input[1]) || ''\n  const file =\n    (isTestingV1() || defaultOrgSlug ? cli.input[1] : cli.input[2]) || '-'\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing'\n    },\n    {\n      test: !!scanId,\n      message: 'Scan ID to report on',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleScanReport({\n    orgSlug,\n    scanId: scanId,\n    includeLicensePolicy: !!license,\n    outputKind,\n    filePath: file,\n    fold: fold as 'none' | 'file' | 'pkg' | 'version',\n    short: !!cli.flags['short'],\n    reportLevel: reportLevel as\n      | 'warn'\n      | 'error'\n      | 'defer'\n      | 'ignore'\n      | 'monitor'\n  })\n}\n","import { debugLog } from '@socketsecurity/registry/lib/debug'\n\nimport { queryApiSafeText } from '../../utils/api.mts'\n\nimport type { CResult } from '../../types.mts'\nimport type { components } from '@socketsecurity/sdk/types/api'\n\nexport async function fetchScan(\n  orgSlug: string,\n  scanId: string\n): Promise<CResult<Array<components['schemas']['SocketArtifact']>>> {\n  const result = await queryApiSafeText(\n    `orgs/${orgSlug}/full-scans/${encodeURIComponent(scanId)}`,\n    'a scan'\n  )\n\n  if (!result.ok) {\n    return result\n  }\n\n  const jsonsString = result.data\n\n  // This is nd-json; each line is a json object\n  const lines = jsonsString.split('\\n').filter(Boolean)\n  let ok = true\n  const data = lines.map(line => {\n    try {\n      return JSON.parse(line)\n    } catch {\n      ok = false\n      debugLog('ndjson failed to parse the following line:')\n      debugLog(line)\n      return null\n    }\n  }) as unknown as Array<components['schemas']['SocketArtifact']>\n\n  if (ok) {\n    return { ok: true, data }\n  }\n\n  return {\n    ok: false,\n    message: 'Invalid API response',\n    cause:\n      'The API responded with at least one line that was not valid JSON. Please report if this persists.'\n  }\n}\n","import fs from 'node:fs/promises'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { mdTable } from '../../utils/markdown.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { components } from '@socketsecurity/sdk/types/api'\n\nexport async function outputScanView(\n  result: CResult<Array<components['schemas']['SocketArtifact']>>,\n  orgSlug: string,\n  scanId: string,\n  filePath: string,\n  outputKind: OutputKind\n): Promise<void> {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (!result.ok) {\n    if (outputKind === 'json') {\n      logger.log(serializeResultJson(result))\n      return\n    }\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (\n    outputKind === 'json' ||\n    (outputKind === 'text' && filePath && filePath.endsWith('.json'))\n  ) {\n    const json = serializeResultJson(result)\n\n    if (filePath && filePath !== '-') {\n      logger.info('Writing json results to', filePath)\n      try {\n        await fs.writeFile(filePath, json, 'utf8')\n        logger.info(`Data successfully written to ${filePath}`)\n      } catch (e) {\n        process.exitCode = 1\n        logger.fail('There was an error trying to write the markdown to disk')\n        logger.error(e)\n        logger.log(\n          serializeResultJson({\n            ok: false,\n            message: 'File Write Failure',\n            cause: 'Failed to write json to disk'\n          })\n        )\n      }\n      return\n    }\n\n    logger.log(json)\n    return\n  }\n\n  const display = result.data.map(art => {\n    const author = Array.isArray(art.author)\n      ? `${art.author[0]}${art.author.length > 1 ? ' et.al.' : ''}`\n      : art.author\n    return {\n      type: art.type,\n      name: art.name,\n      version: art.version,\n      author,\n      score: JSON.stringify(art.score)\n    }\n  })\n\n  const md = mdTable<any>(display, [\n    'type',\n    'version',\n    'name',\n    'author',\n    'score'\n  ])\n\n  const report =\n    `\n# Scan Details\n\nThese are the artifacts and their scores found.\n\nScan ID: ${scanId}\n\n${md}\n\nView this report at: https://socket.dev/dashboard/org/${orgSlug}/sbom/${scanId}\n  `.trim() + '\\n'\n\n  if (filePath && filePath !== '-') {\n    try {\n      await fs.writeFile(filePath, report, 'utf8')\n      logger.log(`Data successfully written to ${filePath}`)\n    } catch (e) {\n      process.exitCode = 1\n      logger.fail('There was an error trying to write the markdown to disk')\n      logger.error(e)\n    }\n  } else {\n    logger.log(report)\n  }\n}\n","import { fetchScan } from './fetch-scan.mts'\nimport { outputScanView } from './output-scan-view.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleScanView(\n  orgSlug: string,\n  scanId: string,\n  filePath: string,\n  outputKind: OutputKind\n): Promise<void> {\n  const data = await fetchScan(orgSlug, scanId)\n\n  await outputScanView(data, orgSlug, scanId, filePath, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nexport async function streamScan(\n  orgSlug: string,\n  scanId: string,\n  file: string | undefined\n) {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return sockSdkResult\n  }\n  const sockSdk = sockSdkResult.data\n\n  logger.error('Requesting data from API...')\n\n  // Note: this will write to stdout or target file. It's not a noop\n  return await handleApiCall(\n    sockSdk.getOrgFullScan(orgSlug, scanId, file === '-' ? undefined : file),\n    'a scan'\n  )\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleScanView } from './handle-scan-view.mts'\nimport { streamScan } from './stream-scan.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type {\n  CliCommandConfig,\n  CliSubcommand\n} from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'view',\n  description: 'View the raw results of a scan',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    stream: {\n      type: 'boolean',\n      default: false,\n      description:\n        'Only valid with --json. Streams the response as \"ndjson\" (chunks of valid json blobs).'\n    },\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'} <scan ID> [path to output file]\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: full-scans:list\n\n    When no output path is given the contents is sent to stdout.\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} 000aaaa1-0000-0a0a-00a0-00a0000000a0 ./stream.txt\n  `\n}\n\nexport const cmdScanView: CliSubcommand = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const {\n    dryRun,\n    interactive,\n    json,\n    markdown,\n    org: orgFlag,\n    stream\n  } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug, defaultOrgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const scanId =\n    (isTestingV1() || defaultOrgSlug ? cli.input[0] : cli.input[1]) || ''\n  const file =\n    (isTestingV1() || defaultOrgSlug ? cli.input[1] : cli.input[2]) || '-'\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: !!defaultOrgSlug,\n      test: !!orgSlug && orgSlug !== '.',\n      message: isTestingV1()\n        ? 'Org name by default setting, --org, or auto-discovered'\n        : 'Org name must be the first argument',\n      pass: 'ok',\n      fail:\n        orgSlug === '.'\n          ? 'dot is an invalid org, most likely you forgot the org name here?'\n          : 'missing'\n    },\n    {\n      test: !!scanId,\n      message: 'Scan ID to view',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message:\n        'The `--json` and `--markdown` flags can not be used at the same time',\n      pass: 'ok',\n      fail: 'bad'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    },\n    {\n      nook: true,\n      test: !stream || !!json,\n      message: 'You can only use --stream when using --json',\n      pass: 'ok',\n      fail: 'Either remove --stream or add --json'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  if (json && stream) {\n    await streamScan(orgSlug, scanId, file)\n  } else {\n    await handleScanView(orgSlug, scanId, file, outputKind)\n  }\n}\n","import { cmdScanCreate } from './cmd-scan-create.mts'\nimport { cmdScanDel } from './cmd-scan-del.mts'\nimport { cmdScanDiff } from './cmd-scan-diff.mts'\nimport { cmdScanList } from './cmd-scan-list.mts'\nimport { cmdScanMetadata } from './cmd-scan-metadata.mts'\nimport { cmdScanReport } from './cmd-scan-report.mts'\nimport { cmdScanView } from './cmd-scan-view.mts'\nimport { meowWithSubcommands } from '../../utils/meow-with-subcommands.mts'\n\nimport type { CliSubcommand } from '../../utils/meow-with-subcommands.mts'\n\nconst description = 'Scan related commands'\n\nexport const cmdScan: CliSubcommand = {\n  description,\n  async run(argv, importMeta, { parentName }) {\n    await meowWithSubcommands(\n      {\n        create: cmdScanCreate,\n        list: cmdScanList,\n        del: cmdScanDel,\n        diff: cmdScanDiff,\n        metadata: cmdScanMetadata,\n        report: cmdScanReport,\n        view: cmdScanView\n      },\n      {\n        aliases: {\n          // Backwards compat. TODO: Drop next major bump\n          stream: {\n            description: cmdScanView.description,\n            hidden: true,\n            argv: ['view'] // Original args will be appended (!)\n          }\n        },\n        argv,\n        description,\n        importMeta,\n        name: parentName + ' scan'\n      }\n    )\n  }\n}\n","import { queryApiSafeJson } from '../../utils/api.mts'\n\nimport type { ThreadFeedResponse } from './types.mts'\nimport type { CResult } from '../../types.mts'\n\nexport async function fetchThreatFeed({\n  direction,\n  ecosystem,\n  filter,\n  page,\n  perPage\n}: {\n  direction: string\n  ecosystem: string\n  filter: string\n  page: string\n  perPage: number\n}): Promise<CResult<ThreadFeedResponse>> {\n  const queryParams = new URLSearchParams([\n    ['direction', direction],\n    ['ecosystem', ecosystem],\n    ['filter', filter],\n    ['page', page],\n    ['per_page', String(perPage)]\n  ])\n\n  return await queryApiSafeJson(\n    `threat-feed?${queryParams}`,\n    'the Threat Feed data'\n  )\n}\n","import { createRequire } from 'node:module'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../constants.mts'\nimport { failMsgWithBadge } from '../../utils/fail-msg-with-badge.mts'\nimport { serializeResultJson } from '../../utils/serialize-result-json.mts'\n\nimport type { ThreadFeedResponse, ThreatResult } from './types.mts'\nimport type { CResult, OutputKind } from '../../types.mts'\nimport type { Widgets } from 'blessed'\n\nconst require = createRequire(import.meta.url)\n\nexport async function outputThreatFeed(\n  result: CResult<ThreadFeedResponse>,\n  outputKind: OutputKind\n) {\n  if (!result.ok) {\n    process.exitCode = result.code ?? 1\n  }\n\n  if (outputKind === 'json') {\n    logger.log(serializeResultJson(result))\n    return\n  }\n  if (!result.ok) {\n    logger.fail(failMsgWithBadge(result.message, result.cause))\n    return\n  }\n\n  if (!result.data?.results?.length) {\n    logger.error('Did not receive any data to display...')\n    return\n  }\n\n  const formattedOutput = formatResults(result.data.results)\n  const descriptions = result.data.results.map(d => d.description)\n\n  // Note: this temporarily takes over the terminal (just like `man` does).\n  const ScreenWidget = require('blessed/lib/widgets/screen.js')\n  // Lazily access constants.blessedOptions.\n  const screen: Widgets.Screen = new ScreenWidget({\n    ...constants.blessedOptions\n  })\n  // Register these keys first so you can always exit, even when it gets stuck\n  // If we don't do this and the code crashes, the user must hard-kill the\n  // node process just to exit it. That's very bad UX.\n  // eslint-disable-next-line n/no-process-exit\n  screen.key(['escape', 'q', 'C-c'], () => process.exit(0))\n\n  const TableWidget = require('blessed-contrib/lib/widget/table.js')\n  const table: any = new TableWidget({\n    keys: 'true',\n    fg: 'white',\n    selectedFg: 'white',\n    selectedBg: 'magenta',\n    interactive: 'true',\n    label: 'Threat feed',\n    width: '100%',\n    height: '70%', // Changed from 100% to 70%\n    border: {\n      type: 'line',\n      fg: 'cyan'\n    },\n    columnWidth: [10, 30, 20, 18, 15, 200],\n    // TODO: the truncation doesn't seem to work too well yet but when we add\n    //       `pad` alignment fails, when we extend columnSpacing alignment fails\n    columnSpacing: 1,\n    truncate: '_'\n  })\n\n  // Create details box at the bottom\n  const BoxWidget = require('blessed/lib/widgets/box.js')\n  const detailsBox: Widgets.BoxElement = new BoxWidget({\n    bottom: 0,\n    height: '30%',\n    width: '100%',\n    border: {\n      type: 'line',\n      fg: 'cyan'\n    },\n    label: 'Details',\n    content:\n      'Use arrow keys to navigate. Press Enter to select a threat. Press q to exit.',\n    style: {\n      fg: 'white'\n    }\n  })\n\n  table.setData({\n    headers: [\n      ' Ecosystem',\n      ' Name',\n      '  Version',\n      '  Threat type',\n      '  Detected at',\n      ' Details'\n    ],\n    data: formattedOutput\n  })\n\n  // allow control the table with the keyboard\n  table.focus()\n\n  screen.append(table)\n  screen.append(detailsBox)\n\n  // Update details box when selection changes\n  table.rows.on('select item', () => {\n    const selectedIndex = table.rows.selected\n    if (selectedIndex !== undefined && selectedIndex >= 0) {\n      const selectedRow = formattedOutput[selectedIndex]\n      if (selectedRow) {\n        // Note: the spacing works around issues with the table; it refuses to pad!\n        detailsBox.setContent(\n          `Ecosystem: ${selectedRow[0]}\\n` +\n            `Name: ${selectedRow[1]}\\n` +\n            `Version:${selectedRow[2]}\\n` +\n            `Threat type:${selectedRow[3]}\\n` +\n            `Detected at:${selectedRow[4]}\\n` +\n            `Details: ${selectedRow[5]}\\n` +\n            `Description: ${descriptions[selectedIndex]}`\n        )\n        screen.render()\n      }\n    }\n  })\n\n  screen.render()\n\n  screen.key(['return'], () => {\n    const selectedIndex = table.rows.selected\n    screen.destroy()\n    const selectedRow = formattedOutput[selectedIndex]\n    logger.log('Last selection:\\n', selectedRow)\n  })\n}\n\nfunction formatResults(data: ThreatResult[]) {\n  return data.map(d => {\n    const ecosystem = d.purl.split('pkg:')[1]!.split('/')[0]!\n    const name = d.purl.split('/')[1]!.split('@')[0]!\n    const version = d.purl.split('@')[1]!\n\n    const timeDiff = msAtHome(d.createdAt)\n\n    // Note: the spacing works around issues with the table; it refuses to pad!\n    return [\n      ecosystem,\n      decodeURIComponent(name),\n      ` ${version}`,\n      ` ${d.threatType}`,\n      ` ${timeDiff}`,\n      d.locationHtmlUrl\n    ]\n  })\n}\n\nfunction msAtHome(isoTimeStamp: string): string {\n  const timeStart = Date.parse(isoTimeStamp)\n  const timeEnd = Date.now()\n\n  const rtf = new Intl.RelativeTimeFormat('en', {\n    numeric: 'always',\n    style: 'short'\n  })\n\n  const delta = timeEnd - timeStart\n  if (delta < 60 * 60 * 1000) {\n    return rtf.format(-Math.round(delta / (60 * 1000)), 'minute')\n    // return Math.round(delta / (60 * 1000)) + ' min ago'\n  } else if (delta < 24 * 60 * 60 * 1000) {\n    return rtf.format(-(delta / (60 * 60 * 1000)).toFixed(1), 'hour')\n    // return (delta / (60 * 60 * 1000)).toFixed(1) + ' hr ago'\n  } else if (delta < 7 * 24 * 60 * 60 * 1000) {\n    return rtf.format(-(delta / (24 * 60 * 60 * 1000)).toFixed(1), 'day')\n    // return (delta / (24 * 60 * 60 * 1000)).toFixed(1) + ' day ago'\n  } else {\n    return isoTimeStamp.slice(0, 10)\n  }\n}\n","import { fetchThreatFeed } from './fetch-threat-feed.mts'\nimport { outputThreatFeed } from './output-threat-feed.mts'\n\nimport type { OutputKind } from '../../types.mts'\n\nexport async function handleThreatFeed({\n  direction,\n  ecosystem,\n  filter,\n  outputKind,\n  page,\n  perPage\n}: {\n  direction: string\n  ecosystem: string\n  filter: string\n  outputKind: OutputKind\n  page: string\n  perPage: number\n}): Promise<void> {\n  const data = await fetchThreatFeed({\n    direction,\n    ecosystem,\n    filter,\n    page,\n    perPage\n  })\n\n  await outputThreatFeed(data, outputKind)\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { handleThreatFeed } from './handle-threat-feed.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags, outputFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { isTestingV1 } from '../../utils/config.mts'\nimport { determineOrgSlug } from '../../utils/determine-org-slug.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\nimport { hasDefaultToken } from '../../utils/sdk.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'threat-feed',\n  description: '[beta] View the threat feed',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    ...outputFlags,\n    interactive: {\n      type: 'boolean',\n      default: true,\n      description:\n        'Allow for interactive elements, asking for input. Use --no-interactive to prevent any input questions, defaulting them to cancel/no.'\n    },\n    org: {\n      type: 'string',\n      description:\n        'Force override the organization slug, overrides the default org from config'\n    },\n    perPage: {\n      type: 'number',\n      shortFlag: 'pp',\n      default: 30,\n      description: 'Number of items per page'\n    },\n    page: {\n      type: 'string',\n      shortFlag: 'p',\n      default: '1',\n      description: 'Page token'\n    },\n    direction: {\n      type: 'string',\n      shortFlag: 'd',\n      default: 'desc',\n      description: 'Order asc or desc by the createdAt attribute'\n    },\n    eco: {\n      type: 'string',\n      shortFlag: 'e',\n      default: '',\n      description: 'Only show threats for a particular ecosystem'\n    },\n    filter: {\n      type: 'string',\n      shortFlag: 'f',\n      default: 'mal',\n      description: 'Filter what type of threats to return'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command}${isTestingV1() ? '' : ' <org slug>'}\n\n    API Token Requirements\n      - Quota: 1 unit\n      - Permissions: threat-feed:list\n      - Special access\n\n    This feature requires a Threat Feed license. Please contact\n    sales@socket.dev if you are interested in purchasing this access.\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Valid filters:\n\n      - anom    Anomaly\n      - c       Do not filter\n      - fp      False Positives\n      - joke    Joke / Fake\n      - mal     Malware and Possible Malware [default]\n      - secret  Secrets\n      - spy     Telemetry\n      - tp      False Positives and Unreviewed\n      - typo    Typo-squat\n      - u       Unreviewed\n      - vuln    Vulnerability\n\n    Valid ecosystems:\n\n      - gem\n      - golang\n      - maven\n      - npm\n      - nuget\n      - pypi\n\n    Examples\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'}\n      $ ${command}${isTestingV1() ? '' : ' FakeOrg'} --perPage=5 --page=2 --direction=asc --filter=joke\n  `\n}\n\nexport const cmdThreatFeed = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { dryRun, interactive, json, markdown, org: orgFlag } = cli.flags\n  const outputKind = getOutputKind(json, markdown)\n\n  const [orgSlug] = await determineOrgSlug(\n    String(orgFlag || ''),\n    cli.input[0] || '',\n    !!interactive,\n    !!dryRun\n  )\n\n  const hasApiToken = hasDefaultToken()\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      nook: true,\n      test: !!orgSlug,\n      message: 'Org name as the first argument',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !json || !markdown,\n      message: 'The json and markdown flags cannot be both set, pick one',\n      pass: 'ok',\n      fail: 'omit one'\n    },\n    {\n      nook: true,\n      test: hasApiToken,\n      message:\n        'You need to be logged in to use this command. See `socket login`.',\n      pass: 'ok',\n      fail: 'missing API token'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  await handleThreatFeed({\n    direction: String(cli.flags['direction'] || 'desc'),\n    ecosystem: String(cli.flags['eco'] || ''),\n    filter: String(cli.flags['filter'] || 'mal'),\n    outputKind,\n    page: String(cli.flags['page'] || '1'),\n    perPage: Number(cli.flags['perPage']) || 30\n  })\n}\n","import fs from 'node:fs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nexport function addSocketWrapper(file: string): void {\n  return fs.appendFile(\n    file,\n    'alias npm=\"socket npm\"\\nalias npx=\"socket npx\"\\n',\n    err => {\n      if (err) {\n        return new Error(`There was an error setting up the alias: ${err}`)\n      }\n      // TODO: pretty sure you need to source the file or restart\n      //       any terminal session before changes are reflected.\n      logger.log(\n        `\nThe alias was added to ${file}. Running 'npm install' will now be wrapped in Socket's \"safe npm\" 🎉\nIf you want to disable it at any time, run \\`socket wrapper --disable\\`\n      `.trim()\n      )\n    }\n  )\n}\n","import fs from 'node:fs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nexport function checkSocketWrapperSetup(file: string): boolean {\n  const fileContent = fs.readFileSync(file, 'utf8')\n  const linesWithSocketAlias = fileContent\n    .split('\\n')\n    .filter(\n      l => l === 'alias npm=\"socket npm\"' || l === 'alias npx=\"socket npx\"'\n    )\n\n  if (linesWithSocketAlias.length) {\n    logger.log(\n      `The Socket npm/npx wrapper is set up in your bash profile (${file})`\n    )\n    return true\n  }\n  return false\n}\n","import { existsSync } from 'node:fs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { confirm } from '@socketsecurity/registry/lib/prompts'\n\nimport { addSocketWrapper } from './add-socket-wrapper.mts'\nimport { checkSocketWrapperSetup } from './check-socket-wrapper-setup.mts'\nimport constants from '../../constants.mts'\n\nexport async function postinstallWrapper() {\n  // Lazily access constants.bashRcPath and constants.zshRcPath.\n  const { bashRcPath, zshRcPath } = constants\n  const socketWrapperEnabled =\n    (existsSync(bashRcPath) && checkSocketWrapperSetup(bashRcPath)) ||\n    (existsSync(zshRcPath) && checkSocketWrapperSetup(zshRcPath))\n\n  if (!socketWrapperEnabled) {\n    await installSafeNpm(\n      `\nThe Socket CLI is now successfully installed! 🎉\n\nTo better protect yourself against supply-chain attacks, our \"safe npm\" wrapper can warn you about malicious packages whenever you run 'npm install'.\n\nDo you want to install \"safe npm\" (this will create an alias to the socket-npm command)?\n    `.trim()\n    )\n  }\n}\n\nasync function installSafeNpm(query: string): Promise<void> {\n  logger.log(`\n _____         _       _\n|   __|___ ___| |_ ___| |_\n|__   | . |  _| '_| -_|  _|\n|_____|___|___|_,_|___|_|\n\n`)\n  if (\n    await confirm({\n      message: query,\n      default: true\n    })\n  ) {\n    // Lazily access constants.bashRcPath and constants.zshRcPath.\n    const { bashRcPath, zshRcPath } = constants\n    try {\n      if (existsSync(bashRcPath)) {\n        addSocketWrapper(bashRcPath)\n      }\n      if (existsSync(zshRcPath)) {\n        addSocketWrapper(zshRcPath)\n      }\n    } catch (e) {\n      throw new Error(\n        `There was an issue setting up the alias: ${(e as any)?.['message']}`\n      )\n    }\n  }\n}\n","import fs from 'node:fs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nexport function removeSocketWrapper(file: string): void {\n  return fs.readFile(file, 'utf8', function (err, data) {\n    if (err) {\n      logger.fail('There was an error removing the alias:')\n      logger.error(err)\n      return\n    }\n    const linesWithoutSocketAlias = data\n      .split('\\n')\n      .filter(\n        l => l !== 'alias npm=\"socket npm\"' && l !== 'alias npx=\"socket npx\"'\n      )\n\n    const updatedFileContent = linesWithoutSocketAlias.join('\\n')\n\n    fs.writeFile(file, updatedFileContent, function (err) {\n      if (err) {\n        logger.error(err)\n        return\n      }\n      // TODO: pretty sure you need to source the file or restart\n      //       any terminal session before changes are reflected.\n      logger.log(\n        `The alias was removed from ${file}. Running 'npm install' will now run the standard npm command.`\n      )\n    })\n  })\n}\n","import { existsSync } from 'node:fs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { addSocketWrapper } from './add-socket-wrapper.mts'\nimport { checkSocketWrapperSetup } from './check-socket-wrapper-setup.mts'\nimport { postinstallWrapper } from './postinstall-wrapper.mts'\nimport { removeSocketWrapper } from './remove-socket-wrapper.mts'\nimport constants from '../../constants.mts'\nimport { commonFlags } from '../../flags.mts'\nimport { checkCommandInput } from '../../utils/check-input.mts'\nimport { getOutputKind } from '../../utils/get-output-kind.mts'\nimport { meowOrExit } from '../../utils/meow-with-subcommands.mts'\nimport { getFlagListOutput } from '../../utils/output-formatting.mts'\n\nimport type { CliCommandConfig } from '../../utils/meow-with-subcommands.mts'\n\nconst { DRY_RUN_BAILING_NOW } = constants\n\nconst config: CliCommandConfig = {\n  commandName: 'wrapper',\n  description: 'Enable or disable the Socket npm/npx wrapper',\n  hidden: false,\n  flags: {\n    ...commonFlags,\n    enable: {\n      type: 'boolean',\n      default: false,\n      description: 'Enables the Socket npm/npx wrapper'\n    },\n    disable: {\n      type: 'boolean',\n      default: false,\n      description: 'Disables the Socket npm/npx wrapper'\n    }\n  },\n  help: (command, config) => `\n    Usage\n      $ ${command} <flag>\n\n    Options\n      ${getFlagListOutput(config.flags, 6)}\n\n    Examples\n      $ ${command} --enable\n      $ ${command} --disable\n  `\n}\n\nexport const cmdWrapper = {\n  description: config.description,\n  hidden: config.hidden,\n  run\n}\n\nasync function run(\n  argv: readonly string[],\n  importMeta: ImportMeta,\n  { parentName }: { parentName: string }\n): Promise<void> {\n  // I don't think meow would mess with this but ...\n  if (argv[0] === '--postinstall') {\n    await postinstallWrapper()\n    return\n  }\n\n  const cli = meowOrExit({\n    argv,\n    config,\n    importMeta,\n    parentName\n  })\n\n  const { disable, enable, json, markdown } = cli.flags\n  const outputKind = getOutputKind(json, markdown) // TODO: impl json/md further\n\n  const wasValidInput = checkCommandInput(\n    outputKind,\n    {\n      test: !!(enable || disable),\n      message: 'Must use --enabled or --disable',\n      pass: 'ok',\n      fail: 'missing'\n    },\n    {\n      nook: true,\n      test: !enable || !disable,\n      message: 'Do not use both --enable and --disable',\n      pass: 'ok',\n      fail: 'missing'\n    }\n  )\n  if (!wasValidInput) {\n    return\n  }\n\n  if (cli.flags['dryRun']) {\n    logger.log(DRY_RUN_BAILING_NOW)\n    return\n  }\n\n  // Lazily access constants.bashRcPath and constants.zshRcPath.\n  const { bashRcPath, zshRcPath } = constants\n  if (enable) {\n    if (existsSync(bashRcPath) && !checkSocketWrapperSetup(bashRcPath)) {\n      addSocketWrapper(bashRcPath)\n    }\n    if (existsSync(zshRcPath) && !checkSocketWrapperSetup(zshRcPath)) {\n      addSocketWrapper(zshRcPath)\n    }\n  } else {\n    if (existsSync(bashRcPath)) {\n      removeSocketWrapper(bashRcPath)\n    }\n    if (existsSync(zshRcPath)) {\n      removeSocketWrapper(zshRcPath)\n    }\n  }\n  if (!existsSync(bashRcPath) && !existsSync(zshRcPath)) {\n    logger.fail('There was an issue setting up the alias in your bash profile')\n  }\n}\n","#!/usr/bin/env node\n\nimport { fileURLToPath, pathToFileURL } from 'node:url'\n\nimport { messageWithCauses, stackWithCauses } from 'pony-cause'\nimport updateNotifier from 'tiny-updater'\n\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { cmdAnalytics } from './commands/analytics/cmd-analytics.mts'\nimport { cmdAuditLog } from './commands/audit-log/cmd-audit-log.mts'\nimport { cmdCdxgen } from './commands/cdxgen/cmd-cdxgen.mts'\nimport { cmdCI } from './commands/ci/cmd-ci.mts'\nimport { cmdConfig } from './commands/config/cmd-config.mts'\nimport { cmdScanCreate } from './commands/dependencies/cmd-dependencies.mts'\nimport { cmdDiffScan } from './commands/diff-scan/cmd-diff-scan.mts'\nimport { cmdFix } from './commands/fix/cmd-fix.mts'\nimport { cmdInfo } from './commands/info/cmd-info.mts'\nimport { cmdLogin } from './commands/login/cmd-login.mts'\nimport { cmdLogout } from './commands/logout/cmd-logout.mts'\nimport { cmdManifest } from './commands/manifest/cmd-manifest.mts'\nimport { cmdNpm } from './commands/npm/cmd-npm.mts'\nimport { cmdNpx } from './commands/npx/cmd-npx.mts'\nimport { cmdOops } from './commands/oops/cmd-oops.mts'\nimport { cmdOptimize } from './commands/optimize/cmd-optimize.mts'\nimport { cmdOrganization } from './commands/organization/cmd-organization.mts'\nimport { cmdPackage } from './commands/package/cmd-package.mts'\nimport { cmdRawNpm } from './commands/raw-npm/cmd-raw-npm.mts'\nimport { cmdRawNpx } from './commands/raw-npx/cmd-raw-npx.mts'\nimport { cmdReport } from './commands/report/cmd-report.mts'\nimport { cmdRepos } from './commands/repos/cmd-repos.mts'\nimport { cmdScan } from './commands/scan/cmd-scan.mts'\nimport { cmdThreatFeed } from './commands/threat-feed/cmd-threat-feed.mts'\nimport { cmdWrapper } from './commands/wrapper/cmd-wrapper.mts'\nimport constants from './constants.mts'\nimport { AuthError, InputError, captureException } from './utils/errors.mts'\nimport { failMsgWithBadge } from './utils/fail-msg-with-badge.mts'\nimport { meowWithSubcommands } from './utils/meow-with-subcommands.mts'\n\nconst __filename = fileURLToPath(import.meta.url)\n\nconst { SOCKET_CLI_BIN_NAME } = constants\n\n// TODO: Add autocompletion using https://socket.dev/npm/package/omelette\nvoid (async () => {\n  await updateNotifier({\n    name: SOCKET_CLI_BIN_NAME,\n    // Lazily access constants.ENV.INLINED_SOCKET_CLI_VERSION.\n    version: constants.ENV.INLINED_SOCKET_CLI_VERSION,\n    ttl: 86_400_000 /* 24 hours in milliseconds */\n  })\n\n  try {\n    await meowWithSubcommands(\n      {\n        cdxgen: cmdCdxgen,\n        ci: cmdCI,\n        config: cmdConfig,\n        fix: cmdFix,\n        info: cmdInfo,\n        login: cmdLogin,\n        logout: cmdLogout,\n        npm: cmdNpm,\n        npx: cmdNpx,\n        oops: cmdOops,\n        optimize: cmdOptimize,\n        organization: cmdOrganization,\n        package: cmdPackage,\n        'raw-npm': cmdRawNpm,\n        'raw-npx': cmdRawNpx,\n        report: cmdReport,\n        wrapper: cmdWrapper,\n        scan: cmdScan,\n        'audit-log': cmdAuditLog,\n        repos: cmdRepos,\n        dependencies: cmdScanCreate,\n        analytics: cmdAnalytics,\n        'diff-scan': cmdDiffScan,\n        'threat-feed': cmdThreatFeed,\n        manifest: cmdManifest\n      },\n      {\n        aliases: {},\n        argv: process.argv.slice(2),\n        name: SOCKET_CLI_BIN_NAME,\n        importMeta: { url: `${pathToFileURL(__filename)}` } as ImportMeta\n      }\n    )\n  } catch (e) {\n    process.exitCode = 1\n    let errorBody: string | undefined\n    let errorTitle: string\n    let errorMessage = ''\n    if (e instanceof AuthError) {\n      errorTitle = 'Authentication error'\n      errorMessage = e.message\n    } else if (e instanceof InputError) {\n      errorTitle = 'Invalid input'\n      errorMessage = e.message\n      errorBody = e.body\n    } else if (e instanceof Error) {\n      errorTitle = 'Unexpected error'\n      errorMessage = messageWithCauses(e)\n      errorBody = stackWithCauses(e)\n    } else {\n      errorTitle = 'Unexpected error with no details'\n    }\n    logger.error('\\n') // Any-spinner-newline\n    logger.fail(failMsgWithBadge(errorTitle, errorMessage))\n    if (errorBody) {\n      debugLog(`${errorBody}`)\n    }\n    await captureException(e)\n  }\n})()\n"],"names":["time","process","logger","ok","message","cause","rows","cols","screen","label","barWidth","barSpacing","xOffset","maxHeight","barBgColor","data","formattedData","totalTopAlerts","sortedTopFiveAlerts","top_five_alert_types","formatted","style","line","text","baseline","xLabelPadding","xPadding","wholeNumbersOnly","legend","width","x","y","result","DRY_RUN_BAILING_NOW","commandName","description","hidden","flags","file","type","shortFlag","repo","default","scope","run","parentName","markdown","repoName","nook","test","pass","fail","filePath","perPage","outputJson","outputMarkdown","page","REDACTED","desc","generated","org","nextPage","user_email","debugLog","logType","interactive","help","YARN_LOCK","__proto__","cleanupPackageLock","configuration","coerce","filter","only","profile","standard","technique","alias","array","key","boolean","string","allowUnknownFlags","argv","length","yargv","branch","commit_hash","commit_message","committers","make_default_branch","set_as_pending_head","spinner","scanStatus","updateProgress","policyStatus","finishedFetching","scan","version","alerts","healthy","addAlert","options","reportLevel","policy","url","manifest","ecomap","pkgmap","vermap","filemap","short","includeLicensePolicy","depth","value","Package","Policy","scanId","tmp","branchName","fold","commitMessage","commitHash","cwd","defaultBranch","outputKind","pendingHead","pullRequest","readOnly","report","slug","name","failed","obj","config","full","auto","get","list","set","unset","offset","columns","field","limit","orgSlug","fs","showHidden","colors","maxArrayLength","after","before","json","stdout","auth","_octokitGraphql","headers","authorization","ttlMs","recursive","workspaceName","apiType","cacheKey","entry","index","parent","props","allOpenPrs","state","per_page","baseRefName","headRefName","number","pull_number","match","node_id","pullRequestId","error","baseBranch","head","base","body","consolidate","nothrow","include","existing","unfixable","upgradable","NPM","path","testScript","pkgPath","pkgEnvDetails","editable","vulnerableVersionRange","dependencies","optionalDependencies","peerDependencies","updateNode","updatePackageJsonFromNode","ignoreWhitespace","stdio","fixedSpecs","errored","editablePkgJson","PNPM","ignoreIncompatible","lockfile","actualTree","cmdName","agent","autoMerge","autopilot","purl","isMultiple","rangeStyle","acc","count","fallbackToUrl","severityCount","pkgVersion","Maintenance","Quality","Vulnerabilities","Object","outputPackageIssuesDetails","strict","includeAllIssues","updateConfigValue","SOCKET_PUBLIC_API_TOKEN","apiBaseUrl","apiProxy","choices","enforcedOrgs","applyLogout","attemptLogout","buf","resolve","reject","keeping","collecting","arr","out","verbose","stderr","bin","gradleOpts","task","poms","sbtOpts","subArgs","meow","importMeta","conda","scala","gradle","kotlin","aliases","yolo","NPX","YARN_CLASSIC","overrides","pkgs","pkgid","names","isPlacingHigher","insertIndex","entries","added","addedInWorkspaces","updated","updatedInWorkspaces","warnedPnpmWorkspaceRequiresNpm","npmExecPath","overridesDataObjects","semver","package","depAliasMap","thisSpec","depObj","newSpec","updateManifestByAgent","NPM_BUGGY_OVERRIDES_PATCHED_VERSION","prod","pin","mw1","mw2","mw3","security","license","defaultSub","quota","self","capabilities","score","transitively","selfCaps","valid","purls","components","License","outputPurlsShallowScore","shallowScore","shallow","deep","meowOrExit","create","view","visibility","outputCreateRepo","homepage","repoDescription","sort","direction","del","update","dryRun","defaultOrgSlug","updatedInput","id1","id2","from","created_at","year","month","day","fromTime","untilTime","stream","diff","metadata","keys","fg","selectedFg","selectedBg","height","border","columnWidth","columnSpacing","truncate","bottom","content","table","numeric","eco","zshRcPath","enable","disable","SOCKET_CLI_BIN_NAME","cdxgen","ci","fix","info","login","logout","npm","npx","oops","optimize","organization","wrapper","repos","analytics","errorTitle","errorMessage","errorBody"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMO;AAGL;AACA;AACE;AACF;AACA;AAEA;AAIF;;ACbO;AAIL;AACA;AACE;AACF;AACA;AAEA;AAIF;;ACRuC;;AAGvC,iBAAA;AAEA;;AAeA;AACA;AAeO;;;;;AAUHA;AAOF;AAEA;AACEC;AACF;AAEA;;AAEIC;AACA;AACF;AACAA;AACA;AACF;;AAGE;AAEA;;;AAGIA;;;AAGAA;AAEIC;AACAC;AACAC;AACF;AAEJ;AACF;AACEH;AACF;AAEA;AACF;AAEA;;;;AAME;AACA;;;AAGIA;;AAEAA;AACF;AACF;AACEA;AACF;AACF;;AAEA;AACF;AAkBO;;AAOP;;AAEA;;AAEA;AAoCA;;AAEA;AACA;;AAIA;;AAEA;AACA;AAEA;AAEA;AACE;AACA;AACA;AACE;AACF;AACA;AACA;AAA8BI;AAASC;AAASC;AAAO;;;;;;;;;AA2DvD;AACA;AACEC;AACAC;AACAC;AACAC;AACAC;AACAC;AACF;AAEAN;;;;AAIEO;AACF;;AAGA;AACAP;AACF;AAEO;;;;AAOL;AACEQ;AACF;AAEA;AACE;;AAEE;AACA;AACEC;;AAEAA;AACF;AACF;AACF;AACA;AACE;AACED;AACF;AACF;AAEA;;AAIEE;AACF;;AAGE;AACAC;;AAEJ;AAEO;;;;AAOL;AACEH;AACF;AAEA;AACE;;AAEE;AACA;AACEC;AACF;AACEA;AACF;AACF;AACF;AAEA;AACE;AACA;;AAEE;AACEG;AACF;AACEA;AACF;AACF;AACF;AAEA;;AAIEF;AACF;;AAGE;AACAC;;AAEJ;AAEA;;AAEA;AAEA;AAOE;;AAEEE;AAASC;AAAcC;AAAcC;;AACrCC;AACAC;AACAd;AACAe;AACAC;AACEC;;AAEFpB;AACF;AAEAD;AAEA;AACEsB;AACAC;;AAGFT;AACF;;ACrZO;;;;;AAKLtB;AAOF;AACE;;AAKEgC;;AAEAA;AACF;AACEA;AACE7B;AACAC;;AAEJ;;AAEE4B;AACE7B;;AAEAY;;AAEJ;;;;;;AAOEf;AACF;AACF;;ACnCA;AAAQiC;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAC;AACEC;AACAC;AACAL;;AAGFM;AACEF;AACAC;AACAE;AACAP;;AAEFQ;AACEJ;AACAC;AACAE;AACAP;;AAGFnC;AACEuC;AACAC;AACAE;AACAP;AACF;;;AAEgBE;AAAM;AAE1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACM;AAAA;AAEN;AAEO;;;AAGLO;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;AAEoBC;;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMI;AACE9C;AACF;;AAEA2C;AACA;AACEI;AACF;AACA;AACE/C;AACF;;AAEAA;AACF;AACF;AACE;;AAEA;;;AAGA;AACA;;AAEA;AACF;AAEA;AAEA;AAGI;AACAgD;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACA;;AAEA5C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAGA8C;AACAC;AACF;AAEEH;;AAKA5C;AACA8C;AACAC;AACF;;AAKE/C;AACA8C;AACAC;AAGF;AAEEH;;AAEA5C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;;;AAMEuC;;AAEAW;AACF;AACF;;AChOO;;;;;AAKLC;AAOF;AACE;AACA;AACE;AACF;AACA;;AAII;AACAC;AACA;AACAC;;AAEAhB;AACAiB;;AAEF;AAGJ;;AC3BA;AAAQC;AAAS;AAEV;;;;;AAOHJ;AAOF;AAEA;AACEpD;AACF;;AAGEC;;;;AAKImD;AACF;;AAGFnD;AACF;AACEA;;;;AAKImD;AACF;AAEJ;AACF;AAEO;;;;AAMHA;AAMF;AAEA;;AAEA;AAEA;AACElD;AACAY;AACE2C;AACA;AACAC;AACAC;;;AAGAC;;;AAGE;;;;;;;AAOEC;AACF;;;;;;;AAOEA;;;AAGN;AACF;AACF;AAEO;;;;AAMHT;AAMF;AAEA;;AAEF;;AAEA;;AAEA;AACA;AAUA;;AAEA;AAEA;AACA;AACA;AACA;AACE;;;;AAaF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGInD;;AAIE6D;AACF;AACA;AACA;AACF;AACF;;AClLO;;;;;AAKLV;AAOF;AACE;;;;;AAKEW;AACF;;;;;;AAOEX;AACF;AACF;;AClBA;AAAQpB;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA4B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFI;AACEA;AACAC;AACAE;AACAP;;AAEFkB;AACEd;AACAC;AACAE;AACAP;;AAEFqB;AACEjB;AACAC;AACAE;AACAP;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAOEe;;;AAGArB;;AAEF;AACA;AAEA;AAOA;AAEA;AAGIS;;AAEA5C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;;AAGEsD;AACAH;AACAW;AACF;AACF;;ACnJA;;;;;;AAAiDG;AAAU;AAE3D;AAWO;;;;;AAEiB;AAAMC;;;;;AAO1B;;AAEA;AACE;AACA;;AAEE;AAEE;AACA;;AAKFC;;AAEJ;AACF;AACA;AAEE;AACA;AAGF;;AAEI;;AAEJ;AACA;AACA;AACEnE;AACF;AACF;AAEA;AAGE;;AAEA;;AAEA;AAAa;AAAQ;AAAS;AAC5B;AACE;AACF;;AAEE;AACA;AACA8B;AACF;AACEA;AACF;;;AAGEA;AACF;AACF;AACA;;AAEA;AACA;AACF;;ACjFA;AAAQC;AAAoB;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACEqC;AACE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEFC;AACE;AACA;AACAC;AACAC;AACAC;AACAC;AACAC;AACArC;;AAEFG;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEFmC;;;;;;;;;;AAUAC;AACIC;AAAexC;AAAe;AAC9BwC;AAAgBxC;AAAe;AAC/BwC;AAAqBxC;AAAe;AACpCwC;AAAsBxC;;AAAkB;AAC1C;AAAEwC;AAAexC;AAAe;AAC9BwC;AAAaxC;AAAe;AAC5BwC;AAAiBxC;AAAe;AAChCwC;AAAkBxC;AAAe;AACjCwC;AAAaxC;AAAe;AAEhCyC;AAGY;;AAGM;;AAgBhB;AACA;AACA;AAEFC;AAE2B;;AACL;;AACH;AACjB;AACkB;;AACG;AACrB;AAOkB;;AACQ;;AACD;AACzB;AAGgB;AAChB;AAAqB;AAEzB;AAEA;AACE/C;AACAC;AACAC;AACA;AACA;;;AAGF;AAEO;;;AAGLQ;AACF;AAEA;AAGIC;AAAmC;;AAGnCqC;AACA;AACAC;;;AAGAtC;AACF;;AAEA;AACA;AACE;;AAGF;;AACQuC;AAAsB;AAC9B;AACE;AACA;AACA;;;AAKA;AACF;AAEA;AACElF;AACA;AACF;;AAEA;AACA;AACA;AACA;;AAEEmF;AACAnF;AAMF;AAEA;;AAEA;;AAGF;;AC1RA;AACO;AACL;AAEA;AACE6D;;AACS5D;AAAUY;;AACrB;AAEA;AACA;AACE;AACF;AACA;AAEA;AAKA;AACE;AACF;AAEA;AACA;AAEA;;AAEIZ;AACAC;AACAW;;AAEJ;;;;AAMIZ;AACAC;AACAW;;AAEJ;AAEAgD;;AAEE5D;AACAC;AACAW;;AAEJ;;ACrDO;;;;;;AAaHgC;AAQF;AAEA;AACA;AACE;AACF;AACA;;AAMM;AAAmBuC;;AACnB;AAAmBC;;AACnB;AAAsBC;;AACtB;AAAmBC;;AACnBC;AACA;;;;AAC+C;AAC/CC;;AAEF;AAMN;;AChDO;AAGL;AACA;AACE;AACF;AACA;;AAMF;;ACRA;AACA;AACA;AACA;AACO;AAUL;AACA;AACE;AACF;AACA;;;;;AAMA;;AACQC;AAAQ;;AAGdC;AACAC;AACF;;AAGEC;AACAD;AACF;;AAGE;;;AAKA;;AAIA;AACF;;AAKE;;AAMA;AACE;AACF;AAEA;;AAEA;AACA;;AAEA;;AAEI;AACF;AACE3F;;;AAGA;AACF;AACF;AAEA;;;AAEWA;AAAUY;;AACrB;;;AAKEZ;AACAC;AACAC;;AAGJ;;AAKE;;AAOA;AACF;AAEAyF;AAEA;;;AAOM3F;AACAC;AACAC;;;;;AAMAF;AACAC;AACAC;;AAEJ;AAEA2F;AACAF;AACF;AAEA;AACE;AACF;AACA;AACE;AACF;;;AAII3F;AACAC;AACAC;;AAEJ;;AAGEF;AACAY;;;AAGA;;AAEJ;;ACrIA;AACA;AACO;;;;;;AASH6E;AAQF;AAEA;AAEAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAIA;AACA;AACE;AACAK;;;;AAII1D;AACA2D;AACF;AAEAC;AAMI;;AAEA;AACE;AAAc;AACZC;;AAEEC;AAUF;AACA;AACF;AACA;AAAa;AACX;AACEA;AAUF;AACA;AACF;AACA;AAAgB;;AAEZA;AAUF;AACA;AACF;AAEA;AAAe;AACb;AAMEA;AAUF;AACA;AACF;AAEA;AAAc;AACZ;AACA;AACEA;AAUF;AACA;AACF;AAKF;AACF;AAEJ;AACF;AAEAT;AAEA;;AAEIzF;AACAY;AAAQqF;AAAQ;;AAEpB;AAEA;;;;AAIEE;;AAAiBC;;AACjBJ;;;;AAKEhG;AACAC;AAEAW;;AAEJ;;AAGEZ;AACAY;;AAEJ;AAEA;AAKE;;AAEEyF;AACAC;AACAC;;AAEF;AACF;AAEA;AAUE;;AAEA;AACA;;AAEE;;AAEEC;AACF;AACF;AACE;;AAEA;AACA;;AAEE;;AAEEC;AACF;AACF;AACE;;AAEA;AACA;AACA;;AAGE;;AAEEC;AACF;AACF;AACE;;AAEA;AACA;AACA;AACA;;AAEEC;AACF;AACF;AACF;AACF;AACF;AAEA;AAIE;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEE;AACF;AACA;AACA;AACF;;ACtUO;;;;;;;;AAaHC;AAUF;AAEA;AACE9G;AACF;AAEA;;AAEIC;AACA;AACF;AACAA;AACA;AACF;AAEA;;;;;;AASI;;AAEF;AAGF;AACE;AACAD;;AAEA;;AAEEC;AACA;AACF;AACAA;AACA;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAIE;AAIA;AACEA;;AAEF;AAEAA;AACA;AACF;AAEA;AACE;AAGqC;AAC/B8G;AAGN;AACE9G;;AAEF;AAEAA;AACAA;AACA;AACF;AAEA;AACEA;AACF;AACEA;AAA8B+G;AAAY;AAC5C;AACF;AAEO;AAIL;AAEA;;AAEE;AACAd;;AAGF;AACEhG;AACAY;AACF;AACF;AAEO;AAIL;;AACWmG;AAAiD;;;;;AACxBT;AAAI;;AAElC;AACAU;AACA;;AAEA;AACAC;;AAEJ;AAGF;AAEF;;AAEA;AACA;;AAEA;;AAEA;;AAKA;;AAEA;;AAEA;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAKA;AAYA;AAGE;AACF;;ACjNO;;;;;;;;AAQLL;AAUF;;;;;AAMIM;;;;;AAKAN;AACF;AACF;;ACxBO;AAKL;AACE9G;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEA;AACEA;;AAEF;;AAGEA;AACAA;AACA;AACEA;AAGAA;AACF;AACEA;AAGF;AACAA;AACA;AACF;AAEA;AACAA;AAEA;AAGIE;AACAsC;;;AAIJ;AACF;;ACrDO;;;;;;;;;;;;;;;;AAgBL4E;AAkBF;AACE;AACA;AACE;AACA;AACF;AAEA;AAMA;AACEtE;AACAC;AACAC;AACAC;AACA/C;AAEF;;AAEE;AACF;AAEA;AACEF;AACA;AACF;AAEA;;;;;;AAaIqH;AACF;AAGF;AACE;AACE;AACEnE;AACAoE;AACAR;;;AAGAT;AACAc;AACAN;AACF;AACF;AACE;AAEI5G;AACAC;AACAC;;AAEF;AAIJ;AACF;AACE;AACF;AACF;;ACjHO;AACL;AACA;AACA;AACA;AACA;AACA;AACEJ;AACA;AACAC;AACA;AACF;;AAEA;AACA;AACA;AACEqH;AACAE;AACAC;AACAjC;AACAkC;AACAC;AACA3D;;AAEA4D;AACAC;AAAmB;AACnBC;AACAhF;AACAiF;AACAC;;;AAGF;AACF;;AC9BA;AAAQhG;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;;;AAGA6B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;AAEA;AACE3C;AACA;AACF;;AAGF;;AChDO;AAGL;AACA;AACA;;AAEA;;AAEIC;AACAC;AACAC;;AAEJ;;AAGE;;AAEEF;AACAC;AACAC;;AAGJ;;AAGE;;AAEEF;AACAC;AACAC;;AAGJ;;;AAIIF;AACAC;AACAC;;AAGJ;;AAGE;;;AAGIF;AACAC;AACAC;;AAEJ;AAEA;AACA;;AAEIF;AACAC;AACAC;;AAEJ;AAEA;;AAEIF;AACAY;AACAX;;AAEJ;;AAGED;AACAY;AACAX;;AAEJ;;AAGE;;;AAGID;AACAC;AACAC;;AAEJ;AAEA;AACA;;AAEIF;AACAC;AACAC;;AAGJ;;AAGEF;AACAY;AACAX;;AAEJ;;;AAIID;AACAC;AACAC;;AAEJ;;AAEA;;AAEEF;AACAC;AACAC;;AAEJ;AAEA;AAGE;AACA;AACE;AACF;AACA;AAEA;;;AAOO6H;;AAEL;AACE;AACF;AACA;;AAEA;AACA;AACF;AAEA;AACF;AAEA;AACE;AACA;AACE;AACF;AACA;AAEA;;;AAOOA;;AAEL;AACE;AACF;AACA;AACF;AAEA;AACF;;AC3KO;AAKL;AACEjI;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGEA;AACAA;AACAA;AAGAA;;;;AAIIA;AACAA;AACF;AACF;AACAA;AACF;;AAEIA;AACAA;AACF;;AAEAA;;AAGEA;AAGF;AACE;AACEE;;AAII+H;AACAjB;;AAEF;AAEEiB;AACAjB;AACA/E;;AAEN;AACA;AACEjC;AACA;;AAEEA;AAGF;AACEA;AACF;AACF;AACEA;AACF;AACF;AACE;AACEE;;AAII+H;AACAjB;;AAEF;AAEEiB;AACAjB;AACA/E;;AAEN;AACA;AACEjC;AACA;;AAEEA;AACF;AACEA;AACF;AACF;AACEA;AACF;AACF;AACF;AACF;;AC3GO;;AAEL2H;AAIF;AACE;AAEA;AACF;;ACFA;AAAQ5F;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF6B;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAIA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;AAIA;;AAII1C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACE6E;AACA8C;AACF;AACF;;AC3FO;AAKL;AACE5H;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEA;;AAGEA;AACAA;;AAEA;AACEA;AACAA;AAGF;AACF;;AAEE;AACEA;AACAA;AAGF;AACF;AACF;;AC1CO;;AAEL2H;AAIF;AACE;AAEA;AACF;;ACFA;AAAQ5F;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF6B;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAIA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;AAIA;;AAII1C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACE6E;AACA8C;AACF;AACF;;ACnFO;;AAELA;AAIF;AACE;;;;;AAKI;AACA;AACA;AACEX;AACAkB;;AAEAlB;AACF;AACA;AACEmB;AACF;AACF;AACA;;AAEA;AACAnI;AAIUC;AACAC;AACAW;;AAEEuH;AACAN;;AAEJ;AAEE7H;AACAY;;AAEEuH;AACAN;AACF;AACF;AAGV;AACE;AAKA9H;AACAA;;AAEAA;;AAEE;AACA;;AAEA;AACE;;AAEEgH;AACF;AACA;;AAIA;AACF;AACF;AACA;AACEhH;AACAA;AAGF;AACF;AACF;;ACjFA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAkG;AACEhG;AACAG;AACAP;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAIA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;AAEoBC;;AACpB;AAEA;AACEE;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAEE;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;AAEE2H;AACF;AACF;;ACjFO;AAIL;AACE5H;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGEA;AACAA;AACAA;;AAEEA;AACAA;AACF;AACF;AACEA;AACAA;;AAEEA;AACAA;AACF;AACF;AACF;;AClCO;;;AAGLgH;AAKF;AACE;AAEA;AACF;;ACJA;AAAQjF;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF6B;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAIA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;AAGA;AAEA;;AAII1C;AACA8C;AACAC;AACF;;AAEiB;AACf/C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACE6E;;AAEAmC;AACF;AACF;;ACtGO;AAIL;AACEjH;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGEA;AACAA;AACAA;;AAEEA;AACAA;AACF;AACF;AACEA;AACAA;;AAEEA;AACAA;AACF;AACF;AACF;;AClCO;;AAEL2H;AAIF;AACE;AAEA;AACF;;ACFA;AAAQ5F;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF6B;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAIA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;AAIA;;AAII1C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACE6E;AACA8C;AACF;AACF;;ACtFA;AAEO;;AAELzF;AAAc;AACd;AAA8BS;AAAW;AACvC;AAEI2F;AACAC;AACAC;AACAC;AACAC;AACF;;;;;AAMA;AAEJ;AACF;;ACzBO;;AAELC;AAIF;AACE;AACA;AACE;AACF;AACA;AAEA;;AACsCA;;AAGxC;;ACvBA;AAYO;;;AAKHhB;AAKF;AAEA;AACE5H;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAWA;AACE4I;AACIC;AAAoBZ;AAA+B;AACnDY;AAAeZ;AAA0B;AACzCY;AAAkBZ;AAA6B;AAC/CY;AAAqBZ;AAAgC;AACrDY;AAAiBZ;AAA4B;AAC7CY;AAAeZ;AAA0B;AACzCY;AAAiBZ;;;AAIvBjI;AACF;;ACtDO;;;AAGL2H;AAKF;AACE;;AAAgDgB;AAAO;;;;AAELhB;AAAW;AAC/D;;ACJA;AAAQ5F;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACA2G;AACEzG;AACAC;AACAE;AACAP;;AAEF0G;AACEtG;AACAC;AACAE;AACAP;;;;AAIJ+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;AAE+BgG;;AAC/B;AAEA;AAEA;AAGI7F;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;;AAGE2H;AACF;AACF;;ACvGO;;;AAGLoB;AAKF;AACE;AAIF;;ACLO;;;AAKHpB;AAKF;AAEA;AACE5H;AACF;AAEA;;AAEIC;AACA;AACF;AACAA;AACA;AACF;AAEA;AACA;;AAIA;AACA;AACA;AACA;AACE;AAEA;AACEA;AACAgJ;AACE;AACEhJ;AACAA;AACF;AACEA;AACF;AACAA;AACF;AACF;AACE;AACAA;AACAA;AACAA;AACF;AAEA;AACF;;AAEA;AACA;;AAEAA;;AAGIiJ;AACAlC;AACAmC;AACAC;AACF;AAEFnJ;AAGAA;AACF;;ACjFO;;;;;;AAML2H;AAQF;AACE;;;AAGEoB;AACF;;;;AAKEpB;AACF;AACF;;ACjBA;AAAQ5F;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACAiH;AACE/G;AACAC;AACAE;AACAP;;AAEFoH;AACEhH;AACAC;AACAE;AACAP;;AAEF8E;AACE1E;AACAG;AACAP;;AAGFqH;AACEjH;AACAC;AACAE;AACAP;;AAGFG;AACEC;AACAC;AACAE;AACAP;AAEF;;;AAMJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLS;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;;AAE0CC;;AAC1C;AAEA;;AAGA;AAEA;AAGIG;AACA7C;AAEA8C;AACAC;AAMF;;AAGEH;AACA5C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEAjD;AAIA;AACEA;AACA;AACF;AAEA;AACEqJ;AACAD;AACArC;;;AAGA3E;AACF;AACF;;ACjKA;AAEO;;AAEL;AACA;AACA;AACA;AACAF;AACA;AAA8BS;AAAW;AACvC;AAEI4F;AACF;;;;;AAMA;AAEJ;AACF;;ACbA;;AAKA;AAEO;AACL;AACA;AAEE;AACA;;AAGJ;AAEO;AAKL;;AAIA;AAGA;AACA;AACF;AAEO;AAIL;AACA;;AAIA;AAGF;AAEO;AAKL;AACA;;;AAGF;AAEO;AAKL;AACA;;AAEA;AACF;AAEO;AAKL;AACA;;;AAGF;AAEO;AAKL;AACEvI;AACA;AACF;AACA;AACE;;AAMF;AACA;AACEA;AACA;AACF;;AACiDyH;AAAI;;AACHA;AAAI;;AACJA;AAAI;;AAEpD;AAAmEA;AAAI;AACvE;;AAEFzH;;AAEE;AAGIyH;AAAI;AAER;;AAEFzH;AACA;AACF;AAEO;AAIL;AACA;AACA;;AAEF;AAEO;;AAI6CyH;AAAI;AACxD;AAEO;;AACmCA;AAAI;AAC9C;AAEO;;;AAKK8B;AAAO;AAGX9B;AAAI;;AAGV;AACE;AACF;AACF;AAEA;;AAGU8B;;AAAyD9B;AAAI;AACrE;;AAEF;;ACxJA;AACA;;;AAGM;AACA+B;AACF;AACF;AACA;AACF;AAEA;AACO;;AAEHC;AACEC;AACE;AACAC;AACF;AACF;AACF;AACA;AACF;AAEO;AAKL;AACA;;AAEA;;;AAGE9I;AACA;AACF;AACA;AACF;AAEA;AAEE;AACA+I;AAEA;;;;AAIE;AACA;;AAEE;AACF;;AAEF;AACF;AAEA;AACE;;;AAGA;AACE;AAA4BC;AAAgB;AAC9C;AACA;AACF;AAQO;;AAOGC;AAAc;AAAM5F;;;AAC5B;AACA;AACA;;;AAqBE;AACA;AACA;;AAIJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACiB3B;AAAK;;AAIlB;AACE;AAAkB2C;;AAChB;;;AAGI6E;AACAC;AACAnJ;AACAoJ;AACAC;AACAC;AACAC;AACF;AACF;AACF;AACF;;;AAGF;AACA;AACA;AACE;;AAEEC;;;AAMMC;AACAC;AACF;;AAGN;AACE;AAAkBrF;;AAChB;;;AAGI6E;;AAEAlJ;AACAoJ;AACAC;AACAC;AACAC;AACEI;AACAC;AACA;AACA;;;;AAKF;AACF;AACF;AACF;AACF;AACF;AAEA;AACE;AACF;AAEA;;;AAIYL;AAAM;AACd;;AACQM;AAAiB;AACzB;AACA;;;AAGI;;;AAGEC;AACAL;AACF;;AAEA;;AAEA;;;;AAMA;AACF;AACF;AACA;AACA;AACA;;AAEI;;;;;AAKA;AACAtK;AACA;AACA;AACE4K;AACF;AACEA;AACF;AACA;;;AAGA;;AAEF;AACF;AACF;;;AAK2B;AAAQ;;AAErC;AACF;AAEO;AACLC;AACAH;AACE;AACF;AACA;;AAEE;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQI;AAAoB;;AAIxB;AACE9K;AACA;AACF;;AAEA+K;AACF;AACA;AACA;;AAEY7K;AAAQ;;AAGpB;AACAF;AACA;AACF;AAOO;AACL;AACA;AACA;AACA;AACE;AACF;;;AAGEuC;;AAEJ;AAQO;;AASHyI;AACAvD;AACAqC;AACF;AACE5F;;;AAGF;AACA;AACE;AACA;;AAEE;AACF;;AAEA;AACEuD;AACF;AACA;;AAEE;;;;AAIEwD;AACAC;AACAC;AACF;;;;;AAKE;AACE;;AAOF;AACF;AACAnL;AACA;AACF;AACF;AACA;AACF;AAEO;AAKL;;;AAEUa;AAAU;;;AAGhBoK;AACAX;AACAC;AACF;AACA;;AAEF;AACF;;ACpaO;AAEA;;AAEHrG;AACAkH;AACAC;AACA;AACAC;AACEpH;AACAqH;AACAC;AACAC;AACA;AACF;;AAMJ;AAEO;AAGL;AACEvH;;;AAGF;;AAEA;AACA;AACEkC;AACF;AACA;AACEA;AACF;;AAMAA;AAEAA;AAIA;;AAEA;AACA;AACEA;AACF;AACA;;AAEA;AACA;AACF;;ACVA;;AAA4BsF;AAAI;AAMhC;;AAIUjE;AAAoB;AAC1BvD;;;AAGF;AAA2ByH;AAAU;;AAErC;AACF;AAEO;;;;;;;;AAUHC;AACoB;AAEtB;AACE5L;AACA;AACF;AACA;;AACQ0F;AAAQ;;;AAIRmG;AAAkB;AAC1B;AACEF;;AAEF;AACA;AACA;AAEA;AAC4D7C;;AACCA;AAAM;AAEnE;AAAqDA;AAAM;;;AAGzD9I;AACA;AACF;;AAEA;AACA;;;AAMA;AAEE;AACA8L;;;AAI0B;AAAS;;AACnCjI;AAEA;AACE6B;AACA;AACF;AACA;AACE7B;AACA;AACF;AACA;AACA;;AAEEA;AACA;AACF;;AAGA;AAEA;AACE;;AAGA;AAIAA;;AAGA;AACA;AAEA;AAKA;AACEA;AACA;AACF;;AAEA;AACA;AACA;AACA;AACEkI;AACF;AAEA;AACE;AACA;;;AAIElI;AACA;AACF;AAEA;;AAEEmI;;;;AAYA;AACEnI;AAGA;AACF;;AAGA;AACA;AAEA;AACEA;AACA;AACF;AAEA;AACE;AACEoI;;AAAwD;AAC1D;AACA;AACEC;;AAEA;AACF;AACA;AACEC;;AAAgE;;;AAIpEC;AACAC;AAOA;AACA;AAAmCC;;AACjCzI;AACA;AACA;AACE;AACA;AACF;AACA;AACF;;AAIA;;;AAGE;AACA;AAAgC4D;AAAI;AACpC;;AAEE;AACA;;AAA2C8E;AAAgB;AAC7D;AACAC;;;;AAIAC;AACA1B;AACF;AAEA;;;;;AAOmBxI;;AACf;AACE;;AAEA;AACA;AAMA;AACF;AACA;;AAEEuH;AACF;AACA;AACA;;;AASIA;AACF;AAEF;;AACUjJ;AAAK;;AAEb;AACE;;AAEF;AACF;;AAEAkK;AACA0B;AACF;AACF;AAEA;AACE;AACA;AACA;AACA;AAAgChF;AAAI;AACtC;AACA;;AAEIiF;AACA;AACA;AAEyBJ;;AAEzB;AACA;AAAgC7E;AAAI;AACtC;;AAKF;AACA;AACE;AACF;AACF;AACF;AACF;AACF;;AAGF;;ACtSA;;;;AAA4CkF;AAAK;AAEjD;AACE;AACEhB;;AAEF;AACA;AACF;AAQA;;;;AAIqBjG;AAAQ;AACzBxB;;;;;;AAMAqI;AACF;AACA;AACF;AAEA;AACE;AACEK;AACF;AACF;AAEO;;;;;;;;AAUHhB;AACoB;AAEtB;AACE5L;AACA;AACF;AACA;;AACQ0F;AAAQ;;AACRmG;AAAkB;;AAI1B;;AAEA;;;;AAEsCnG;AAAQ;AAC5CmH;AACF;AACA;AACA;;;;;AAMiEnH;AAAQ;AACvEmH;AACF;AACA;;;AAGE7M;AACA;AACF;AAEA;AAC4D8I;;AAGjCA;AAAM;AAGjC;AAAqDA;AAAM;;;AAGzD9I;AACA;AACF;;AAEA;AACA;;;AAMA;AAEE;AACA8L;;;AAI0B;AAAS;;AACnCjI;AAEA;AACE6B;AACA;AACF;AACA;AACE7B;AACA;AACF;AACA;AACA;;AAEEA;AACA;AACF;;AAGA;AAEA;AACE;;AAGA;AAIAA;;AAEA;AACA;AAEA;AAKA;AACEA;AACA;AACF;;AAEA;AACA;AACA;AACA;AACEkI;AACF;AACA;AACA;AAGA;AAIA;AACE;AACA;;;AAIElI;AACA;AACF;AAEA;;AAEEmI;;;;AAYA;AACEnI;AAGA;AACF;AAEA;AACA;AAKA;AACA;AAEA;AACEA;AACA;AACF;;AAIM;AACE;AACA;AACE;AACA;AACF;AACF;AACF;AAGJ;AACE;AAEM;AACE;AACA;AAGQ;AACA;AACF;AAER;;AAGN;AACEoI;;AAAwD;AAC1D;AACA;AACEC;;AAEA;AACF;AACA;AACEC;;AAAgE;;;AAIpE;AACEO;AACF;;AAQA;AACA;AAAmCJ;;AACjCzI;AACA;AACA;AACE;AACA;AACF;AACA;AACF;;AAIA;;;AAGE;AACAiJ;;AAAiDpH;AAAQ;AACzD;;AAEE;AACA;;AAA2C6G;AAAgB;AAC7D;AACAC;;;;AAIAzB;AACA0B;AACF;AAEA;;;;;AAOmBlK;;AACf;AACE;;AAEA;AACA;AAMA;AACF;AACA;;AAEEuH;AACF;AACA;AACA;;;AASIA;AACF;AAEF;;AACUjJ;AAAK;;AAEb;AACE;;AAEF;AACF;;AAEAkK;AACA0B;AACF;AACF;AAEA;AACE;AACA;AACA;AACAK;;AAAiDpH;AAAQ;AAC3D;AACA;;AAEIgH;AACA;AACA;AAEyBJ;;AAEzB;AACAQ;;AAAiDpH;AAAQ;AAC3D;;AAKF;AACA;AACE;AACF;AACF;AACF;AACF;AACF;;AAGF;;AC7aA;;AAAaiH;AAAK;AAEX;AACL;;AAEEI;AACA/M;AACF;;AAEE;AACF;;;AAEQgN;AAAM;;AAEZ;AACF;AACE;AACF;AACF;;ACbA;AACEhL;AACAC;AACAC;AACAC;AACE;AACA8K;AACE5K;AACAG;AACAP;;AAKFiL;AACE7K;AACAG;AACAP;;AAEF6G;AACEzG;AACAG;AACAP;;AAEFkL;AACE9K;AACAG;;AAKA4K;AACA9K;;AAEF+K;AACEhL;AACAG;AACAP;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEIc;AACEV;AACAG;AACAP;;AAEF2J;AACEvJ;AACAG;AACAP;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;;;AAGd;;AAEE1C;AACA8C;AACAC;AACF;;AAEE;AACF;AAEA;;;;;;;;AAUE2I;AACF;AACF;;ACvHO;;AAML;AACE;AACF;AACA;AAEA;AAIA;AAKA;;AAOA;AAEA;;AAOA;AAEA;;;;;;AAUF;;ACrCA;AAAQF;AAAI;AAEZ;;AAEI;;AAEA;AACF;AACA;AACF;AAEA;;;;AAUYrJ;AAAK;AACb;AACE;AACA;;AAEA;AACEiL;AACE/M;AACAgN;AACF;AACF;AACF;AACA;AACF;AACA;AACA;AACE;AAGIC;AAAoB;AAExB;AACExN;AACF;;AAEA;AACF;AACF;AAEO;;;AACUyN;AAA2B;;;;AAKxCC;AAOF;;AAGE1N;AACA;AACF;;;AAIF;;AAEA;AACA;AAEE;AACEA;AACF;AACA;AACE;AACA2N;AACAC;AACAC;;;AAGF7N;AACA8N;AAGA9N;AACA;;AAEIA;AACF;;AAIA+N;AACF;AACE/N;AACF;;;AAKAA;;AAEEA;AACwEwN;;AAE1E;AACExN;AACuFwN;;AAEzF;;;AAOA;AACExN;AACF;AACF;;ACnIO;;;;;;AAMLgO;AAQF;;AAOE;;;;;AAMIN;AACF;;AAGE;;AAEF;AACF;AACF;;ACrCA;AAAQ3L;AAAoB;AAE5B;AACEC;AACAC;AACAC;AAAc;AACdC;AACE;AACA;;;;AAOJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLO;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;AAE6BqL;;AAC7B;;AAIA;;AAII9N;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACA;AAEA;AAGA;AACEjD;AACA;AACF;AAEA;AACEgC;AACAiM;;;;;AAKF;AACF;;AC9GO;AAMLC;AACAA;AACAA;AACAA;AACF;;ACKA;AAAQC;AAAwB;AAEzB;AAILC;AACAC;AACA;AAEInO;;;AAOJ;;AAEEF;AACA;AACF;AAEA;AAKA;;AAEEA;AACA;AACF;AAEAA;AAEA;;AAKIiI;;AAEF;;AAGF;AACE;AACE/H;AAEAoO;AACErG;AACAjB;AACA/E;;AAEJ;AACA;;AAEA;AACF;;;AAIMO;AACF;AAEA;AACA;AACE+L;AACF;AACF;AACF;AAEA;;;AAGEvO;;AAIEA;AACAA;AAGF;AACF;;AAEEA;AACF;AACF;;AC9FA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACAiM;AACE/L;AACAJ;;AAEFoM;AACEhM;AACAJ;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;AAEA;AACA;AAEA;AACE3C;AACA;AACF;AAEA;AACE;AAGF;AAEA;AACF;;AC9EO;AACLkO;AACAA;AACAA;AACAA;AACF;;ACFO;;AAEHM;AACAxO;;AAEEA;AACAA;AAGF;AACF;AACEA;AACF;AACF;;ACTA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;;;AAGA6B;AACF;AACA;;AAEA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;AAEA;AACE3C;AACA;AACF;AAEAyO;AACF;;AC3CO;AAKL;;AAEE;AACEzO;AACF;;;;AAKI;AACA0O;AACF;AACA3O;AACE4O;AACF;;AAEE;AACE3O;AACF;;AAEF;AACAD;AACE;AACE;AACEC;AACF;AACA4O;AACF;AACE;AACE5O;AAGF;AACA2O;AACF;AACF;AACF;;;AAII1O;AACAC;AACAC;;AAEJ;AACF;;AAGE;AACEH;AACF;AAEA;;AAEIC;AACAC;;;AAGJ;;;;AAMID;AACAC;AACAC;;AAEJ;AACF;;AAGEF;AACAY;;;AAGA;;AAEJ;;AAEA;AACO;;;;;;;AAOD;AACA;AACF;AACA;AACE;AACE;AACA;AACF;AACA;AACE;AACA;AACA;AACF;;AAEI;;;AAGE;AACE;AACA;AACA;AACF;AACF;AACF;AACA;AACEgO;AACF;AACE;AACA;AACF;AACF;AACF;AACE;;;AAGEC;AACF;AACF;AACF;AAEA;AACF;;ACpIO;AAKL;AACE/O;AACF;AAEA;;AAEIC;AACA;AACF;AACAA;AACA;AACF;;AAGE;;AAGEA;AACF;;AAEA;AAEA;AACF;;;AAIE+O;AACAA;AACAA;AAGAA;AACAA;;AAEAA;AACAA;AACA;;AAGE/O;AACF;;AAEA;AACA;AACF;;;AAIEA;AACF;AACEgJ;AACF;AACF;;AC9DO;;AASL;AACF;;ACHA;AAAQjH;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACA;AACAsF;AACEpF;AACAJ;;AAEF+M;AACE3M;AACAG;AACAP;;AAEFgN;AACE5M;AACAJ;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AAGE8E;AACA6B;AACA1G;AACAoM;AACAC;;;;;AAMF;AACEjP;;;AAGAA;AACAA;;AAEF;AAEA;;AAIIE;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEAjD;AAIA;AACEA;AACA;AACF;AAEA;AAOF;;ACjIO;AAOL;AACA;;AAEA;;AAEA;;AAEA;;AAGA;AAEA;AAEAA;AACA;AACEA;AAGAA;AAGF;AACEA;;AAEEA;AAGF;AACAA;;AAEEA;AAGF;AACF;;;AAIE;AACA;AACA;AACA;AACA;;AAEA;;;AAIA;AACEA;AACF;;AAKA;AAEA;AACEA;AACAA;;AAEF;AACA;;;AAGE;;AAEEA;AACAA;;AAEF;AACA;AACF;AACAA;AACAA;;AAIIA;AACA;AACF;AAEFA;AACAA;;;;AASA;AACEA;AACAA;;AAEF;AACF;AACF;AAEA;AAME;;AACQ0F;AAAQ;;;AAIdA;;AAIE;AACA;AACA;AACA;;AAEF;AACA1C;;;;AACsBuG;AAAO;;;;AACN2F;;AACzB;AACE;AACExJ;AACF;AACEA;AACF;AACF;AACF;;ACxIA;AAAQ3D;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACAgN;AACE9M;AACAJ;;AAEFwF;AACEpF;AACAJ;;AAEFmN;AACE/M;AACAG;AACAP;;AAGFoN;AACEhN;AACAG;AACAP;;AAEFgN;AACE5M;AACAJ;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;AAGcC;;;;AAGd;AACE5C;;;;;AAKF;;;AAIA;AACA;AACA;;AAEA;AAGI+C;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;;;AAE4CwE;;AAE5C;;AAEEzH;AACAA;;AAEF;;AAGA;;AAKA;AAEA;AACEA;AACA;AACF;AAEA;AAOF;;AC9JO;AAOL;;AAEA;;AACQ0F;AAAQ;AAChB;AACA;AAEA;AACE1F;AACAA;AACAA;AACA;;AAEF;AACEA;AACAA;AACAA;AACA;;AAEF;;;;AAKE;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAIA;AACEA;AACAA;;AAEF;;;AAGEA;AACA;;AAEEA;AACAA;;AAEF;AACA;AACF;;;AAGEsP;AACA;AACF;AACA;;AAEEtP;AAGA;AACF;AACA;AACA;AACA;;AAEEA;;AAEAA;AACAA;AACF;;AAEEA;AAGAsP;AACAtP;AACA;AACF;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAsP;AACAtP;AACF;;;;;AAQA;AACEA;AACAA;;AAEF;AACF;AACF;;AC7GA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACAgN;AACE9M;AACAG;AACAP;;AAEFwF;AACEpF;AACAJ;;AAEF+M;AACE3M;AACAG;AACAP;;AAGFsH;AACElH;AACAJ;;AAEFsN;AACElN;AACAG;AACAP;;AAEFgN;AACE5M;AACAJ;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;AAGcC;;;;AAGd;AACE5C;;;;;AAKF;;;AAIA;AACA;AACA;;AAEA;AAGI+C;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;;AAGA;AACEkM;AACF;;AAGA;AACEH;AACF;AACA;AACEA;AACF;AAEA;;AAEEhP;AACAA;AACAA;;AAEF;;AAGA;;AAKA;AAEA;AACEA;AACA;AACF;;AAGF;;ACnKA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACAsF;AACEpF;AACAJ;;AAEFgN;AACE5M;AACAG;AACAP;AACF;AACA;;AAEF+B;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AAEA;AACA;;AAEA;AACE3C;;;;AAIAA;;AAEF;;AAGA;AACEwP;AACF;;;AAKExP;AACA;AACEwP;AACF;AACAA;AACA;AACExP;AACA;AACF;AACA;AAAkD2C;AAAW;AAC7D;AACF;;AAGE3C;AACA;AACE;AACAwP;AACF;AACA;AACExP;AACA;AACF;AACA;AAAmD2C;AAAW;AAC9D;AACF;;AAGA;;;;AAIE3C;AAGA;AACAwP;AACA;AACExP;AACA;AACF;AACA;AAAkD2C;AAAW;AAC7D;AACF;AAEA;AACE3C;AACA;AACF;;AAEA;AACAyP;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEMxK;;AAEAyK;AACF;AAEJ;;AChJA;AAAQ3N;AAAoB;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACEC;AACAC;AAEAC;AACAC;AACE;AACAgN;AACE9M;AACAJ;;AAEFwF;AACEpF;AACAJ;;AAEFmN;AACE/M;AACAG;AACAP;;AAGFoN;AACEhN;AACAG;AACAP;;AAEFgN;AACE5M;AACAJ;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;AAGcC;;;;AAGd;AACE5C;;;;;AAKF;;;AAIA;AACA;AACA;;AAEA;AAGI+C;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;;;AAE4CwE;;AAE5C;;AAEEzH;AACAA;;AAEF;;AAGA;;AAKA;AAEA;AACEA;AACA;AACF;AAEA;AAOF;;AChKA;AACEgC;AACAC;AACAC;AACAC;;;AA+BK;;;AAGLO;AACF;AAEA;AAGIC;AAAmC;AAErC;AAEI2F;AACAqH;AACAC;AACAC;AACAC;AACF;;AAGEC;AACEC;;AAEE9N;;AAEF;;;;;AAKF+F;AACF;AAEJ;;AC5EA,iBAAA;AAEA;AAAQyD;AAAI;AAEL;AACL;AACA;AACA;AACF;;ACHA;;AAA6BA;AAAI;AAEjC;AACE1J;;AAEAE;AACAC;;;AAGA6B;AACF;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;AAGnCqC;;;;AAIArC;AACF;AAEA;AACE3C;AACA;AACF;;AAGF;;AC7CA,iBAAA;AAEA;AAAQiQ;AAAI;AAEL;AACL;AACA;AACA;AACF;;ACHA;;AAA6BA;AAAI;AAEjC;AACEjO;;AAEAE;AACAC;;;AAGA6B;AACF;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;AAGnCqC;;;;AAIArC;AACF;AAEA;AACE3C;AACA;AACF;;AAGF;;ACvCA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF6B;AACF;AACA;;AAEA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AAEd;AACE5C;AACA;AACF;AAEA;;AAEEA;AAEIC;AACAC;AACAC;AACF;AAEJ;AAEA;;;AAKE;AACF;AAEA;AACF;;ACnEA;;;;;;AAAyC+P;AAAa;AAEtD;AACE;AACF;AAEA;AACE;AACF;AAEO;;ACdA;;;;;AAKH/D;AACF;AACA;AAGqBjI;;;AAIGA;;;AAICA;;;AAKfA;;AAAyC;AAGvC;;AACd;;ACxBA;;;;;;;;AAQEgM;AACF;AAEA;AACE;;AAGS7N;AAAkB8N;;AAC7B;;AAEA;AACA;AACA;AACE;;AAES9N;AAAW8N;;AACtB;;AAEA;AACA;AACA;AACE;;AAGS9N;AAAY8N;;AACvB;AAEA;AACE;;AAES9N;AAAW8N;;AACtB;;AAEA;AACA;AACA;AACE;;AAGS9N;AAAkB8N;;AAC7B;;AAEA;AACA;AACA;AACE;;AAGS9N;AAAoB8N;;AAC/B;AAMO;;ACxDP;;;;;;;AAAmDD;AAAa;AAEhE;AACE;AACA;AACA;AACF;AAEA;AACE;AACA;AACA;AACA;;AAIA;AACF;AAEA;AACE;AACA;AACE;AACA;AACA;AACA;AACA;;AAIJ;AAEA;AACE;AACA;AACA;AACF;AAEA;AACE;AACA;AACE;AACA;AACA;AACA;AACA;;AAIJ;AAEO;;ACzDP;;;;;;AAAyCA;AAAa;AAEtD;;AAEI;AACF;AACA;;AAEEE;;AAEF;AACE;AACF;AACA;AACA;;;AAAwBC;;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEEC;AACF;AACF;AACA;AACF;AAEA;;AAEI;AACF;AACA;AACA;AACA;;AAEA;AACF;AAEA;;;AAGI/G;;AAGI;;;;;AAMR;AAEA;;AAEI;AACA;AACA;;AAGI;;;;AAKN;AACF;AAEA;;AAEA;AAEA;AAKE;AACA;;AAEE;AACE;AACF;AACF;;;AAGEA;AAGI;AACA;;;AAIE;;;;;AAOV;AAEA;;;AAGI;AACAA;;AAMM;;;;;AAOV;AAEA;;AAKI;AACE;AACA;AACA;;AAMM;;AAEF;AAEW;;AAGnB;AACF;AAEA;;AAKI;AACA;AACA;AACA;AACA;;AAGI;;AAEF;;AAGJ;AACF;AAUO;;ACrLA;;ACQP;;;;;;;;AAQE2G;AACF;AAEA;AASA;AAIE;AAIF;AAEA;;AAKA;AAEA;AAIE;AACF;AAEA;AAKE;AACA;AACE;;AAEE;AACA;;AAEI;AACE;AACAC;;;AAGA;AACF;AACF;AACF;AACE;AACAzD;AAGQ;AACE;AACAyD;AACF;AACF;AACE;AAAmB;AAE7B;;AAEA;;;AAGA;AACF;;AAC2B;AAAe;AAC1C;AACA;AACF;AACA;AAIE;AACF;AACA;AACA;AACA;;;;;;AAME;AACEI;;AAEF;AACF;AACEA;AACAC;AACF;;AAEE;AACED;AACAC;AACF;AACF;AACA;;AAEA;AACA;AACED;AACAC;AACF;AACA;;;AAGEA;AACF;AACAC;AAEqB;;;AAKvB;AAEA;;AAEA;AAEA;;AAKA;AAEA;;AAEA;AAOO;;ACzHP;;;AAAmBP;AAAa;AAEhC;AAEO;;;;;;AAUHrE;AACF;;;;;;AAMEvB;AACEoG;AACAC;AACAC;AACAC;AACAC;AACF;AACF;AAAM5M;;;;AAEN;AACA;AACA;AACA;AAGA;AAGE;AACA6M;;AAIA/Q;AAMF;;;AAIEgR;AACF;;AAKA;AAEAtL;AAEA;AACA;AAEA;AAAuD;;AAEnD;AACA;AACAuL;;AAKJ;AACA;AAAyC;AAAQ;;AACvChJ;AAAsBiJ;AAAsBlL;AAAQ;AAC5D;AACA;AACA;AACA;AAAa;;AACX;AAGA;AACEmL;AACF;AACA;AAGA;;AAEE;AACA;AACA;AACA;AACE;AACA;AAEE;AACA;AACAF;AAGFG;AACAC;AACA/G;;AAEEA;AACF;AACF;AACA6G;AACF;AACF;AACA;AACE;AACA;AACA;AACA;AACA;AAKA;AAE0DJ;AAAY;AACtE;AACA;;AAAyD1O;AAAK;AAC5D;;;AAME;AACA;AACA;;AAEA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACAiP;AACF;AACE;AAGA;AACE;AAGI;AACA;AACA;AACA;AACA;AACAL;;AAKF;AACEK;AACF;AACF;AACF;AACEA;AACF;AACF;;AAEEnB;AACA;AACA7F;AACF;AACF;AACF;AACF;AACF;AAEA;AACE;;AAEE;;;;AAOI5E;AACF;AAEF;AAeE;AACE4E;AACF;AACF;AACF;AACF;AAEA;;AAIE;;AAAwBjI;;AACtBkP;AACF;AACA;AACF;AAEA;AACF;;AC1QA;AAAQC;AAAoC;AAQrC;;AAKHzE;;AAEArH;AACF;AACExB;;;AAGF;;;AAGA;;;;AAGyCwB;AAAQ;AAC/C;;;AAKA;;;AAGA1F;AAMAA;AACF;AACA;;AAEA;;AAEA;AACF;;AChDA;;AAMA;AAEO;AAKL;AACE+M;;AAEA0E;AACF;;AAEE;AACF;AACA;;AACQ/L;AAAQ;AAEhBA;;;;;AAMEA;AACF;AAEA;AACA;;AAGA;;AACwCqH;;AAA2BrH;AAAQ;AAC3E;;AAIA;;;AAKE;;AAEE1F;AAGF;AACF;AACEA;AACF;AACF;;ACxDA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACAuP;AACErP;AACAG;AACAP;;AAEFwP;AACEpP;AACAG;AACAP;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AAEA;;AAEA;AAEA;AACE3C;AACA;AACF;;AAOF;;ACpEO;AAGL;AACA;AACE;AACF;AACA;;AAGF;;ACLO;AAIL;AACED;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGA;AAEA;AACE;AAAiB;AACf;AACA;AACA;AACA;;;;AAIA;AACE2R;AACAC;AACAC;AACF;AACA7R;;AAIAA;;AAMA;;AAIA;;AAIA;AACF;AACA;AAAS;;AAIP;AACA;AACEA;AAGF;AACF;AACF;AACF;;ACxEO;AAGL;AAEA;AACF;;ACEA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF6B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;AAEA;AAEA;AAGIE;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;AAGF;;AClFO;AAGL;AACA;AACE;AACF;AACA;;AAMF;;ACVO;AAIL;AACED;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AACAA;AACAA;AACAA;AACAA;AACA;;;;AAOAA;AACAA;AACF;;ACnCO;AAIL;AAEA;AACF;;ACGA;AAAQ+B;AAAoB;;AAE5B;AACA;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA4B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;AAC7C;AAEA;AAOA;AAEA;AAGIZ;;AAEA5C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACF;;ACtHO;AAGL;AACA;AACE;AACF;AACA;;AAMF;;ACVO;AAIL;AACED;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AACAA;;AAIAA;AACAA;AAGAA;AACA;;;;AASAA;AACAA;AACF;;AC1CO;AAIL;AAEA;AACF;;ACGA;AAAQ+B;AAAoB;;AAE5B;AACA;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA4B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;AAC7C;AAEA;AAOA;AAEA;AAGIZ;;AAEA5C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACF;;ACpHA;AAEO;;AAEL;AACA;AACA;AACA;AACAkC;AACA;AAA8BS;AAAW;AACvC;AAEImP;AACAC;AACF;;;AAIEC;AAAoB;;;AAGtB;AAEJ;AACF;;ACxBO;AAGL;AACA;AACE;AACF;AACA;;AAGF;;ACRO;AAIL;AACEjS;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGEA;AACAA;;AAEAA;AACA;AACF;;AAGAA;AACF;;AC9BO;AAGL;AAEA;AACF;;ACEA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;;;AAGF6B;AACF;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAIA;AAEA;AAEA;AAGIG;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;AAGF;;AC7EA;AAEO;;AAEL;AACA;AACA;AACA;AACAkC;AACA;AAA8BS;AAAW;AACvC;AAEI6F;AACAyJ;AACA3L;AACF;;;AAIE0L;AAAoB;;;AAGtB;AAEJ;AACF;;ACuBO;AAGLhS;;AAMF;;ACvDO;AAKL;AACED;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;;AAIImN;AACA+E;AACEjM;AACAkM;;AAEAC;;AAEFC;;;;;;AAMED;AACF;;;AAIFpS;AACAA;AACA;;AAIA;AACEA;AAGF;AACAA;AACA;AACEA;AAGF;AACEA;AAGAA;AACAA;AAGF;AACAA;AACA;AACE;AACAA;AAGAA;AACAA;AACAA;AACAA;AAGF;AACEA;AACAA;AACAA;AAGF;AACAA;AACAA;AACAA;AACAA;AACAA;;;;;;;AAOAA;AACAA;AACAA;;AAEEA;AACAA;AACAsS;AACEtS;AACF;AACF;AACEA;AACF;AACAA;AACAA;AACAA;;AAEE;AACEA;AACF;AACEA;AACF;AACAA;AACAA;AAGF;AACEA;AACF;AACAA;AACA;AACEA;AACAA;AACAA;AAGAA;AACAA;AACAA;AACAA;AAGAA;AAGAA;;;;;;;AAOAA;AACAA;AACAA;AACAA;AAGAA;;;;;;;AAOAA;AACAA;AACAA;;AAEEA;AAGAA;AACAmS;AACEnS;AACF;AACF;AACEA;AAGF;AACAA;AACAA;AACAA;;AAEEA;AACAA;;AASF;AACEA;AAGF;AACAA;AACF;AACA;AACF;AAEAA;AAGAA;AACAA;AACF;;AC9MO;AAIL;AAEA;AACF;;ACZA;AACA;AACA;AACA;AACO;;;;AAOHuS;;AAEA;AACE;;AAEEA;AACA;;AAEA;AACAC;AACF;;AAEA;AACF;AACA;AACED;AACF;AACF;AACE;AACAnC;AAEA;AACE;AACA;AACE;AACAmC;AACA;;AAEAC;AACF;AACEA;AACF;AACF;AAEA;AACED;AACF;AACF;;;AAEgBA;;AAClB;;ACrCA;AAAQxQ;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;;;AAGF6B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;AAIA;;;AAEe2P;AAAM;AAErB;AAGIxP;AACA7C;AACA8C;AACAC;AACF;AAEEF;AACA7C;AACA8C;;AAEF;AAEEF;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;AAGF;;ACtHO;AAGLA;AAIA;AACA;AACE;AACF;AACA;;AAKMiG;AACF;AACEwM;AAAiCtF;AAAK;;AAK5C;AACE;AACF;;AAEA;;AAEElN;;;AAGJ;;AC9BO;AAKL;AACEF;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAEA;;AAEA;AACA8B;;AAEE2G;AACF;AACA;AACE;AACE;AACF;;AAEE;AACF;AACA;AACF;;;AAKF;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AAEI;AACF;AAEAzI;AACAA;;;AASA;AAEA8B;AACE9B;;AAEF;AACAA;AACF;AAEA;AAIE;AACE;AACA2N;AACAC;AACAC;AACA6E;;;AAGF;AAEA;AAUF;AAEA;AACE;AACA;AACE;AACF;;AAEE;AACF;;AAEE;AACF;AACA;AACF;AAEA;AAIE;;AAEA;;;;;AAWA;AACA;AACA;AAEA;;AAaA;AACA;AAsBF;;AC7KO;;AAELF;AAIF;AACE;AAEAG;AAKF;;ACPA;AAAQ5Q;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;;;AAGF6B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEO;;;AAGLW;AACEiO;;AAEE1Q;AACA+C;AACF;;AAEFvC;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;;;AAIe2P;AAAM;AAErB;AAGIxP;AACA7C;AAEA8C;AACAC;AACF;AAEEF;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;AAEEwS;AACF;AACF;;ACxHA;AAEO;;AAELtQ;AACA;AAA8BS;AAAW;AACvC;AAEIyP;AACAS;AACF;AAEE9C;AACE+C;;AAEE5Q;;AAEF;;;;;;AAMJ;AAEJ;AACF;;AC3BO;;AAIH;;AAEAqK;AACF;AACA;;AAEE;;AAEA;AACE;AACAxM;AACF;AACF;AACA;AACF;;ACfA;;AAA6B2L;AAAI;AAEjC;AACE1J;;AAEAE;;;AAGF;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLQ;AACF;AAEA;AAGIC;AAAmC;;AAGnCqC;;;;AAIArC;AACF;AAEA;AACE3C;AACA;AACF;;AAGF;;AC5CO;;AAIH;;AAEAuM;AACF;AACA;;AAEE;;AAEA;AACE;AACAxM;AACF;AACF;AACA;AACF;;ACfA;;AAA6BkQ;AAAI;AAEjC;AACEjO;;AAEAE;;;AAGF;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLQ;AACF;AAEA;AAGIC;AAAmC;;AAGnCqC;;;;AAIArC;AACF;AAEA;AACE3C;AACA;AACF;;AAGF;;AC1CA;AACEgC;AACAC;AACAC;AACAC;AACE;;;;AAIJ;AACA;AACA;AACA;AAEO;;;AAGLO;AACF;AAEA;AAGIC;AAAmC;AAErCoQ;;;;AAIEpQ;AACF;AAEA3C;;AAKF;;ACrCA;AACEgC;AACAC;AACAC;AACAC;AACE;;;;AAIJ;AACA;AACA;AACA;AAEO;;;AAGLO;AACF;AAEA;AAGIC;AAAmC;AAErCoQ;;;;AAIEpQ;AACF;AAEA3C;;AAKF;;ACtCA;AAEO;;AAELkC;AAAc;AACd;AAA8BS;AAAW;AACvC;AAEIqQ;AACAC;AACF;;;;;AAMA;AAEJ;AACF;;ACnBO;;;;;;AAMLC;AAQF;AACE;AACA;AACE;AACF;AACA;;AAIIjL;;;;AAIAiL;;AAIN;;AC7BO;AAKL;AACEnT;AACF;;AAEEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AACQgI;;AACRhI;AAGF;;ACvBO;;;;;;AAOHkT;AAQF;AAGA;;;;;;AAMEA;AACF;AACAC;AACF;;ACjBA;AAAQpR;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAuF;AACErF;AACAC;AACAE;AACAP;;AAEFmR;AACE/Q;AACAC;AACAE;AACAP;;AAEF8B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFoR;AACEhR;AACAC;AACAE;AACAP;;AAEFY;AACER;AACAC;AACAE;AACAP;;AAEFiR;AACE7Q;AACAC;AACAE;AACAP;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAOEe;AACAb;;;;AAIF;AAOA;AAEA;AAEA;AAGIC;;AAEA5C;AAGA8C;AACAC;AACF;;AAGE/C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;AAGI6C;;;;;;AAQN;;AC1KO;AAIL;AACA;AACE;AACF;AACA;AAEA;AAIF;;ACZO;AAKL;AACE9C;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AACF;;ACtBO;;AAOL;AACF;;ACEA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA4B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;AAC7C;AAEA;;AAUA;AAEA;AAGIZ;;AAEA5C;AAGA8C;AACAC;AACF;;AAGE/C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACF;;ACrHO;;;;;AAKLsT;AAOF;AACE;AACA;AACE;AACF;AACA;;;;AAMI/I;;;AAKN;;AClCA;AAYO;AAIL;AACExK;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEA;AACE4I;AACIC;AAAaZ;AAA2B;AACxCY;AAAeZ;AAA6B;AAC5CY;AAAqBZ;AAAmC;AACxDY;AAAyBZ;AAAuC;AAChEY;AAAmBZ;;;AAIzBjI;AACF;;ACnCO;;;;;;AAMLsT;AAQF;AACE;;;;;AAKEA;AACF;AAEA;AACF;;ACdA;AAAQvR;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAmR;AACEjR;AACAC;AACAE;AACAP;;AAEFsR;AACElR;AACAG;AACAP;;AAEF8B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFkB;AACEd;AACAC;AACAE;AACAP;;AAEFqB;AACEjB;AACAC;AACAE;AACAP;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;AAEcC;;AACd;;;;AAE6Bc;;AAE7B;AAOA;AAEA;AAGIZ;;AAEA5C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACEuT;;;;;;AAMF;AACF;;AClJO;;;;;;AAMLL;AAQF;AACE;AACA;AACE;AACF;AACA;;;AAKIjL;;;;AAIAiL;;AAIN;;AC9BO;AAKL;AACEnT;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AACF;;ACtBO;;;;;;AAOHkT;AAQF;AAGA;;;;;;AAMEA;AACF;AAEA;AACF;;AClBA;AAAQnR;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAuF;AACErF;AACAC;AACAE;AACAP;;AAEFmR;AACE/Q;AACAC;AACAE;AACAP;;AAEF8B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFY;AACER;AACAC;AACAE;AACAP;;AAEFoR;AACEhR;AACAC;AACAE;AACAP;;AAEFiR;AACE7Q;AACAC;AACAE;AACAP;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;;;AAG7C;AAOA;AACA;AAEA;AAEA;AAGIZ;;AAEA5C;AAGA8C;AACAC;AACF;;AAGE/C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;AAGI6C;;;;;;AAQN;;ACpKO;AAIL;AACA;AACE;AACF;AACA;AAEA;AAIF;;ACpBA;AAYO;AAIL;AACE9C;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEA;AACE4I;AACIC;AAAaZ;AAA2B;AACxCY;AAAeZ;AAA6B;AAC5CY;AAAqBZ;AAAmC;AACxDY;AAAyBZ;AAAuC;AAChEY;AAAmBZ;AAAiC;AACpDY;AAAmBZ;AAAiC;AACpDY;AAAqBZ;;;AAI3BjI;AACF;;ACrCO;;AAOL;AACF;;ACEA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA4B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFY;AACEZ;AACAO;AACAH;AACF;;AAEF2B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAOEe;AACAb;;AAEF;AAEA;AAOA;AAEA;AAEA;AAGIC;;AAEA5C;AAGA8C;AACAC;AACF;;AAGE/C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;AAGF;;AC5IA;AAEO;;AAEL;AAA8B2C;AAAW;AACvC;AAEIqQ;AACAC;AACAzK;AACAgL;AACAC;AACF;;;;;AAMA;AAEJ;AACF;;AC5BO;AACL;AACA;AACA;AACEvT;AACAoO;AAEIrG;AACAjB;AACA/E;AACF;AAEEgG;AACAjB;AACA/E;;AAIN;AACA;;AAEA;AACF;;ACPA;AAAQF;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAiD;AACE/C;AACAC;AACAE;AACAP;;AAEFsF;AACElF;AACAC;AACAE;AACAP;;AAEFuF;AACEnF;AACAC;AACAE;AACAP;;AAEFsD;AACElD;AACAC;AACAE;AACAP;;AAEFwF;AACEpF;AACAJ;;AAEFyF;AACErF;AACAG;AACAP;;AAGF8B;AACE1B;AACAG;AACAP;;AAGF2F;AACEvF;AACAG;AACAP;;AAGF4F;AACExF;AACAC;AACAL;;AAEFyB;AACErB;AACAJ;;AAGF6F;AACEzF;AACAG;AACAP;;AAGFM;AACEF;AACAC;AACAE;AACAP;;AAEF8F;AACE1F;AACAG;AACAP;;AAGFmF;AACE/E;AACAC;AACAE;AACAP;AAEF;;AAEF;AACA+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAOE8E;;AAEAiM;AACA3P;;;AAGAL;;;;;;AAMA0D;;AAoBF;AAEA;;AAOE;AACAuM;AACF;AAEA;AAEA;;AAKA;AACA;AACA;AACA;;AAEA;AACA;;;AAIE;;AAEAC;AACF;;AAEA;AACA;AACA;AACA;;AAEI;AACA;AACE7K;AACF;AACA6K;AACF;AACF;AAEA;AACE5T;AAGAA;AACAA;AAGAA;AACF;AAEA;;AAII+C;AACA7C;AAGA8C;AACAC;AAIF;AAEEF;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;;AAEA;AACA;AACEjD;AACA;AACF;AAEA;AACEqH;;;;;AAKAK;AACA3D;;;AAGA6D;AACAC;AACAC;AACAjF;;;;AAIF;AACF;;ACrVO;AAIL;AACA;AACE;AACF;AACA;AAEA;AAIF;;ACZO;AAIL;AACE9C;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEAA;AACF;;ACrBO;;AAOL;AACF;;ACEA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA4B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;AAC7C;AAEA;;AASA;AAEA;;AAIIX;AACA7C;AAGA8C;AACAC;AAIF;;AAGE/C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACF;;ACpHO;;;AAGL+I;AAKF;AACE/I;AACAA;AACAA;AAEA;AAIF;;ACXA;AAGO;;;AAKH2H;AAKF;AAEA;AACE5H;AACF;AAEA;;AAEIC;AACA;AACF;AACAA;AACA;AACF;AAEA;AACA;;AAIA;AACA;AACA;AACA;AACE;AACA;AACF;;AAGE;AACA;AACF;;AAEA;AACA;;AAEAA;;AAGIiJ;AACAlC;AACAmC;AACAC;AACF;AAEFnJ;AAGAA;AACF;AAEA;AAKE;AAEA;AACEA;;AAEE;AACEA;AACAA;AACF;AACEA;AACF;AACAA;AACF;AACF;AACE;AACAA;AACAA;AACAA;AACF;AACF;AAEA;AAGEA;AACAA;AACAA;AACAA;AAGAA;AACAA;;AAIAA;AACAA;AACAA;;AAEAA;;AAEEa;AACEb;AACF;;AAEEA;AACF;AACF;AACAA;;AAEEa;AACEb;AACF;;AAEEA;AACF;AACF;AACAA;;AAEEa;AACEb;AACF;;AAEEA;AACF;AACF;AACAA;;AAEEa;AACEb;AACF;;AAEEA;AACF;AACF;AACAA;;AAEEa;AACEb;AACF;;AAEEA;AACF;AACF;AACAA;;AAEAA;AACAA;AAGAA;AACA;AACE;AACE;AACF;AACA;;;AAKA;AACF;AACAA;;AAEAA;AACAA;AACAA;AACA;AACE;AACE;AACF;AACA;;;AAKA;AACF;AACAA;AACF;;ACpMO;;;;;;AAML2H;AAQF;AACE;;;AAGEoB;AACF;;;;AAKEpB;AACF;AACF;;AChBA;AAAQ5F;AAAoB;AAE5B;AAGA;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA4E;AACE1E;AACAG;AACAP;;AAGFG;AACEC;AACAC;AACAE;AACAP;;AAGF8B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;;;AASEe;;AAEF;AAEA;AAOA;AACA;AACA;;AAEA;AACA;;AAEA;AAEA;AAEA;AAGIX;AACA7C;AAEA8C;AACAC;AAMF;;AAGEH;AACA5C;AAGA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACE6T;AACAC;AACA/M;;;AAGA3E;AACF;AACF;;AC9KO;;;;;;;;AAQLkR;AAUF;AACE;AACA;AACE;AACF;AACA;;AAII;AAAelO;;AACf;AAAa7C;;;;AAGbgI;AACAjH;AACAyQ;;AAIN;;AC3CA;AAYO;AAIL;AACEhU;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;AAEA;AACE4I;AACIC;AAAaZ;AAA2B;AACxCY;AAAqBZ;AAAiC;AACtDY;AAAeZ;AAA6B;AAC5CY;AAAiBZ;AAA+B;AAChDY;AAAqBZ;;;;;;;AAQvB+L;AAEMC;AACAC;AACAC;;;;;AAMV;;AAGF;;ACnDO;;;;;;;;;AASLb;AAWF;AACE;;;;;;;;AAQEA;AACF;AAEA;AACF;;ACpBA;AAAQvR;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAiD;AACE/C;AACAJ;;AAEFsR;AACElR;AACAC;AACAE;AACAP;;AAEFmS;AACE/R;AACAC;AACAE;AACAP;;AAEF8B;AACE1B;AACAG;AACAP;;AAGFqB;AACEjB;AACAC;AACAE;AACAP;;AAEFkB;AACEd;AACAC;AACAE;AACAP;;AAEFyB;AACErB;AACAJ;;AAGFM;AACEF;AACAJ;;AAEFqR;AACEjR;AACAC;AACAE;AACAP;;AAGFoS;AACEhS;AACAC;AACAE;AACAP;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;;AAQEe;AACAnB;;AAEF;AAEA;AAOA;AAEA;;AAIIQ;AACA7C;AAGA8C;AACAC;AAIF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;;;;;;;;;AAUA;AACF;;ACtLO;AAIL;AACA;AACE;AACF;AACA;AAEA;AAIF;;ACZO;AAKL;AACED;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGEA;AACF;AACAA;AACA;AACE;AAUE;AACF;;AAEF;;AAEEA;AAGF;;AAIA;AACF;;ACjDO;;AAOL;AACF;;ACKA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA4B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;AAC7C;AAEA;;AASA;AAEA;;AAIIX;AACA7C;AAGA8C;AACAC;AAIF;;AAGE/C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;AACF;;ACnHA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AAEAC;AACAC;AACE;AACA;AACAmF;AACEjF;AACAG;AACAP;;AAEF8B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFoE;AACEhE;AACAG;AACAP;;AAEF4E;AACExE;AACAG;AACAP;;AAEF8P;AACE1P;AACAG;AACAP;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;AAGE2E;;;;AAIAjB;;AAEF;;;;AAE6B3C;;AAE7B;;;AAWA;AAEA;;AAIIX;AACA7C;AAGA8C;AACAC;AAIF;;AAGE/C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;AAEEmH;;;AAGAjE;AACAoE;;AAEAjB;AAMF;AACF;;ACrLO;AAIL;AAKA;AACE;AACF;AAEA;;AAEA;AACA;;AAEA;;AAEI;AACF;AACEpG;;;AAGA;AACF;AACF;AAEA;;AACWA;AAAUY;;AACrB;;AAGEZ;AACAC;AACAC;;AAGJ;;ACnCO;AAOL;AACEJ;AACF;AAEA;;AAEIC;AACA;AACF;AACAA;AACA;AACF;AAEA;AAIE;AAEA;AACEA;;;AAGEA;;;AAGAA;AACAA;AACAA;AAEIC;AACAC;AACAC;AACF;AAEJ;AACA;AACF;AAEAH;AACA;AACF;;AAGE;;;;;;AAQEoS;;AAEJ;AAEA;AAQA;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AAEE;;;AAGIpS;;;AAGAA;AACAA;AACF;AACF;AACEA;AACF;AACF;;ACtGO;;;AASP;;ACTO;AAKL;AACA;AACE;AACF;AACA;AAEAA;;AAEA;;AAKF;;ACJA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACAmS;AACEjS;AACAG;AACAP;;AAGF8B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;AAEF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAOEe;AACA4Q;;AAEF;AAEA;;;AAWA;AAEA;;AAIIvR;AACA7C;AAGA8C;AACAC;AAIF;;AAGE/C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;AAGE;AACF;;AAEA;AACF;;ACxJA;AAEO;;AAEL;AAA8B2C;AAAW;AACvC;AAEIqQ;AACAxK;AACAgL;AACAe;AACAC;AACAzM;AACAkL;AACF;AAEElD;AACE;AACAuE;;AAEEpS;AACA+C;AACF;;;;;;AAMJ;AAEJ;AACF;;ACrCO;;;;;AAKL9B;AAOF;AACE;;AAYF;;AClBA,iBAAA;AAEO;AAIL;AACEpD;AACF;;AAGEC;AACA;AACF;AACA;AACEA;AACA;AACF;;AAGEA;AACA;AACF;;AAGA;;AAEA;AACA;AACA;AACA;AACE;AACF;AACA;AACA;AACA;AACA;AACAM;AAEA;AACA;AACEmU;AACAC;AACAC;AACAC;AACA7Q;AACAxD;AACAoB;AACAkT;AAAe;AACfC;AACEzS;AACAqS;;AAEFK;AACA;AACA;AACAC;AACAC;AACF;;AAEA;AACA;AACA;AACEC;AACAL;AACAlT;AACAmT;AACEzS;AACAqS;;AAEFnU;AACA4U;AAEAhU;AACEuT;AACF;AACF;;AAGEhL;AAQA7I;AACF;;AAEA;;AAGAP;AACAA;;AAEA;AACA8U;AACE;AACA;AACE;AACA;AACE;;;AAWF;AACF;AACF;;AAIA9U;AACE;;AAEA;AACAN;AACF;AACF;AAEA;AACE;;;AAGE;AAEA;;AAEA;;AASF;AACF;AAEA;AACE;AACA;;AAGEqV;AACAlU;AACF;AAEA;AACA;AACE;AACA;;;AAGA;AACF;;AAEE;AACF;AACE;AACF;AACF;;AChLO;;;;;;AAMLgC;AAQF;AACE;;;;;AAKEA;AACF;AAEA;AACF;;ACdA;AAAQpB;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACA;AACA4B;AACE1B;AACAG;AACAP;;AAGFyB;AACErB;AACAJ;;AAGFkB;AACEd;AACAC;AACAE;AACAP;;AAEFqB;AACEjB;AACAC;AACAE;AACAP;;AAEFsR;AACElR;AACAC;AACAE;AACAP;;AAEFqT;AACEjT;AACAC;AACAE;AACAP;;AAEFqC;AACEjC;AACAC;AACAE;AACAP;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;;;;;AAMnCA;AACF;;;;;;AAE6Ce;;AAC7C;AAEA;AAOA;AAEA;AAGIZ;;AAEA5C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AAEA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;AAEA;;;;;;;AAOA;AACF;;AClLO;;AAKD;AACE;AACF;AACA;AACA;;AAGN;AACA;AACA;AAEI;AAEJ;;AClBO;;;;AASHA;AAGA;AACF;AACA;AACF;;ACVO;AACL;;;AACoBuV;AAAU;;;AAM5B;AAEJ;;AAEA;;AAEA;AACA;AAEE;AACF;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAGMrV;AACAsC;AACF;AAEA;;;AACoB+S;AAAU;;AAE5B;;AAEA;AACA;;AAEA;;;AAKF;AACF;AACF;;ACtDO;AACL;AACE;AACEvV;AACAA;AACA;AACF;;AAOA;;AAGE;AACEA;AACA;AACF;AACA;AACA;AACAA;AAGF;AACF;AACF;;ACdA;AAAQ+B;AAAoB;AAE5B;AACEC;AACAC;AACAC;AACAC;AACE;AACAqT;AACEnT;AACAG;AACAP;;AAEFwT;AACEpT;AACAG;AACAP;AACF;;AAEF+B;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEO;;;AAGLtB;AACF;AAEA;AAGIC;AAAmC;AAErC;AACA;;AAEE;AACF;;;;;AAMEA;AACF;;;;;AAE+BC;;;;AAG/B;AAGIG;AACA7C;AACA8C;AACAC;AACF;AAEEH;AACAC;AACA7C;AACA8C;AACAC;AACF;;AAGA;AACF;AAEA;AACEjD;AACA;AACF;;AAEA;;;AACoBuV;AAAU;AAC9B;;;AAGE;;;AAGA;AACF;AACE;;AAEA;AACA;;AAEA;AACF;;AAEEvV;AACF;AACF;;ACjFA;AAEA;AAAQ0V;AAAoB;;AAE5B;AACA;AACE;AACEzN;AACA;AACAjC;;AAEF;;AAGE;AAEI2P;AACAC;AACAxN;AACAyN;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAnF;AACA;AACA;AACAnJ;AACAuO;AACAvQ;AACA;AACAwQ;AACAtK;AACAuK;AACA;AACA;AACAhQ;AACF;;;AAIEyB;AACAyH;AAAcnJ;AAAoC;AACpD;;;AAIF;AACA;;;AAGEkQ;;AAEF;AACEA;;;AAGF;AACEA;AACAC;AACAC;AACF;AACEF;AACF;AACAzW;;AAEA;AACE6D;AACF;;AAEF;AACF","debugId":"a4b81e94-18e0-4900-a5c2-a2b66c92bf6c"}