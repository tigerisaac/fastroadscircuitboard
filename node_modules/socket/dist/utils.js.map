{"version":3,"file":"utils.js","sources":["../src/utils/glob.mts","../src/utils/fs.mts","../src/utils/config.mts","../src/utils/errors.mts","../src/utils/fail-msg-with-badge.mts","../src/utils/sdk.mts","../src/utils/api.mts","../src/utils/markdown.mts","../src/utils/serialize-result-json.mts","../src/flags.mts","../src/utils/check-input.mts","../src/utils/get-output-kind.mts","../src/utils/output-formatting.mts","../src/utils/meow-with-subcommands.mts","../src/commands/scan/suggest-org-slug.mts","../src/utils/determine-org-slug.mts","../src/utils/path-resolve.mts","../src/utils/npm-paths.mts","../src/utils/cmd.mts","../src/utils/socket-url.mts","../src/utils/map-to-object.mts","../src/utils/walk-nested-map.mts","../src/utils/alert/artifact.mts","../src/utils/objects.mts","../src/utils/alert/fix.mts","../src/utils/strings.mts","../src/utils/alert/severity.mts","../src/utils/color-or-markdown.mts","../src/utils/translations.mts","../src/utils/spec.mts","../src/utils/socket-package-alert.mts","../src/utils/semver.mts","../src/utils/pnpm.mts","../src/utils/alerts-map.mts","../src/shadow/npm/install.mts","../src/utils/agent.mts","../src/utils/package-environment.mts"],"sourcesContent":["import { promises as fs } from 'node:fs'\nimport path from 'node:path'\n\nimport ignore from 'ignore'\nimport micromatch from 'micromatch'\nimport { glob as tinyGlob } from 'tinyglobby'\nimport { parse as yamlParse } from 'yaml'\n\nimport { readPackageJson } from '@socketsecurity/registry/lib/packages'\nimport { isNonEmptyString } from '@socketsecurity/registry/lib/strings'\n\nimport constants from '../constants.mts'\nimport { safeReadFile } from './fs.mts'\n\nimport type { Agent } from './package-environment.mts'\nimport type { SocketYml } from '@socketsecurity/config'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\nimport type { GlobOptions } from 'tinyglobby'\n\nconst { NPM, PNPM } = constants\n\nconst PNPM_WORKSPACE = `${PNPM}-workspace`\n\nconst ignoredDirs = [\n  // Taken from ignore-by-default:\n  // https://github.com/novemberborn/ignore-by-default/blob/v2.1.0/index.js\n  '.git', // Git repository files, see <https://git-scm.com/>\n  '.log', // Log files emitted by tools such as `tsserver`, see <https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29>\n  '.nyc_output', // Temporary directory where nyc stores coverage data, see <https://github.com/bcoe/nyc>\n  '.sass-cache', // Cache folder for node-sass, see <https://github.com/sass/node-sass>\n  '.yarn', // Where node modules are installed when using Yarn, see <https://yarnpkg.com/>\n  'bower_components', // Where Bower packages are installed, see <http://bower.io/>\n  'coverage', // Standard output directory for code coverage reports, see <https://github.com/gotwarlost/istanbul>\n  'node_modules', // Where Node modules are installed, see <https://nodejs.org/>\n  // Taken from globby:\n  // https://github.com/sindresorhus/globby/blob/v14.0.2/ignore.js#L11-L16\n  'flow-typed'\n] as const\n\nconst ignoredDirPatterns = ignoredDirs.map(i => `**/${i}`)\n\nasync function getWorkspaceGlobs(\n  agent: Agent,\n  cwd = process.cwd()\n): Promise<string[]> {\n  let workspacePatterns\n  if (agent === PNPM) {\n    for (const workspacePath of [\n      path.join(cwd, `${PNPM_WORKSPACE}.yaml`),\n      path.join(cwd, `${PNPM_WORKSPACE}.yml`)\n    ]) {\n      // eslint-disable-next-line no-await-in-loop\n      const yml = await safeReadFile(workspacePath)\n      if (yml) {\n        try {\n          workspacePatterns = yamlParse(yml)?.packages\n        } catch {}\n        if (workspacePatterns) {\n          break\n        }\n      }\n    }\n  } else {\n    workspacePatterns = (await readPackageJson(cwd, { throws: false }))?.[\n      'workspaces'\n    ]\n  }\n  return Array.isArray(workspacePatterns)\n    ? workspacePatterns\n        .filter(isNonEmptyString)\n        .map(workspacePatternToGlobPattern)\n    : []\n}\n\nfunction ignoreFileLinesToGlobPatterns(\n  lines: string[] | readonly string[],\n  filepath: string,\n  cwd: string\n): string[] {\n  const base = path.relative(cwd, path.dirname(filepath)).replace(/\\\\/g, '/')\n  const patterns = []\n  for (let i = 0, { length } = lines; i < length; i += 1) {\n    const pattern = lines[i]!.trim()\n    if (pattern.length > 0 && pattern.charCodeAt(0) !== 35 /*'#'*/) {\n      patterns.push(\n        ignorePatternToMinimatch(\n          pattern.length && pattern.charCodeAt(0) === 33 /*'!'*/\n            ? `!${path.posix.join(base, pattern.slice(1))}`\n            : path.posix.join(base, pattern)\n        )\n      )\n    }\n  }\n  return patterns\n}\n\nfunction ignoreFileToGlobPatterns(\n  content: string,\n  filepath: string,\n  cwd: string\n): string[] {\n  return ignoreFileLinesToGlobPatterns(content.split(/\\r?\\n/), filepath, cwd)\n}\n\n// Based on `@eslint/compat` convertIgnorePatternToMinimatch.\n// Apache v2.0 licensed\n// Copyright Nicholas C. Zakas\n// https://github.com/eslint/rewrite/blob/compat-v1.2.1/packages/compat/src/ignore-file.js#L28\nfunction ignorePatternToMinimatch(pattern: string): string {\n  const isNegated = pattern.startsWith('!')\n  const negatedPrefix = isNegated ? '!' : ''\n  const patternToTest = (isNegated ? pattern.slice(1) : pattern).trimEnd()\n  // Special cases.\n  if (\n    patternToTest === '' ||\n    patternToTest === '**' ||\n    patternToTest === '/**' ||\n    patternToTest === '**'\n  ) {\n    return `${negatedPrefix}${patternToTest}`\n  }\n  const firstIndexOfSlash = patternToTest.indexOf('/')\n  const matchEverywherePrefix =\n    firstIndexOfSlash === -1 || firstIndexOfSlash === patternToTest.length - 1\n      ? '**/'\n      : ''\n  const patternWithoutLeadingSlash =\n    firstIndexOfSlash === 0 ? patternToTest.slice(1) : patternToTest\n  // Escape `{` and `(` because in gitignore patterns they are just\n  // literal characters without any specific syntactic meaning,\n  // while in minimatch patterns they can form brace expansion or extglob syntax.\n  //\n  // For example, gitignore pattern `src/{a,b}.js` ignores file `src/{a,b}.js`.\n  // But, the same minimatch pattern `src/{a,b}.js` ignores files `src/a.js` and `src/b.js`.\n  // Minimatch pattern `src/\\{a,b}.js` is equivalent to gitignore pattern `src/{a,b}.js`.\n  const escapedPatternWithoutLeadingSlash =\n    patternWithoutLeadingSlash.replaceAll(\n      /(?=((?:\\\\.|[^{(])*))\\1([{(])/guy,\n      '$1\\\\$2'\n    )\n  const matchInsideSuffix = patternToTest.endsWith('/**') ? '/*' : ''\n  return `${negatedPrefix}${matchEverywherePrefix}${escapedPatternWithoutLeadingSlash}${matchInsideSuffix}`\n}\n\nfunction workspacePatternToGlobPattern(workspace: string): string {\n  const { length } = workspace\n  if (!length) {\n    return ''\n  }\n  // If the workspace ends with \"/\"\n  if (workspace.charCodeAt(length - 1) === 47 /*'/'*/) {\n    return `${workspace}/*/package.json`\n  }\n  // If the workspace ends with \"/**\"\n  if (\n    workspace.charCodeAt(length - 1) === 42 /*'*'*/ &&\n    workspace.charCodeAt(length - 2) === 42 /*'*'*/ &&\n    workspace.charCodeAt(length - 3) === 47 /*'/'*/\n  ) {\n    return `${workspace}/*/**/package.json`\n  }\n  // Things like \"packages/a\" or \"packages/*\"\n  return `${workspace}/package.json`\n}\n\nexport async function filterGlobResultToSupportedFiles(\n  entries: string[] | readonly string[],\n  supportedFiles: SocketSdkReturnType<'getReportSupportedFiles'>['data']\n): Promise<string[]> {\n  const patterns = ['golang', NPM, 'maven', 'pypi', 'gem', 'nuget'].reduce(\n    (r: string[], n: string) => {\n      const supported = supportedFiles[n]\n      r.push(\n        ...(supported\n          ? Object.values(supported).map(p => `**/${p.pattern}`)\n          : [])\n      )\n      return r\n    },\n    []\n  )\n  return entries.filter(p => micromatch.some(p, patterns))\n}\n\ntype GlobWithGitIgnoreOptions = GlobOptions & {\n  socketConfig?: SocketYml | undefined\n}\n\nexport async function globWithGitIgnore(\n  patterns: string[] | readonly string[],\n  options: GlobWithGitIgnoreOptions\n) {\n  const {\n    cwd = process.cwd(),\n    socketConfig,\n    ...additionalOptions\n  } = { __proto__: null, ...options } as GlobWithGitIgnoreOptions\n  const projectIgnorePaths = socketConfig?.projectIgnorePaths\n  const ignoreFiles = await tinyGlob(['**/.gitignore'], {\n    absolute: true,\n    cwd,\n    expandDirectories: true\n  })\n  const ignores = [\n    ...ignoredDirPatterns,\n    ...(Array.isArray(projectIgnorePaths)\n      ? ignoreFileLinesToGlobPatterns(\n          projectIgnorePaths,\n          path.join(cwd, '.gitignore'),\n          cwd\n        )\n      : []),\n    ...(\n      await Promise.all(\n        ignoreFiles.map(async filepath =>\n          ignoreFileToGlobPatterns(\n            await fs.readFile(filepath, 'utf8'),\n            filepath,\n            cwd\n          )\n        )\n      )\n    ).flat()\n  ]\n  const hasNegatedPattern = ignores.some(p => p.charCodeAt(0) === 33 /*'!'*/)\n  const globOptions = {\n    absolute: true,\n    cwd,\n    expandDirectories: false,\n    ignore: hasNegatedPattern ? [] : ignores,\n    ...additionalOptions\n  }\n  const result = await tinyGlob(patterns as string[], globOptions)\n  if (!hasNegatedPattern) {\n    return result\n  }\n  const { absolute } = globOptions\n\n  // Note: the input files must be INSIDE the cwd. If you get strange looking\n  // relative path errors here, most likely your path is outside the given cwd.\n  const filtered = ignore()\n    .add(ignores)\n    .filter(absolute ? result.map(p => path.relative(cwd, p)) : result)\n  return absolute ? filtered.map(p => path.resolve(cwd, p)) : filtered\n}\n\nexport async function globNodeModules(cwd = process.cwd()): Promise<string[]> {\n  return await tinyGlob('**/node_modules/**', {\n    absolute: true,\n    cwd\n  })\n}\n\nexport async function globWorkspace(\n  agent: Agent,\n  cwd = process.cwd()\n): Promise<string[]> {\n  const workspaceGlobs = await getWorkspaceGlobs(agent, cwd)\n  return workspaceGlobs.length\n    ? await tinyGlob(workspaceGlobs, {\n        absolute: true,\n        cwd,\n        ignore: ['**/node_modules/**', '**/bower_components/**']\n      })\n    : []\n}\n\nexport function pathsToGlobPatterns(\n  paths: string[] | readonly string[]\n): string[] {\n  // TODO: Does not support `~/` paths.\n  return paths.map(p => (p === '.' || p === './' ? '**/*' : p))\n}\n","import { promises as fs, readFileSync as fsReadFileSync } from 'node:fs'\nimport path from 'node:path'\n\nimport { remove } from '@socketsecurity/registry/lib/fs'\n\nimport constants from '../constants.mts'\nimport { globNodeModules } from './glob.mts'\n\nimport type { Remap } from '@socketsecurity/registry/lib/objects'\nimport type { Abortable } from 'node:events'\nimport type {\n  ObjectEncodingOptions,\n  OpenMode,\n  PathLike,\n  PathOrFileDescriptor\n} from 'node:fs'\nimport type { FileHandle } from 'node:fs/promises'\n\nconst { abortSignal } = constants\n\nexport async function removeNodeModules(cwd = process.cwd()) {\n  const nodeModulesPaths = await globNodeModules(cwd)\n  await Promise.all(nodeModulesPaths.map(p => remove(p)))\n}\n\nexport type FindUpOptions = {\n  cwd?: string | undefined\n  signal?: AbortSignal | undefined\n}\n\nexport async function findUp(\n  name: string | string[],\n  { cwd = process.cwd(), signal = abortSignal }: FindUpOptions\n): Promise<string | undefined> {\n  let dir = path.resolve(cwd)\n  const { root } = path.parse(dir)\n  const names = [name].flat()\n  while (dir && dir !== root) {\n    for (const name of names) {\n      if (signal?.aborted) {\n        return undefined\n      }\n      const filePath = path.join(dir, name)\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        const stats = await fs.stat(filePath)\n        if (stats.isFile()) {\n          return filePath\n        }\n      } catch {}\n    }\n    dir = path.dirname(dir)\n  }\n  return undefined\n}\n\nexport type ReadFileOptions = Remap<\n  ObjectEncodingOptions &\n    Abortable & {\n      flag?: OpenMode | undefined\n    }\n>\n\nexport async function readFileBinary(\n  filepath: PathLike | FileHandle,\n  options?: ReadFileOptions | undefined\n): Promise<Buffer> {\n  return (await fs.readFile(filepath, {\n    signal: abortSignal,\n    ...options,\n    encoding: 'binary'\n  } as ReadFileOptions)) as Buffer\n}\n\nexport async function readFileUtf8(\n  filepath: PathLike | FileHandle,\n  options?: ReadFileOptions | undefined\n): Promise<string> {\n  return await fs.readFile(filepath, {\n    signal: abortSignal,\n    ...options,\n    encoding: 'utf8'\n  })\n}\n\nexport async function safeReadFile(\n  filepath: PathLike | FileHandle,\n  options?: 'utf8' | 'utf-8' | { encoding: 'utf8' | 'utf-8' } | undefined\n): Promise<string | undefined>\n\nexport async function safeReadFile(\n  filepath: PathLike | FileHandle,\n  options?: ReadFileOptions | NodeJS.BufferEncoding | undefined\n): Promise<Awaited<ReturnType<typeof fs.readFile>> | undefined> {\n  try {\n    return await fs.readFile(filepath, {\n      encoding: 'utf8',\n      signal: abortSignal,\n      ...(typeof options === 'string' ? { encoding: options } : options)\n    })\n  } catch {}\n  return undefined\n}\n\nexport function safeReadFileSync(\n  filepath: PathOrFileDescriptor,\n  options?: 'utf8' | 'utf-8' | { encoding: 'utf8' | 'utf-8' } | undefined\n): string | undefined\n\nexport function safeReadFileSync(\n  filepath: PathOrFileDescriptor,\n  options?:\n    | {\n        encoding?: NodeJS.BufferEncoding | undefined\n        flag?: string | undefined\n      }\n    | NodeJS.BufferEncoding\n    | undefined\n): ReturnType<typeof fsReadFileSync> | undefined {\n  try {\n    return fsReadFileSync(filepath, {\n      encoding: 'utf8',\n      ...(typeof options === 'string' ? { encoding: options } : options)\n    })\n  } catch {}\n  return undefined\n}\n","import fs from 'node:fs'\nimport os from 'node:os'\nimport path from 'node:path'\n\nimport config from '@socketsecurity/config'\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { safeReadFileSync } from './fs.mts'\nimport constants from '../constants.mts'\n\nimport type { CResult } from '../types.mts'\n\nconst { LOCALAPPDATA, SOCKET_APP_DIR } = constants\n\nexport interface LocalConfig {\n  apiBaseUrl?: string | null | undefined\n  // @deprecated ; use apiToken. when loading a config, if this prop exists it\n  //               is deleted and set to apiToken instead, and then persisted.\n  //               should only happen once for legacy users.\n  apiKey?: string | null | undefined\n  apiProxy?: string | null | undefined\n  apiToken?: string | null | undefined\n  defaultOrg?: string\n  enforcedOrgs?: string[] | readonly string[] | null | undefined\n  // Temporary to prepare (and mark) CLI API changes for the major bump\n  isTestingV1?: boolean\n}\n\nexport const supportedConfigKeys: Map<keyof LocalConfig, string> = new Map([\n  ['apiBaseUrl', 'Base URL of the API endpoint'],\n  ['apiProxy', 'A proxy through which to access the API'],\n  ['apiToken', 'The API token required to access most API endpoints'],\n  [\n    'defaultOrg',\n    'The default org slug to use; usually the org your API token has access to. When set, all orgSlug arguments are implied to be this value.'\n  ],\n  [\n    'enforcedOrgs',\n    'Orgs in this list have their security policies enforced on this machine'\n  ],\n  ['isTestingV1', 'For development of testing the next major bump']\n])\n\nexport const sensitiveConfigKeys: Set<keyof LocalConfig> = new Set(['apiToken'])\n\nlet _cachedConfig: LocalConfig | undefined\n// When using --config or SOCKET_CLI_CONFIG, do not persist the config.\nlet _readOnlyConfig = false\n\nexport function overrideCachedConfig(jsonConfig: unknown): CResult<undefined> {\n  debugLog('Overriding entire config, marking config as read-only')\n\n  let config\n  try {\n    config = JSON.parse(String(jsonConfig))\n    if (!config || typeof config !== 'object') {\n      // `null` is valid json, so are primitive values. They're not valid config objects :)\n      return {\n        ok: false,\n        message: 'Could not parse Config as JSON',\n        cause:\n          \"Could not JSON parse the config override. Make sure it's a proper JSON object (double-quoted keys and strings, no unquoted `undefined`) and try again.\"\n      }\n    }\n  } catch {\n    // Force set an empty config to prevent accidentally using system settings\n    _cachedConfig = {} as LocalConfig\n    _readOnlyConfig = true\n\n    return {\n      ok: false,\n      message: 'Could not parse Config as JSON',\n      cause:\n        \"Could not JSON parse the config override. Make sure it's a proper JSON object (double-quoted keys and strings, no unquoted `undefined`) and try again.\"\n    }\n  }\n\n  // @ts-ignore Override an illegal object.\n  _cachedConfig = config as LocalConfig\n  _readOnlyConfig = true\n\n  // Normalize apiKey to apiToken.\n  if (_cachedConfig['apiKey']) {\n    if (_cachedConfig['apiToken']) {\n      logger.warn(\n        'Note: The config override had both apiToken and apiKey. Using the apiToken value. Remove the apiKey to get rid of this message.'\n      )\n    }\n    _cachedConfig['apiToken'] = _cachedConfig['apiKey']\n    delete _cachedConfig['apiKey']\n  }\n\n  return { ok: true, data: undefined }\n}\n\nexport function overrideConfigApiToken(apiToken: unknown) {\n  debugLog('Overriding API token, marking config as read-only')\n  // Set token to the local cached config and mark it read-only so it doesn't persist\n  _cachedConfig = {\n    ...config,\n    ...(apiToken === undefined ? {} : { apiToken: String(apiToken) })\n  } as LocalConfig\n  _readOnlyConfig = true\n}\n\nfunction getConfigValues(): LocalConfig {\n  if (_cachedConfig === undefined) {\n    _cachedConfig = {} as LocalConfig\n    // Order: env var > --config flag > file\n    const configPath = getConfigPath()\n    if (configPath) {\n      const raw = safeReadFileSync(configPath)\n      if (raw) {\n        try {\n          Object.assign(\n            _cachedConfig,\n            JSON.parse(Buffer.from(raw, 'base64').toString())\n          )\n        } catch {\n          logger.warn(`Failed to parse config at ${configPath}`)\n        }\n        // Normalize apiKey to apiToken and persist it.\n        // This is a one time migration per user.\n        if (_cachedConfig['apiKey']) {\n          const token = _cachedConfig['apiKey']\n          delete _cachedConfig['apiKey']\n          updateConfigValue('apiToken', token)\n        }\n      } else {\n        fs.mkdirSync(path.dirname(configPath), { recursive: true })\n      }\n    }\n  }\n  return _cachedConfig\n}\n\nlet _configPath: string | undefined\nlet _warnedConfigPathWin32Missing = false\nfunction getConfigPath(): string | undefined {\n  // Get the OS app data folder:\n  // - Win: %LOCALAPPDATA% or fail?\n  // - Mac: %XDG_DATA_HOME% or fallback to \"~/Library/Application Support/\"\n  // - Linux: %XDG_DATA_HOME% or fallback to \"~/.local/share/\"\n  // Note: LOCALAPPDATA is typically: C:\\Users\\USERNAME\\AppData\n  // Note: XDG stands for \"X Desktop Group\", nowadays \"freedesktop.org\"\n  //       On most systems that path is: $HOME/.local/share\n  // Then append `socket/settings`, so:\n  // - Win: %LOCALAPPDATA%\\socket\\settings or return undefined\n  // - Mac: %XDG_DATA_HOME%/socket/settings or \"~/Library/Application Support/socket/settings\"\n  // - Linux: %XDG_DATA_HOME%/socket/settings or \"~/.local/share/socket/settings\"\n\n  if (_configPath === undefined) {\n    // Lazily access constants.WIN32.\n    const { WIN32 } = constants\n    let dataHome: string | undefined = WIN32\n      ? // Lazily access constants.ENV.LOCALAPPDATA\n        constants.ENV.LOCALAPPDATA\n      : // Lazily access constants.ENV.XDG_DATA_HOME\n        constants.ENV.XDG_DATA_HOME\n    if (!dataHome) {\n      if (WIN32) {\n        if (!_warnedConfigPathWin32Missing) {\n          _warnedConfigPathWin32Missing = true\n          logger.warn(`Missing %${LOCALAPPDATA}%`)\n        }\n      } else {\n        dataHome = path.join(\n          os.homedir(),\n          ...(process.platform === 'darwin'\n            ? ['Library', 'Application Support']\n            : ['.local', 'share'])\n        )\n      }\n    }\n    _configPath = dataHome ? path.join(dataHome, SOCKET_APP_DIR) : undefined\n  }\n  return _configPath\n}\n\nfunction normalizeConfigKey(\n  key: keyof LocalConfig\n): CResult<keyof LocalConfig> {\n  // Note: apiKey was the old name of the token. When we load a config with\n  //       property apiKey, we'll copy that to apiToken and delete the old property.\n  const normalizedKey = key === 'apiKey' ? 'apiToken' : key\n  if (!supportedConfigKeys.has(normalizedKey)) {\n    return {\n      ok: false,\n      message: `Invalid config key: ${normalizedKey}`,\n      data: undefined\n    }\n  }\n  return { ok: true, data: key }\n}\n\nexport function findSocketYmlSync(dir = process.cwd()) {\n  let prevDir = null\n  while (dir !== prevDir) {\n    let ymlPath = path.join(dir, 'socket.yml')\n    let yml = safeReadFileSync(ymlPath)\n    if (yml === undefined) {\n      ymlPath = path.join(dir, 'socket.yaml')\n      yml = safeReadFileSync(ymlPath)\n    }\n    if (typeof yml === 'string') {\n      try {\n        return {\n          path: ymlPath,\n          parsed: config.parseSocketConfig(yml)\n        }\n      } catch {\n        throw new Error(`Found file but was unable to parse ${ymlPath}`)\n      }\n    }\n    prevDir = dir\n    dir = path.join(dir, '..')\n  }\n  return null\n}\n\nexport function getConfigValue<Key extends keyof LocalConfig>(\n  key: Key\n): CResult<LocalConfig[Key]> {\n  const localConfig = getConfigValues()\n  const keyResult = normalizeConfigKey(key)\n  if (!keyResult.ok) {\n    return keyResult\n  }\n  return { ok: true, data: localConfig[keyResult.data as Key] }\n}\n// This version squashes errors, returning undefined instead.\n// Should be used when we can reasonably predict the call can't fail.\nexport function getConfigValueOrUndef<Key extends keyof LocalConfig>(\n  key: Key\n): LocalConfig[Key] | undefined {\n  const localConfig = getConfigValues()\n  const keyResult = normalizeConfigKey(key)\n  if (!keyResult.ok) {\n    return undefined\n  }\n  return localConfig[keyResult.data as Key]\n}\nexport function isReadOnlyConfig() {\n  return _readOnlyConfig\n}\n\nlet _pendingSave = false\nexport function updateConfigValue<Key extends keyof LocalConfig>(\n  key: keyof LocalConfig,\n  value: LocalConfig[Key]\n): CResult<undefined | string> {\n  const localConfig = getConfigValues()\n  const keyResult = normalizeConfigKey(key)\n  if (!keyResult.ok) {\n    return keyResult\n  }\n  localConfig[keyResult.data as Key] = value\n  if (_readOnlyConfig) {\n    return {\n      ok: true,\n      message: `Config key '${key}' was updated`,\n      data: 'Change applied but not persisted; current config is overridden through env var or flag'\n    }\n  }\n\n  if (!_pendingSave) {\n    _pendingSave = true\n    process.nextTick(() => {\n      _pendingSave = false\n      const configPath = getConfigPath()\n      if (configPath) {\n        fs.writeFileSync(\n          configPath,\n          Buffer.from(JSON.stringify(localConfig)).toString('base64')\n        )\n      }\n    })\n  }\n\n  return {\n    ok: true,\n    message: `Config key '${key}' was updated`,\n    data: undefined\n  }\n}\n\nexport function isTestingV1() {\n  return !!getConfigValueOrUndef('isTestingV1')\n}\n","import { setTimeout as wait } from 'node:timers/promises'\n\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\n\nimport constants from '../constants.mts'\n\nconst {\n  kInternalsSymbol,\n  [kInternalsSymbol as unknown as 'Symbol(kInternalsSymbol)']: { getSentry }\n} = constants\n\ntype EventHintOrCaptureContext = { [key: string]: any } | Function\n\nexport class AuthError extends Error {}\n\nexport class InputError extends Error {\n  public body: string | undefined\n\n  constructor(message: string, body?: string) {\n    super(message)\n    this.body = body\n  }\n}\n\nexport async function captureException(\n  exception: unknown,\n  hint?: EventHintOrCaptureContext | undefined\n): Promise<string> {\n  const result = captureExceptionSync(exception, hint)\n  // \"Sleep\" for a second, just in case, hopefully enough time to initiate fetch.\n  await wait(1000)\n  return result\n}\n\nexport function captureExceptionSync(\n  exception: unknown,\n  hint?: EventHintOrCaptureContext | undefined\n): string {\n  const Sentry = getSentry()\n  if (!Sentry) {\n    return ''\n  }\n  debugLog('captureException: Sending exception to Sentry')\n  return Sentry.captureException(exception, hint) as string\n}\n\nexport function isErrnoException(\n  value: unknown\n): value is NodeJS.ErrnoException {\n  if (!(value instanceof Error)) {\n    return false\n  }\n  return (value as NodeJS.ErrnoException).code !== undefined\n}\n","import colors from 'yoctocolors-cjs'\n\nexport function failMsgWithBadge(\n  badge: string,\n  msg: string | undefined\n): string {\n  return `${colors.bgRed(colors.bold(colors.white(` ${badge}${msg ? ': ' : ''}`)))}${msg ? ' ' + colors.bold(msg) : ''}`\n}\n","import { HttpsProxyAgent } from 'hpagent'\n\nimport isInteractive from '@socketregistry/is-interactive/index.cjs'\nimport { password } from '@socketsecurity/registry/lib/prompts'\nimport { isNonEmptyString } from '@socketsecurity/registry/lib/strings'\nimport { SocketSdk, createUserAgentFromPkgJson } from '@socketsecurity/sdk'\n\nimport { getConfigValueOrUndef } from './config.mts'\nimport constants from '../constants.mts'\n\nimport type { CResult } from '../types.mts'\n\nconst { SOCKET_PUBLIC_API_TOKEN } = constants\n\n// The API server that should be used for operations.\nfunction getDefaultApiBaseUrl(): string | undefined {\n  const baseUrl =\n    // Lazily access constants.ENV.SOCKET_SECURITY_API_BASE_URL.\n    constants.ENV.SOCKET_SECURITY_API_BASE_URL ||\n    getConfigValueOrUndef('apiBaseUrl')\n  return isNonEmptyString(baseUrl) ? baseUrl : undefined\n}\n\n// The API server that should be used for operations.\nfunction getDefaultHttpProxy(): string | undefined {\n  const apiProxy =\n    // Lazily access constants.ENV.SOCKET_SECURITY_API_PROXY.\n    constants.ENV.SOCKET_SECURITY_API_PROXY || getConfigValueOrUndef('apiProxy')\n  return isNonEmptyString(apiProxy) ? apiProxy : undefined\n}\n\n// This API key should be stored globally for the duration of the CLI execution.\nlet _defaultToken: string | undefined\nexport function getDefaultToken(): string | undefined {\n  // Lazily access constants.ENV.SOCKET_CLI_NO_API_TOKEN.\n  if (constants.ENV.SOCKET_CLI_NO_API_TOKEN) {\n    _defaultToken = undefined\n  } else {\n    const key =\n      // Lazily access constants.ENV.SOCKET_SECURITY_API_TOKEN.\n      constants.ENV.SOCKET_SECURITY_API_TOKEN ||\n      getConfigValueOrUndef('apiToken') ||\n      _defaultToken\n    _defaultToken = isNonEmptyString(key) ? key : undefined\n  }\n  return _defaultToken\n}\n\nexport function getVisibleTokenPrefix(): string {\n  const apiToken = getDefaultToken()\n  if (!apiToken) {\n    return ''\n  }\n\n  const PREFIX = 'sktsec_'\n  return apiToken.slice(PREFIX.length, PREFIX.length + 5)\n}\n\nexport function hasDefaultToken(): boolean {\n  return !!getDefaultToken()\n}\n\nexport function getPublicToken(): string {\n  return (\n    // Lazily access constants.ENV.SOCKET_SECURITY_API_TOKEN.\n    (constants.ENV.SOCKET_SECURITY_API_TOKEN || getDefaultToken()) ??\n    SOCKET_PUBLIC_API_TOKEN\n  )\n}\n\nexport async function setupSdk(\n  apiToken: string | undefined = getDefaultToken(),\n  apiBaseUrl: string | undefined = getDefaultApiBaseUrl(),\n  proxy: string | undefined = getDefaultHttpProxy()\n): Promise<CResult<SocketSdk>> {\n  if (typeof apiToken !== 'string' && isInteractive()) {\n    apiToken = await password({\n      message:\n        'Enter your Socket.dev API key (not saved, use socket login to persist)'\n    })\n    _defaultToken = apiToken\n  }\n  if (!apiToken) {\n    return {\n      ok: false,\n      message: 'Auth Error',\n      cause: 'You need to provide an API Token. Run `socket login` first.'\n    }\n  }\n  return {\n    ok: true,\n    data: new SocketSdk(apiToken, {\n      agent: proxy ? new HttpsProxyAgent({ proxy }) : undefined,\n      baseUrl: apiBaseUrl,\n      userAgent: createUserAgentFromPkgJson({\n        // Lazily access constants.ENV.INLINED_SOCKET_CLI_NAME.\n        name: constants.ENV.INLINED_SOCKET_CLI_NAME,\n        // Lazily access constants.ENV.INLINED_SOCKET_CLI_VERSION.\n        version: constants.ENV.INLINED_SOCKET_CLI_VERSION,\n        // Lazily access constants.ENV.INLINED_SOCKET_CLI_HOMEPAGE.\n        homepage: constants.ENV.INLINED_SOCKET_CLI_HOMEPAGE\n      })\n    })\n  }\n}\n","import { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { isNonEmptyString } from '@socketsecurity/registry/lib/strings'\n\nimport { getConfigValueOrUndef } from './config.mts'\nimport { AuthError } from './errors.mts'\nimport constants from '../constants.mts'\nimport { failMsgWithBadge } from './fail-msg-with-badge.mts'\nimport { getDefaultToken } from './sdk.mts'\n\nimport type { CResult } from '../types.mts'\nimport type {\n  SocketSdkErrorType,\n  SocketSdkOperations,\n  SocketSdkResultType,\n  SocketSdkReturnType\n} from '@socketsecurity/sdk'\n\n// TODO: this function is removed after v1.0.0\nexport function handleUnsuccessfulApiResponse<T extends SocketSdkOperations>(\n  _name: T,\n  error: string,\n  cause: string,\n  status: number\n): never {\n  const message = `${error || 'No error message returned'}${cause ? ` (reason: ${cause})` : ''}`\n  if (status === 401 || status === 403) {\n    // Lazily access constants.spinner.\n    const { spinner } = constants\n\n    spinner.stop()\n\n    throw new AuthError(message)\n  }\n  logger.fail(failMsgWithBadge('Socket API returned an error', message))\n  // eslint-disable-next-line n/no-process-exit\n  process.exit(1)\n}\n\nexport async function handleApiCall<T extends SocketSdkOperations>(\n  value: Promise<SocketSdkResultType<T>>,\n  fetchingDesc: string\n): Promise<CResult<SocketSdkReturnType<T>['data']>> {\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n\n  spinner.start(`Requesting ${fetchingDesc} from API...`)\n\n  let result: SocketSdkResultType<T>\n  try {\n    result = await value\n\n    // TODO: info, not success (looks weird when response is non-200)\n    spinner.successAndStop(\n      `Received API response (after requesting ${fetchingDesc}).`\n    )\n  } catch (e) {\n    spinner.failAndStop(`An error was thrown while requesting ${fetchingDesc}`)\n\n    debugLog(`handleApiCall(${fetchingDesc}) threw error:\\n`, e)\n\n    const message = `${e || 'No error message returned'}`\n    const cause = `${e || 'No error message returned'}`\n\n    return {\n      ok: false,\n      message: 'Socket API returned an error',\n      cause: `${message}${cause ? ` ( Reason: ${cause} )` : ''}`\n    }\n  } finally {\n    spinner.stop()\n  }\n\n  // Note: TS can't narrow down the type of result due to generics\n  if (result.success === false) {\n    const err = result as SocketSdkErrorType<T>\n    const message = `${err.error || 'No error message returned'}`\n    debugLog(`handleApiCall(${fetchingDesc}) bad response:\\n`, err)\n\n    return {\n      ok: false,\n      message: 'Socket API returned an error',\n      cause: `${message}${err.cause ? ` ( Reason: ${err.cause} )` : ''}`,\n      data: {\n        code: result.status\n      }\n    }\n  } else {\n    const ok = result as SocketSdkReturnType<T>\n    return {\n      ok: true,\n      data: ok.data\n    }\n  }\n}\n\nexport async function handleApiCallNoSpinner<T extends SocketSdkOperations>(\n  value: Promise<SocketSdkResultType<T>>,\n  description: string\n): Promise<CResult<SocketSdkReturnType<T>['data']>> {\n  let result: SocketSdkResultType<T>\n  try {\n    result = await value\n  } catch (e) {\n    debugLog(`handleApiCall(${description}) threw error:\\n`, e)\n\n    const message = `${e || 'No error message returned'}`\n    const cause = `${e || 'No error message returned'}`\n\n    return {\n      ok: false,\n      message: 'Socket API returned an error',\n      cause: `${message}${cause ? ` ( Reason: ${cause} )` : ''}`\n    }\n  }\n\n  // Note: TS can't narrow down the type of result due to generics\n  if (result.success === false) {\n    const err = result as SocketSdkErrorType<T>\n    const message = `${err.error || 'No error message returned'}`\n    debugLog(`handleApiCall(${description}) bad response:\\n`, err)\n\n    return {\n      ok: false,\n      message: 'Socket API returned an error',\n      cause: `${message}${err.cause ? ` ( Reason: ${err.cause} )` : ''}`,\n      data: {\n        code: result.status\n      }\n    }\n  } else {\n    const ok = result as SocketSdkReturnType<T>\n    return {\n      ok: true,\n      data: ok.data\n    }\n  }\n}\n\nexport async function getErrorMessageForHttpStatusCode(code: number) {\n  if (code === 400) {\n    return 'One of the options passed might be incorrect'\n  }\n  if (code === 403 || code === 401) {\n    return 'Your API token may not have the required permissions for this command or you might be trying to access (data from) an organization that is not linked to the API key you are logged in with'\n  }\n  if (code === 404) {\n    return 'The requested Socket API endpoint was not found (404) or there was no result for the requested parameters. If unexpected, this could be a temporary problem caused by an incident or a bug in the CLI. If the problem persists please let us know.'\n  }\n  if (code === 500) {\n    return 'There was an unknown server side problem with your request. This ought to be temporary. Please let us know if this problem persists.'\n  }\n  return `Server responded with status code ${code}`\n}\n\n// The API server that should be used for operations.\nexport function getDefaultApiBaseUrl(): string | undefined {\n  // Lazily access constants.ENV.SOCKET_SECURITY_API_BASE_URL.\n  const SOCKET_SECURITY_API_BASE_URL =\n    constants.ENV.SOCKET_SECURITY_API_BASE_URL\n  const baseUrl =\n    SOCKET_SECURITY_API_BASE_URL || getConfigValueOrUndef('apiBaseUrl')\n  if (isNonEmptyString(baseUrl)) {\n    return baseUrl\n  }\n  // Lazily access constants.API_V0_URL.\n  const API_V0_URL = constants.API_V0_URL\n  return API_V0_URL\n}\n\nexport async function queryApi(path: string, apiToken: string) {\n  const baseUrl = getDefaultApiBaseUrl() || ''\n  if (!baseUrl) {\n    logger.warn(\n      'API endpoint is not set and default was empty. Request is likely to fail.'\n    )\n  }\n  return await fetch(`${baseUrl}${baseUrl.endsWith('/') ? '' : '/'}${path}`, {\n    method: 'GET',\n    headers: {\n      Authorization: `Basic ${btoa(`${apiToken}:`)}`\n    }\n  })\n}\n\nexport async function queryApiSafeText(\n  path: string,\n  fetchSpinnerDesc?: string\n): Promise<CResult<string>> {\n  const apiToken = getDefaultToken()\n  if (!apiToken) {\n    return {\n      ok: false,\n      message: 'Authentication Error',\n      cause:\n        'User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.'\n    }\n  }\n\n  if (fetchSpinnerDesc) {\n    // Lazily access constants.spinner.\n    const { spinner } = constants\n\n    spinner.start(`Requesting ${fetchSpinnerDesc} from API...`)\n  }\n\n  let result\n  try {\n    result = await queryApi(path, apiToken)\n    if (fetchSpinnerDesc) {\n      // Lazily access constants.spinner.\n      const { spinner } = constants\n\n      spinner.successAndStop(\n        `Received API response (after requesting ${fetchSpinnerDesc}).`\n      )\n    }\n  } catch (e) {\n    if (fetchSpinnerDesc) {\n      // Lazily access constants.spinner.\n      const { spinner } = constants\n\n      spinner.failAndStop(\n        `An error was thrown while requesting ${fetchSpinnerDesc}`\n      )\n    }\n    debugLog('Error thrown trying to await queryApi():')\n    debugLog(e)\n\n    const msg = (e as undefined | { message: string })?.message\n\n    return {\n      ok: false,\n      message: 'API Request failed to complete',\n      ...(msg ? { cause: msg } : {})\n    }\n  }\n\n  if (!result.ok) {\n    const cause = await getErrorMessageForHttpStatusCode(result.status)\n    return {\n      ok: false,\n      message: 'Socket API returned an error',\n      cause: `${result.statusText}${cause ? ` (cause: ${cause})` : ''}`\n    }\n  }\n\n  try {\n    const data = await result.text()\n\n    return {\n      ok: true,\n      data\n    }\n  } catch (e) {\n    debugLog('Error thrown trying to await result.text():')\n    debugLog(e)\n\n    return {\n      ok: false,\n      message: 'API Request failed to complete',\n      cause: 'There was an unexpected error trying to read the response text'\n    }\n  }\n}\n\nexport async function queryApiSafeJson<T>(\n  path: string,\n  fetchSpinnerDesc = ''\n): Promise<CResult<T>> {\n  const result = await queryApiSafeText(path, fetchSpinnerDesc)\n\n  if (!result.ok) {\n    return result\n  }\n\n  try {\n    return {\n      ok: true,\n      data: JSON.parse(result.data) as T\n    }\n  } catch (e) {\n    return {\n      ok: false,\n      message: 'Server returned invalid JSON',\n      cause: `Please report this. JSON.parse threw an error over the following response: \\`${(result.data?.slice?.(0, 100) || '<empty>').trim() + (result.data?.length > 100 ? '...' : '')}\\``\n    }\n  }\n}\n","export function mdTableStringNumber(\n  title1: string,\n  title2: string,\n  obj: Record<string, number | string>\n): string {\n  // | Date        | Counts |\n  // | ----------- | ------ |\n  // | Header      | 201464 |\n  // | Paragraph   |     18 |\n  let mw1 = title1.length\n  let mw2 = title2.length\n  for (const [key, value] of Object.entries(obj)) {\n    mw1 = Math.max(mw1, key.length)\n    mw2 = Math.max(mw2, String(value ?? '').length)\n  }\n\n  const lines = []\n  lines.push(`| ${title1.padEnd(mw1, ' ')} | ${title2.padEnd(mw2)} |`)\n  lines.push(`| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} |`)\n  for (const [key, value] of Object.entries(obj)) {\n    lines.push(\n      `| ${key.padEnd(mw1, ' ')} | ${String(value ?? '').padStart(mw2, ' ')} |`\n    )\n  }\n  lines.push(`| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} |`)\n\n  return lines.join('\\n')\n}\n\nexport function mdTable<T extends Array<Record<string, string>>>(\n  logs: T,\n  // This is saying \"an array of strings and the strings are a valid key of elements of T\"\n  // In turn, T is defined above as the audit log event type from our OpenAPI docs.\n  cols: Array<string & keyof T[number]>,\n  titles: string[] = cols\n): string {\n  // Max col width required to fit all data in that column\n  const cws = cols.map(col => col.length)\n\n  for (const log of logs) {\n    for (let i = 0, { length } = cols; i < length; i += 1) {\n      // @ts-ignore\n      const val: unknown = log[cols[i] ?? ''] ?? ''\n      cws[i] = Math.max(\n        cws[i] ?? 0,\n        String(val).length,\n        (titles[i] || '').length\n      )\n    }\n  }\n\n  let div = '|'\n  for (const cw of cws) {\n    div += ' ' + '-'.repeat(cw) + ' |'\n  }\n\n  let header = '|'\n  for (let i = 0, { length } = titles; i < length; i += 1) {\n    header += ' ' + String(titles[i]).padEnd(cws[i] ?? 0, ' ') + ' |'\n  }\n\n  let body = ''\n  for (const log of logs) {\n    body += '|'\n    for (let i = 0, { length } = cols; i < length; i += 1) {\n      // @ts-ignore\n      const val: unknown = log[cols[i] ?? ''] ?? ''\n      body += ' ' + String(val).padEnd(cws[i] ?? 0, ' ') + ' |'\n    }\n    body += '\\n'\n  }\n\n  return [div, header, div, body.trim(), div].filter(s => !!s.trim()).join('\\n')\n}\n\nexport function mdTableOfPairs(\n  arr: Array<[string, string]>,\n  // This is saying \"an array of strings and the strings are a valid key of elements of T\"\n  // In turn, T is defined above as the audit log event type from our OpenAPI docs.\n  cols: string[]\n): string {\n  // Max col width required to fit all data in that column\n  const cws = cols.map(col => col.length)\n\n  for (const [key, val] of arr) {\n    cws[0] = Math.max(cws[0] ?? 0, String(key).length)\n    cws[1] = Math.max(cws[1] ?? 0, String(val ?? '').length)\n  }\n\n  let div = '|'\n  for (const cw of cws) {\n    div += ' ' + '-'.repeat(cw) + ' |'\n  }\n\n  let header = '|'\n  for (let i = 0, { length } = cols; i < length; i += 1) {\n    header += ' ' + String(cols[i]).padEnd(cws[i] ?? 0, ' ') + ' |'\n  }\n\n  let body = ''\n  for (const [key, val] of arr) {\n    body += '|'\n    body += ' ' + String(key).padEnd(cws[0] ?? 0, ' ') + ' |'\n    body += ' ' + String(val ?? '').padEnd(cws[1] ?? 0, ' ') + ' |'\n    body += '\\n'\n  }\n\n  return [div, header, div, body.trim(), div].filter(s => !!s.trim()).join('\\n')\n}\n","import { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport type { CResult } from '../types.mts'\n\n// Serialize the final result object before printing it\n// All commands that support the --json flag should call this before printing\nexport function serializeResultJson(data: CResult<unknown>): string {\n  if (typeof data !== 'object' || !data) {\n    process.exitCode = 1\n    // We should not allow to expect the json value to be \"null\", or a boolean/number/string, even if they are valid \"json\".\n    const msg =\n      'There was a problem converting the data set to JSON. The JSON was not an object. Please try again without --json'\n    debugLog('typeof data=', typeof data)\n    if (typeof data !== 'object' && data) {\n      debugLog('data:\\n', data)\n    }\n    return (\n      JSON.stringify({\n        ok: false,\n        message: 'Unable to serialize JSON',\n        data: msg\n      }).trim() + '\\n'\n    )\n  }\n\n  try {\n    return JSON.stringify(data, null, 2).trim() + '\\n'\n  } catch (e) {\n    debugLog('Error:\\n', e)\n    process.exitCode = 1\n    // This could be caused by circular references, which is an \"us\" problem\n    const msg =\n      'There was a problem converting the data set to JSON. Please try again without --json'\n    logger.error(msg)\n    return (\n      JSON.stringify({\n        ok: false,\n        message: 'Unable to serialize JSON',\n        data: msg\n      }).trim() + '\\n'\n    )\n  }\n}\n","import type { Flag } from 'meow'\n\n// TODO: not sure if I'm missing something but meow doesn't seem to expose this?\ntype StringFlag = Flag<'string', string> | Flag<'string', string[], true>\ntype BooleanFlag = Flag<'boolean', boolean> | Flag<'boolean', boolean[], true>\ntype NumberFlag = Flag<'number', number> | Flag<'number', number[], true>\ntype AnyFlag = StringFlag | BooleanFlag | NumberFlag\n\n// Note: we use this description in getFlagListOutput, meow doesn't care\nexport type MeowFlags = Record<\n  string,\n  AnyFlag & { description: string; hidden?: boolean }\n>\n\nexport const commonFlags: MeowFlags = {\n  config: {\n    type: 'string',\n    default: '',\n    hidden: true,\n    description: 'Override the local config with this JSON'\n  },\n  dryRun: {\n    type: 'boolean',\n    default: false,\n    hidden: true, // Only show in root command\n    description: 'Do input validation for a command and exit 0 when input is ok'\n  },\n  help: {\n    type: 'boolean',\n    default: false,\n    shortFlag: 'h',\n    description: 'Print this help'\n  },\n  silent: {\n    type: 'boolean',\n    default: false,\n    hidden: true,\n    shortFlag: 's',\n    description: 'Make the CLI less chatty'\n  }\n}\n\nexport const outputFlags: MeowFlags = {\n  json: {\n    type: 'boolean',\n    shortFlag: 'j',\n    default: false,\n    description: 'Output result as json'\n  },\n  markdown: {\n    type: 'boolean',\n    shortFlag: 'm',\n    default: false,\n    description: 'Output result as markdown'\n  }\n}\n\nexport const validationFlags: MeowFlags = {\n  all: {\n    type: 'boolean',\n    default: false,\n    description: 'Include all issues'\n  },\n  strict: {\n    type: 'boolean',\n    default: false,\n    description: 'Exits with an error code if any matching issues are found'\n  }\n}\n","import colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { failMsgWithBadge } from './fail-msg-with-badge.mts'\nimport { serializeResultJson } from './serialize-result-json.mts'\n\nimport type { OutputKind } from '../types.mts'\n\nexport function checkCommandInput(\n  outputKind: OutputKind,\n  ...checks: Array<{\n    fail: string\n    message: string\n    pass: string\n    test: boolean\n    nook?: boolean | undefined\n  }>\n): boolean {\n  if (checks.every(d => d.test)) {\n    return true\n  }\n\n  const msg = ['Please review the input requirements and try again', '']\n  for (const d of checks) {\n    // If nook, then ignore when test is ok\n    if (d.nook && d.test) {\n      continue\n    }\n    const lines = d.message.split('\\n')\n    const { length: lineCount } = lines\n    if (!lineCount) {\n      continue\n    }\n    // If the message has newlines then format the first line with the input\n    // expectation and the rest indented below it.\n    msg.push(\n      `  - ${lines[0]} (${d.test ? colors.green(d.pass) : colors.red(d.fail)})`\n    )\n    if (lineCount > 1) {\n      msg.push(...lines.slice(1).map(str => `    ${str}`))\n    }\n    msg.push('')\n  }\n\n  // Use exit status of 2 to indicate incorrect usage, generally invalid\n  // options or missing arguments.\n  // https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html\n  process.exitCode = 2\n\n  if (outputKind === 'json') {\n    logger.log(\n      serializeResultJson({\n        ok: false,\n        message: 'Input error',\n        data: msg.join('\\n')\n      })\n    )\n  } else {\n    logger.fail(failMsgWithBadge('Input error', msg.join('\\n')))\n  }\n\n  return false\n}\n","import type { OutputKind } from '../types.mts'\n\nexport function getOutputKind(json: unknown, markdown: unknown): OutputKind {\n  if (json) {\n    return 'json'\n  }\n  if (markdown) {\n    return 'markdown'\n  }\n  return 'text'\n}\n","import type { MeowFlags } from '../flags.mts'\n\ntype HelpListOptions = {\n  keyPrefix: string\n  padName: number\n}\n\ntype ListDescription =\n  | { description: string }\n  | { description: string; hidden: boolean }\n\nexport function getFlagListOutput(\n  list: MeowFlags,\n  indent: number,\n  { keyPrefix = '--', padName } = {} as HelpListOptions\n): string {\n  return getHelpListOutput(\n    {\n      ...list\n    },\n    indent,\n    { keyPrefix, padName }\n  )\n}\n\nexport function getHelpListOutput(\n  list: Record<string, ListDescription>,\n  indent: number,\n  { keyPrefix = '', padName = 18 } = {} as HelpListOptions\n): string {\n  let result = ''\n  const names = Object.keys(list).sort()\n  for (const name of names) {\n    const entry = list[name]\n    if (entry && 'hidden' in entry && entry?.hidden) {\n      continue\n    }\n    const description =\n      (typeof entry === 'object' ? entry.description : entry) || ''\n    result +=\n      ''.padEnd(indent) +\n      (keyPrefix + name).padEnd(padName) +\n      description +\n      '\\n'\n  }\n  return result.trim() || '(none)'\n}\n","import path from 'node:path'\n\nimport meow from 'meow'\nimport semver from 'semver'\nimport colors from 'yoctocolors-cjs'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\nimport { toSortedObject } from '@socketsecurity/registry/lib/objects'\nimport { normalizePath } from '@socketsecurity/registry/lib/path'\nimport { escapeRegExp } from '@socketsecurity/registry/lib/regexps'\n\nimport {\n  getConfigValueOrUndef,\n  isReadOnlyConfig,\n  isTestingV1,\n  overrideCachedConfig,\n  overrideConfigApiToken\n} from './config.mts'\nimport { getFlagListOutput, getHelpListOutput } from './output-formatting.mts'\nimport constants from '../constants.mts'\nimport { commonFlags } from '../flags.mts'\nimport { getVisibleTokenPrefix } from './sdk.mts'\n\nimport type { MeowFlags } from '../flags.mts'\nimport type { Options } from 'meow'\n\ninterface CliAlias {\n  description: string\n  argv: readonly string[]\n  hidden?: boolean | undefined\n}\n\ntype CliAliases = Record<string, CliAlias>\n\ntype CliSubcommandRun = (\n  argv: string[] | readonly string[],\n  importMeta: ImportMeta,\n  context: { parentName: string }\n) => Promise<void> | void\n\nexport interface CliSubcommand {\n  description: string\n  hidden?: boolean | undefined\n  run: CliSubcommandRun\n}\n\n// Property names are picked such that the name is at the top when the props\n// get ordered by alphabet while flags is near the bottom and the help text\n// at the bottom, because they tend ot occupy the most lines of code.\nexport interface CliCommandConfig {\n  commandName: string // tmp optional while we migrate\n  description: string\n  hidden: boolean\n  flags: MeowFlags // tmp optional while we migrate\n  help: (command: string, config: CliCommandConfig) => string\n}\n\ninterface MeowOptions extends Options<any> {\n  aliases?: CliAliases | undefined\n  argv: readonly string[]\n  name: string\n  // When no sub-command is given, default to this sub-command\n  defaultSub?: string\n}\n\n// For debugging. Whenever you call meowOrExit it will store the command here\n// This module exports a getter that returns the current value.\nlet lastSeenCommand = ''\n\nexport function getLastSeenCommand(): string {\n  return lastSeenCommand\n}\n\nexport async function meowWithSubcommands(\n  subcommands: Record<string, CliSubcommand>,\n  options: MeowOptions\n): Promise<void> {\n  const {\n    aliases = {},\n    argv,\n    defaultSub,\n    importMeta,\n    name,\n    ...additionalOptions\n  } = { __proto__: null, ...options }\n  const [commandOrAliasName_, ...rawCommandArgv] = argv\n  let commandOrAliasName = commandOrAliasName_\n  if (!commandOrAliasName && defaultSub) {\n    commandOrAliasName = defaultSub\n  }\n\n  const flags: MeowFlags = {\n    ...commonFlags,\n    ...additionalOptions.flags\n  }\n\n  // No further args or first arg is a flag (shrug)\n  if (\n    name === 'socket' &&\n    (!commandOrAliasName || commandOrAliasName?.startsWith('-'))\n  ) {\n    flags['dryRun'] = {\n      type: 'boolean',\n      default: false,\n      hidden: false, // Only show on root\n      description:\n        'Do input validation for a command and exit 0 when input is ok. Every command should support this flag (not shown on help screens)'\n    }\n  }\n\n  // This is basically a dry-run parse of cli args and flags. We use this to\n  // determine config overrides and expected output mode.\n  const cli1 = meow(`(this should never be printed)`, {\n    argv,\n    importMeta,\n    ...additionalOptions,\n    flags,\n    // Do not strictly check for flags here.\n    allowUnknownFlags: true,\n    // We will emit help when we're ready\n    // Plus, if we allow this then meow() can just exit here.\n    autoHelp: false\n  })\n\n  // Hard override the config if instructed to do so.\n  // The env var overrides the --flag, which overrides the persisted config\n  // Also, when either of these are used, config updates won't persist.\n  let configOverrideResult\n  // Lazily access constants.ENV.SOCKET_CLI_CONFIG.\n  if (constants.ENV.SOCKET_CLI_CONFIG) {\n    configOverrideResult = overrideCachedConfig(\n      // Lazily access constants.ENV.SOCKET_CLI_CONFIG.\n      constants.ENV.SOCKET_CLI_CONFIG\n    )\n  } else if (cli1.flags['config']) {\n    configOverrideResult = overrideCachedConfig(\n      String(cli1.flags['config'] || '')\n    )\n  }\n\n  // Lazily access constants.ENV.SOCKET_CLI_NO_API_TOKEN.\n  if (constants.ENV.SOCKET_CLI_NO_API_TOKEN) {\n    // This overrides the config override and even the explicit token env var.\n    // The config will be marked as readOnly to prevent persisting it.\n    overrideConfigApiToken(undefined)\n  } else {\n    // Lazily access constants.ENV.SOCKET_SECURITY_API_TOKEN.\n    const tokenOverride = constants.ENV.SOCKET_SECURITY_API_TOKEN\n    if (tokenOverride) {\n      // This will set the token (even if there was a config override) and\n      // set it to readOnly, making sure the temp token won't be persisted.\n      overrideConfigApiToken(tokenOverride)\n    }\n  }\n\n  if (configOverrideResult?.ok === false) {\n    emitBanner(name)\n    logger.fail(configOverrideResult.message)\n    process.exitCode = 2\n    return\n  }\n\n  // If we got at least some args, then lets find out if we can find a command.\n  if (commandOrAliasName) {\n    const alias = aliases[commandOrAliasName]\n    // First: Resolve argv data from alias if its an alias that's been given.\n    const [commandName, ...commandArgv] = alias\n      ? [...alias.argv, ...rawCommandArgv]\n      : [commandOrAliasName, ...rawCommandArgv]\n    // Second: Find a command definition using that data.\n    const commandDefinition = commandName ? subcommands[commandName] : undefined\n    // Third: If a valid command has been found, then we run it...\n    if (commandDefinition) {\n      return await commandDefinition.run(commandArgv, importMeta, {\n        parentName: name\n      })\n    }\n  }\n\n  if (isTestingV1()) {\n    delete subcommands['diff-scan']\n    delete subcommands['info']\n    delete subcommands['report']\n  }\n\n  // Parse it again. Config overrides should now be applied (may affect help).\n  const cli2 = meow(\n    `\n    Usage\n      $ ${name} <command>\n\n    Commands\n      ${getHelpListOutput(\n        {\n          ...toSortedObject(\n            Object.fromEntries(\n              Object.entries(subcommands).filter(\n                ({ 1: subcommand }) => !subcommand.hidden\n              )\n            )\n          ),\n          ...toSortedObject(\n            Object.fromEntries(\n              Object.entries(aliases).filter(({ 1: alias }) => {\n                const { hidden } = alias\n                const cmdName = hidden ? '' : alias.argv[0]\n                const subcommand = cmdName ? subcommands[cmdName] : undefined\n                return subcommand && !subcommand.hidden\n              })\n            )\n          )\n        },\n        6\n      )}\n\n    Options\n      ${getFlagListOutput(flags, 6)}\n\n    Examples\n      $ ${name} --help\n  `,\n    {\n      argv,\n      importMeta,\n      ...additionalOptions,\n      flags,\n      // Do not strictly check for flags here.\n      allowUnknownFlags: true,\n      // We will emit help when we're ready\n      // Plus, if we allow this then meow() can just exit here.\n      autoHelp: false\n    }\n  )\n\n  // ...else we provide basic instructions and help.\n  if (!cli2.flags['silent']) {\n    emitBanner(name)\n  }\n  if (!cli2.flags['help'] && cli2.flags['dryRun']) {\n    process.exitCode = 0\n    // Lazily access constants.DRY_RUN_LABEL.\n    logger.log(`${constants.DRY_RUN_LABEL}: No-op, call a sub-command; ok`)\n  } else {\n    // When you explicitly request --help, the command should be successful\n    // so we exit(0). If we do it because we need more input, we exit(2).\n    cli2.showHelp(cli2.flags['help'] ? 0 : 2)\n  }\n}\n\n/**\n * Note: meow will exit immediately if it calls its .showHelp()\n */\nexport function meowOrExit({\n  allowUnknownFlags, // commands that pass-through args need to allow this\n  argv,\n  config,\n  importMeta,\n  parentName\n}: {\n  allowUnknownFlags?: boolean | undefined\n  argv: readonly string[]\n  config: CliCommandConfig\n  parentName: string\n  importMeta: ImportMeta\n}) {\n  const command = `${parentName} ${config.commandName}`\n  lastSeenCommand = command\n\n  // This exits if .printHelp() is called either by meow itself or by us.\n  const cli = meow({\n    argv,\n    description: config.description,\n    help: config.help(command, config),\n    importMeta,\n    flags: config.flags,\n    allowUnknownFlags: true, // meow will exit(1) before printing the banner\n    autoHelp: false // meow will exit(0) before printing the banner\n  })\n\n  if (!cli.flags['silent']) {\n    emitBanner(command)\n  }\n  if (!allowUnknownFlags) {\n    // Run meow specifically with the flag setting. It will exit(2) if an\n    // invalid flag is set and print a message.\n    meow({\n      argv,\n      description: config.description,\n      help: config.help(command, config),\n      importMeta,\n      flags: config.flags,\n      allowUnknownFlags: false,\n      autoHelp: false\n    })\n  }\n\n  if (cli.flags['help']) {\n    cli.showHelp(0)\n  }\n  // Now test for help state. Run meow again. If it exits now, it must be due\n  // to wanting to print the help screen. But it would exit(0) and we want a\n  // consistent exit(2) for that case (missing input). TODO: move away from meow\n  process.exitCode = 2\n  meow({\n    argv,\n    description: config.description,\n    help: config.help(command, config),\n    importMeta,\n    flags: config.flags,\n    allowUnknownFlags: Boolean(allowUnknownFlags),\n    autoHelp: false\n  })\n  // Ok, no help, reset to default.\n  process.exitCode = 0\n\n  return cli\n}\n\nexport function emitBanner(name: string) {\n  // Print a banner at the top of each command.\n  // This helps with brand recognition and marketing.\n  // It also helps with debugging since it contains version and command details.\n  // Note: print over stderr to preserve stdout for flags like --json and\n  //       --markdown. If we don't do this, you can't use --json in particular\n  //       and pipe the result to other tools. By emitting the banner over stderr\n  //       you can do something like `socket scan view xyz | jq | process`.\n  //       The spinner also emits over stderr for example.\n  logger.error(getAsciiHeader(name))\n}\n\nfunction getAsciiHeader(command: string) {\n  // Note: In tests we return <redacted> because otherwise snapshots will fail.\n  const { REDACTED } = constants\n  // Lazily access constants.ENV.VITEST.\n  const redacting = constants.ENV.VITEST\n  const cliVersion = redacting\n    ? REDACTED\n    : // Lazily access constants.ENV.INLINED_SOCKET_CLI_VERSION_HASH.\n      constants.ENV.INLINED_SOCKET_CLI_VERSION_HASH\n  const nodeVersion = redacting ? REDACTED : process.version\n  const defaultOrg = getConfigValueOrUndef('defaultOrg')\n  const readOnlyConfig = isReadOnlyConfig() ? '*' : '.'\n  const v1test = isTestingV1() ? ' (is testing v1)' : ''\n  const feedback = isTestingV1()\n    ? colors.green(\n        '   (Thank you for testing the v1 bump! Please send us any feedback you might have!)\\n'\n      )\n    : ''\n  const shownToken = redacting ? REDACTED : getVisibleTokenPrefix() || 'no'\n  const relCwd = redacting\n    ? REDACTED\n    : normalizePath(\n        process\n          .cwd()\n          .replace(\n            new RegExp(\n              `^${escapeRegExp(constants.homePath)}(?:${path.sep}|$)`,\n              'i'\n            ),\n            '~/'\n          )\n      )\n  let nodeVerWarn = ''\n  if ((semver.parse(constants.NODE_VERSION)?.major ?? 0) < 20) {\n    nodeVerWarn += colors.bold(\n      `   ${colors.red('Warning:')} NodeJS version 19 and lower will be ${colors.red('unsupported')} after April 30th, 2025.`\n    )\n    nodeVerWarn += '\\n'\n    nodeVerWarn +=\n      '            Soon after the Socket CLI will require NodeJS version 20 or higher.'\n    nodeVerWarn += '\\n'\n  }\n  const body = `\n   _____         _       _        /---------------\n  |   __|___ ___| |_ ___| |_      | Socket.dev CLI ver ${cliVersion}${v1test}\n  |__   | ${readOnlyConfig} |  _| '_| -_|  _|     | Node: ${nodeVersion}, API token set: ${shownToken}${defaultOrg ? `, default org: ${redacting ? REDACTED : defaultOrg}` : ''}\n  |_____|___|___|_,_|___|_|.dev   | Command: \\`${command}\\`, cwd: ${relCwd}`.trimStart()\n\n  return `   ${body}\\n${nodeVerWarn}${feedback}`\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\nimport { select } from '@socketsecurity/registry/lib/prompts'\n\nimport { handleApiCall } from '../../utils/api.mts'\nimport { setupSdk } from '../../utils/sdk.mts'\n\nexport async function suggestOrgSlug(): Promise<string | void> {\n  const sockSdkResult = await setupSdk()\n  if (!sockSdkResult.ok) {\n    return\n  }\n  const sockSdk = sockSdkResult.data\n\n  const result = await handleApiCall(\n    sockSdk.getOrganizations(),\n    'list of organizations'\n  )\n\n  // Ignore a failed request here. It was not the primary goal of\n  // running this command and reporting it only leads to end-user confusion.\n  if (result.ok) {\n    const proceed = await select<string>({\n      message:\n        'Missing org name; do you want to use any of these orgs for this scan?',\n      choices: [\n        ...Object.values(result.data.organizations).map(org => {\n          const name = org.name ?? org.slug\n          return {\n            name: `Yes [${name}]`,\n            value: name,\n            description: `Use \"${name}\" as the organization`\n          }\n        }),\n        {\n          name: 'No',\n          value: '',\n          description:\n            'Do not use any of these organizations (will end in a no-op)'\n        }\n      ]\n    })\n    if (proceed) {\n      return proceed\n    }\n  } else {\n    logger.fail(\n      'Failed to lookup organization list from API, unable to suggest'\n    )\n  }\n}\n","import { logger } from '@socketsecurity/registry/lib/logger'\n\nimport { getConfigValueOrUndef, isTestingV1 } from './config.mts'\nimport { suggestOrgSlug } from '../commands/scan/suggest-org-slug.mts'\n\nexport async function determineOrgSlug(\n  orgFlag: string,\n  firstArg: string,\n  interactive: boolean,\n  dryRun: boolean\n): Promise<[string, string | undefined]> {\n  const defaultOrgSlug = getConfigValueOrUndef('defaultOrg')\n  let orgSlug = String(orgFlag || defaultOrgSlug || '')\n  if (!orgSlug) {\n    if (isTestingV1()) {\n      // ask from server\n      logger.error(\n        'Missing the org slug and no --org flag set. Trying to auto-discover the org now...'\n      )\n      logger.error(\n        'Note: you can set the default org slug to prevent this issue. You can also override all that with the --org flag.'\n      )\n      if (dryRun) {\n        logger.fail('Skipping auto-discovery of org in dry-run mode')\n      } else if (!interactive) {\n        logger.fail('Skipping auto-discovery of org when interactive = false')\n      } else {\n        orgSlug = (await suggestOrgSlug()) || ''\n      }\n    } else {\n      orgSlug = firstArg || ''\n    }\n  }\n\n  return [orgSlug, defaultOrgSlug]\n}\n","import { existsSync, statSync } from 'node:fs'\nimport path from 'node:path'\n\nimport which from 'which'\n\nimport { debugLog, isDebug } from '@socketsecurity/registry/lib/debug'\nimport { resolveBinPath } from '@socketsecurity/registry/lib/npm'\nimport { pluralize } from '@socketsecurity/registry/lib/words'\n\nimport constants from '../constants.mts'\nimport {\n  filterGlobResultToSupportedFiles,\n  globWithGitIgnore,\n  pathsToGlobPatterns\n} from './glob.mts'\n\nimport type { SocketYml } from '@socketsecurity/config'\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nconst { NODE_MODULES, NPM, shadowBinPath } = constants\n\nexport function findBinPathDetailsSync(binName: string): {\n  name: string\n  path: string | undefined\n  shadowed: boolean\n} {\n  const binPaths =\n    which.sync(binName, {\n      all: true,\n      nothrow: true\n    }) ?? []\n  let shadowIndex = -1\n  let theBinPath: string | undefined\n  for (let i = 0, { length } = binPaths; i < length; i += 1) {\n    const binPath = binPaths[i]!\n    // Skip our bin directory if it's in the front.\n    if (path.dirname(binPath) === shadowBinPath) {\n      shadowIndex = i\n    } else {\n      theBinPath = resolveBinPath(binPath)\n      break\n    }\n  }\n  return { name: binName, path: theBinPath, shadowed: shadowIndex !== -1 }\n}\n\nexport function findNpmPathSync(npmBinPath: string): string | undefined {\n  // Lazily access constants.WIN32.\n  const { WIN32 } = constants\n  let thePath = npmBinPath\n  while (true) {\n    const libNmNpmPath = path.join(thePath, 'lib', NODE_MODULES, NPM)\n    // mise puts its npm bin in a path like:\n    //   /Users/SomeUsername/.local/share/mise/installs/node/vX.X.X/bin/npm.\n    // HOWEVER, the location of the npm install is:\n    //   /Users/SomeUsername/.local/share/mise/installs/node/vX.X.X/lib/node_modules/npm.\n    if (\n      // Use existsSync here because statsSync, even with { throwIfNoEntry: false },\n      // will throw an ENOTDIR error for paths like ./a-file-that-exists/a-directory-that-does-not.\n      // See https://github.com/nodejs/node/issues/56993.\n      existsSync(libNmNpmPath) &&\n      statSync(libNmNpmPath, { throwIfNoEntry: false })?.isDirectory()\n    ) {\n      thePath = path.join(libNmNpmPath, NPM)\n    }\n    const nmPath = path.join(thePath, NODE_MODULES)\n    if (\n      // npm bin paths may look like:\n      //   /usr/local/share/npm/bin/npm\n      //   /Users/SomeUsername/.nvm/versions/node/vX.X.X/bin/npm\n      //   C:\\Users\\SomeUsername\\AppData\\Roaming\\npm\\bin\\npm.cmd\n      // OR\n      //   C:\\Program Files\\nodejs\\npm.cmd\n      //\n      // In practically all cases the npm path contains a node_modules folder:\n      //   /usr/local/share/npm/bin/npm/node_modules\n      //   C:\\Program Files\\nodejs\\node_modules\n      existsSync(nmPath) &&\n      statSync(nmPath, { throwIfNoEntry: false })?.isDirectory() &&\n      // Optimistically look for the default location.\n      (path.basename(thePath) === NPM ||\n        // Chocolatey installs npm bins in the same directory as node bins.\n        (WIN32 && existsSync(path.join(thePath, `${NPM}.cmd`))))\n    ) {\n      return thePath\n    }\n    const parent = path.dirname(thePath)\n    if (parent === thePath) {\n      return undefined\n    }\n    thePath = parent\n  }\n}\n\nexport async function getPackageFilesForScan(\n  cwd: string,\n  inputPaths: string[],\n  supportedFiles: SocketSdkReturnType<'getReportSupportedFiles'>['data'],\n  config?: SocketYml | undefined\n): Promise<string[]> {\n  debugLog(\n    `getPackageFilesForScan: resolving ${inputPaths.length} paths:\\n`,\n    inputPaths\n  )\n\n  // Lazily access constants.spinner.\n  const { spinner } = constants\n\n  const patterns = pathsToGlobPatterns(inputPaths)\n\n  spinner.start('Searching for local files to include in scan...')\n\n  const entries = await globWithGitIgnore(patterns, {\n    cwd,\n    socketConfig: config\n  })\n\n  if (isDebug()) {\n    spinner.stop()\n    debugLog(\n      `Resolved ${inputPaths.length} paths to ${entries.length} local paths:\\n`,\n      entries\n    )\n    spinner.start('Searching for files now...')\n  } else {\n    spinner.start(\n      `Resolved ${inputPaths.length} paths to ${entries.length} local paths, searching for files now...`\n    )\n  }\n\n  const packageFiles = await filterGlobResultToSupportedFiles(\n    entries,\n    supportedFiles\n  )\n\n  spinner.successAndStop(\n    `Found ${packageFiles.length} local ${pluralize('file', packageFiles.length)}`\n  )\n  debugLog('Absolute paths:\\n', packageFiles)\n\n  return packageFiles\n}\n","import { existsSync } from 'node:fs'\nimport Module from 'node:module'\nimport path from 'node:path'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../constants.mts'\nimport { findBinPathDetailsSync, findNpmPathSync } from './path-resolve.mts'\n\nconst { NODE_MODULES, NPM, NPX, SOCKET_CLI_ISSUES_URL } = constants\n\nfunction exitWithBinPathError(binName: string): never {\n  logger.fail(\n    `Socket unable to locate ${binName}; ensure it is available in the PATH environment variable`\n  )\n  // The exit code 127 indicates that the command or binary being executed\n  // could not be found.\n  // eslint-disable-next-line n/no-process-exit\n  process.exit(127)\n}\n\nlet _npmBinPathDetails: ReturnType<typeof findBinPathDetailsSync> | undefined\nfunction getNpmBinPathDetails(): ReturnType<typeof findBinPathDetailsSync> {\n  if (_npmBinPathDetails === undefined) {\n    _npmBinPathDetails = findBinPathDetailsSync(NPM)\n  }\n  return _npmBinPathDetails\n}\n\nlet _npxBinPathDetails: ReturnType<typeof findBinPathDetailsSync> | undefined\nfunction getNpxBinPathDetails(): ReturnType<typeof findBinPathDetailsSync> {\n  if (_npxBinPathDetails === undefined) {\n    _npxBinPathDetails = findBinPathDetailsSync(NPX)\n  }\n  return _npxBinPathDetails\n}\n\nexport function isNpmBinPathShadowed() {\n  return getNpmBinPathDetails().shadowed\n}\n\nexport function isNpxBinPathShadowed() {\n  return getNpxBinPathDetails().shadowed\n}\n\nlet _npmBinPath: string | undefined\nexport function getNpmBinPath(): string {\n  if (_npmBinPath === undefined) {\n    _npmBinPath = getNpmBinPathDetails().path\n    if (!_npmBinPath) {\n      exitWithBinPathError(NPM)\n    }\n  }\n  return _npmBinPath\n}\n\nlet _npmPath: string | undefined\nexport function getNpmPath() {\n  if (_npmPath === undefined) {\n    const npmBinPath = getNpmBinPath()\n    _npmPath = npmBinPath ? findNpmPathSync(npmBinPath) : undefined\n    if (!_npmPath) {\n      let message = 'Unable to find npm CLI install directory.'\n      if (npmBinPath) {\n        message += `\\nSearched parent directories of ${path.dirname(npmBinPath)}.`\n      }\n      message += `\\n\\nThis is may be a bug with socket-npm related to changes to the npm CLI.\\nPlease report to ${SOCKET_CLI_ISSUES_URL}.`\n      logger.fail(message)\n      // The exit code 127 indicates that the command or binary being executed\n      // could not be found.\n      // eslint-disable-next-line n/no-process-exit\n      process.exit(127)\n    }\n  }\n  return _npmPath\n}\n\nlet _npmRequire: NodeJS.Require | undefined\nexport function getNpmRequire(): NodeJS.Require {\n  if (_npmRequire === undefined) {\n    const npmPath = getNpmPath()\n    const npmNmPath = path.join(npmPath, NODE_MODULES, NPM)\n    _npmRequire = Module.createRequire(\n      path.join(existsSync(npmNmPath) ? npmNmPath : npmPath, '<dummy-basename>')\n    )\n  }\n  return _npmRequire\n}\n\nlet _npxBinPath: string | undefined\nexport function getNpxBinPath(): string {\n  if (_npxBinPath === undefined) {\n    _npxBinPath = getNpxBinPathDetails().path\n    if (!_npxBinPath) {\n      exitWithBinPathError(NPX)\n    }\n  }\n  return _npxBinPath\n}\n","const helpFlags = new Set(['--help', '-h'])\n\nexport function cmdFlagsToString(args: string[]) {\n  const result = []\n  for (let i = 0, { length } = args; i < length; i += 1) {\n    if (args[i]!.startsWith('--')) {\n      // Check if the next item exists and is NOT another flag.\n      if (i + 1 < length && !args[i + 1]!.startsWith('--')) {\n        result.push(`${args[i]}=${args[i + 1]}`)\n        i += 1\n      } else {\n        result.push(args[i])\n      }\n    }\n  }\n  return result.join(' ')\n}\n\nexport function cmdPrefixMessage(cmdName: string, text: string): string {\n  const cmdPrefix = cmdName ? `${cmdName}: ` : ''\n  return `${cmdPrefix}${text}`\n}\n\nexport function isHelpFlag(cmdArg: string) {\n  return helpFlags.has(cmdArg)\n}\n","import type { PackageURL } from '@socketregistry/packageurl-js'\nimport type { components } from '@socketsecurity/sdk/types/api'\n\ntype PurlLikeType = PackageURL | components['schemas']['SocketPURL']\n\nexport function getPkgFullNameFromPurlObj(purlObj: PurlLikeType): string {\n  const { name, namespace } = purlObj\n  return namespace\n    ? `${namespace}${purlObj.type === 'maven' ? ':' : '/'}${name}`\n    : name\n}\n\nexport function getSocketDevAlertUrl(alertType: string): string {\n  return `https://socket.dev/alerts/${alertType}`\n}\n\nexport function getSocketDevPackageOverviewUrlFromPurl(\n  purlObj: PurlLikeType\n): string {\n  const fullName = getPkgFullNameFromPurlObj(purlObj)\n  return getSocketDevPackageOverviewUrl(purlObj.type, fullName, purlObj.version)\n}\n\nexport function getSocketDevPackageOverviewUrl(\n  ecosystem: string,\n  fullName: string,\n  version?: string | undefined\n): string {\n  if (ecosystem === 'go') {\n    return `https://socket.dev/go/package/${fullName}${version ? `?section=overview&version=${version}` : ''}`\n  } else {\n    return `https://socket.dev/${ecosystem}/package/${fullName}${version ? `/overview/${version}` : ''}`\n  }\n}\n","interface NestedRecord<T> {\n  [key: string]: T | NestedRecord<T>\n}\n\n/**\n * Convert a Map<string, Map|string> to a nested object of similar shape.\n * The goal is to serialize it with JSON.stringify, which Map can't do.\n */\nexport function mapToObject<T>(\n  map: Map<string, T | Map<string, T | Map<string, T>>>\n): NestedRecord<T> {\n  return Object.fromEntries(\n    Array.from(map.entries()).map(([k, v]) => [\n      k,\n      v instanceof Map ? mapToObject(v) : v\n    ])\n  )\n}\n","type NestedMap<T> = Map<string, T | NestedMap<T>>\n\nexport function* walkNestedMap<T>(\n  map: NestedMap<T>,\n  keys: string[] = []\n): Generator<{ keys: string[]; value: T }> {\n  for (const [key, value] of map.entries()) {\n    if (value instanceof Map) {\n      yield* walkNestedMap(value as NestedMap<T>, keys.concat(key))\n    } else {\n      yield { keys: keys.concat(key), value: value }\n    }\n  }\n}\n","import constants from '../../constants.mts'\n\nimport type { Remap } from '@socketsecurity/registry/lib/objects'\nimport type { components, operations } from '@socketsecurity/sdk/types/api'\n\nexport type ALERT_ACTION = 'error' | 'monitor' | 'warn' | 'ignore'\n\nexport type ALERT_TYPE = keyof NonNullable<\n  operations['getOrgSecurityPolicy']['responses']['200']['content']['application/json']['securityPolicyRules']\n>\n\nexport type CVE_ALERT_TYPE = 'cve' | 'mediumCVE' | 'mildCVE' | 'criticalCVE'\n\nexport type ArtifactAlertCve = Remap<\n  Omit<CompactSocketArtifactAlert, 'type'> & {\n    type: CVE_ALERT_TYPE\n  }\n>\n\nexport type ArtifactAlertCveFixable = Remap<\n  Omit<CompactSocketArtifactAlert, 'props' | 'type'> & {\n    type: CVE_ALERT_TYPE\n    props: {\n      firstPatchedVersionIdentifier: string\n      vulnerableVersionRange: string\n      [key: string]: any\n    }\n  }\n>\n\nexport type ArtifactAlertUpgrade = Remap<\n  Omit<CompactSocketArtifactAlert, 'type'> & {\n    type: 'socketUpgradeAvailable'\n  }\n>\n\nexport type CompactSocketArtifactAlert = Remap<\n  Omit<SocketArtifactAlert, 'category' | 'end' | 'file' | 'start'>\n>\n\nexport type CompactSocketArtifact = Remap<\n  Omit<SocketArtifact, 'alerts' | 'batchIndex' | 'size'> & {\n    alerts: CompactSocketArtifactAlert[]\n  }\n>\n\nexport type SocketArtifact = Remap<\n  Omit<components['schemas']['SocketArtifact'], 'alerts'> & {\n    alerts?: SocketArtifactAlert[]\n  }\n>\n\nexport type SocketArtifactAlert = Remap<\n  Omit<components['schemas']['SocketAlert'], 'action' | 'props' | 'type'> & {\n    type: ALERT_TYPE\n    action?: 'error' | 'monitor' | 'warn' | 'ignore'\n    props?: any | undefined\n  }\n>\n\nconst {\n  ALERT_TYPE_CRITICAL_CVE,\n  ALERT_TYPE_CVE,\n  ALERT_TYPE_MEDIUM_CVE,\n  ALERT_TYPE_MILD_CVE\n} = constants\n\nexport function isArtifactAlertCve(\n  alert: CompactSocketArtifactAlert\n): alert is ArtifactAlertCve {\n  const { type } = alert\n  return (\n    type === ALERT_TYPE_CVE ||\n    type === ALERT_TYPE_MEDIUM_CVE ||\n    type === ALERT_TYPE_MILD_CVE ||\n    type === ALERT_TYPE_CRITICAL_CVE\n  )\n}\n","export function createEnum<const T extends Record<string, any>>(\n  obj: T\n): Readonly<T> {\n  return Object.freeze({ __proto__: null, ...obj }) as any\n}\n\nexport function pick<T extends Record<string, any>, K extends keyof T>(\n  input: T,\n  keys: K[] | readonly K[]\n): Pick<T, K> {\n  const result: Partial<Pick<T, K>> = {}\n  for (const key of keys) {\n    result[key] = input[key]\n  }\n  return result as Pick<T, K>\n}\n","import { createEnum } from '../objects.mts'\n\nexport const ALERT_FIX_TYPE = createEnum({\n  cve: 'cve',\n  remove: 'remove',\n  upgrade: 'upgrade'\n})\n","export function stringJoinWithSeparateFinalSeparator(\n  list: string[],\n  separator: string = ' and '\n): string {\n  const values = list.filter(Boolean)\n  const { length } = values\n  if (!length) {\n    return ''\n  }\n  if (length === 1) {\n    return values[0]!\n  }\n  const finalValue = values.pop()\n  return `${values.join(', ')}${separator}${finalValue}`\n}\n","import { createEnum, pick } from '../objects.mts'\nimport { stringJoinWithSeparateFinalSeparator } from '../strings.mts'\n\nimport type { SocketSdkReturnType } from '@socketsecurity/sdk'\n\nexport const ALERT_SEVERITY = createEnum({\n  critical: 'critical',\n  high: 'high',\n  middle: 'middle',\n  low: 'low'\n})\n\nexport type SocketSdkAlertList =\n  SocketSdkReturnType<'getIssuesByNPMPackage'>['data']\n\nexport type SocketSdkAlert = SocketSdkAlertList[number]['value'] extends\n  | infer U\n  | undefined\n  ? U\n  : never\n\n// Ordered from most severe to least.\nexport const ALERT_SEVERITIES_SORTED: ReadonlyArray<\n  SocketSdkAlert['severity']\n> = Object.freeze(['critical', 'high', 'middle', 'low'])\n\nfunction getDesiredSeverities(\n  lowestToInclude: SocketSdkAlert['severity'] | undefined\n): Array<SocketSdkAlert['severity']> {\n  const result: Array<SocketSdkAlert['severity']> = []\n  for (const severity of ALERT_SEVERITIES_SORTED) {\n    result.push(severity)\n    if (severity === lowestToInclude) {\n      break\n    }\n  }\n  return result\n}\n\nexport function formatSeverityCount(\n  severityCount: Record<SocketSdkAlert['severity'], number>\n): string {\n  const summary: string[] = []\n  for (const severity of ALERT_SEVERITIES_SORTED) {\n    if (severityCount[severity]) {\n      summary.push(`${severityCount[severity]} ${severity}`)\n    }\n  }\n  return stringJoinWithSeparateFinalSeparator(summary)\n}\n\nexport function getSeverityCount(\n  issues: SocketSdkAlertList,\n  lowestToInclude: SocketSdkAlert['severity'] | undefined\n): Record<SocketSdkAlert['severity'], number> {\n  const severityCount = pick(\n    { low: 0, middle: 0, high: 0, critical: 0 },\n    getDesiredSeverities(lowestToInclude)\n  ) as Record<SocketSdkAlert['severity'], number>\n\n  for (const issue of issues) {\n    const { value } = issue\n    if (!value) {\n      continue\n    }\n    const { severity } = value\n    if (severityCount[severity] !== undefined) {\n      severityCount[severity] += 1\n    }\n  }\n  return severityCount\n}\n","import terminalLink from 'terminal-link'\nimport colors from 'yoctocolors-cjs'\n\nimport indentString from '@socketregistry/indent-string/index.cjs'\n\nexport class ColorOrMarkdown {\n  public useMarkdown: boolean\n\n  constructor(useMarkdown: boolean) {\n    this.useMarkdown = !!useMarkdown\n  }\n\n  bold(text: string): string {\n    return this.useMarkdown ? `**${text}**` : colors.bold(`${text}`)\n  }\n\n  header(text: string, level = 1): string {\n    return this.useMarkdown\n      ? `\\n${''.padStart(level, '#')} ${text}\\n`\n      : colors.underline(`\\n${level === 1 ? colors.bold(text) : text}\\n`)\n  }\n\n  hyperlink(\n    text: string,\n    url: string | undefined,\n    {\n      fallback = true,\n      fallbackToUrl\n    }: {\n      fallback?: boolean | undefined\n      fallbackToUrl?: boolean | undefined\n    } = {}\n  ) {\n    if (url) {\n      return this.useMarkdown\n        ? `[${text}](${url})`\n        : terminalLink(text, url, {\n            fallback: fallbackToUrl ? (_text, url) => url : fallback\n          })\n    }\n    return text\n  }\n\n  indent(\n    ...args: Parameters<typeof indentString>\n  ): ReturnType<typeof indentString> {\n    return indentString(...args)\n  }\n\n  italic(text: string): string {\n    return this.useMarkdown ? `_${text}_` : colors.italic(`${text}`)\n  }\n\n  json(value: any): string {\n    return this.useMarkdown\n      ? '```json\\n' + JSON.stringify(value) + '\\n```'\n      : JSON.stringify(value)\n  }\n\n  list(items: string[]): string {\n    const indentedContent = items.map(item => this.indent(item).trimStart())\n    return this.useMarkdown\n      ? `* ${indentedContent.join('\\n* ')}\\n`\n      : `${indentedContent.join('\\n')}\\n`\n  }\n}\n","import { createRequire } from 'node:module'\nimport path from 'node:path'\n\nimport constants from '../constants.mts'\n\nconst require = createRequire(import.meta.url)\n\nlet _translations: typeof import('../../translations.json') | undefined\n\nexport function getTranslations() {\n  if (_translations === undefined) {\n    _translations = require(\n      // Lazily access constants.rootPath.\n      path.join(constants.rootPath, 'translations.json')\n    )\n  }\n  return _translations!\n}\n","import semver from 'semver'\n\nimport { PackageURL } from '@socketregistry/packageurl-js'\n\nexport function idToPurl(id: string): string {\n  return `pkg:npm/${id}`\n}\n\nexport function resolvePackageVersion(purlObj: PackageURL): string {\n  const { version } = purlObj\n  return version ? (semver.coerce(stripPeerSuffix(version))?.version ?? '') : ''\n}\n\nexport function stripLeadingSlash(path: string): string {\n  return path.startsWith('/') ? path.slice(1) : path\n}\n\nexport function stripPeerSuffix(depPath: string): string {\n  const idx = depPath.indexOf('(')\n  return idx === -1 ? depPath : depPath.slice(0, idx)\n}\n","import semver from 'semver'\nimport colors from 'yoctocolors-cjs'\n\nimport { PackageURL } from '@socketregistry/packageurl-js'\nimport { getManifestData } from '@socketsecurity/registry'\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { hasOwn } from '@socketsecurity/registry/lib/objects'\nimport { resolvePackageName } from '@socketsecurity/registry/lib/packages'\nimport { naturalCompare } from '@socketsecurity/registry/lib/sorts'\n\nimport { isArtifactAlertCve } from './alert/artifact.mts'\nimport { ALERT_FIX_TYPE } from './alert/fix.mts'\nimport { ALERT_SEVERITY } from './alert/severity.mts'\nimport { ColorOrMarkdown } from './color-or-markdown.mts'\nimport { getSocketDevPackageOverviewUrl } from './socket-url.mts'\nimport { getTranslations } from './translations.mts'\nimport constants from '../constants.mts'\nimport { findSocketYmlSync } from './config.mts'\nimport { createEnum } from './objects.mts'\nimport { idToPurl } from './spec.mts'\n\nimport type {\n  ALERT_ACTION,\n  ALERT_TYPE,\n  CompactSocketArtifact,\n  CompactSocketArtifactAlert\n} from './alert/artifact.mts'\nimport type { Spinner } from '@socketsecurity/registry/lib/spinner'\n\nexport const ALERT_SEVERITY_COLOR = createEnum({\n  critical: 'magenta',\n  high: 'red',\n  middle: 'yellow',\n  low: 'white'\n})\n\nexport const ALERT_SEVERITY_ORDER = createEnum({\n  critical: 0,\n  high: 1,\n  middle: 2,\n  low: 3,\n  none: 4\n})\n\nexport type SocketPackageAlert = {\n  name: string\n  version: string\n  key: string\n  type: string\n  blocked: boolean\n  critical: boolean\n  fixable: boolean\n  raw: CompactSocketArtifactAlert\n  upgradable: boolean\n}\n\nexport type AlertsByPkgId = Map<string, SocketPackageAlert[]>\n\nconst { CVE_ALERT_PROPS_FIRST_PATCHED_VERSION_IDENTIFIER, NPM } = constants\n\nconst MIN_ABOVE_THE_FOLD_COUNT = 3\n\nconst MIN_ABOVE_THE_FOLD_ALERT_COUNT = 1\n\nconst format = new ColorOrMarkdown(false)\n\nfunction alertsHaveBlocked(alerts: SocketPackageAlert[]): boolean {\n  return alerts.find(a => a.blocked) !== undefined\n}\n\nfunction alertsHaveSeverity(\n  alerts: SocketPackageAlert[],\n  severity: `${keyof typeof ALERT_SEVERITY}`\n): boolean {\n  return alerts.find(a => a.raw.severity === severity) !== undefined\n}\n\nfunction alertSeverityComparator(\n  a: SocketPackageAlert,\n  b: SocketPackageAlert\n): number {\n  return getAlertSeverityOrder(a) - getAlertSeverityOrder(b)\n}\n\nfunction getAlertSeverityOrder(alert: SocketPackageAlert): number {\n  const { severity } = alert.raw\n  return severity === ALERT_SEVERITY.critical\n    ? 0\n    : severity === ALERT_SEVERITY.high\n      ? 1\n      : severity === ALERT_SEVERITY.middle\n        ? 2\n        : severity === ALERT_SEVERITY.low\n          ? 3\n          : 4\n}\n\nfunction getAlertsSeverityOrder(alerts: SocketPackageAlert[]): number {\n  return alertsHaveBlocked(alerts) ||\n    alertsHaveSeverity(alerts, ALERT_SEVERITY.critical)\n    ? 0\n    : alertsHaveSeverity(alerts, ALERT_SEVERITY.high)\n      ? 1\n      : alertsHaveSeverity(alerts, ALERT_SEVERITY.middle)\n        ? 2\n        : alertsHaveSeverity(alerts, ALERT_SEVERITY.low)\n          ? 3\n          : 4\n}\n\nexport type RiskCounts = {\n  critical: number\n  high: number\n  middle: number\n  low: number\n}\n\nfunction getHiddenRiskCounts(hiddenAlerts: SocketPackageAlert[]): RiskCounts {\n  const riskCounts = {\n    critical: 0,\n    high: 0,\n    middle: 0,\n    low: 0\n  }\n  for (const alert of hiddenAlerts) {\n    switch (getAlertSeverityOrder(alert)) {\n      case ALERT_SEVERITY_ORDER.critical:\n        riskCounts.critical += 1\n        break\n      case ALERT_SEVERITY_ORDER.high:\n        riskCounts.high += 1\n        break\n      case ALERT_SEVERITY_ORDER.middle:\n        riskCounts.middle += 1\n        break\n      case ALERT_SEVERITY_ORDER.low:\n        riskCounts.low += 1\n        break\n    }\n  }\n  return riskCounts\n}\n\nfunction getHiddenRisksDescription(riskCounts: RiskCounts): string {\n  const descriptions: string[] = []\n  if (riskCounts.critical) {\n    descriptions.push(`${riskCounts.critical} ${getSeverityLabel('critical')}`)\n  }\n  if (riskCounts.high) {\n    descriptions.push(`${riskCounts.high} ${getSeverityLabel('high')}`)\n  }\n  if (riskCounts.middle) {\n    descriptions.push(`${riskCounts.middle} ${getSeverityLabel('middle')}`)\n  }\n  if (riskCounts.low) {\n    descriptions.push(`${riskCounts.low} ${getSeverityLabel('low')}`)\n  }\n  return `(${descriptions.join('; ')})`\n}\n\nfunction getSeverityLabel(severity: `${keyof typeof ALERT_SEVERITY}`): string {\n  return severity === 'middle' ? 'moderate' : severity\n}\n\nexport type AlertIncludeFilter = {\n  actions?: ALERT_ACTION[] | undefined\n  blocked?: boolean | undefined\n  critical?: boolean | undefined\n  cve?: boolean | undefined\n  existing?: boolean | undefined\n  unfixable?: boolean | undefined\n  upgradable?: boolean | undefined\n}\n\nexport type AddSocketArtifactAlertToAlertsMapOptions = {\n  consolidate?: boolean | undefined\n  include?: AlertIncludeFilter | undefined\n  overrides?: { [key: string]: string } | undefined\n  spinner?: Spinner | undefined\n}\n\nexport async function addArtifactToAlertsMap<T extends AlertsByPkgId>(\n  artifact: CompactSocketArtifact,\n  alertsByPkgId: T,\n  options?: AddSocketArtifactAlertToAlertsMapOptions | undefined\n): Promise<T> {\n  // Make TypeScript happy.\n  if (!artifact.name || !artifact.version || !artifact.alerts?.length) {\n    return alertsByPkgId\n  }\n  const {\n    consolidate = false,\n    include: _include,\n    overrides\n  } = {\n    __proto__: null,\n    ...options\n  } as AddSocketArtifactAlertToAlertsMapOptions\n\n  const include = {\n    __proto__: null,\n    actions: undefined,\n    blocked: true,\n    critical: true,\n    cve: true,\n    existing: false,\n    unfixable: true,\n    upgradable: false,\n    ..._include\n  } as AlertIncludeFilter\n\n  const name = resolvePackageName(artifact)\n  const { version } = artifact\n  const pkgId = `${name}@${version}`\n  const major = semver.major(version)\n  const socketYml = findSocketYmlSync()\n  const enabledState = {\n    __proto__: null,\n    ...socketYml?.parsed.issueRules\n  } as Partial<Record<ALERT_TYPE, boolean>>\n  let sockPkgAlerts: SocketPackageAlert[] = []\n  for (const alert of artifact.alerts) {\n    const action = alert.action ?? ''\n    const enabledFlag = enabledState[alert.type]\n    if (\n      (action === 'ignore' && enabledFlag !== true) ||\n      enabledFlag === false\n    ) {\n      continue\n    }\n    const blocked = action === 'error'\n    const critical = alert.severity === ALERT_SEVERITY.critical\n    const cve = isArtifactAlertCve(alert)\n    const fixType = alert.fix?.type ?? ''\n    const fixableCve = fixType === ALERT_FIX_TYPE.cve\n    const fixableUpgrade = fixType === ALERT_FIX_TYPE.upgrade\n    const fixable = fixableCve || fixableUpgrade\n    const upgradable = fixableUpgrade && !hasOwn(overrides, name)\n    if (\n      (include.blocked && blocked) ||\n      (include.critical && critical) ||\n      (include.cve && cve) ||\n      (include.unfixable && !fixable) ||\n      (include.upgradable && upgradable)\n    ) {\n      sockPkgAlerts.push({\n        name,\n        version,\n        key: alert.key,\n        type: alert.type,\n        blocked,\n        critical,\n        fixable,\n        raw: alert,\n        upgradable\n      })\n    }\n  }\n  if (!sockPkgAlerts.length) {\n    return alertsByPkgId\n  }\n  if (consolidate) {\n    const highestForCve = new Map<\n      number,\n      { alert: SocketPackageAlert; version: string }\n    >()\n    const highestForUpgrade = new Map<\n      number,\n      { alert: SocketPackageAlert; version: string }\n    >()\n    const unfixableAlerts: SocketPackageAlert[] = []\n    for (const sockPkgAlert of sockPkgAlerts) {\n      const alert = sockPkgAlert.raw\n      const fixType = alert.fix?.type ?? ''\n      if (fixType === ALERT_FIX_TYPE.cve) {\n        const patchedVersion =\n          alert.props[CVE_ALERT_PROPS_FIRST_PATCHED_VERSION_IDENTIFIER]\n        const patchedMajor = semver.major(patchedVersion)\n        const oldHighest = highestForCve.get(patchedMajor)\n        const highest = oldHighest?.version ?? '0.0.0'\n        if (semver.gt(patchedVersion, highest)) {\n          highestForCve.set(patchedMajor, {\n            alert: sockPkgAlert,\n            version: patchedVersion\n          })\n        }\n      } else if (fixType === ALERT_FIX_TYPE.upgrade) {\n        const oldHighest = highestForUpgrade.get(major)\n        const highest = oldHighest?.version ?? '0.0.0'\n        if (semver.gt(version, highest)) {\n          highestForUpgrade.set(major, { alert: sockPkgAlert, version })\n        }\n      } else {\n        unfixableAlerts.push(sockPkgAlert)\n      }\n    }\n    sockPkgAlerts = [\n      ...unfixableAlerts,\n      ...[...highestForCve.values()].map(d => d.alert),\n      ...[...highestForUpgrade.values()].map(d => d.alert)\n    ]\n  }\n  if (sockPkgAlerts.length) {\n    sockPkgAlerts.sort((a, b) => naturalCompare(a.type, b.type))\n    alertsByPkgId.set(pkgId, sockPkgAlerts)\n  }\n  return alertsByPkgId\n}\n\nexport type CveExcludeFilter = {\n  upgradable?: boolean | undefined\n}\n\nexport type CveInfoByPkgId = Map<\n  string,\n  Array<{\n    firstPatchedVersionIdentifier: string\n    vulnerableVersionRange: string\n  }>\n>\n\nexport type GetCveInfoByPackageOptions = {\n  exclude?: CveExcludeFilter | undefined\n  limit?: number | undefined\n}\n\nexport function getCveInfoByAlertsMap(\n  alertsMap: AlertsByPkgId,\n  options?: GetCveInfoByPackageOptions | undefined\n): CveInfoByPkgId | null {\n  const { exclude: _exclude, limit = Infinity } = {\n    __proto__: null,\n    ...options\n  } as GetCveInfoByPackageOptions\n  const exclude = {\n    __proto__: null,\n    upgradable: true,\n    ..._exclude\n  } as CveExcludeFilter\n\n  let count = 0\n  let infoByPkg: CveInfoByPkgId | null = null\n  alertsMapLoop: for (const [pkgId, sockPkgAlerts] of alertsMap) {\n    const purlObj = PackageURL.fromString(idToPurl(pkgId))\n    const name = resolvePackageName(purlObj)\n    for (const sockPkgAlert of sockPkgAlerts) {\n      const alert = sockPkgAlert.raw\n      if (\n        alert.fix?.type !== ALERT_FIX_TYPE.cve ||\n        (exclude.upgradable && getManifestData(NPM, name))\n      ) {\n        continue\n      }\n      if (!infoByPkg) {\n        infoByPkg = new Map()\n      }\n      let infos = infoByPkg.get(name)\n      if (!infos) {\n        infos = []\n        infoByPkg.set(name, infos)\n      }\n      const { firstPatchedVersionIdentifier, vulnerableVersionRange } =\n        alert.props\n      try {\n        infos.push({\n          firstPatchedVersionIdentifier,\n          vulnerableVersionRange: new semver.Range(\n            // Replace ', ' in a range like '>= 1.0.0, < 1.8.2' with ' ' so that\n            // semver.Range will parse it without erroring.\n            vulnerableVersionRange.replace(/, +/g, ' ')\n          ).format()\n        })\n        if (++count >= limit) {\n          break alertsMapLoop\n        }\n      } catch (e) {\n        debugLog('getCveInfoByAlertsMap', {\n          firstPatchedVersionIdentifier,\n          vulnerableVersionRange\n        })\n        debugLog(e)\n      }\n    }\n  }\n  return infoByPkg\n}\n\nexport type LogAlertsMapOptions = {\n  hideAt?: `${keyof typeof ALERT_SEVERITY}` | 'none' | undefined\n  output?: NodeJS.WriteStream | undefined\n}\n\nexport function logAlertsMap(\n  alertsMap: AlertsByPkgId,\n  options: LogAlertsMapOptions\n) {\n  const { hideAt = 'middle', output = process.stderr } = {\n    __proto__: null,\n    ...options\n  } as LogAlertsMapOptions\n\n  const translations = getTranslations()\n  const sortedEntries = [...alertsMap.entries()].sort(\n    (a, b) => getAlertsSeverityOrder(a[1]) - getAlertsSeverityOrder(b[1])\n  )\n\n  const aboveTheFoldPkgIds = new Set<string>()\n  const viewableAlertsByPkgId = new Map<string, SocketPackageAlert[]>()\n  const hiddenAlertsByPkgId = new Map<string, SocketPackageAlert[]>()\n\n  for (let i = 0, { length } = sortedEntries; i < length; i += 1) {\n    const { 0: pkgId, 1: alerts } = sortedEntries[i]!\n    const hiddenAlerts: typeof alerts = []\n    const viewableAlerts = alerts.filter(a => {\n      const keep =\n        a.blocked || getAlertSeverityOrder(a) < ALERT_SEVERITY_ORDER[hideAt]\n      if (!keep) {\n        hiddenAlerts.push(a)\n      }\n      return keep\n    })\n    if (hiddenAlerts.length) {\n      hiddenAlertsByPkgId.set(pkgId, hiddenAlerts.sort(alertSeverityComparator))\n    }\n    if (!viewableAlerts.length) {\n      continue\n    }\n    viewableAlerts.sort(alertSeverityComparator)\n    viewableAlertsByPkgId.set(pkgId, viewableAlerts)\n    if (\n      viewableAlerts.find(\n        (a: SocketPackageAlert) =>\n          a.blocked || getAlertSeverityOrder(a) < ALERT_SEVERITY_ORDER.middle\n      )\n    ) {\n      aboveTheFoldPkgIds.add(pkgId)\n    }\n  }\n\n  // If MIN_ABOVE_THE_FOLD_COUNT is NOT met add more from viewable pkg ids.\n  for (const { 0: pkgId } of viewableAlertsByPkgId.entries()) {\n    if (aboveTheFoldPkgIds.size >= MIN_ABOVE_THE_FOLD_COUNT) {\n      break\n    }\n    aboveTheFoldPkgIds.add(pkgId)\n  }\n  // If MIN_ABOVE_THE_FOLD_COUNT is STILL NOT met add more from hidden pkg ids.\n  for (const { 0: pkgId, 1: hiddenAlerts } of hiddenAlertsByPkgId.entries()) {\n    if (aboveTheFoldPkgIds.size >= MIN_ABOVE_THE_FOLD_COUNT) {\n      break\n    }\n    aboveTheFoldPkgIds.add(pkgId)\n    const viewableAlerts = viewableAlertsByPkgId.get(pkgId) ?? []\n    if (viewableAlerts.length < MIN_ABOVE_THE_FOLD_ALERT_COUNT) {\n      const neededCount = MIN_ABOVE_THE_FOLD_ALERT_COUNT - viewableAlerts.length\n      let removedHiddenAlerts: SocketPackageAlert[] | undefined\n      if (hiddenAlerts.length - neededCount > 0) {\n        removedHiddenAlerts = hiddenAlerts.splice(\n          0,\n          MIN_ABOVE_THE_FOLD_ALERT_COUNT\n        )\n      } else {\n        removedHiddenAlerts = hiddenAlerts\n        hiddenAlertsByPkgId.delete(pkgId)\n      }\n      viewableAlertsByPkgId.set(pkgId, [\n        ...viewableAlerts,\n        ...removedHiddenAlerts\n      ])\n    }\n  }\n\n  const mentionedPkgIdsWithHiddenAlerts = new Set<string>()\n  for (\n    let i = 0,\n      prevAboveTheFold = true,\n      entries = [...viewableAlertsByPkgId.entries()],\n      { length } = entries;\n    i < length;\n    i += 1\n  ) {\n    const { 0: pkgId, 1: alerts } = entries[i]!\n    const lines = new Set<string>()\n    for (const alert of alerts) {\n      const { type } = alert\n      const severity = alert.raw.severity ?? ''\n      const attributes = [\n        ...(severity\n          ? [colors[ALERT_SEVERITY_COLOR[severity]](getSeverityLabel(severity))]\n          : []),\n        ...(alert.blocked ? [colors.bold(colors.red('blocked'))] : []),\n        ...(alert.fixable ? ['fixable'] : [])\n      ]\n      const maybeAttributes = attributes.length\n        ? ` ${colors.italic(`(${attributes.join('; ')})`)}`\n        : ''\n      // Based data from { pageProps: { alertTypes } } of:\n      // https://socket.dev/_next/data/94666139314b6437ee4491a0864e72b264547585/en-US.json\n      const info = (translations.alerts as any)[type]\n      const title = info?.title ?? type\n      const maybeDesc = info?.description ? ` - ${info.description}` : ''\n      const content = `${title}${maybeAttributes}${maybeDesc}`\n      // TODO: emoji seems to mis-align terminals sometimes\n      lines.add(`  ${content}`)\n    }\n    const purlObj = PackageURL.fromString(idToPurl(pkgId))\n    const hyperlink = format.hyperlink(\n      pkgId,\n      getSocketDevPackageOverviewUrl(\n        NPM,\n        resolvePackageName(purlObj),\n        purlObj.version\n      )\n    )\n    const isAboveTheFold = aboveTheFoldPkgIds.has(pkgId)\n    if (isAboveTheFold) {\n      aboveTheFoldPkgIds.add(pkgId)\n      output.write(`${i ? '\\n' : ''}${hyperlink}:\\n`)\n    } else {\n      output.write(`${prevAboveTheFold ? '\\n' : ''}${hyperlink}:\\n`)\n    }\n    for (const line of lines) {\n      output.write(`${line}\\n`)\n    }\n    const hiddenAlerts = hiddenAlertsByPkgId.get(pkgId) ?? []\n    const { length: hiddenAlertsCount } = hiddenAlerts\n    if (hiddenAlertsCount) {\n      mentionedPkgIdsWithHiddenAlerts.add(pkgId)\n      if (hiddenAlertsCount === 1) {\n        output.write(\n          `  ${colors.dim(`+1 Hidden ${getSeverityLabel(hiddenAlerts[0]!.raw.severity ?? 'low')} risk alert`)}\\n`\n        )\n      } else {\n        output.write(\n          `  ${colors.dim(`+${hiddenAlertsCount} Hidden alerts ${colors.italic(getHiddenRisksDescription(getHiddenRiskCounts(hiddenAlerts)))}`)}\\n`\n        )\n      }\n    }\n    prevAboveTheFold = isAboveTheFold\n  }\n\n  const additionalHiddenCount =\n    hiddenAlertsByPkgId.size - mentionedPkgIdsWithHiddenAlerts.size\n  if (additionalHiddenCount) {\n    const totalRiskCounts = {\n      critical: 0,\n      high: 0,\n      middle: 0,\n      low: 0\n    }\n    for (const { 0: pkgId, 1: alerts } of hiddenAlertsByPkgId.entries()) {\n      if (mentionedPkgIdsWithHiddenAlerts.has(pkgId)) {\n        continue\n      }\n      const riskCounts = getHiddenRiskCounts(alerts)\n      totalRiskCounts.critical += riskCounts.critical\n      totalRiskCounts.high += riskCounts.high\n      totalRiskCounts.middle += riskCounts.middle\n      totalRiskCounts.low += riskCounts.low\n    }\n    output.write(\n      `${aboveTheFoldPkgIds.size ? '\\n' : ''}${colors.dim(`${aboveTheFoldPkgIds.size ? '+' : ''}${additionalHiddenCount} Packages with hidden alerts ${colors.italic(getHiddenRisksDescription(totalRiskCounts))}`)}\\n`\n    )\n  }\n  output.write('\\n')\n}\n","import semver from 'semver'\n\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\n\nexport const RangeStyles = ['caret', 'gt', 'lt', 'pin', 'preserve', 'tilde']\n\nexport type RangeStyle =\n  | 'caret'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'pin'\n  | 'preserve'\n  | 'tilde'\n\nexport function applyRange(\n  refRange: string,\n  version: string,\n  style: RangeStyle = 'preserve'\n): string {\n  switch (style) {\n    case 'caret':\n      return `^${version}`\n    case 'gt':\n      return `>${version}`\n    case 'gte':\n      return `>=${version}`\n    case 'lt':\n      return `<${version}`\n    case 'lte':\n      return `<=${version}`\n    case 'preserve': {\n      const range = new semver.Range(refRange)\n      const { raw } = range\n      const comparators = [...range.set].flat()\n      const { length } = comparators\n      if (length === 1) {\n        const char = /^[<>]=?/.exec(raw)?.[0]\n        if (char) {\n          return `${char}${version}`\n        }\n      } else if (length === 2) {\n        const char = /^[~^]/.exec(raw)?.[0]\n        if (char) {\n          return `${char}${version}`\n        }\n      }\n      return version\n    }\n    case 'tilde':\n      return `~${version}`\n    case 'pin':\n    default:\n      return version\n  }\n}\n\nexport function getMajor(version: string): number | null {\n  const coerced = semver.coerce(version)\n  if (coerced) {\n    try {\n      return semver.major(coerced)\n    } catch (e) {\n      debugLog(`Error parsing '${version}':\\n`, e)\n    }\n  }\n  return null\n}\n","import { refToRelative } from '@pnpm/dependency-path'\nimport { detectDepTypes } from '@pnpm/lockfile.detect-dep-types'\nimport semver from 'semver'\n\nimport { PackageURL } from '@socketregistry/packageurl-js'\nimport { resolvePackageName } from '@socketsecurity/registry/lib/packages'\n\nimport {\n  idToPurl,\n  resolvePackageVersion,\n  stripLeadingSlash,\n  stripPeerSuffix\n} from './spec.mts'\n\nimport type { LockfileObject } from '@pnpm/lockfile.fs'\nimport type { SemVer } from 'semver'\n\nexport function extractPurlsFromPnpmLockfileV6(\n  lockfile: LockfileObject\n): string[] {\n  const deps = new Set<string>()\n  for (const importer of Object.values(lockfile.importers || {})) {\n    if (importer.dependencies) {\n      for (const { 0: alias, 1: ref } of Object.entries(\n        importer.dependencies\n      )) {\n        const id = resolvePnpmPackageId(alias, ref)\n        if (id) {\n          deps.add(idToPurl(id))\n        }\n      }\n    }\n    if (importer.devDependencies) {\n      for (const { 0: alias, 1: ref } of Object.entries(\n        importer.devDependencies\n      )) {\n        const id = resolvePnpmPackageId(alias, ref)\n        if (id) {\n          deps.add(idToPurl(id))\n        }\n      }\n    }\n    if (importer.optionalDependencies) {\n      for (const { 0: alias, 1: ref } of Object.entries(\n        importer.optionalDependencies\n      )) {\n        const id = resolvePnpmPackageId(alias, ref)\n        if (id) {\n          deps.add(idToPurl(id))\n        }\n      }\n    }\n  }\n  if (lockfile.packages) {\n    for (const pkgPath of Object.keys(lockfile.packages)) {\n      const id = resolvePnpmPackageIdFromPath(pkgPath, '')\n      if (id) {\n        deps.add(idToPurl(id))\n      }\n    }\n  }\n  return Array.from(deps)\n}\n\nexport function extractPurlsFromPnpmLockfileV9(\n  lockfile: LockfileObject\n): string[] {\n  const depTypes = detectDepTypes(lockfile)\n  return Object.keys(depTypes).map(refId => {\n    const purlObj = PackageURL.fromString(idToPurl(refId))\n    const name = resolvePackageName(purlObj)\n    const version = resolvePackageVersion(purlObj)\n    return idToPurl(`${name}@${version}`)\n  })\n}\n\nexport function extractPurlsFromPnpmLockfile(\n  lockfile: LockfileObject\n): string[] {\n  return parsePnpmLockfileVersion(lockfile.lockfileVersion).major <= 6\n    ? extractPurlsFromPnpmLockfileV6(lockfile)\n    : extractPurlsFromPnpmLockfileV9(lockfile)\n}\n\nexport function parsePnpmLockfileVersion(version: string): SemVer {\n  return semver.coerce(version)!\n}\n\nexport function resolvePnpmPackageId(\n  alias: string,\n  ref: string\n): string | null {\n  return ref.startsWith('/')\n    ? resolvePnpmPackageIdFromPath(ref, alias)\n    : `${alias}@${stripPeerSuffix(ref)}`\n}\n\nexport function resolvePnpmPackageIdFromPath(\n  ref: string,\n  alias: string\n): string | null {\n  const relative = refToRelative(ref, alias)\n  if (relative) {\n    const id = stripLeadingSlash(relative)\n    const purlObj = PackageURL.fromString(idToPurl(id))\n    const name = resolvePackageName(purlObj)\n    const version = resolvePackageVersion(purlObj)\n    return `${name}@${version}`\n  }\n  return null\n}\n","import { arrayUnique } from '@socketsecurity/registry/lib/arrays'\n\nimport { extractPurlsFromPnpmLockfile } from './pnpm.mts'\nimport { getPublicToken, setupSdk } from './sdk.mts'\nimport { addArtifactToAlertsMap } from './socket-package-alert.mts'\n\nimport type { CompactSocketArtifact } from './alert/artifact.mts'\nimport type {\n  AlertIncludeFilter,\n  AlertsByPkgId\n} from './socket-package-alert.mts'\nimport type { LockfileObject } from '@pnpm/lockfile.fs'\nimport type { Spinner } from '@socketsecurity/registry/lib/spinner'\n\nexport type GetAlertsMapFromPnpmLockfileOptions = {\n  consolidate?: boolean | undefined\n  include?: AlertIncludeFilter | undefined\n  overrides?: { [key: string]: string } | undefined\n  nothrow?: boolean | undefined\n  spinner?: Spinner | undefined\n}\n\nexport async function getAlertsMapFromPnpmLockfile(\n  lockfile: LockfileObject,\n  options_?: GetAlertsMapFromPnpmLockfileOptions | undefined\n): Promise<AlertsByPkgId> {\n  const options = {\n    __proto__: null,\n    consolidate: false,\n    limit: Infinity,\n    nothrow: false,\n    ...options_\n  } as GetAlertsMapFromPnpmLockfileOptions\n  const purls = extractPurlsFromPnpmLockfile(lockfile)\n  return await getAlertsMapFromPurls(purls, {\n    overrides: lockfile.overrides,\n    ...options\n  })\n}\n\nexport type GetAlertsMapFromPurlsOptions = {\n  consolidate?: boolean | undefined\n  include?: AlertIncludeFilter | undefined\n  limit?: number | undefined\n  overrides?: { [key: string]: string } | undefined\n  nothrow?: boolean | undefined\n  spinner?: Spinner | undefined\n}\n\nexport async function getAlertsMapFromPurls(\n  purls: string[] | readonly string[],\n  options_?: GetAlertsMapFromPurlsOptions | undefined\n): Promise<AlertsByPkgId> {\n  const options = {\n    __proto__: null,\n    consolidate: false,\n    limit: Infinity,\n    nothrow: false,\n    ...options_\n  } as GetAlertsMapFromPurlsOptions\n\n  const include = {\n    __proto__: null,\n    actions: undefined,\n    blocked: true,\n    critical: true,\n    cve: true,\n    existing: false,\n    unfixable: true,\n    upgradable: false,\n    ...options.include\n  } as AlertIncludeFilter\n\n  const { spinner } = options\n\n  const uniqPurls = arrayUnique(purls)\n  let { length: remaining } = uniqPurls\n  const alertsByPkgId: AlertsByPkgId = new Map()\n  if (!remaining) {\n    return alertsByPkgId\n  }\n  const getText = () => `Looking up data for ${remaining} packages`\n\n  spinner?.start(getText())\n\n  const sockSdkResult = await setupSdk(getPublicToken())\n  if (!sockSdkResult.ok) {\n    throw new Error('Auth error: Try to run `socket login` first')\n  }\n  const sockSdk = sockSdkResult.data\n\n  const toAlertsMapOptions = {\n    overrides: options.overrides,\n    consolidate: options.consolidate,\n    include,\n    spinner\n  }\n\n  for await (const batchResult of sockSdk.batchPackageStream(\n    {\n      alerts: 'true',\n      compact: 'true',\n      ...(include.actions ? { actions: include.actions.join(',') } : {}),\n      ...(include.unfixable ? {} : { fixable: 'true' })\n    },\n    {\n      components: uniqPurls.map(purl => ({ purl }))\n    }\n  )) {\n    if (batchResult.success) {\n      await addArtifactToAlertsMap(\n        batchResult.data as CompactSocketArtifact,\n        alertsByPkgId,\n        toAlertsMapOptions\n      )\n    } else if (!options.nothrow) {\n      const statusCode = batchResult.status ?? 'unknown'\n      const statusMessage = batchResult.error ?? 'No status message'\n      throw new Error(\n        `Socket API server error (${statusCode}): ${statusMessage}`\n      )\n    }\n    remaining -= 1\n    if (spinner && remaining > 0) {\n      spinner.start()\n      spinner.setText(getText())\n    }\n  }\n\n  spinner?.stop()\n\n  return alertsByPkgId\n}\n","import { isDebug } from '@socketsecurity/registry/lib/debug'\nimport {\n  isAuditFlag,\n  isFundFlag,\n  isLoglevelFlag,\n  isProgressFlag,\n  realExecPathSync\n} from '@socketsecurity/registry/lib/npm'\nimport { isObject } from '@socketsecurity/registry/lib/objects'\nimport { spawn } from '@socketsecurity/registry/lib/spawn'\n\nimport constants from '../../constants.mts'\nimport { getNpmBinPath } from '../../utils/npm-paths.mts'\n\nimport type { Spinner } from '@socketsecurity/registry/lib/spinner'\n\nconst {\n  NPM,\n  SOCKET_CLI_SAFE_BIN,\n  SOCKET_CLI_SAFE_PROGRESS,\n  SOCKET_IPC_HANDSHAKE\n} = constants\n\ntype SpawnOption = Exclude<Parameters<typeof spawn>[2], undefined>\n\nexport type SafeNpmInstallOptions = SpawnOption & {\n  agentExecPath?: string | undefined\n  args?: string[] | readonly string[] | undefined\n  ipc?: object | undefined\n  spinner?: Spinner | undefined\n}\n\nexport function safeNpmInstall(options?: SafeNpmInstallOptions) {\n  const {\n    agentExecPath = getNpmBinPath(),\n    args = [],\n    ipc,\n    spinner,\n    ...spawnOptions\n  } = { __proto__: null, ...options } as SafeNpmInstallOptions\n  let stdio = spawnOptions.stdio\n  const useIpc = isObject(ipc)\n  // Include 'ipc' in the spawnOptions.stdio when an options.ipc object is provided.\n  // See https://github.com/nodejs/node/blob/v23.6.0/lib/child_process.js#L161-L166\n  // and https://github.com/nodejs/node/blob/v23.6.0/lib/internal/child_process.js#L238.\n  if (typeof stdio === 'string') {\n    stdio = useIpc ? [stdio, stdio, stdio, 'ipc'] : [stdio, stdio, stdio]\n  } else if (useIpc && Array.isArray(stdio) && !stdio.includes('ipc')) {\n    stdio = stdio.concat('ipc')\n  }\n  const useDebug = isDebug()\n  const terminatorPos = args.indexOf('--')\n  const rawBinArgs = terminatorPos === -1 ? args : args.slice(0, terminatorPos)\n  const progressArg = rawBinArgs.findLast(isProgressFlag) !== '--no-progress'\n  const binArgs = rawBinArgs.filter(\n    a => !isAuditFlag(a) && !isFundFlag(a) && !isProgressFlag(a)\n  )\n  const otherArgs = terminatorPos === -1 ? [] : args.slice(terminatorPos)\n  const isSilent = !useDebug && !binArgs.some(isLoglevelFlag)\n  const logLevelArgs = isSilent ? ['--loglevel', 'silent'] : []\n  const spawnPromise = spawn(\n    // Lazily access constants.execPath.\n    constants.execPath,\n    [\n      // Lazily access constants.nodeHardenFlags.\n      ...constants.nodeHardenFlags,\n      // Lazily access constants.nodeNoWarningsFlags.\n      ...constants.nodeNoWarningsFlags,\n      // Lazily access constants.ENV.INLINED_SOCKET_CLI_SENTRY_BUILD.\n      ...(constants.ENV.INLINED_SOCKET_CLI_SENTRY_BUILD\n        ? [\n            '--require',\n            // Lazily access constants.distInstrumentWithSentryPath.\n            constants.distInstrumentWithSentryPath\n          ]\n        : []),\n      '--require',\n      // Lazily access constants.distShadowNpmInjectPath.\n      constants.distShadowNpmInjectPath,\n      realExecPathSync(agentExecPath),\n      'install',\n      // Avoid code paths for 'audit' and 'fund'.\n      '--no-audit',\n      '--no-fund',\n      // Add '--no-progress' to fix input being swallowed by the npm spinner.\n      '--no-progress',\n      // Add '--loglevel=silent' if a loglevel flag is not provided and the\n      // SOCKET_CLI_DEBUG environment variable is not truthy.\n      ...logLevelArgs,\n      ...binArgs,\n      ...otherArgs\n    ],\n    {\n      spinner,\n      ...spawnOptions,\n      stdio,\n      env: {\n        ...process.env,\n        ...spawnOptions.env\n      }\n    }\n  )\n  if (useIpc) {\n    spawnPromise.process.send({\n      [SOCKET_IPC_HANDSHAKE]: {\n        [SOCKET_CLI_SAFE_BIN]: NPM,\n        [SOCKET_CLI_SAFE_PROGRESS]: progressArg,\n        ...ipc\n      }\n    })\n  }\n  return spawnPromise\n}\n","import { spawn } from '@socketsecurity/registry/lib/spawn'\nimport { Spinner } from '@socketsecurity/registry/lib/spinner'\n\nimport constants from '../constants.mts'\nimport { cmdFlagsToString } from './cmd.mts'\nimport { safeNpmInstall } from '../shadow/npm/install.mts'\n\nimport type { EnvDetails } from './package-environment.mts'\n\nconst { NPM, PNPM } = constants\n\ntype SpawnOption = Exclude<Parameters<typeof spawn>[2], undefined>\n\nexport type AgentInstallOptions = SpawnOption & {\n  args?: string[] | readonly string[] | undefined\n  spinner?: Spinner | undefined\n}\n\nexport type AgentSpawnResult = ReturnType<typeof spawn>\n\nexport function runAgentInstall(\n  pkgEnvDetails: EnvDetails,\n  options?: AgentInstallOptions | undefined\n): AgentSpawnResult {\n  const { agent, agentExecPath } = pkgEnvDetails\n  // All package managers support the \"install\" command.\n  if (agent === NPM) {\n    return safeNpmInstall({\n      agentExecPath,\n      ...options\n    })\n  }\n  const {\n    args = [],\n    spinner,\n    ...spawnOptions\n  } = { __proto__: null, ...options } as AgentInstallOptions\n  const skipNodeHardenFlags =\n    agent === PNPM && pkgEnvDetails.agentVersion.major < 11\n  return spawn(agentExecPath, ['install', ...args], {\n    // Lazily access constants.WIN32.\n    shell: constants.WIN32,\n    spinner,\n    stdio: 'inherit',\n    ...spawnOptions,\n    env: {\n      ...process.env,\n      NODE_OPTIONS: cmdFlagsToString([\n        ...(skipNodeHardenFlags\n          ? []\n          : // Lazily access constants.nodeHardenFlags.\n            constants.nodeHardenFlags),\n        // Lazily access constants.nodeNoWarningsFlags.\n        ...constants.nodeNoWarningsFlags\n      ]),\n      ...spawnOptions.env\n    }\n  })\n}\n","import { existsSync } from 'node:fs'\nimport path from 'node:path'\n\nimport browserslist from 'browserslist'\nimport semver from 'semver'\nimport which from 'which'\n\nimport { parse as parseBunLockb } from '@socketregistry/hyrious__bun.lockb/index.cjs'\nimport { debugLog } from '@socketsecurity/registry/lib/debug'\nimport { Logger } from '@socketsecurity/registry/lib/logger'\nimport { readPackageJson } from '@socketsecurity/registry/lib/packages'\nimport { naturalCompare } from '@socketsecurity/registry/lib/sorts'\nimport { spawn } from '@socketsecurity/registry/lib/spawn'\nimport { isNonEmptyString } from '@socketsecurity/registry/lib/strings'\n\nimport { cmdPrefixMessage } from './cmd.mts'\nimport { findUp, readFileBinary, readFileUtf8 } from './fs.mts'\nimport constants from '../constants.mts'\n\nimport type { Remap } from '@socketsecurity/registry/lib/objects'\nimport type { EditablePackageJson } from '@socketsecurity/registry/lib/packages'\nimport type { SemVer } from 'semver'\n\nconst {\n  BINARY_LOCK_EXT,\n  BUN,\n  HIDDEN_PACKAGE_LOCK_JSON,\n  LOCK_EXT,\n  NPM,\n  NPM_BUGGY_OVERRIDES_PATCHED_VERSION,\n  PACKAGE_JSON,\n  PNPM,\n  VLT,\n  YARN,\n  YARN_BERRY,\n  YARN_CLASSIC\n} = constants\n\nexport const AGENTS = [BUN, NPM, PNPM, YARN_BERRY, YARN_CLASSIC, VLT] as const\n\nexport type Agent = (typeof AGENTS)[number]\n\nconst binByAgent = new Map<Agent, string>([\n  [BUN, BUN],\n  [NPM, NPM],\n  [PNPM, PNPM],\n  [YARN_BERRY, YARN],\n  [YARN_CLASSIC, YARN],\n  [VLT, VLT]\n])\n\nasync function getAgentExecPath(agent: Agent): Promise<string> {\n  const binName = binByAgent.get(agent)!\n  if (binName === NPM) {\n    // Lazily access constants.npmExecPath.\n    return constants.npmExecPath\n  }\n  return (await which(binName, { nothrow: true })) ?? binName\n}\n\nasync function getAgentVersion(\n  agentExecPath: string,\n  cwd: string\n): Promise<SemVer | undefined> {\n  let result\n  try {\n    result =\n      // Coerce version output into a valid semver version by passing it through\n      // semver.coerce which strips leading v's, carets (^), comparators (<,<=,>,>=,=),\n      // and tildes (~).\n      semver.coerce(\n        // All package managers support the \"--version\" flag.\n        (\n          await spawn(agentExecPath, ['--version'], {\n            cwd,\n            // Lazily access constants.WIN32.\n            shell: constants.WIN32\n          })\n        ).stdout\n      ) ?? undefined\n  } catch (e) {\n    debugLog('getAgentVersion error:\\n', e)\n  }\n  return result\n}\n\n// The order of LOCKS properties IS significant as it affects iteration order.\nconst LOCKS: Record<string, Agent> = {\n  [`bun${LOCK_EXT}`]: BUN,\n  [`bun${BINARY_LOCK_EXT}`]: BUN,\n  // If both package-lock.json and npm-shrinkwrap.json are present in the root\n  // of a project, npm-shrinkwrap.json will take precedence and package-lock.json\n  // will be ignored.\n  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#package-lockjson-vs-npm-shrinkwrapjson\n  'npm-shrinkwrap.json': NPM,\n  'package-lock.json': NPM,\n  'pnpm-lock.yaml': PNPM,\n  'pnpm-lock.yml': PNPM,\n  [`yarn${LOCK_EXT}`]: YARN_CLASSIC,\n  'vlt-lock.json': VLT,\n  // Lastly, look for a hidden lock file which is present if .npmrc has package-lock=false:\n  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#hidden-lockfiles\n  //\n  // Unlike the other LOCKS keys this key contains a directory AND filename so\n  // it has to be handled differently.\n  'node_modules/.package-lock.json': NPM\n}\n\ntype ReadLockFile =\n  | ((lockPath: string) => Promise<string | undefined>)\n  | ((lockPath: string, agentExecPath: string) => Promise<string | undefined>)\n  | ((\n      lockPath: string,\n      agentExecPath: string,\n      cwd: string\n    ) => Promise<string | undefined>)\n\nconst readLockFileByAgent: Map<Agent, ReadLockFile> = (() => {\n  function wrapReader<T extends (...args: any[]) => Promise<any>>(\n    reader: T\n  ): (...args: Parameters<T>) => Promise<Awaited<ReturnType<T>> | undefined> {\n    return async (...args: any[]): Promise<any> => {\n      try {\n        return await reader(...args)\n      } catch {}\n      return undefined\n    }\n  }\n\n  const binaryReader = wrapReader(readFileBinary)\n\n  const defaultReader = wrapReader(\n    async (lockPath: string) => await readFileUtf8(lockPath)\n  )\n\n  return new Map([\n    [\n      BUN,\n      wrapReader(\n        async (\n          lockPath: string,\n          agentExecPath: string,\n          cwd = process.cwd()\n        ) => {\n          const ext = path.extname(lockPath)\n          if (ext === LOCK_EXT) {\n            return await defaultReader(lockPath)\n          }\n          if (ext === BINARY_LOCK_EXT) {\n            const lockBuffer = await binaryReader(lockPath)\n            if (lockBuffer) {\n              try {\n                return parseBunLockb(lockBuffer)\n              } catch {}\n            }\n            // To print a Yarn lockfile to your console without writing it to disk\n            // use `bun bun.lockb`.\n            // https://bun.sh/guides/install/yarnlock\n            return (\n              await spawn(agentExecPath, [lockPath], {\n                cwd,\n                // Lazily access constants.WIN32.\n                shell: constants.WIN32\n              })\n            ).stdout.trim()\n          }\n          return undefined\n        }\n      )\n    ],\n    [NPM, defaultReader],\n    [PNPM, defaultReader],\n    [VLT, defaultReader],\n    [YARN_BERRY, defaultReader],\n    [YARN_CLASSIC, defaultReader]\n  ])\n})()\n\ntype EnvBase = {\n  agent: Agent\n  agentExecPath: string\n  agentSupported: boolean\n  features: {\n    // Fixed by https://github.com/npm/cli/pull/8089.\n    // Landed in npm v11.2.0.\n    npmBuggyOverrides: boolean\n  }\n  nodeSupported: boolean\n  nodeVersion: SemVer\n  npmExecPath: string\n  pkgRequirements: {\n    agent: string\n    node: string\n  }\n  pkgSupports: {\n    agent: boolean\n    node: boolean\n  }\n}\n\nexport type EnvDetails = Readonly<\n  Remap<\n    EnvBase & {\n      agentVersion: SemVer\n      editablePkgJson: EditablePackageJson\n      lockName: string\n      lockPath: string\n      lockSrc: string\n      pkgPath: string\n    }\n  >\n>\n\nexport type PartialEnvDetails = Readonly<\n  Remap<\n    EnvBase & {\n      agentVersion: SemVer | undefined\n      editablePkgJson: EditablePackageJson | undefined\n      lockName: string | undefined\n      lockPath: string | undefined\n      lockSrc: string | undefined\n      pkgPath: string | undefined\n    }\n  >\n>\n\nexport type DetectOptions = {\n  cwd?: string | undefined\n  onUnknown?: (pkgManager: string | undefined) => void\n}\n\nexport async function detectPackageEnvironment({\n  cwd = process.cwd(),\n  onUnknown\n}: DetectOptions = {}): Promise<EnvDetails | PartialEnvDetails> {\n  let lockPath = await findUp(Object.keys(LOCKS), { cwd })\n  let lockName = lockPath ? path.basename(lockPath) : undefined\n  const isHiddenLockFile = lockName === HIDDEN_PACKAGE_LOCK_JSON\n  const pkgJsonPath = lockPath\n    ? path.resolve(\n        lockPath,\n        `${isHiddenLockFile ? '../' : ''}../${PACKAGE_JSON}`\n      )\n    : await findUp(PACKAGE_JSON, { cwd })\n  const pkgPath =\n    pkgJsonPath && existsSync(pkgJsonPath)\n      ? path.dirname(pkgJsonPath)\n      : undefined\n  const editablePkgJson = pkgPath\n    ? await readPackageJson(pkgPath, { editable: true })\n    : undefined\n  // Read Corepack `packageManager` field in package.json:\n  // https://nodejs.org/api/packages.html#packagemanager\n  const pkgManager = isNonEmptyString(editablePkgJson?.content?.packageManager)\n    ? editablePkgJson.content.packageManager\n    : undefined\n\n  let agent: Agent | undefined\n  if (pkgManager) {\n    // A valid \"packageManager\" field value is \"<package manager name>@<version>\".\n    // https://nodejs.org/api/packages.html#packagemanager\n    const atSignIndex = pkgManager.lastIndexOf('@')\n    if (atSignIndex !== -1) {\n      const name = pkgManager.slice(0, atSignIndex) as Agent\n      const version = pkgManager.slice(atSignIndex + 1)\n      if (version && AGENTS.includes(name)) {\n        agent = name\n      }\n    }\n  }\n  if (\n    agent === undefined &&\n    !isHiddenLockFile &&\n    typeof pkgJsonPath === 'string' &&\n    typeof lockName === 'string'\n  ) {\n    agent = LOCKS[lockName] as Agent\n  }\n  if (agent === undefined) {\n    agent = NPM\n    onUnknown?.(pkgManager)\n  }\n  const agentExecPath = await getAgentExecPath(agent)\n  const agentVersion = await getAgentVersion(agentExecPath, cwd)\n  if (agent === YARN_CLASSIC && (agentVersion?.major ?? 0) > 1) {\n    agent = YARN_BERRY\n  }\n  // Lazily access constants.maintainedNodeVersions.\n  const { maintainedNodeVersions } = constants\n  // Lazily access constants.minimumVersionByAgent.\n  const minSupportedAgentVersion = constants.minimumVersionByAgent.get(agent)!\n  const minSupportedNodeVersion = maintainedNodeVersions.last\n  const nodeVersion = semver.coerce(process.version)!\n  let lockSrc: string | undefined\n  let pkgAgentRange: string | undefined\n  let pkgNodeRange: string | undefined\n  let pkgMinAgentVersion = minSupportedAgentVersion\n  let pkgMinNodeVersion = minSupportedNodeVersion\n  if (editablePkgJson?.content) {\n    const { engines } = editablePkgJson.content\n    const engineAgentRange = engines?.[agent]\n    const engineNodeRange = engines?.['node']\n    if (isNonEmptyString(engineAgentRange)) {\n      pkgAgentRange = engineAgentRange\n      // Roughly check agent range as semver.coerce will strip leading\n      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).\n      const coerced = semver.coerce(pkgAgentRange)\n      if (coerced && semver.lt(coerced, pkgMinAgentVersion)) {\n        pkgMinAgentVersion = coerced.version\n      }\n    }\n    if (isNonEmptyString(engineNodeRange)) {\n      pkgNodeRange = engineNodeRange\n      // Roughly check Node range as semver.coerce will strip leading\n      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).\n      const coerced = semver.coerce(pkgNodeRange)\n      if (coerced && semver.lt(coerced, pkgMinNodeVersion)) {\n        pkgMinNodeVersion = coerced.version\n      }\n    }\n    const browserslistQuery = editablePkgJson.content['browserslist'] as\n      | string[]\n      | undefined\n    if (Array.isArray(browserslistQuery)) {\n      // List Node targets in ascending version order.\n      const browserslistNodeTargets = browserslist(browserslistQuery)\n        .filter(v => /^node /i.test(v))\n        .map(v => v.slice(5 /*'node '.length*/))\n        .sort(naturalCompare)\n      if (browserslistNodeTargets.length) {\n        // browserslistNodeTargets[0] is the lowest Node target version.\n        const coerced = semver.coerce(browserslistNodeTargets[0])\n        if (coerced && semver.lt(coerced, pkgMinNodeVersion)) {\n          pkgMinNodeVersion = coerced.version\n        }\n      }\n    }\n    lockSrc =\n      typeof lockPath === 'string'\n        ? await readLockFileByAgent.get(agent)!(lockPath, agentExecPath, cwd)\n        : undefined\n  } else {\n    lockName = undefined\n    lockPath = undefined\n  }\n  // Does the system agent version meet our minimum supported agent version?\n  const agentSupported =\n    !!agentVersion &&\n    semver.satisfies(agentVersion, `>=${minSupportedAgentVersion}`)\n\n  // Does the system Node version meet our minimum supported Node version?\n  const nodeSupported = semver.satisfies(\n    nodeVersion,\n    `>=${minSupportedNodeVersion}`\n  )\n\n  const npmExecPath =\n    agent === NPM ? agentExecPath : await getAgentExecPath(NPM)\n\n  const npmBuggyOverrides =\n    agent === NPM &&\n    !!agentVersion &&\n    semver.lt(agentVersion, NPM_BUGGY_OVERRIDES_PATCHED_VERSION)\n\n  return {\n    agent,\n    agentExecPath,\n    agentSupported,\n    agentVersion,\n    editablePkgJson,\n    features: { npmBuggyOverrides },\n    lockName,\n    lockPath,\n    lockSrc,\n    nodeSupported,\n    nodeVersion,\n    npmExecPath,\n    pkgPath,\n    pkgRequirements: {\n      agent: pkgAgentRange ?? `>=${pkgMinAgentVersion}`,\n      node: pkgNodeRange ?? `>=${pkgMinNodeVersion}`\n    },\n    pkgSupports: {\n      // Does our minimum supported agent version meet the package's requirements?\n      agent: semver.satisfies(\n        minSupportedAgentVersion,\n        `>=${pkgMinAgentVersion}`\n      ),\n      // Does our supported Node versions meet the package's requirements?\n      node: maintainedNodeVersions.some(v =>\n        semver.satisfies(v, `>=${pkgMinNodeVersion}`)\n      )\n    }\n  }\n}\n\nexport type DetectAndValidateOptions = {\n  cmdName?: string | undefined\n  logger?: Logger | undefined\n  prod?: boolean | undefined\n}\n\nexport async function detectAndValidatePackageEnvironment(\n  cwd: string,\n  options?: DetectAndValidateOptions | undefined\n): Promise<void | EnvDetails> {\n  const {\n    cmdName = '',\n    logger,\n    prod\n  } = {\n    __proto__: null,\n    ...options\n  } as DetectAndValidateOptions\n  const details = await detectPackageEnvironment({\n    cwd,\n    onUnknown(pkgManager: string | undefined) {\n      logger?.warn(\n        cmdPrefixMessage(\n          cmdName,\n          `Unknown package manager${pkgManager ? ` ${pkgManager}` : ''}, defaulting to npm`\n        )\n      )\n    }\n  })\n  const { agent, nodeVersion, pkgRequirements } = details\n  const agentVersion = details.agentVersion ?? 'unknown'\n  if (!details.agentSupported) {\n    const minVersion = constants.minimumVersionByAgent.get(agent)!\n    logger?.fail(\n      cmdPrefixMessage(\n        cmdName,\n        `Requires ${agent} >=${minVersion}. Current version: ${agentVersion}.`\n      )\n    )\n    return\n  }\n  if (!details.nodeSupported) {\n    const minVersion = constants.maintainedNodeVersions.last\n    logger?.fail(\n      cmdPrefixMessage(\n        cmdName,\n        `Requires Node >=${minVersion}. Current version: ${nodeVersion}.`\n      )\n    )\n    return\n  }\n  if (!details.pkgSupports.agent) {\n    logger?.fail(\n      cmdPrefixMessage(\n        cmdName,\n        `Package engine \"${agent}\" requires ${pkgRequirements.agent}. Current version: ${agentVersion}`\n      )\n    )\n    return\n  }\n  if (!details.pkgSupports.node) {\n    logger?.fail(\n      cmdPrefixMessage(\n        cmdName,\n        `Package engine \"node\" requires ${pkgRequirements.node}. Current version: ${nodeVersion}`\n      )\n    )\n    return\n  }\n  if (agent === VLT) {\n    logger?.fail(\n      cmdPrefixMessage(\n        cmdName,\n        `${agent} does not support overrides. Soon, though ⚡`\n      )\n    )\n    return\n  }\n  const lockName = details.lockName ?? 'lock file'\n  if (details.lockName === undefined || details.lockSrc === undefined) {\n    logger?.fail(cmdPrefixMessage(cmdName, `No ${lockName} found`))\n    return\n  }\n  if (details.lockSrc.trim() === '') {\n    logger?.fail(cmdPrefixMessage(cmdName, `${lockName} is empty`))\n    return\n  }\n  if (details.pkgPath === undefined) {\n    logger?.fail(cmdPrefixMessage(cmdName, `No ${PACKAGE_JSON} found`))\n    return\n  }\n  if (prod && (agent === BUN || agent === YARN_BERRY)) {\n    logger?.fail(\n      cmdPrefixMessage(\n        cmdName,\n        `--prod not supported for ${agent}${agentVersion ? `@${agentVersion}` : ''}`\n      )\n    )\n    return\n  }\n  if (\n    details.lockPath &&\n    path.relative(cwd, details.lockPath).startsWith('.')\n  ) {\n    // Note: In tests we return <redacted> because otherwise snapshots will fail.\n    const { REDACTED } = constants\n    // Lazily access constants.ENV.VITEST.\n    const redacting = constants.ENV.VITEST\n    logger?.warn(\n      cmdPrefixMessage(\n        cmdName,\n        `Package ${lockName} found at ${redacting ? REDACTED : details.lockPath}`\n      )\n    )\n  }\n  return details as EnvDetails\n}\n"],"names":["PNPM","workspacePatterns","throws","length","cwd","__proto__","absolute","expandDirectories","ignore","abortSignal","signal","root","dir","encoding","SOCKET_APP_DIR","ok","message","cause","_readOnlyConfig","_cachedConfig","logger","data","updateConfigValue","recursive","WIN32","_warnedConfigPathWin32Missing","dataHome","_configPath","yml","path","parsed","prevDir","localConfig","_pendingSave","getSentry","constructor","SOCKET_PUBLIC_API_TOKEN","_defaultToken","agent","proxy","baseUrl","name","version","homepage","spinner","process","debugLog","method","headers","Authorization","result","mw2","lines","cols","cws","body","config","type","default","hidden","description","dryRun","help","shortFlag","silent","json","markdown","all","strict","msg","keyPrefix","padName","commandOrAliasName","allowUnknownFlags","autoHelp","configOverrideResult","constants","parentName","cli2","meow","cli","REDACTED","nodeVerWarn","choices","value","orgSlug","shadowBinPath","nothrow","shadowIndex","theBinPath","existsSync","throwIfNoEntry","thePath","socketConfig","SOCKET_CLI_ISSUES_URL","_npmBinPathDetails","_npxBinPathDetails","_npmBinPath","_npxBinPath","i","namespace","keys","ALERT_TYPE_MILD_CVE","cve","remove","upgrade","ALERT_SEVERITY","critical","high","middle","low","severity","severityCount","header","hyperlink","fallback","fallbackToUrl","_translations","none","NPM","descriptions","consolidate","include","overrides","actions","existing","upgradable","raw","highestForCve","alert","highestForUpgrade","unfixableAlerts","sockPkgAlerts","alertsByPkgId","exclude","limit","infoByPkg","infos","vulnerableVersionRange","hideAt","hiddenAlerts","viewableAlerts","viewableAlertsByPkgId","aboveTheFoldPkgIds","removedHiddenAlerts","hiddenAlertsByPkgId","output","mentionedPkgIdsWithHiddenAlerts","prevAboveTheFold","totalRiskCounts","RangeStyles","deps","blocked","unfixable","alerts","compact","fixable","components","purl","remaining","SOCKET_IPC_HANDSHAKE","args","stdio","env","spawnPromise","agentExecPath","NODE_OPTIONS","YARN_CLASSIC","semver","onUnknown","editable","maintainedNodeVersions","engines","pkgAgentRange","pkgNodeRange","lockName","lockPath","features","npmBuggyOverrides","pkgRequirements","node","pkgSupports","cmdName","prod"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;;AAAaA;AAAK;AAElB;AAEA;AACE;AACA;AACA;AAAQ;AACR;AAAQ;AACR;AAAe;AACf;AAAe;AACf;AAAS;AACT;AAAoB;AACpB;AAAY;AACZ;AAAgB;AAChB;AACA;AACA;AAGF;AAEA;AAIE;;;AAMI;AACA;AACA;;AAEIC;;AAEF;AACE;AACF;AACF;AACF;AACF;AACEA;AAAkDC;;AAGpD;AACA;AAKF;AAEA;;;AAOE;AAAkBC;;;AAEhB;;AAQA;AACF;AACA;AACF;AAEA;AAKE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACE;AACA;AACA;AACA;AACA;AAME;AACF;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAQF;AAEA;;AACUA;AAAO;;AAEb;AACF;AACA;;;AAGA;AACA;AACA;;AAMA;AACA;;AAEF;AAEO;;AAMD;;AAMA;;AAIJ;AACF;AAMO;;AAKHC;;;AAGF;AAAMC;;;AACN;;AAEEC;;AAEAC;AACF;AACA;AAqBA;AACA;AACED;;AAEAC;AACAC;;;;;AAKA;AACF;;AACQF;AAAS;;AAEjB;AACA;AACA;AAGA;AACF;AAEO;AACL;AACEA;AACAF;AACF;AACF;AAEO;;;AAOCE;;AAEAE;;AAGR;AAEO;AAGL;AACA;AACF;;AC9PA;AAAQC;AAAY;AAEb;AACL;AACA;AACF;AAOO;AAEHL;AAAqBM;AAAoC;AAE3D;;AACQC;AAAK;;AAEb;AACE;;AAEI;AACF;;;AAGE;;AAEA;AACE;AACF;;AAEJ;AACAC;AACF;AACA;AACF;AASO;AAIL;AACEF;AACA;AACAG;AACF;AACF;AAEO;AAIL;AACEH;AACA;AACAG;AACF;AACF;AAOO;;AAKH;AACEA;AACAH;AACA;AAAoCG;AAAkB;AACxD;;AAEF;AACF;AAOO;;;AAYDA;AACA;AAAoCA;AAAkB;AACxD;;AAEF;AACF;;ACjHA;;AAAsBC;AAAe;;AA+B9B;AAEP;AACA;AACA;AAEO;;AAGL;;;AAGE;AACE;;AAEEC;AACAC;AACAC;;AAGJ;AACF;AACE;;AAEAC;;AAGEH;AACAC;AACAC;;AAGJ;;AAEA;AACAE;AACAD;;AAEA;AACA;AACE;AACEE;AAGF;AACAD;;AAEF;;AAESJ;AAAUM;;AACrB;AAEO;;AAEL;AACAF;AACE;AACA;;;;AAEFD;AACF;AAEA;;;AAGI;AACA;AACA;AACE;AACA;;;AAME;AACEE;AACF;AACA;AACA;AACA;AACE;;AAEAE;AACF;AACF;;AAC2CC;AAAgB;AAC3D;AACF;AACF;AACA;AACF;AAEA;AACA;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE;;AACQC;AAAM;;AAEV;;AAEA;;;AAGF;;AAEIC;AACAL;AACF;AACF;AACEM;AAMF;AACF;AACAC;AACF;AACA;AACF;AAEA;AAGE;AACA;;AAEA;;AAEIZ;;AAEAM;;AAEJ;;AACSN;AAAUM;;AACrB;AAEO;;;;AAIH;;;AAGEO;AACF;AACA;;;AAGMC;AACAC;;AAEJ;AACE;AACF;AACF;AACAC;;AAEF;AACA;AACF;AAEO;AAGL;AACA;AACA;AACE;AACF;;AACShB;AAAUM;;AACrB;AACA;AACA;AACO;AAGL;AACA;AACA;AACE;AACF;AACA;AACF;AACO;AACL;AACF;AAEA;AACO;AAIL;AACA;AACA;AACE;AACF;AACAW;AACA;;AAEIjB;;AAEAM;;AAEJ;;AAGEY;;AAEEA;AACA;AACA;;AAKA;AACF;AACF;;AAGElB;;AAEAM;;AAEJ;AAEO;AACL;AACF;;AC3RA;;AAEE;AAA+Da;AAAU;AAC3E;AAIO;AAEA;AAGLC;;;AAGA;AACF;AAEO;AAIL;AACA;;AAEA;AACF;AAEO;AAIL;;AAEE;AACF;;AAEA;AACF;;AC1CO;AAIL;AACF;;ACKA;AAAQC;AAAwB;;AAEhC;AACA;AACE;AACE;;AAGF;AACF;;AAEA;AACA;AACE;AACE;;AAEF;AACF;;AAEA;AACA;AACO;AACL;AACA;AACEC;AACF;AACE;AACE;;;AAKJ;AACA;AACF;AAEO;AACL;;AAEE;AACF;;AAGA;AACF;AAEO;AACL;AACF;AAEO;AACL;AACE;;AAEuB;AAE3B;AAEO;;;AAODrB;AAEF;AACAqB;AACF;;;AAGItB;AACAC;AACAC;;AAEJ;;AAEEF;AACAM;AACEiB;AAAqCC;;AACrCC;;AAEE;AACAC;AACA;AACAC;AACA;AACAC;;;;AAIR;;ACtFA;AACO;AAML;AACA;AACE;;AACQC;AAAQ;;AAIhB;AACF;;AAEA;AACAC;AACF;AAEO;AAIL;;AACQD;AAAQ;AAEhBA;AAEA;;;;AAIE;AACAA;;AAIAA;AAEAE;AAEA;AACA;;AAGE/B;AACAC;;;AAGJ;;AAEA;;AAEA;AACA;;;AAGE8B;;AAGE/B;AACAC;AACAC;AACAI;;AAEA;;AAEJ;;;AAGIN;;;AAGJ;AACF;AAEO;AAIL;;;;AAIE+B;AAEA;AACA;;AAGE/B;AACAC;;;AAGJ;;AAEA;AACA;;;AAGE8B;;AAGE/B;AACAC;AACAC;AACAI;;AAEA;;AAEJ;;;AAGIN;;;AAGJ;AACF;AAEO;;AAEH;AACF;AACA;AACE;AACF;;AAEE;AACF;;AAEE;AACF;;AAEF;;AAEA;AACO;AACL;AACA;AAEA;AAEA;AACE;AACF;AACA;AACA;AACA;AACF;AAEO;AACL;;AAEEK;AAGF;AACA;AACE2B;AACAC;AACEC;AACF;AACF;AACF;AAEO;AAIL;;;AAGIlC;AACAC;AACAC;;AAGJ;AAEA;AACE;;AACQ2B;AAAQ;AAEhBA;AACF;AAEA;;AAEEM;AACA;AACE;;AACQN;AAAQ;AAEhBA;AAGF;;AAEA;AACE;;AACQA;AAAQ;AAEhBA;AAGF;;;AAIA;;AAGE7B;AACAC;AACA;AAAYC;;;AAEhB;AAEA;;;AAGIF;AACAC;AACAC;;AAEJ;;AAGE;;AAGEF;AACAM;;;;;;AAOAN;AACAC;AACAC;;AAEJ;AACF;AAEO;;AAML;AACE;AACF;;;AAIIF;AACAM;;;;AAIAN;AACAC;AACAC;;AAEJ;AACF;;AChSO;AAKL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEEkC;AACF;;;AAIAC;AACA;;AAIA;AACAA;AAEA;AACF;AAEO;AAEL;AACA;AACAC;AAGA;;AAGA;AACE;AAAkBlD;;AAChB;AACA;AACAmD;AAKF;AACF;;AAGA;;AAEA;;AAGA;AAAkBnD;;;AAElB;;AAGA;AACEoD;AACA;AAAkBpD;;AAChB;AACA;;AAEF;AACAoD;AACF;AAEA;AACF;AAEO;AAEL;AACA;AACAF;AAEA;;;;;AAMA;;AAGA;;AAEA;;AAGA;AAAkBlD;;;AAElB;;;AAIEoD;;;AAGAA;AACF;AAEA;AACF;;ACvGA;AACA;AACO;AACL;;AAEE;;AAGAT;AACA;AACEA;AACF;;AAGI/B;AACAC;AACAK;AACF;AAEJ;;AAGE;;AAEAyB;;AAEA;;AAGA1B;;AAGIL;AACAC;AACAK;AACF;AAEJ;AACF;;ACzCA;;AAMA;;AAMO;AACLmC;AACEC;AACAC;AACAC;AACAC;;AAEFC;AACEJ;AACAC;AACAC;AAAc;AACdC;;AAEFE;AACEL;AACAC;AACAK;AACAH;;AAEFI;AACEP;AACAC;AACAC;AACAI;AACAH;AACF;AACF;AAEO;AACLK;AACER;AACAM;AACAL;AACAE;;AAEFM;AACET;AACAM;AACAL;AACAE;AACF;AACF;AAEO;AACLO;AACEV;AACAC;AACAE;;AAEFQ;AACEX;AACAC;AACAE;AACF;AACF;;AC3DO;;AAWH;AACF;AAEA;AACA;AACE;AACA;AACE;AACF;;;AAEQzD;AAAkB;;AAExB;AACF;AACA;AACA;AACAkE;;AAIEA;AACF;AACAA;AACF;;AAEA;AACA;AACA;;;AAIEjD;AAEIL;AACAC;AACAK;AACF;AAEJ;AACED;AACF;AAEA;AACF;;AC7DO;AACL;AACE;AACF;AACA;AACE;AACF;AACA;AACF;;ACCO;AAGHkD;AAAkBC;AAAQ;AAE5B;;;;AAKeA;AAAQ;AAEzB;AAEO;AAGHD;AAAgBC;AAAa;;;AAI/B;AACE;;AAEE;AACF;AACA;;AAOF;AACA;AACF;;AC2BO;;;;;;;;AAWL;AAAMlE;;;AACN;;AAEA;AACEmE;AACF;AAEA;AACE;AACA;;;AAGF;AACA;;AAKIf;AACAC;AACAC;AAAe;AACfC;;AAGJ;;AAEA;AACA;AACA;;;AAGE;;AAEA;AACAa;AACA;AACA;AACAC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACEC;AACE;AACAC;;AAGFD;AAGF;;AAEA;AACA;AACE;AACA;;AAEF;AACE;AACA;AACA;AACE;AACA;;AAEF;AACF;AAEA;;AAEEvD;;AAEA;AACF;;AAEA;AACA;AACE;AACA;;AAIA;;AAEA;AACA;;AAEIyD;AACF;AACF;AACF;;;;;AAMA;;AAEA;;AAGF;AACA;;AAEA;AACA;AAEU;AAGS;AAAc;AAIvB;AAEsC;AAAS;;AACjClB;AAAO;;;AAGf;AACF;;;AAOd;AACA;;AAEA;AACA;AACA;;;AAIM;;AAEA;AACAc;AACA;AACA;AACAC;AACF;;AAGF;AACA;;AAEA;AACA;;AAEE;;AAEF;AACE;AACA;AACAI;AACF;AACF;;AAEA;AACA;AACA;AACO;;AACc;;;;AAInBD;AAOF;;;AAIE;;;;;;;AAOEJ;AAAyB;;AAE3B;AAEA;;AAEA;;AAEE;AACA;AACAM;;;;;;AAMEN;AACAC;AACF;AACF;AAEA;AACEM;AACF;AACA;AACA;AACA;;AAEAD;;;;;;AAMEN;AACAC;AACF;AACA;;AAGA;AACF;AAEO;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAtD;AACF;AAEA;AACE;;AACQ6D;AAAS;AACjB;AACA;AACA;AAEI;;;AAGJ;;;AAGA;;AAMA;;AAcA;;AAIEC;AACAA;AAEAA;AACF;AACA;AACF;AACA;AACA;AACA;AAEE;AACF;;ACrXO;AACL;AACA;AACE;AACF;AACA;AAEA;;AAKA;AACA;;AAEE;AACElE;AAEAmE;;;;AAKMC;;;AAGJ;AAEE3C;AACA2C;AACAxB;;AAIN;AACA;AACE;AACF;AACF;AACExC;AAGF;AACF;;AC5CO;AAML;;;;AAII;AACAA;AAGAA;AAGA;AACEA;AACF;AACEA;AACF;AACEiE;AACF;AACF;;AAEA;AACF;AAEA;AACF;;AChBA;;;AAA2BC;AAAc;AAElC;AAKL;AAEInB;AACAoB;;;AAGJ;AACA;AAAkBpF;;AAChB;AACA;;AAEEqF;AACF;AACEC;AACA;AACF;AACF;;AACShD;AAAeZ;;;AAC1B;AAEO;AACL;;AACQL;AAAM;;AAEd;AACE;AACA;AACA;AACA;AACA;AACA;AACE;AACA;AACA;AACAkE;AACyBC;AAAsB;;AAGjD;;AAEA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAD;AACmBC;AAAsB;AACzC;AACC9D;AACC;AACCL;AAEH;AACF;AACA;;AAEE;AACF;AACAoE;AACF;AACF;AAEO;;;AAWL;;AACQhD;AAAQ;AAEhB;AAEAA;AAEA;;AAEEiD;AACF;;;AAIE/C;AAIAF;AACF;AACEA;AAGF;;AAOAA;AAGAE;AAEA;AACF;;ACpIA;;;;AAAgCgD;AAAsB;AAEtD;AACE1E;AAGA;AACA;AACA;AACAyB;AACF;AAEA;AACA;;AAEIkD;AACF;AACA;AACF;AAEA;AACA;;AAEIC;AACF;AACA;AACF;AAEO;AACL;AACF;AAEO;AACL;AACF;AAEA;AACO;;AAEHC;;;AAGA;AACF;AACA;AACF;AAEA;AACO;;AAEH;;;;AAIE;;AAEA;;AAEA7E;AACA;AACA;AACA;AACAyB;AACF;AACF;AACA;AACF;AAEA;AACO;;AAEH;;;AAKF;AACA;AACF;AAEA;AACO;;AAEHqD;;;AAGA;AACF;AACA;AACF;;AClGA;AAEO;;AAEL;AAAkB/F;;;AAEd;AACA;AACE+C;AACAiD;AACF;AACEjD;AACF;AACF;AACF;AACA;AACF;AAEO;;AAEL;AACF;AAEO;AACL;AACF;;ACpBO;;;AACSkD;AAAU;AACxB;AAGF;AAEO;;AAEP;AAEO;AAGL;;AAEF;AAEO;;;AAOL;AACE;AACF;AACF;;AC7BA;AACA;AACA;AACA;AACO;AAGL;AAMF;;ACfO;AAIL;;;AAGE;;AACUC;AAAwBjB;;AAClC;AACF;AACF;;AC+CA;;;;AAIEkB;AACF;AAEO;;AAGG7C;AAAK;AACb;AAMF;;AC7EO;;AAGkBpD;;AAAwB;AACjD;AAEO;;AAKL;AACE6C;AACF;AACA;AACF;;ACbO;AACLqD;AACAC;AACAC;AACF;;ACNO;AAIL;;AACQtG;AAAO;;AAEb;AACF;;;AAGA;AACA;;AAEF;;ACTauG;AACXC;AACAC;AACAC;AACAC;AACF;AAWA;AACO;AAIP;;AAIE;AACE5D;;AAEE;AACF;AACF;AACA;AACF;AAEO;;AAIL;AACE;;AAEA;AACF;;AAEF;AAEO;;AAKD4D;AAAQD;AAAWD;AAASD;AAAY;AAI5C;;AACUvB;AAAM;;AAEZ;AACF;;AACQ2B;AAAS;AACjB;AACEC;AACF;AACF;AACA;AACF;;AClEO;;AAIH;AACF;;AAGE;AACF;AAEAC;AACE;AAGF;AAEAC;AAIIC;AACAC;;AAMF;AACE;;AAII;AACN;AACA;AACF;;AAKE;AACF;;AAGE;AACF;;;AAMA;;AAGE;;AAIF;AACF;;AC5DA,iBAAA;AAEA;AAEO;;AAEHC;AACE;;AAGJ;AACA;AACF;;ACbO;;AAEP;AAEO;;AACG3E;AAAQ;AAChB;AACF;AAEO;AACL;AACF;AAEO;AACL;AACA;AACF;;ACSO;AACLiE;AACAC;AACAC;AACAC;AACF;AAEO;AACLH;AACAC;AACAC;AACAC;AACAQ;AACF;AAgBA;;AAA0DC;AAAI;AAE9D;AAEA;AAEA;AAEA;;AAEA;AAEA;AAIE;AACF;AAEA;;AAKA;AAEA;;AACUR;;AACR;AASF;AAEA;;AAWA;AASA;AACE;AACEJ;AACAC;AACAC;AACAC;;AAEF;;;;AAIM;;;AAGA;;;AAGA;;;AAGA;AACJ;AACF;AACA;AACF;AAEA;;;AAGIU;AACF;;AAEEA;AACF;;AAEEA;AACF;;AAEEA;AACF;AACA;AACF;AAEA;AACE;AACF;AAmBO;AAKL;AACA;AACE;AACF;;AAEEC;AACAC;AACAC;AACF;AACEtH;;;AAIF;AACEA;AACAuH;AAEAjB;AACAJ;AACAsB;AAEAC;;;AAIF;;AACQpF;AAAQ;AAChB;AACA;AACA;AACA;AACErC;;;;AAIF;AACE;AACA;;AAKE;AACF;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;AAeI0H;AACAD;AACF;AACF;AACF;AACA;AACE;AACF;AACA;AACE;AAIA;;AAKA;AACE;;AAEA;AACE;AAEA;AACA;AACA;;AAEEE;AACEC;AACAvF;AACF;AACF;AACF;AACE;AACA;;AAEEwF;AAA+BD;AAAqBvF;AAAQ;AAC9D;AACF;AACEyF;AACF;AACF;AACAC;AAKF;;AAEEA;AACAC;AACF;AACA;AACF;AAmBO;;AAIGC;AAAmBC;AAAiB;AAC1ClI;;;AAGF;AACEA;AACAyH;;;;;;;AAQA;AACA;AACE;;AAKE;AACF;;AAEEU;AACF;AACA;;AAEEC;AACAD;AACF;;;AACuCE;;;;;AAKnCA;AACE;AACA;;AAGJ;AACA;AACE;AACF;;;;AAIEA;AACF;;AAEF;AACF;AACF;AACA;AACF;AAOO;;AAIGC;;AAA2C;AACjDtI;;;AAIF;AACA;AAIA;AACA;AACA;AAEA;AAAkBF;;;AACR;AAAU;AAAU;;AAE5B;AACE;;AAGEyI;AACF;AACA;AACF;;;AAGA;AACA;AACE;AACF;AACAC;AACAC;AACA;AAMEC;AACF;AACF;;AAEA;AACA;AAAa;AAAS;AACpB;AACE;AACF;AACAA;AACF;AACA;AACA;AAAa;AAAU;AAAgB;AACrC;AACE;AACF;AACAA;;AAEA;AACE;AACA;AACA;;AAKA;AACEC;AACAC;AACF;AACAH;AAIF;AACF;AAEA;AACA;AAIM3I;;;AAII;AAAU;AAAU;AAC5B;AACA;;AACUsD;AAAK;;;;AAYb;AACA;AACA;AACA;AACA;;AAEA;AACAL;AACF;;;AAUA;AACA;AACE2F;AACAG;AACF;AACEA;AACF;AACA;AACEA;AACF;;;AAEQ/I;AAA0B;AAClC;AACEgJ;;;AAKA;;AAIA;AACF;AACAC;AACF;;AAIA;AACE;AACEzC;AACAC;AACAC;AACAC;;AAEF;AAAa;AAAU;AAAU;AAC/B;AACE;AACF;AACA;AACAuC;AACAA;AACAA;AACAA;AACF;AACAH;AAGF;AACAA;AACF;;ACjjBaI;AAYN;AAKL;AACE;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AAAiB;;;AAEPvB;AAAI;;;AAEJ5H;AAAO;;;AAGb;AACE;AACF;AACF;;AAEE;AACE;AACF;AACF;AACA;AACF;AACA;;AAEA;AACA;AACE;AACJ;AACF;AAEO;AACL;AACA;;AAEI;;AAEA2C;AACF;AACF;AACA;AACF;;ACnDO;AAGL;AACA;;AAEI;AAAa;AAAU;;AAGrB;AACA;AACEyG;AACF;AACF;AACF;;AAEE;AAAa;AAAU;;AAGrB;AACA;AACEA;AACF;AACF;AACF;;AAEE;AAAa;AAAU;;AAGrB;AACA;AACEA;AACF;AACF;AACF;AACF;;;AAGI;AACA;AACEA;AACF;AACF;AACF;AACA;AACF;AAEO;AAGL;;;AAGE;AACA;AACA;AACF;AACF;AAEO;AAGL;AAGF;AAEO;AACL;AACF;AAEO;;AAOP;AAEO;AAIL;AACA;AACE;;AAEA;AACA;AACA;AACF;AACA;AACF;;ACxFO;AAIL;AACElJ;AACAoH;AACAc;AACAhD;;;AAGF;AACA;;;AAGA;AACF;AAWO;AAIL;AACElF;AACAoH;AACAc;;;AAKF;AACElI;AACAuH;AACA4B;AACA7C;AACAJ;AACAsB;AACA4B;AACA3B;AACA;;;AAGMlF;AAAQ;AAEhB;;AACMzC;AAAkB;AACxB;;AAEE;AACF;AACA;AAEAyC;;AAGA;AACE;AACF;AACA;AAEA;;;;AAIEA;;AAGF;AAEI8G;AACAC;;AACwB/B;;AACxB;AAA+BgC;;AACjC;AAEEC;AAAqCC;AAAK;AAC5C;;;AAQA;AACE;AACA;;AAIF;AACAC;AACA;;AAEEnH;AACF;AACF;;AAIA;AACF;;ACpHA;;;;AAIEoH;AACF;AAWO;;;AAGHC;;;;AAIF;AAAM5J;;;AACN;AACA;AACA;AACA;AACA;AACA;AACE6J;AACF;AACEA;AACF;AACA;AACA;AACA;;;AAKA;;;;AAIE;;AAGE;;AAEA;;AAEA;AACA;AAGM;AACAtF;AAIN;;AAIA;AACA;AAEA;;AAEA;AACA;;;AAOA;;AAEAuF;;AAEE;AACF;AACF;AAEF;AACEC;AACE;;;;AAIA;AACF;AACF;AACA;AACF;;ACvGA;;AAAapK;AAAK;AAWX;;;AAIUqK;AAAc;AAC7B;;AAEE;;;AAGA;AACF;;AAEEJ;;;AAGF;AAAM5J;;;AACN;;AAGE;;;AAGA6J;AACA;AACAC;;AAEEG;AAGM;;AAEJ;AACA;AAEF;AACF;AACF;AACF;;ACnCA;;;;;;;;;;;;AAYEC;AACF;AAEO;AAIP;AASA;AACE;;AAEE;;AAEF;AACA;AAA+BhF;;AACjC;AAEA;AAIE;;;AAGI;AACA;AACA;AACAiF;AACE;;;AAII;;AAEF;;AAIN1H;AACF;AACA;AACF;;AAEA;AACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACF;AAWA;;;;AAMQ;;AAEF;;AAEJ;AAEA;AAEA;;AAaQ;;AAEE;AACF;;AAEE;AACA;;;;AAIA;AACA;AACA;AACA;;;AAII;;AAEF;AAEJ;AACA;AACF;AASR;AAuDO;AACL1C;AACAqK;AACa;;AACqCrK;AAAI;;AAEtD;;AAMiCA;AAAI;AACrC;;AAKqCsK;;AAErC;AACA;AACA;AAIA;AACA;AACE;AACA;AACA;AACA;;;;AAIIpI;AACF;AACF;AACF;AACA;AAMEA;AACF;;AAEEA;;AAEF;AACA;;AAEA;AACEA;AACF;AACA;;AACQqI;AAAuB;AAC/B;;AAEA;;AAEA;AACA;AACA;;;;;AAIUC;;AACR;AACA;AACA;AACEC;AACA;AACA;AACA;;;AAGA;AACF;AACA;AACEC;AACA;AACA;AACA;;;AAGA;AACF;AACA;AAGA;AACE;AACA;;AAKE;;;;AAIA;AACF;AACF;;AAKF;AACEC;AACAC;AACF;AACA;AACA;;AAIA;;AAMA;AAGA;;;;;;;AAWEC;AAAYC;;;;;;;;;AAQZC;AACE7I;AACA8I;;AAEFC;AACE;;AAKA;AACAD;AAGF;;AAEJ;AAQO;;AAKHE;;AAEAC;AACF;AACElL;;;AAGF;;;AAGIe;AAMF;AACF;;;;AAC4B+J;AAAgB;AAC5C;AACA;;AAEE/J;AAMA;AACF;AACA;AACE;AACAA;AAMA;AACF;AACA;AACEA;AAMA;AACF;AACA;AACEA;AAMA;AACF;;;AAQE;AACF;AACA;;;AAGE;AACF;;;AAGE;AACF;AACA;;AAEE;AACF;;AAEEA;AAMA;AACF;AACA;AAIE;;AACQ6D;AAAS;AACjB;AACA;AACA7D;AAMF;AACA;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","debugId":"ce901e44-4e3e-43e6-8016-50895b08fc53"}